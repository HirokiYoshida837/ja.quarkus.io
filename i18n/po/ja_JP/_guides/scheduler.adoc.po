# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-12-29 14:10+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/building-my-first-extension.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Building my first extension"
msgstr "Quarkus - 私の最初の拡張機能を構築する"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:14
#, fuzzy
msgid ""
"Quarkus extensions enhance your application just as projects dependencies do."
"  The role of the extensions is to leverage Quarkus paradigms to integrate "
"seamlessly a library into Quarkus architecture - e.g. do more things at "
"build time.  This is how you can use your battle-tested ecosystem and take "
"advantage of Quarkus performance and native compilation.  Go to https://code."
"quarkus.io/[code.quarkus.io] to get the list of the supported extensions."
msgstr ""
"Quarkusの拡張機能は、プロジェクトの依存関係がそうであるように、アプリケーションを強化します。拡張機能の役割は、Quarkusのパラダイムを活用して、ライブラリをQuarkusアーキテクチャにシームレスに統合することです。このようにして、実績のあるエコシステムを利用して、Quarkusのパフォーマンスとネイティブコンパイルを活用することができます。 "
"link:https://code.quarkus.io/[code.quarkus."
"io]にアクセスして、サポートされている拡張機能のリストを入手してください。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:17
#, fuzzy
msgid ""
"In this guide we are going to develop the *Sample Greeting Extension*.  The "
"extension will expose a customizable HTTP endpoint which simply greets the "
"visitor."
msgstr ""
"このガイドでは、 *サンプルグリーティング拡張機能を*開発します。この拡張機能は、訪問者に挨拶をするだけのカスタマイズ可能な HTTP "
"エンドポイントを公開します。"

#. type: Block title
#: upstream/_guides/building-my-first-extension.adoc:19
#, no-wrap, fuzzy
msgid "Disclaimer"
msgstr "免責事項"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:23
#, fuzzy
msgid ""
"To be sure it's extra clear you don't need an extension to add a Servlet to "
"your application.  This guide is a simplified example to explain the "
"concepts of extensions development.  Keep in mind it's not representative of "
"the power of moving things to build time or simplifying the build of native "
"images."
msgstr ""
"アプリケーションにサーブレットを追加するのに拡張機能は必要ありません。このガイドは拡張機能開発の概念を説明するための簡略化された例です。ビルド時間に物を動かす力や、ネイティブイメージのビルドを単純化する力を代表するものではないことを覚えておいてください。"

#. type: Title ==
#: upstream/_guides/scheduler.adoc:15
#, no-wrap, fuzzy
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:18
#, fuzzy
msgid "To complete this guide, you need:"
msgstr "このガイドを完成させるには、以下のものが必要です。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:17
#, fuzzy
msgid "less than 30 minutes"
msgstr "三十分以内"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:21
#, fuzzy
msgid "an IDE"
msgstr "アイディーイーイー"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:22
#, fuzzy
msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 1.8+ がインストールされ、 `JAVA_HOME` が適切に設定されています。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:23
#, fuzzy
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version} の場合"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:33
#, no-wrap, fuzzy
msgid "Basic Concepts"
msgstr "基本概念"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:36
#, fuzzy
msgid "First things first, we will need to start with some basic concepts."
msgstr "まず最初に、いくつかの基本的な概念から始めましょう。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:38
#, fuzzy
msgid "JVM mode vs Native mode"
msgstr "JVMモードとネイティブモード"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:39
#, fuzzy
msgid ""
"Quarkus is first and foremost a Java framework, that means you can develop, "
"package and run classic JAR applications, that's what we call *JVM mode*."
msgstr "つまり、古典的な *JAR*アプリケーションを開発、パッケージ化、実行することができます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:40
#, fuzzy
msgid ""
"Thanks to https://graalvm.org/[GraalVM] you can compile your Java "
"application into machine specific code (like you do in Go or C++) and that's "
"what we call *Native mode*."
msgstr ""
"link:https://graalvm.org/[GraalVMの]おかげで、Javaアプリケーションをマシン "
"*固有*のコードにコンパイルすることができます（GoやC++のように）。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:42
#, fuzzy
msgid ""
"The operation of compiling Java bytecode into a native system-specific "
"machine code is named *Ahead of Time Compilation* (aka AoT)."
msgstr ""
"Javaバイトコードをネイティブシステム固有のマシンコードにコンパイルする操作は、 *Ahead of Time "
"Compilation*(AoT)と呼ばれています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:44
#, fuzzy
msgid "build time vs runtime in classic Java frameworks"
msgstr "古典的なJavaフレームワークにおけるビルド時間とランタイムの比較"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:45
#, fuzzy
msgid ""
"The build time corresponds to all the actions you apply to your Java source "
"files to convert them into something runnable (class files, jar/war, native "
"images)."
msgstr ""
"ビルド時間は、Javaソースファイルを実行可能なもの（クラスファイル、jar/"
"war、ネイティブイメージ）に変換するためにJavaソースファイルに適用するすべてのアクションに対応しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:46
#, fuzzy
msgid ""
"Usually this stage is composed by the compilation, annotation processing, "
"bytecode generation, etc. At this point, everything is under the developer's "
"scope and control."
msgstr ""
"通常、この段階はコンパイル、アノテーション処理、バイトコード生成などで構成されます。この時点では、すべてが開発者のスコープとコントロール下にあります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:47
#, fuzzy
msgid ""
"The runtime is all the actions that happen when you execute your application."
""
msgstr "ランタイムとは、アプリケーションを実行するときに発生するすべてのアクションのことです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:48
#, fuzzy
msgid ""
"It's obviously focused on starting your business-oriented actions but it "
"relies on a lot of technical actions like loading libraries and "
"configuration files, scanning the application's classpath, configuring the "
"dependency injection, setting up your Object-Relational Mapping, "
"instantiating your REST controllers, etc."
msgstr ""
"これは明らかにビジネス指向のアクションを開始することに焦点を当てていますが、ライブラリや設定ファイルのロード、アプリケーションのクラスパスのスキャン、依存性インジェクションの設定、オブジェクトリレーショナルマッピングの設定、RESTコントローラのインスタンス化など、多くの技術的なアクションに依存しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:50
#, fuzzy
msgid ""
"Usually, Java frameworks do their bootstrapping during the runtime before "
"actually starting the application \"Business oriented layer\". During "
"bootstrap, frameworks dynamically collect metadata by scanning the classpath "
"to find configurations, entity definitions, dependency injection binding, "
"etc. in order to instantiate proper objects through reflection. The main "
"consequences are:"
msgstr ""
"通常、Javaフレームワークは、アプリケーションの「ビジネス指向レイヤー」を実際に起動する前に、ランタイム中にブートストラップを行います。ブートストラップの間、フレームワークは、リフレクションによって適切なオブジェクトをインスタンス化するために、設定、エンティティ定義、依存性注入バインディングなどを見つけるためにクラスパスをスキャンすることによって動的にメタデータを収集します。主な結果は以下の通りです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:52
#, fuzzy
msgid ""
"Delaying the readiness of your application: you need to wait a couple of "
"seconds before actually serving a business request."
msgstr "アプリケーションの準備を遅らせる：実際にビジネスリクエストに対応する前に数秒待つ必要があります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:53
#, fuzzy
msgid ""
"Having a peak of resource consumption at bootstrap: in a constrained "
"environment, you will need to size the needed resources based on your "
"technical bootstrap needs rather than your actual business needs."
msgstr ""
"ブートストラップでリソース消費のピークを持つ：制約のある環境では、実際のビジネスニーズではなく、技術的なブートストラップのニーズに基づいて、必要なリソースのサイズを決定する必要があります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:56
#, fuzzy
msgid ""
"Quarkus' philosophy is to prevent as much as possible slow and memory "
"intensive dynamic code execution by shifting left these actions and "
"eventually do them during the build time.  A Quarkus extension is a Java "
"piece of code acting as an adapter layer for your favorite library or "
"technology."
msgstr ""
"Quarkusの哲学は、これらのアクションを左にシフトし、最終的にはビルド時に実行することで、可能な限り低速でメモリ集約的な動的コードの実行を防ぐことです。Quarkusの拡張機能は、お気に入りのライブラリやテクノロジーのアダプターレイヤーとして機能するJavaのコードです。"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:57
#, no-wrap, fuzzy
msgid "Description of a Quarkus extension"
msgstr "Quarkusの拡張機能の説明"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:60
#, fuzzy
msgid "A Quarkus extension consists of two parts:"
msgstr "Quarkusの拡張機能は、2つの部分から構成されています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:63
#, fuzzy
msgid ""
"The *runtime module* which represents the capabilities the extension "
"developer exposes to the application's developer (an authentication filter, "
"an enhanced data layer API, etc).  Runtime dependencies are the ones the "
"users will add as their application dependencies (in Maven POMs or Gradle "
"build scripts)."
msgstr ""
"拡張機能開発者がアプリケーションの開発者に公開する機能を表す "
"*ランタイムモジュール*(認証フィルタ、強化されたデータ層APIなど)。ランタイム依存関係は、ユーザーがアプリケーションの依存関係として追加するものです "
"(Maven POM または Gradle ビルドスクリプトで)。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:67
#, fuzzy
msgid ""
"The *deployment module* which is used during the augmentation phase of the "
"build, it describes how to \"deploy\" a library following the Quarkus "
"philosophy.  In other words, it applies all the Quarkus optimizations to "
"your application during the build.  The deployment module is also where we "
"prepare things for GraalVM's native compilation."
msgstr ""
"ビルドの拡張フェーズで使用される "
"*デプロイモジュール*で、Quarkusの哲学に従ったライブラリを「デプロイ」する方法を説明しています。言い換えれば、ビルド中にアプリケーションにQuarkusのすべての最適化を適用します。デプロイメントモジュールは、GraalVMのネイティブコンパイルのための準備をする場所でもあります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:70
#, fuzzy
msgid ""
"Users should not be adding the deployment modules of extension as "
"application dependencies. The deployment dependencies are resolved by "
"Quarkus during the augmentation phase from the runtime dependencies of the "
"application."
msgstr ""
"ユーザーは、拡張機能のデプロイメントモジュールをアプリケーションの依存関係として追加すべきではありません。デプロイメントの依存関係は、拡張フェーズの間にQuarkusによってアプリケーションのランタイム依存関係から解決されます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:72
#, fuzzy
msgid ""
"At this point, you should have understood that most of the magic will happen "
"at the Augmentation build time thanks to the deployment module."
msgstr "この時点で、デプロイメントモジュールのおかげで、ほとんどのマジックは拡張ビルド時に起こることを理解しているはずです。"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:73
#, no-wrap, fuzzy
msgid "Quarkus Application Bootstrap"
msgstr "Quarkusアプリケーションブートストラップ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:76
#, fuzzy
msgid "There are three distinct bootstrap phases of a Quarkus application."
msgstr "Quarkusアプリケーションには、3つの異なるブートストラップフェーズがあります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:81
#, no-wrap, fuzzy
msgid ""
"*Augmentation*. During the build time, the Quarkus extensions will load and "
"scan your application's bytecode (including the dependencies) and "
"configuration.\n"
"At this stage, the extension can read configuration files, scan classes for "
"specific annotations, etc.\n"
"Once all the metadata has been collected, the extensions can pre-process the "
"libraries bootstrap actions like your ORM, DI or REST controllers "
"configurations.\n"
"The result of the bootstrap is directly recorded into bytecode and will be "
"part of your final application package.\n"
msgstr ""
"*拡張*。ビルド時に、Quarkus拡張機能はアプリケーションのバイトコード（依存関係を含む）と設定をロードしてスキャンします。この段階で、拡張機能は設定ファイルを読み込んだり、特定のアノテーションのためにクラスをスキャンしたりすることができます。すべてのメタデータが収集されると、拡張機能は、ORM、DI、またはRESTコントローラの設定のようなライブラリのブートストラップアクションを前処理することができます。ブートストラップの結果はバイトコードに直接記録され、最終的なアプリケーションパッケージの一部となります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:84
#, no-wrap, fuzzy
msgid ""
"*Static Init*. During the run time, Quarkus will execute first a static init "
"method which contains some extensions actions/configurations.\n"
"When you will do your native packaging, this static method will be pre-"
"processed during the build time and the objects it has generated will be "
"serialized into the final native executable, so the initialization code will "
"not be executed in the native mode (imagine you execute a Fibonacci function "
"during this phase, the result of the computation will be directly recorded "
"in the native executable).\n"
"When running the application in JVM mode, this static init phase is executed "
"at the start of the application.\n"
msgstr ""
"スタティック *init*.ランタイムの間、Quarkusは最初に、いくつかの拡張アクション/"
"設定を含む静的initメソッドを実行します。ネイティブパッケージングを行う場合、このスタティックメソッドはビルド時に前処理され、生成されたオブジェクトは最終的なネイティブ実行ファイルにシリアライズされるため、初期化コードはネイティブモードでは実行されません（このフェーズでフィボナッチ関数を実行すると想像してください。JVMモードでアプリケーションを実行している場合、この静的initフェーズはアプリケーションの開始時に実行されます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:87
#, no-wrap, fuzzy
msgid ""
"*Runtime Init*. Well nothing fancy here, we do classic run time code "
"execution.\n"
"So, the more code you run during the two phases above, the faster your "
"application will start.\n"
msgstr ""
"ラン "
"*タイム*起動ここでは何も派手なことはしていませんが、古典的なランタイムコードの実行を行います。つまり、上記の2つのフェーズでより多くのコードを実行すればするほど、アプリケーションの起動が速くなります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:89
#, fuzzy
msgid "Now that everything is explained, we can start coding!"
msgstr "これで全てが説明されたので、さっそくコーディングに取り掛かりましょう"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:90
#, no-wrap, fuzzy
msgid "Maven setup"
msgstr "Mavenのセットアップ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:93
#, fuzzy
msgid ""
"Quarkus provides `create-extension` Maven Mojo to initialize your extension "
"project."
msgstr "Quarkusは、 `create-extension` Maven Mojoを提供し、拡張プロジェクトを初期化します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:114
#, no-wrap
msgid ""
"$ mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N "
"\\\n"
"    -DgroupId=org.acme \\ #<1>\n"
"    -DartifactId=quarkus-greeting \\  #<2>\n"
"    -Dversion=1.0-SNAPSHOT \\ #<3>\n"
"    -Dquarkus.nameBase=\"Greeting Extension\" #<4>\n"
"[INFO] Scanning for projects...\n"
"[INFO] \n"
"[INFO] ------------------< org.apache.maven:standalone-pom >-----------------"
"--\n"
"[INFO] Building Maven Stub Project (No POM) 1\n"
"[INFO] --------------------------------[ pom ]-------------------------------"
"--\n"
"[INFO] \n"
"[INFO] --- quarkus-maven-plugin:{quarkus-version}:create-extension (default-"
"cli) @ standalone-pom ---\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] BUILD SUCCESS\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Total time:  1.233 s\n"
"[INFO] Finished at: 2020-04-22T23:28:15+02:00\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:117
#, fuzzy
msgid "Project's groupId"
msgstr "プロジェクトのグループID"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:118
#, fuzzy
msgid ""
"artifactId for the runtime artifact of the extension (the deployment "
"artifactId will be derived from the runtime artifactId by appending `-"
"deployment`)"
msgstr ""
"拡張機能の実行時アーティファクトのartifactId (展開時アーティファクトIdは `-deployment` "
"を付加することで実行時アーティファクトIdから導出されます)"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:119
#, fuzzy
msgid "Project's version"
msgstr "プロジェクトのバージョン"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:120
#, fuzzy
msgid "Prefix for the `<name>` element values in the generated POMs"
msgstr "生成された POM の `&amp;lt;name&amp;gt;` 要素値の接頭辞"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:122
#, fuzzy
msgid ""
"Maven has generated a `quarkus-greeting` directory containing the extension "
"project which consists of the parent `pom.xml`, the `runtime` and the "
"`deployment` modules."
msgstr ""
"Maven は、親 `pom.xml` 、 `runtime` 、 `deployment` モジュールからなる拡張プロジェクトを含む `quarkus-"
"greeting` ディレクトリを生成しました。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:123
#, no-wrap, fuzzy
msgid "The parent pom.xml"
msgstr "親の pom.xml"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:126
#, fuzzy
msgid ""
"Your extension is a multi-module project. So let's start by checking out the "
"parent POM at `./quarkus-greeting/pom.xml`."
msgstr ""
"あなたの拡張モジュールはマルチモジュールプロジェクトです。ですから、まず親の POM を `./quarkus-greeting/pom.xml` "
"からチェックしてみましょう。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:134
#, no-wrap
msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://"
"maven.apache.org/xsd/maven-4.0.0.xsd\">\n"
"    <modelVersion>4.0.0</modelVersion>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:139
#, no-wrap
msgid ""
"    <groupId>org.acme</groupId>\n"
"    <artifactId>quarkus-greeting-parent</artifactId>\n"
"    <version>1.0-SNAPSHOT</version>\n"
"    <name>Greeting Extension - Parent</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:177
#, no-wrap
msgid ""
"    <packaging>pom</packaging>\n"
"    <properties>\n"
"        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n"
"        <project.reporting.outputEncoding>UTF-8</project.reporting."
"outputEncoding>\n"
"        <maven.compiler.source>1.8</maven.compiler.source>\n"
"        <maven.compiler.target>1.8</maven.compiler.target>\n"
"        <maven.compiler.parameters>true</maven.compiler.parameters>\n"
"        <quarkus.version>{quarkus-version}</quarkus.version>\n"
"        <compiler-plugin.version>3.8.1</compiler-plugin.version>\n"
"    </properties>\n"
"    <modules> #<1>\n"
"        <module>deployment</module>\n"
"        <module>runtime</module>\n"
"    </modules>\n"
"    <dependencyManagement>\n"
"        <dependencies>\n"
"            <dependency>\n"
"                <groupId>io.quarkus</groupId>\n"
"                <artifactId>quarkus-bom</artifactId> #<2>\n"
"                <version>${quarkus.version}</version>\n"
"                <type>pom</type>\n"
"                <scope>import</scope>\n"
"            </dependency>\n"
"        </dependencies>\n"
"    </dependencyManagement>\n"
"    <build>\n"
"        <pluginManagement>\n"
"            <plugins>\n"
"                <plugin>\n"
"                    <groupId>org.apache.maven.plugins</groupId>\n"
"                    <artifactId>maven-compiler-plugin</artifactId>\n"
"                    <version>${compiler-plugin.version}</version> #<3>\n"
"                </plugin>\n"
"            </plugins>\n"
"        </pluginManagement>\n"
"    </build>\n"
"</project>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:180
#, fuzzy
msgid "Your extension declares 2 sub-modules `deployment` and `runtime`."
msgstr "あなたの拡張機能は、2つのサブモジュール `deployment` と `runtime` を宣言しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:181
#, fuzzy
msgid ""
"The `quarkus-bom` aligns your dependencies with those used by Quarkus during "
"the augmentation phase."
msgstr "`quarkus-bom` は、オーグメンテーションの段階でQuarkusが使用している依存関係を調整します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:182
#, fuzzy
msgid ""
"Quarkus requires a recent version of the Maven compiler plugin supporting "
"the annotationProcessorPaths configuration."
msgstr ""
"Quarkusでは、annotationProcessorPaths設定をサポートするMavenコンパイラプラグインの最新バージョンが必要です。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:183
#, no-wrap, fuzzy
msgid "The Deployment module"
msgstr "デプロイメントモジュール"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:186
#, fuzzy
msgid ""
"Let's have a look at the deployment's `./quarkus-greeting/deployment/pom."
"xml`."
msgstr "デプロイメントの `./quarkus-greeting/deployment/pom.xml`."

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:199
#: upstream/_guides/building-my-first-extension.adoc:291
#, no-wrap
msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven."
"apache.org/xsd/maven-4.0.0.xsd\">\n"
"    <modelVersion>4.0.0</modelVersion>\n"
"    <parent>\n"
"        <groupId>org.acme</groupId>\n"
"        <artifactId>quarkus-greeting-parent</artifactId>\n"
"        <version>1.0-SNAPSHOT</version>\n"
"        <relativePath>../pom.xml</relativePath>\n"
"    </parent>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:202
#, no-wrap
msgid ""
"    <artifactId>quarkus-greeting-deployment</artifactId> <!--1-->\n"
"    <name>Greeting Extension - Deployment</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:215
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-core-deployment</artifactId> <!--2-->\n"
"            <version>${quarkus.version}</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId> <!--3-->\n"
"            <version>${project.version}</version>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:233
#, no-wrap
msgid ""
"    <build>\n"
"        <plugins>\n"
"            <plugin>\n"
"                <groupId>org.apache.maven.plugins</groupId>\n"
"                <artifactId>maven-compiler-plugin</artifactId>\n"
"                <configuration>\n"
"                    <annotationProcessorPaths>\n"
"                        <path>\n"
"                            <groupId>io.quarkus</groupId>\n"
"                            <artifactId>quarkus-extension-processor</"
"artifactId>  <!--4-->\n"
"                            <version>${quarkus.version}</version>\n"
"                        </path>\n"
"                    </annotationProcessorPaths>\n"
"                </configuration>\n"
"            </plugin>\n"
"        </plugins>\n"
"    </build>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:235
#: upstream/_guides/building-my-first-extension.adoc:575
#, no-wrap
msgid "</project>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:238
#: upstream/_guides/building-my-first-extension.adoc:336
#, fuzzy
msgid "The key points are:"
msgstr "肝心のポイントは"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:240
#, fuzzy
msgid ""
"By convention, the deployment module has the `-deployment` suffix (`greeting-"
"deployment`)."
msgstr "慣例では、配置モジュールのサフィックスは `-deployment` ( `greeting-deployment`) です。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:242
#, fuzzy
msgid ""
"The deployment module depends on the `quarkus-core-deployment` artifact.  We "
"will see later which dependencies are convenient to add."
msgstr ""
"デプロイメントモジュールは `quarkus-core-deployment` "
"アーティファクトに依存しています。どの依存関係を追加するのが便利かは後ほど見ていきます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:243
#, fuzzy
msgid "The deployment module also *must* depend on the runtime module."
msgstr "デプロイメントモジュールもランタイムモジュールに依存する *必要があります*。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:244
#: upstream/_guides/building-my-first-extension.adoc:340
#, fuzzy
msgid ""
"We add the `quarkus-extension-processor` to the compiler annotation "
"processors."
msgstr "コンパイラのアノテーションプロセッサに `quarkus-extension-processor` を追加します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:246
#, fuzzy
msgid ""
"In addition to the `pom.xml` `create-extension` also generated the `org.acme."
"quarkus.greeting.deployment.GreetingProcessor` class."
msgstr ""
"`pom.xml` `create-extension` に加えて `org.acme.quarkus.greeting.deployment."
"GreetingProcessor` クラスも生成されました。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:250
#: upstream/_guides/building-my-first-extension.adoc:403
#: upstream/_guides/building-my-first-extension.adoc:465
#: upstream/_guides/building-my-first-extension.adoc:594
#, no-wrap
msgid "package org.acme.quarkus.greeting.deployment;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:253
#: upstream/_guides/building-my-first-extension.adoc:406
#, no-wrap
msgid ""
"import io.quarkus.deployment.annotations.BuildStep;\n"
"import io.quarkus.deployment.builditem.FeatureBuildItem;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:255
#: upstream/_guides/building-my-first-extension.adoc:408
#: upstream/_guides/building-my-first-extension.adoc:472
#, no-wrap
msgid "class GreetingProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:257
#: upstream/_guides/building-my-first-extension.adoc:410
#: upstream/_guides/building-my-first-extension.adoc:474
#, no-wrap
msgid "    private static final String FEATURE = \"greeting\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:262
#: upstream/_guides/building-my-first-extension.adoc:479
#, no-wrap
msgid ""
"    @BuildStep\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(FEATURE);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:201
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:269
#, fuzzy
msgid ""
"`FeatureBuildItem` represents a functionality provided by an extension.  The "
"name of the feature gets displayed in the log during application bootstrap.  "
"An extension should provide at most one feature."
msgstr ""
"`FeatureBuildItem` "
"は拡張機能によって提供される機能を表します。機能の名前は、アプリケーションの起動時にログに表示されます。拡張機能は最大でも一つの機能を提供しなければなりません。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:273
#, fuzzy
msgid ""
"Be patient, we will explain the `Build Step Processor` concept and all the "
"extension deployment API later on.  At this point, you just need to "
"understand that this class explains to Quarkus how to deploy a feature named "
"`greeting` which is your extension.  In other words, you are augmenting your "
"application to use the `greeting` extension with all the Quarkus benefits "
"(build time optimization, native support, etc.)."
msgstr ""
"`Build Step Processor` の概念とすべての拡張機能のデプロイメント API については、後で説明します。この時点では、このクラスは、 "
"`greeting` "
"という拡張機能をデプロイする方法をQuarkusに説明していることを理解する必要があります。言い換えれば、アプリケーションを拡張して、 "
"`greeting` 拡張機能を使用して、Quarkusのすべての利点（ビルド時間の最適化、ネイティブサポートなど）を利用することになります。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:274
#, no-wrap, fuzzy
msgid "The Runtime module"
msgstr "ランタイムモジュール"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:277
#, fuzzy
msgid "Finally `./quarkus-greeting/runtime/pom.xml`."
msgstr "最後に `./quarkus-greeting/runtime/pom.xml`."

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:294
#, no-wrap
msgid ""
"    <artifactId>quarkus-greeting</artifactId>  <!--1-->\n"
"    <name>Greeting Extension - Runtime</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:297
#, no-wrap
msgid "    <dependencies>\n"
"    </dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:333
#, no-wrap
msgid ""
"    <build>\n"
"        <plugins>\n"
"            <plugin>\n"
"                <groupId>io.quarkus</groupId>\n"
"                <artifactId>quarkus-bootstrap-maven-plugin</artifactId>  <!--"
"2-->\n"
"                <version>${quarkus.version}</version>\n"
"                <executions>\n"
"                    <execution>\n"
"                        <goals>\n"
"                            <goal>extension-descriptor</goal>\n"
"                        </goals>\n"
"                        <phase>compile</phase>\n"
"                        <configuration>\n"
"                            <deployment>${project.groupId}:${project."
"artifactId}-deployment:${project.version}\n"
"                            </deployment>\n"
"                        </configuration>\n"
"                    </execution>\n"
"                </executions>\n"
"            </plugin>\n"
"            <plugin>\n"
"                <groupId>org.apache.maven.plugins</groupId>\n"
"                <artifactId>maven-compiler-plugin</artifactId>\n"
"                <configuration>\n"
"                    <annotationProcessorPaths>\n"
"                        <path>\n"
"                            <groupId>io.quarkus</groupId>\n"
"                            <artifactId>quarkus-extension-processor</"
"artifactId> <!--3-->\n"
"                            <version>${quarkus.version}</version>\n"
"                        </path>\n"
"                    </annotationProcessorPaths>\n"
"                </configuration>\n"
"            </plugin>\n"
"        </plugins>\n"
"    </build>\n"
"</project>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:338
#, fuzzy
msgid ""
"By convention, the runtime module has no suffix (`greeting`) as it is the "
"artifact exposed to the end user."
msgstr "慣習的に、ランタイムモジュールはエンドユーザーに公開される成果物であるため、サフィックス ( `greeting`) を持たない。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:339
#, fuzzy
msgid ""
"We add the `quarkus-bootstrap-maven-plugin` to generate the Quarkus "
"extension descriptor included into the runtime artifact which links it with "
"the corresponding deployment artifact."
msgstr ""
"ランタイム成果物に含まれるQuarkus拡張記述子を生成するために `quarkus-bootstrap-maven-plugin` "
"を追加し、これを対応するデプロイメント成果物とリンクさせています。"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:341
#, no-wrap, fuzzy
msgid "Basic version of the Sample Greeting extension"
msgstr "サンプルグリーティング拡張機能の基本バージョン"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:343
#, no-wrap, fuzzy
msgid "Implementing the Greeting feature"
msgstr "グリーティング機能の実装"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:346
#, fuzzy
msgid ""
"The (killer) feature proposed by our extension is to greet the user.  To do "
"so, our extension will deploy, in the user application, a Servlet exposing "
"the HTTP endpoint `/greeting` which responds to the GET verb with a plain "
"text `Hello`."
msgstr ""
"私たちの拡張機能が提案する(キラー)機能は、ユーザに挨拶をすることです。 "
"`Hello`これを実現するために、我々の拡張機能はユーザアプリケーション内に、HTTP エンドポイント `/greeting` "
"を公開するサーブレットを配置します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:348
#, fuzzy
msgid ""
"The `runtime` module is where you develop the feature you want to propose to "
"your users, so it's time to create our Web Servlet."
msgstr "`runtime` モジュールは、ユーザーに提案したい機能を開発するところなので、そろそろ Web Servlet を作成しましょう。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:352
#, fuzzy
msgid ""
"To use Servlets in your applications you need to have a Servlet Container "
"such as http://undertow.io[Undertow].  Luckily, `quarkus-bom` imported by "
"our parent `pom.xml` already includes the Undertow Quarkus extension.  All "
"we need to do is add"
msgstr ""
"アプリケーションでサーブレットを使用するには、 link:http://undertow."
"io[Undertow]のようなサーブレットコンテナが必要です。 `pom.xml` 幸いにも、親である `quarkus-bom` がインポートした "
"には、すでに Undertow Quarkus 拡張機能が含まれています。必要なのは"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:360
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-undertow</artifactId>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:362
#, fuzzy
msgid "to our `./quarkus-greeting/runtime/pom.xml`."
msgstr "を `./quarkus-greeting/runtime/pom.xml` に移動します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:364
#, fuzzy
msgid ""
"Now we can create our Servlet `org.acme.quarkus.greeting.GreetingServlet` in "
"the `runtime` module."
msgstr ""
"これで、 `runtime` モジュールでサーブレット `org.acme.quarkus.greeting.GreetingServlet` "
"を作成することができるようになりました。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:367
#, no-wrap
msgid "package org.acme.quarkus.greeting;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:373
#, no-wrap
msgid ""
"import javax.servlet.annotation.WebServlet;\n"
"import javax.servlet.http.HttpServlet;\n"
"import javax.servlet.http.HttpServletRequest;\n"
"import javax.servlet.http.HttpServletResponse;\n"
"import java.io.IOException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:376
#, no-wrap
msgid "@WebServlet\n"
"public class GreetingServlet extends HttpServlet { // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:382
#, no-wrap
msgid ""
"    @Override\n"
"    protected void doGet(HttpServletRequest req, HttpServletResponse resp) "
"throws IOException { // <2>\n"
"        resp.getWriter().write(\"Hello\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:385
#, fuzzy
msgid ""
"As usual, defining a servlet requires to extend `javax.servlet.http."
"HttpServlet`."
msgstr "いつものように、サーブレットを定義するには `javax.servlet.http.HttpServlet`."

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:386
#, fuzzy
msgid ""
"Since we want to respond to the HTTP GET verb, we override the `doGet` "
"method and write `Hello` in the Servlet response's output stream."
msgstr ""
"HTTP GET動詞に応答したいので、 `doGet` メソッドをオーバーライドして、サーブレット応答の出力ストリームに `Hello` を記述します。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:387
#, no-wrap, fuzzy
msgid "Deploying the Greeting feature"
msgstr "グリーティング機能の展開"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:392
#, fuzzy
msgid ""
"Quarkus magic relies on bytecode generation at build time rather than "
"waiting for the runtime code evaluation, that's the role of your extension's "
"`deployment` module.  Calm down, we know, bytecode is hard and you don't "
"want to do it manually, Quarkus proposes a high level API to make your life "
"easier.  Thanks to basic concepts, you will describe the items to produce/"
"consume and the corresponding steps in order to generate the bytecode to "
"produce during the deployment time."
msgstr ""
"`deployment` Quarkus "
"magicは、実行時のコード評価を待つのではなく、ビルド時のバイトコード生成に依存しています。落ち着いてください。バイトコードは難しいし、手動でやりたくないことはわかっています。基本的な概念のおかげで、デプロイ時に生成するバイトコードを生成するために、生成/"
"消費するアイテムとそれに対応するステップを記述します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:394
#, fuzzy
msgid ""
"The `io.quarkus.builder.item.BuildItem` concept represents object instances "
"you will produce or consume (and at some point convert into bytecode) thanks "
"to methods annotated with `@io.quarkus.deployment.annotations.BuildStep` "
"which describe your extension's deployment tasks."
msgstr ""
"`io.quarkus.builder.item.BuildItem` の概念は、 `@io.quarkus.deployment."
"annotations.BuildStep` でアノテーションされたメソッドのおかげで、あなたが生成したり消費したり "
"(そしてある時点でバイトコードに変換したり) するオブジェクトインスタンスを表しており、拡張機能の展開タスクを記述します。"

#. type: Labeled list
#: upstream/_guides/gradle-config.adoc:37
#, no-wrap, fuzzy
msgid "NOTE"
msgstr "ノート"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:396
#, fuzzy
msgid ""
"See link:all-builditems[the complete list of BuildItem implementations in "
"core] for more information"
msgstr "詳細は link:all-builditems[core の BuildItem 実装の完全なリストを]参照してください。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:399
#, fuzzy
msgid ""
"Go back to the generated `org.acme.quarkus.greeting.deployment."
"GreetingProcessor` class."
msgstr ""
"生成された `org.acme.quarkus.greeting.deployment.GreetingProcessor` クラスに戻ります。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:415
#, no-wrap
msgid ""
"    @BuildStep // <1>\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(FEATURE); // <2>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:422
#, fuzzy
msgid ""
"`feature()` method is annotated with `@BuildStep` which means it is "
"identified as a deployment task Quarkus will have to execute during the "
"deployment.  `BuildStep` methods are run concurrently at augmentation time "
"to augment the application.  They use a producer/consumer model, where a "
"step is guaranteed not to be run until all the items that it is consuming "
"have been produced."
msgstr ""
"`feature()` メソッドには `@BuildStep` "
"というアノテーションが付けられており、Quarkusがデプロイ時に実行しなければならないデプロイタスクとして識別されます。 `BuildStep` "
"メソッドは、アプリケーションを拡張するための拡張時に同時に実行されます。プロデューサ／消費者モデルを使用しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:425
#, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.FeatureBuildItem` is an implementation of "
"`BuildItem` which represents the description of an extension.  This "
"`BuildItem` will be used by Quarkus to display information to the users when "
"the application is starting."
msgstr ""
"`io.quarkus.deployment.builditem.FeatureBuildItem` は、拡張機能の記述を表す `BuildItem` "
"の実装です。この `BuildItem` は、アプリケーションの起動時にユーザーに情報を表示するためにQuarkusが使用します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:428
#, fuzzy
msgid ""
"There are many `BuildItem` implementations, each one represents an aspect of "
"the deployment process.  Here are some examples:"
msgstr "多くの `BuildItem` 実装があり、それぞれが展開プロセスの一面を表しています。ここではいくつかの例を紹介します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:430
#, fuzzy
msgid ""
"`ServletBuildItem`: describes a Servlet (name, path, etc.) we want to "
"generate during the deployment."
msgstr "`ServletBuildItem`: デプロイ時に生成したいサーブレット(名前、パスなど)を記述します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:431
#, fuzzy
msgid ""
"`BeanContainerBuildItem`: describes a container used to store and retrieve "
"object instances during the deployment."
msgstr ""
"`BeanContainerBuildItem`: デプロイ時にオブジェクトインスタンスを保存・取得するために使用するコンテナについて説明します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:434
#, fuzzy
msgid ""
"If you don't find a `BuildItem` for what you want to achieve, you can create "
"your own implementation. Keep in mind that a `BuildItem` should be as fine-"
"grained as possible, representing a specific part of the deployment.  To "
"create your `BuildItem` you can extend:"
msgstr ""
"実現したいことに対応する `BuildItem` が見つからない場合は、独自の実装を作成することができます。 `BuildItem` "
"は、デプロイメントの特定の部分を表すもので、できるだけ細かいものでなければならないということを覚えておいてください。 `BuildItem` "
"を作成するには"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:436
#, fuzzy
msgid ""
"`io.quarkus.builder.item.SimpleBuildItem` if you need only a single instance "
"of the item during the deployment (e.g. `BeanContainerBuildItem`, you only "
"want one container)."
msgstr ""
"`io.quarkus.builder.item.SimpleBuildItem` デプロイ時にアイテムのインスタンスを1つだけ必要とする場合(例: "
"`BeanContainerBuildItem`, コンテナを1つだけにしたい場合)。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:437
#, fuzzy
msgid ""
"`io.quarkus.builder.item.MultiBuildItem` if you want to have multiple "
"instances (e.g. `ServletBuildItem`, you can produce many Servlets during the "
"deployment)."
msgstr ""
"複数のインスタンスを持ちたい場合は `io.quarkus.builder.item.MultiBuildItem` (例: "
"`ServletBuildItem`, デプロイ時に多くのサーブレットを生成することができます)。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:440
#, fuzzy
msgid ""
"It's now time to declare our HTTP endpoint. To do so, we need to produce a "
"`ServletBuildItem`.  At this point, we are sure you understood that if the "
"`quarkus-undertow` dependency proposes Servlet support for our `runtime` "
"module, we will need the `quarkus-undertow-deployment` dependency in our "
"`deployment` module to have access to the `io.quarkus.undertow.deployment."
"ServletBuildItem`."
msgstr ""
"これで、HTTP エンドポイントを宣言する時が来ました。これを行うには、 `ServletBuildItem` を生成する必要があります。この時点で、 "
"`quarkus-undertow` 依存関係が `runtime` モジュールの Servlet サポートを提案している場合、 "
"`deployment` モジュールの `quarkus-undertow-deployment` 依存関係が `io.quarkus.undertow."
"deployment.ServletBuildItem` にアクセスできるようにする必要があることをご理解いただけたと思います。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:442
#, fuzzy
msgid "Update the `./quarkus-greeting/deployment/pom.xml` as follows:"
msgstr "`./quarkus-greeting/deployment/pom.xml` を以下のように更新します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:456
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId>\n"
"            <version>${project.version}</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-undertow-deployment</artifactId>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:459
#, fuzzy
msgid ""
"The dependency on `quarkus-core-deployment` generated by the `create-"
"extension` mojo can now be removed since `quarkus-undertow-deployment` "
"already depends on it."
msgstr ""
"`create-extension` mojo で生成された `quarkus-core-deployment` への依存は、 `quarkus-"
"undertow-deployment` が既に依存しているので、これで削除できます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:461
#, fuzzy
msgid ""
"We can now update `org.acme.quarkus.greeting.deployment.GreetingProcessor`:"
msgstr ""
"`org.acme.quarkus.greeting.deployment.GreetingProcessor` を更新できるようになりました。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:470
#, no-wrap
msgid ""
"import io.quarkus.deployment.annotations.BuildStep;\n"
"import io.quarkus.deployment.builditem.FeatureBuildItem;\n"
"import org.acme.quarkus.greeting.GreetingServlet;\n"
"import io.quarkus.undertow.deployment.ServletBuildItem;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:487
#, no-wrap
msgid ""
"    @BuildStep\n"
"    ServletBuildItem createServlet() { // <1>\n"
"      ServletBuildItem servletBuildItem = ServletBuildItem."
"builder(\"greeting\", GreetingServlet.class.getName())\n"
"        .addMapping(\"/greeting\")\n"
"        .build(); // <2>\n"
"      return servletBuildItem;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:493
#, fuzzy
msgid ""
"We add a `createServlet` method which returns a `ServletBuildItem` and "
"annotate it with `@BuildStep`.  Now, Quarkus will process this new task "
"which will result in the bytecode generation of the Servlet registration at "
"build time."
msgstr ""
"`ServletBuildItem` を返す `createServlet` メソッドを追加し、 `@BuildStep` "
"とアノテーションを付けます。これで、Quarkusはこの新しいタスクを処理して、ビルド時にサーブレット登録のバイトコードを生成します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:495
#, fuzzy
msgid ""
"`ServletBuildItem` proposes a fluent API to instantiate a Servlet named "
"`greeting` of type `GreetingServlet` (it's our class provided by our "
"extension `runtime` module), and map it the `/greeting` path."
msgstr ""
"`ServletBuildItem` は、 `GreetingServlet` 型の `greeting` というサーブレットをインスタンス化し、 `/"
"greeting` パスをマッピングするための流暢な API を提案しています (拡張モジュール `runtime` によって提供されるクラスです)。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:496
#, no-wrap, fuzzy
msgid "Testing the Greeting feature"
msgstr "グリーティング機能のテスト"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:500
#, fuzzy
msgid ""
"When developing a Quarkus extension, you mainly want to test your feature is "
"properly deployed in an application and works as expected.  That's why the "
"tests will be hosted in the `deployment` module."
msgstr ""
"Quarkus拡張機能を開発する際には、主に機能がアプリケーションに正しくデプロイされ、期待通りに動作するかどうかをテストしたいと考えています。そのため、テストは "
"`deployment` モジュールでホストされます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:502
#, fuzzy
msgid ""
"Let's add the testing dependencies into the `./quarkus-greeting/deployment/"
"pom.xml` and `maven-surefire` configuration"
msgstr ""
"`./quarkus-greeting/deployment/pom.xml` と `maven-surefire` "
"の設定にテスト用の依存関係を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:516
#, no-wrap
msgid ""
"    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven."
"apache.org/xsd/maven-4.0.0.xsd\">\n"
"    <modelVersion>4.0.0</modelVersion>\n"
"    <parent>\n"
"        <groupId>org.acme</groupId>\n"
"        <artifactId>quarkus-greeting-parent</artifactId>\n"
"        <version>1.0-SNAPSHOT</version>\n"
"        <relativePath>../pom.xml</relativePath>\n"
"    </parent>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:519
#, no-wrap
msgid ""
"    <artifactId>quarkus-greeting-deployment</artifactId>\n"
"    <name>Greeting Extension - Deployment</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:523
#, no-wrap
msgid ""
"    <properties>\n"
"        <maven.surefire.version>3.0.0-M4</maven.surefire.version>\n"
"    </properties>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:545
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId>\n"
"            <version>${project.version}</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-undertow-deployment</artifactId>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-junit5-internal</artifactId> <!--1-->\n"
"            <scope>test</scope>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.rest-assured</groupId>\n"
"            <artifactId>rest-assured</artifactId> <!--2-->\n"
"            <scope>test</scope>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:573
#, no-wrap
msgid ""
"    <build>\n"
"        <plugins>\n"
"            <plugin>\n"
"                <groupId>org.apache.maven.plugins</groupId>\n"
"                <artifactId>maven-compiler-plugin</artifactId>\n"
"                <configuration>\n"
"                    <annotationProcessorPaths>\n"
"                        <path>\n"
"                            <groupId>io.quarkus</groupId>\n"
"                            <artifactId>quarkus-extension-processor</"
"artifactId>\n"
"                            <version>${quarkus.version}</version>\n"
"                        </path>\n"
"                    </annotationProcessorPaths>\n"
"                </configuration>\n"
"            </plugin>\n"
"            <plugin>\n"
"                <artifactId>maven-surefire-plugin</artifactId> <!--3-->\n"
"                <version>${maven.surefire.version}</version>\n"
"                <configuration>\n"
"                    <systemPropertyVariables>\n"
"                        <java.util.logging.manager>org.jboss.logmanager."
"LogManager</java.util.logging.manager>\n"
"                        <maven.home>${maven.home}</maven.home>\n"
"                    </systemPropertyVariables>\n"
"                </configuration>\n"
"            </plugin>\n"
"        </plugins>\n"
"    </build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:579
#, fuzzy
msgid ""
"Quarkus proposes facilities to test extensions via the `quarkus-junit5-"
"internal` artifact, in particular the `io.quarkus.test.QuarkusUnitTest` "
"runner which starts an application with your extension."
msgstr ""
"Quarkusは、 `quarkus-junit5-internal` "
"アーティファクトを介して拡張機能をテストするための機能、特に拡張機能を使ってアプリケーションを起動する `io.quarkus.test."
"QuarkusUnitTest` ランナーを提案しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:580
#, fuzzy
msgid ""
"We will use http://rest-assured.io[RestAssured] (massively used in Quarkus) "
"to test our HTTP endpoint."
msgstr ""
"link:http://rest-assured."
"io[RestAssured]（Quarkusで大量に使用されている）を使用してHTTPエンドポイントをテストします。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:581
#, fuzzy
msgid ""
"In order to not fallback to JUnit 4 legacy mode you need to define a recent "
"version of `maven-surefire` plugin."
msgstr ""
"JUnit 4 のレガシーモードにフォールバックしないようにするには、 `maven-surefire` "
"プラグインの最新バージョンを定義する必要があります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:583
#, fuzzy
msgid ""
"Currently, the `create-extension` Maven Mojo does not create the test "
"structure. We'll create it ourselves:"
msgstr "現在、 `create-extension` Maven Mojoはテスト構造を作成しません。自分たちで作成します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:587
#, no-wrap
msgid ""
"mkdir -p ./quarkus-greeting/deployment/src/test/java/org/acme/quarkus/"
"greeting/deployment\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:590
#, fuzzy
msgid ""
"To start testing your extension, create the following `org.acme.quarkus."
"greeting.deployment.GreetingTest` test class:"
msgstr ""
"拡張機能のテストを開始するには、次の `org.acme.quarkus.greeting.deployment.GreetingTest` "
"テストクラスを作成します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:601
#, no-wrap
msgid ""
"import io.quarkus.test.QuarkusUnitTest;\n"
"import io.restassured.RestAssured;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:603
#, no-wrap
msgid "import static org.hamcrest.Matchers.containsString;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:605
#, no-wrap
msgid "public class GreetingTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:609
#, no-wrap
msgid ""
"  @RegisterExtension\n"
"  static final QuarkusUnitTest config = new QuarkusUnitTest()\n"
"    .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)); // "
"<1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:614
#, no-wrap
msgid ""
"  @Test\n"
"  public void testGreeting() {\n"
"    RestAssured.when().get(\"/greeting\").then().statusCode(200)."
"body(containsString(\"Hello\")); // <2>\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:619
#, fuzzy
msgid ""
"We register a Junit Extension which will start a Quarkus application with "
"the Greeting extension."
msgstr "グリーティング拡張機能でQuarkusアプリを起動するJunit拡張機能を登録しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:620
#, fuzzy
msgid ""
"We verify the application has a `greeting` endpoint responding to a HTTP GET "
"request with a OK status (200) and a plain text body containing `Hello`"
msgstr ""
"アプリケーションが `greeting` エンドポイントから OK ステータス (200) の HTTP GET "
"要求に応答していることと、以下の内容を含むプレーンテキストボディを持っていることを確認します。 `Hello`"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:622
#, fuzzy
msgid "Time to test!"
msgstr "テストの時間だ！"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:664
#, no-wrap
msgid ""
"$ mvn clean test\n"
"[INFO] Scanning for projects...\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Reactor Build Order:\n"
"[INFO]\n"
"[INFO] Greeting Extension - Parent                                        "
"[pom]\n"
"[INFO] Greeting Extension - Runtime                                       "
"[jar]\n"
"[INFO] Greeting Extension - Deployment                                    "
"[jar]\n"
"[INFO]\n"
"...\n"
"[INFO] --- maven-surefire-plugin:3.0.0-M4:test (default-test) @ quarkus-"
"greeting-deployment ---\n"
"[INFO] \n"
"[INFO] -------------------------------------------------------\n"
"[INFO]  T E S T S\n"
"[INFO] -------------------------------------------------------\n"
"[INFO] Running org.acme.quarkus.greeting.deployment.GreetingTest\n"
"2020-04-23 13:55:44,612 INFO  [io.quarkus] (main) Quarkus {quarkus-version} "
"started in 0.395s. Listening on: http://0.0.0.0:8081\n"
"2020-04-23 13:55:44,614 INFO  [io.quarkus] (main) Profile test activated. \n"
"2020-04-23 13:55:44,614 INFO  [io.quarkus] (main) Installed features: [cdi, "
"quarkus-greeting, servlet]\n"
"2020-04-23 13:55:45,876 INFO  [io.quarkus] (main) Quarkus stopped in 0.025s\n"
"[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.609 "
"s - in org.acme.quarkus.greeting.deployment.GreetingTest\n"
"[INFO] \n"
"[INFO] Results:\n"
"[INFO] \n"
"[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0\n"
"[INFO]\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Reactor Summary for getting-started-extension 1.0-SNAPSHOT:\n"
"[INFO]\n"
"[INFO] getting-started-extension .......................... SUCCESS [  0.076 "
"s]\n"
"[INFO] Greeting Extension - Parent ........................ SUCCESS [  0.002 "
"s]\n"
"[INFO] Greeting Extension - Runtime ....................... SUCCESS [  1.467 "
"s]\n"
"[INFO] Greeting Extension - Deployment .................... SUCCESS [  4.099 "
"s]\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] BUILD SUCCESS\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Total time:  5.745 s\n"
"[INFO] Finished at: 2020-01-28T22:40:56+01:00\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:667
#, fuzzy
msgid "Looks good! Congratulations you just finished your first extension."
msgstr "良さそうですね～。初めての増築を終えたばかりで、おめでとうございます。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:668
#, no-wrap, fuzzy
msgid "Debugging your extension"
msgstr "拡張機能のデバッグ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:672
#, fuzzy
msgid ""
"_If debugging is the process of removing bugs, then programming must be the "
"process of putting them in._ Edsger W. Dijkstra"
msgstr "_デバッグがバグを取り除く作業であるならば、プログラミングはバグを入れる作業でなければならない。_エドガー・W・ダイクストラ"

#. type: Title ====
#: upstream/_guides/building-my-first-extension.adoc:674
#, no-wrap, fuzzy
msgid "Debugging your application build"
msgstr "アプリケーションのビルドをデバッグする"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:678
#, fuzzy
msgid ""
"Since your extension deployment is made during the application build, this "
"process is triggered by your build tool.  That means if you want to debug "
"this phase you need to launch your build tool with the remote debug mode "
"switched one."
msgstr ""
"拡張機能のデプロイはアプリケーションのビルド中に行われるので、このプロセスはビルドツールによってトリガされます。つまり、このフェーズをデバッグしたい場合は、リモートデバッグモードを切り替えてビルドツールを起動する必要があります。"

#. type: Title =====
#: upstream/_guides/building-my-first-extension.adoc:679
#, no-wrap, fuzzy
msgid "Maven"
msgstr "メイヴン"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:683
#, fuzzy
msgid ""
"You can activate Maven remote debugging by using `mvnDebug`.  You can launch "
"your application with the following command line:"
msgstr ""
"`mvnDebug` を使用して、Maven リモートデバッグを有効にすることができます。以下のコマンドラインでアプリケーションを起動できます。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:687
#, no-wrap
msgid "mvnDebug clean compile quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:691
#, fuzzy
msgid ""
"By default, Maven will wait for a connection on `localhost:8000`.  Now, you "
"can run your IDE `Remote` configuration to attach it to `localhost:8000`."
msgstr ""
"デフォルトでは、Mavenは、 `localhost:8000` 上の接続を待ちます。今、あなたはそれをアタッチするために、IDE `Remote` "
"の設定を実行することができます `localhost:8000`."

#. type: Title =====
#: upstream/_guides/building-my-first-extension.adoc:692
#, no-wrap, fuzzy
msgid "Gradle"
msgstr "グラドル"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:696
#, fuzzy
msgid ""
"You can activate Gradle remote debugging by using the flags `org.gradle."
"debug=true` or `org.gradle.daemon.debug=true` in daemon mode.  You can "
"launch your application with the following command line:"
msgstr ""
"Gradle のリモートデバッグは、デーモンモードでフラグ `org.gradle.debug=true` または `org.gradle.daemon."
"debug=true` を使用して有効にすることができます。以下のコマンドラインでアプリケーションを起動することができます。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:700
#, no-wrap
msgid "./gradlew quarkusDev -Dorg.gradle.daemon.debug=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:704
#, fuzzy
msgid ""
"By default, Gradle will wait for a connection on `localhost:5005`.  Now, you "
"can run your IDE `Remote` configuration to attach it to `localhost:5005`."
msgstr ""
"デフォルトでは、Gradleは、 `localhost:5005` 上の接続を待ちます。今、あなたはそれを `localhost:5005` "
"にアタッチするために、あなたの IDE `Remote` の設定を実行することができます。"

#. type: Title ====
#: upstream/_guides/building-my-first-extension.adoc:706
#, no-wrap, fuzzy
msgid "Debugging your extension tests"
msgstr "拡張機能テストのデバッグ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:710
#, fuzzy
msgid ""
"We have seen together how to test your extension and sometimes things don't "
"go so well and you want to debug your tests.  Same principle here, the trick "
"is to enable the Maven Surefire remote debugging in order to attach an IDE "
"`Remote` configuration."
msgstr ""
"拡張機能をテストする方法を一緒に見てきましたが、時にはうまくいかず、テストをデバッグしたい場合もあります。ここでも同じ原理で、IDE `Remote` "
"の設定をアタッチするために Maven Surefire リモートデバッグを有効にするのがコツです。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:715
#, no-wrap
msgid "$ cd ./greeting\n"
"$ mvn clean test -Dmaven.surefire.debug\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:718
#, fuzzy
msgid "By default, Maven will wait for a connection on `localhost:5005`."
msgstr "デフォルトでは、Maven は `localhost:5005` で接続を待ちます。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:719
#, no-wrap, fuzzy
msgid "Extension publication"
msgstr "拡張出版物"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:722
#, fuzzy
msgid ""
"Now that you just finished building your first extension you should be eager "
"to use it in a Quarkus application!"
msgstr "最初の拡張機能を構築し終えたばかりなので、Quarkusアプリケーションで使いたいと思うはずです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:724
#, no-wrap, fuzzy
msgid "*Classic Maven publication*\n"
msgstr "*古典的なメイヴンの出版*"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:727
#, fuzzy
msgid ""
"Because your extension produces traditional JARs, the easiest way to share "
"your extension is to publish it to a Maven repository.  Once published you "
"can simply declare it with your project dependencies. Let's demonstrate that "
"by creating a simple Quarkus application"
msgstr ""
"あなたの拡張機能は従来の JAR を生成するので、拡張機能を共有する最も簡単な方法は Maven "
"リポジトリに公開することです。公開したら、プロジェクトの依存関係とともに宣言するだけです。シンプルなQuarkusアプリケーションを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:735
#, no-wrap
msgid ""
"$mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"     -DprojectGroupId=org.acme \\\n"
"     -DprojectArtifactId=greeting-app \\\n"
"     -DprojectVersion=1.0-SNAPSHOT \\\n"
"     -DnoExamples\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:738
#, fuzzy
msgid ""
"`cd` into `greeting-app` and add the dependency on `quarkus-greeting` "
"extension we created above."
msgstr ""
"`cd` を `greeting-app` に入れて、上で作成した `quarkus-greeting` の拡張機能に依存関係を追加します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:740
#, fuzzy
msgid ""
"`quarkus-greeting` extension has to be installed in the local Maven "
"repository to be usable in the application."
msgstr ""
"`quarkus-greeting` 拡張機能をアプリケーションで使用できるようにするには、ローカルの Maven "
"リポジトリにインストールする必要があります。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:754
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId>\n"
"            <version>1.0-SNAPSHOT</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-resteasy</artifactId>\n"
"        </dependency>\n"
"        <!-- the rest of the application dependencies -->\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:757
#, fuzzy
msgid ""
"Run the application and notice the `Install Features` list contains the "
"`quarkus-greeting` extension."
msgstr ""
"アプリケーションを実行して、 `Install Features` のリストに `quarkus-greeting` "
"の拡張子が含まれていることに気づきます。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:787
#, no-wrap
msgid ""
"$ mvn clean compile quarkus:dev\n"
"[INFO] Scanning for projects...\n"
"[INFO]\n"
"[INFO] ---------------------< org.acme:code-with-quarkus >-------------------"
"--\n"
"[INFO] Building code-with-quarkus 1.0.0-SNAPSHOT\n"
"[INFO] --------------------------------[ jar ]-------------------------------"
"--\n"
"[INFO]\n"
"[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ code-with-quarkus -"
"--\n"
"[INFO] Deleting /tmp/code-with-quarkus/target\n"
"[INFO]\n"
"[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ code-"
"with-quarkus ---\n"
"[INFO] Using 'UTF-8' encoding to copy filtered resources.\n"
"[INFO] Copying 2 resources\n"
"[INFO]\n"
"[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ code-with-"
"quarkus ---\n"
"[INFO] Changes detected - recompiling the module!\n"
"[INFO] Compiling 1 source file to /tmp/code-with-quarkus/target/classes\n"
"[INFO]\n"
"[INFO] --- quarkus-maven-plugin:{quarkus-version}:dev (default-cli) @ code-"
"with-quarkus ---\n"
"Listening for transport dt_socket at address: 5005\n"
"__  ____  __  _____   ___  __ ____  ______ \n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/ \n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\   \n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/   \n"
"2020-04-23 14:17:36,137 INFO  [io.quarkus] (Quarkus Main Thread) greeting-"
"app 1.0-SNAPSHOT (powered by Quarkus {quarkus-version}) started in 0.985s. "
"Listening on: http://0.0.0.0:8080\n"
"2020-04-23 14:17:36,140 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev "
"activated. Live Coding activated.\n"
"2020-04-23 14:17:36,140 INFO  [io.quarkus] (Quarkus Main Thread) Installed "
"features: [cdi, quarkus-greeting, resteasy, servlet]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:792
#, fuzzy
msgid ""
"From an extension developer standpoint the Maven publication strategy is "
"very handy and fast but Quarkus wants to go one step further by also "
"ensuring a reliability of the ecosystem for the people who will use the "
"extensions.  Think about it, we all had a poor Developer Experience with an "
"unmaintained library, an incompatibility between dependencies (and we don't "
"even talk about legal issues).  That's why there is the Quarkus Platform."
msgstr ""
"拡張機能の開発者の立場からすると、Mavenの公開戦略は非常に便利で高速ですが、Quarkusは、拡張機能を使用する人々のためにエコシステムの信頼性も確保することで、さらに一歩進んでいきたいと考えています。考えてみてください。私たちは皆、メンテナンスされていないライブラリ、依存関係間の非互換性（法的な問題についても話しません）で、開発者の経験が乏しいことを経験しています。そのためにQuarkus "
"Platformがあるのです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:794
#, no-wrap, fuzzy
msgid "*Quarkus Platform*\n"
msgstr "*Quarkusプラットフォーム*"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:796
#, fuzzy
msgid ""
"Quarkus proposes a `quarkus-universe-bom` which is a certified list of "
"extensions placed under the Quarkus Platform label. From an application "
"developer, the objectives of the platform are:"
msgstr ""
"Quarkusは、Quarkus Platformラベルの下に置かれた拡張機能の認定リストである `quarkus-universe-bom` "
"を提案しています。アプリケーション開発者からすると、このプラットフォームの目的は"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:798
#, fuzzy
msgid ""
"To guarantee a supportability of the extension (bugfix, security issues, "
"dependency upgrades)"
msgstr "拡張機能のサポート性を保証するために (バグフィックス、セキュリティ問題、依存関係のアップグレード)"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:799
#, fuzzy
msgid ""
"To ease the extension discovery through the Quarkus CLI or https://code."
"quarkus.io/"
msgstr "Quarkus CLIまたは https://code.quarkus.io/ を通じて拡張機能の発見を容易にするには"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:800
#, fuzzy
msgid "To ensure a global consistency of the extension ecosystem"
msgstr "拡張エコシステムのグローバルな整合性を確保するために"

#. type: Block title
#: upstream/_guides/building-my-first-extension.adoc:802
#, no-wrap, fuzzy
msgid "Should I publish my extension to the platform?"
msgstr "拡張機能をプラットフォームに公開すべきか？"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:807
#, fuzzy
msgid ""
"If you feel your extensions is for you or a limited group, simply publishing "
"to Maven is fine.  If the extension solves a general problem, it is very "
"handy for Quarkus users to see it on https://code.quarkus.io.  But this "
"comes with some responsibility for you, keeping it up to date with Quarkus "
"minor releases (every month or so at the moment).  When in doubt, have a "
"conversation with the community in the https://groups.google.com/forum/"
"#!forum/quarkus-dev[Quarkus Google Group]. We can make a collective decision."
""
msgstr ""
"拡張機能が自分や限定されたグループのためのものだと感じるのであれば、Mavenに公開するだけでも構いません。拡張機能が一般的な問題を解決する場合、Quarkusユーザーにとって、 "
"https://code.quarkus.io  "
"でそれを見ることができるのは非常に便利です。しかし、これには、Quarkusのマイナーリリース（現時点では1ヶ月に1回程度）に合わせて最新の状態に保つという、あなたの責任が伴います。疑問がある場合は、Quarkusの "
"link:https://groups.google.com/forum/#!forum/quarkus-"
"dev[Googleグループ]でコミュニティと会話をしてください。集団的な決定をすることができます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:811
#, fuzzy
msgid ""
"As for now, the process to propose a new extension is not defined yet.  Your "
"best chance is to present your extension on the https://groups.google.com/"
"forum/#!forum/quarkus-dev[Quarkus Google Group] and wait for an official "
"invitation to join the Quarkus Platform."
msgstr ""
"今のところ、新しい拡張機能を提案するプロセスはまだ定義されていません。最良のチャンスは、 link:https://groups.google.com/"
"forum/#!forum/quarkus-dev[Quarkus Googleグループ]で拡張機能を提案し、Quarkus "
"Platformへの正式な招待状が届くのを待つことです。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:590
#, no-wrap, fuzzy
msgid "Conclusion"
msgstr "結論"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:815
#, fuzzy
msgid ""
"Creating new extensions may appear to be an intricate task at first but once "
"you understood the Quarkus game-changer paradigm (build time vs runtime) the "
"structure of an extension makes perfectly sense."
msgstr ""
"新しい拡張機能の作成は、最初は複雑な作業に見えるかもしれませんが、Quarkusのゲームチェンジャーのパラダイム（ビルド時間とランタイム）を理解してしまえば、拡張機能の構造は完璧に理にかなったものになります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:816
#, fuzzy
msgid ""
"As usual, along the path Quarkus simplifies things under the hood (Maven "
"Mojo, bytecode generation or testing) to make it pleasant to develop new "
"features."
msgstr ""
"いつものように、Quarkusはパスに沿って、新機能の開発を快適にするために、フードの下で物事を単純化します（Maven "
"Mojo、バイトコード生成またはテスト）。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/microprofile-graphql.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - GraphQL"
msgstr "Quarkus - GraphQL"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:12
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize the "
"**Eclipse MicroProfile GraphQL** specification through the SmallRye GraphQL "
"extension."
msgstr ""
"このガイドでは、QuarkusアプリケーションがSmallRye GraphQL拡張機能を使用して *Eclipse MicroProfile "
"GraphQL*仕様を利用する方法を説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:14
#, fuzzy
msgid "As the https://www.graphql.org/[GraphQL] specification website states:"
msgstr "link:https://www.graphql.org/[GraphQLの]仕様サイトにも記載されているように"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:20
#, fuzzy
msgid ""
"GraphQL is a query language for APIs and a runtime for fulfilling those "
"queries with your existing data.  GraphQL provides a complete and "
"understandable description of the data in your API, gives clients the power "
"to ask for exactly what they need and nothing more, makes it easier to "
"evolve APIs over time, and enables powerful developer tools."
msgstr ""
"GraphQLはAPI用のクエリ言語であり、既存のデータを使ってクエリを実行するためのランタイムです。GraphQLは、API内のデータを完全かつ理解しやすい形で記述し、クライアントが必要とするものを正確に求めることができるようにします。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:23
#, no-wrap, fuzzy
msgid ""
"**GraphQL** was originally developed by **Facebook** in 2012 and has been\n"
"an open standard since 2015.\n"
msgstr "*GraphQLは*もともと2012年に *Facebookが*開発したもので、2015年からはオープンスタンダードとなっています。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:26
#, fuzzy
msgid ""
"GraphQL is not a replacement for REST API specification but merely an "
"alternative. Unlike REST, GraphQL API's have the ability to benefit the "
"client by:"
msgstr ""
"GraphQLはREST APIの仕様を置き換えるものではなく、単なる代替品です。RESTとは異なり、GraphQL "
"APIは以下のようにクライアントに利益をもたらす機能を持っています。"

#. type: Labeled list
#: upstream/_guides/microprofile-graphql.adoc:27
#, no-wrap, fuzzy
msgid "Preventing Over-fetching and Under-fetching"
msgstr "オーバーフェッチとアンダーフェッチの防止"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:33
#, fuzzy
msgid ""
"REST API's are server-driven fixed data responses that cannot be determined "
"by the client. Although the client does not require all the fields the "
"client must retrieve all the data hence `Over-fetching`. A client may also "
"require multiple REST API calls according to the first call (HATEOAS) to "
"retrieve all the data that is required thereby `Under-fetching`."
msgstr ""
"REST API "
"は、クライアントが決定できないサーバー主導の固定データレスポンスです。クライアントはすべてのフィールドを必要としませんが、クライアントはすべてのデータを取得しなければならないため、 "
"`Over-fetching` 。クライアントはまた、必要とされるすべてのデータを取得するために、最初の呼び出し（HATEOAS）に応じて複数のREST "
"API呼び出しを必要とする場合があります。 `Under-fetching`."

#. type: Labeled list
#: upstream/_guides/microprofile-graphql.adoc:34
#, no-wrap, fuzzy
msgid "API Evolution"
msgstr "APIの進化"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:38
#, fuzzy
msgid ""
"Since GraphQL API's returns data that are requested by the client adding "
"additional fields and capabilities to existing API will not create breaking "
"changes to existing clients."
msgstr ""
"GraphQL "
"APIはクライアントから要求されたデータを返すので、既存のAPIにフィールドや機能を追加しても、既存のクライアントに大きな変更を加えることはありません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:21
#, fuzzy
msgid "less than 15 minutes"
msgstr "15分以内"

#. type: Title ==
#: upstream/_guides/scheduler.adoc:24
#, no-wrap, fuzzy
msgid "Architecture"
msgstr "建築"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:52
#, fuzzy
msgid ""
"In this guide, we build a simple GraphQL application that exposes a GraphQL "
"API at `/graphql`."
msgstr "このガイドでは、 `/graphql` で GraphQL API を公開するシンプルな GraphQL アプリケーションを構築します。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:54
#, fuzzy
msgid "This example was inspired by a popular GraphQL API."
msgstr "この例は、人気のある GraphQL API にインスパイアされたものです。"

#. type: Title ==
#: upstream/_guides/scheduler.adoc:31
#, no-wrap, fuzzy
msgid "Solution"
msgstr "解決策"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:35
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step.  However, you can go right to the "
"completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:37
#, fuzzy
msgid ""
"Clone the Git repository: `git clone {quickstarts-clone-url}`, or download "
"an {quickstarts-archive-url}[archive]."
msgstr ""
"Git リポジトリをクローンします: `git clone {quickstarts-clone-url}` 、または {quickstarts-"
"archive-url}[archive] をダウンロードしてください。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:63
#, fuzzy
msgid ""
"The solution is located in the `microprofile-graphql-quickstart` "
"{quickstarts-tree-url}/microprofile-graphql-quickstart[directory]."
msgstr ""
"ソリューションは `microprofile-graphql-quickstart` {quickstarts-tree-url}/"
"microprofile-graphql-quickstart[directory] にあります。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:45
#, no-wrap, fuzzy
msgid "Creating the Maven Project"
msgstr "Mavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:43
#, fuzzy
msgid ""
"First, we need a new project. Create a new project with the following "
"command:"
msgstr "まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:76
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=microprofile-graphql-quickstart \\\n"
"    -DclassName=\"org.acme.microprofile.graphql.FilmResource\" \\\n"
"    -Dextensions=\"graphql\"\n"
"cd microprofile-graphql-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:79
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `smallrye-graphql` "
"extension which is an implementation of the MicroProfile GraphQL "
"specification used in Quarkus."
msgstr ""
"このコマンドは、Quarkusで使用されているMicroProfile GraphQL仕様の実装である `smallrye-graphql` "
"拡張子をインポートして、Mavenプロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:82
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-graphql` extension to your project by running the following "
"command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-graphql` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:86
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"graphql\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler.adoc:75
#, fuzzy
msgid "This will add the following to your `pom.xml`:"
msgstr "これにより、 `pom.xml`."

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:96
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-graphql</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:98
#, no-wrap, fuzzy
msgid "Preparing an Application: GraphQL API"
msgstr "アプリケーションの準備GraphQL API"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:101
#, fuzzy
msgid "In this section we will start creating the GraphQL API."
msgstr "このセクションでは、GraphQL APIの作成を開始します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:103
#, fuzzy
msgid ""
"First, create the following entities representing a film from a galaxy far "
"far away:"
msgstr "まず、遠く離れた銀河系の映画を表す次のような実体を作りなさい。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:107
#, no-wrap
msgid "package org.acme.microprofile.graphql;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:109
#, no-wrap
msgid "public class Film {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:114
#, no-wrap
msgid ""
"    private String title;\n"
"    private Integer episodeID;\n"
"    private String director;\n"
"    private LocalDate releaseDate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:118
#, no-wrap
msgid "    public String getTitle() {\n"
"        return title;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:122
#, no-wrap
msgid ""
"    public void setTitle(String title) {\n"
"        this.title = title;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:126
#, no-wrap
msgid "    public Integer getEpisodeID() {\n"
"        return episodeID;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:130
#, no-wrap
msgid ""
"    public void setEpisodeID(Integer episodeID) {\n"
"        this.episodeID = episodeID;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:134
#, no-wrap
msgid "    public String getDirector() {\n"
"        return director;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:138
#, no-wrap
msgid ""
"    public void setDirector(String director) {\n"
"        this.director = director;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:142
#, no-wrap
msgid ""
"    public LocalDate getReleaseDate() {\n"
"        return releaseDate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:146
#, no-wrap
msgid ""
"    public void setReleaseDate(LocalDate releaseDate) {\n"
"        this.releaseDate = releaseDate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:150
#, no-wrap
msgid "public class Hero {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:158
#, no-wrap
msgid ""
"    private String name;\n"
"    private String surname;\n"
"    private Double height;\n"
"    private Integer mass;\n"
"    private Boolean darkSide;\n"
"    private LightSaber lightSaber;\n"
"    private List<Integer> episodeIds = new ArrayList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:152
#, no-wrap
msgid "    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:156
#, no-wrap
msgid ""
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:170
#, no-wrap
msgid "    public String getSurname() {\n"
"        return surname;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:174
#, no-wrap
msgid ""
"    public void setSurname(String surname) {\n"
"        this.surname = surname;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:178
#, no-wrap
msgid "    public Double getHeight() {\n"
"        return height;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:182
#, no-wrap
msgid ""
"    public void setHeight(Double height) {\n"
"        this.height = height;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:186
#, no-wrap
msgid "    public Integer getMass() {\n"
"        return mass;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:190
#, no-wrap
msgid ""
"    public void setMass(Integer mass) {\n"
"        this.mass = mass;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:194
#, no-wrap
msgid "    public Boolean getDarkSide() {\n"
"        return darkSide;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:198
#, no-wrap
msgid ""
"    public void setDarkSide(Boolean darkSide) {\n"
"        this.darkSide = darkSide;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:202
#, no-wrap
msgid ""
"    public LightSaber getLightSaber() {\n"
"        return lightSaber;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:206
#, no-wrap
msgid ""
"    public void setLightSaber(LightSaber lightSaber) {\n"
"        this.lightSaber = lightSaber;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:210
#, no-wrap
msgid ""
"    public List<Integer> getEpisodeIds() {\n"
"        return episodeIds;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:215
#, no-wrap
msgid ""
"    public void setEpisodeIds(List<Integer> episodeIds) {\n"
"        this.episodeIds = episodeIds;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:219
#, no-wrap
msgid "enum LightSaber {\n"
"    RED, BLUE, GREEN\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:223
#, fuzzy
msgid ""
"The classes we have just created describe the GraphQL schema which is a set "
"of possible data (objects, fields, relationships) that a client can access."
msgstr ""
"先ほど作成したクラスは、クライアントがアクセスできる可能性のあるデータ（オブジェクト、フィールド、リレーションシップ）のセットである GraphQL "
"スキーマを記述しています。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:225
#, fuzzy
msgid ""
"Let's continue with an example CDI bean, that would work as a repository:"
msgstr "リポジトリとして動作するCDIビーンの例を見てみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:230
#, no-wrap
msgid "@ApplicationScoped\n"
"public class GalaxyService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:232
#, no-wrap
msgid "    private List<Hero> heroes = new ArrayList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:234
#, no-wrap
msgid "    private List<Film> films = new ArrayList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:236
#, no-wrap
msgid "    public GalaxyService() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:242
#, no-wrap
msgid ""
"        Film aNewHope = new Film();\n"
"        aNewHope.setTitle(\"A New Hope\");\n"
"        aNewHope.setReleaseDate(LocalDate.of(1977, Month.MAY, 25));\n"
"        aNewHope.setEpisodeID(4);\n"
"        aNewHope.setDirector(\"George Lucas\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:248
#, no-wrap
msgid ""
"        Film theEmpireStrikesBack = new Film();\n"
"        theEmpireStrikesBack.setTitle(\"The Empire Strikes Back\");\n"
"        theEmpireStrikesBack.setReleaseDate(LocalDate.of(1980, Month.MAY, "
"21));\n"
"        theEmpireStrikesBack.setEpisodeID(5);\n"
"        theEmpireStrikesBack.setDirector(\"George Lucas\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:254
#, no-wrap
msgid ""
"        Film returnOfTheJedi = new Film();\n"
"        returnOfTheJedi.setTitle(\"Return Of The Jedi\");\n"
"        returnOfTheJedi.setReleaseDate(LocalDate.of(1983, Month.MAY, 25));\n"
"        returnOfTheJedi.setEpisodeID(6);\n"
"        returnOfTheJedi.setDirector(\"George Lucas\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:258
#, no-wrap
msgid ""
"        films.add(aNewHope);\n"
"        films.add(theEmpireStrikesBack);\n"
"        films.add(returnOfTheJedi);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:267
#, no-wrap
msgid ""
"        Hero luke = new Hero();\n"
"        luke.setName(\"Luke\");\n"
"        luke.setSurname(\"Skywalker\");\n"
"        luke.setHeight(1.7);\n"
"        luke.setMass(73);\n"
"        luke.setLightSaber(LightSaber.GREEN);\n"
"        luke.setDarkSide(false);\n"
"        luke.getEpisodeIds().addAll(Arrays.asList(4, 5, 6));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:275
#, no-wrap
msgid ""
"        Hero leia = new Hero();\n"
"        leia.setName(\"Leia\");\n"
"        leia.setSurname(\"Organa\");\n"
"        leia.setHeight(1.5);\n"
"        leia.setMass(51);\n"
"        leia.setDarkSide(false);\n"
"        leia.getEpisodeIds().addAll(Arrays.asList(4, 5, 6));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:285
#, no-wrap
msgid ""
"        Hero vader = new Hero();\n"
"        vader.setName(\"Darth\");\n"
"        vader.setSurname(\"Vader\");\n"
"        vader.setHeight(1.9);\n"
"        vader.setMass(89);\n"
"        vader.setDarkSide(true);\n"
"        vader.setLightSaber(LightSaber.RED);\n"
"        vader.getEpisodeIds().addAll(Arrays.asList(4, 5, 6));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:289
#, no-wrap
msgid ""
"        heroes.add(luke);\n"
"        heroes.add(leia);\n"
"        heroes.add(vader);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:291
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:295
#, no-wrap
msgid "    public List<Film> getAllFilms() {\n"
"        return films;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:299
#, no-wrap
msgid "    public Film getFilm(int id) {\n"
"        return films.get(id);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:305
#, no-wrap
msgid ""
"    public List<Hero> getHeroesByFilm(Film film) {\n"
"        return heroes.stream()\n"
"                .filter(hero -> hero.getEpisodeIds().contains(film."
"getEpisodeID()))\n"
"                .collect(Collectors.toList());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:309
#, no-wrap
msgid "    public void addHero(Hero hero) {\n"
"        heroes.add(hero);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:313
#, no-wrap
msgid ""
"    public Hero deleteHero(int id) {\n"
"        return heroes.remove(id);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:320
#, no-wrap
msgid ""
"    public List<Hero> getHeroesBySurname(String surname) {\n"
"        return heroes.stream()\n"
"                .filter(hero -> hero.getSurname().equals(surname))\n"
"                .collect(Collectors.toList());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:323
#, fuzzy
msgid "Now, let's create our first GraphQL API."
msgstr "では、最初の GraphQL API を作成してみましょう。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:325
#, fuzzy
msgid ""
"Edit the `org.acme.microprofile.graphql.FilmResource` class as following:"
msgstr "`org.acme.microprofile.graphql.FilmResource` クラスを以下のように編集します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:330
#, no-wrap
msgid "@GraphQLApi // <1>\n"
"public class FilmResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:333
#, no-wrap
msgid "    @Inject\n"
"    GalaxyService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:340
#, no-wrap
msgid ""
"    @Query(\"allFilms\") // <2>\n"
"    @Description(\"Get all Films from a galaxy far far away\") // <3>\n"
"    public List<Film> getAllFilms() {\n"
"        return service.getAllFilms();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:343
#, fuzzy
msgid ""
"`@GraphQLApi` annotation indicates that the CDI bean will be a GraphQL "
"endpoint"
msgstr "`@GraphQLApi` アノテーションは、CDI BeanがGraphQLエンドポイントになることを示します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:344
#, fuzzy
msgid ""
"`@Query` annotation defines that this method will be queryable with the name "
"`allFilms`"
msgstr "`@Query` アノテーションは、このメソッドが名前を付けてクエリ可能であることを定義しています。 `allFilms`"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:345
#, fuzzy
msgid "Documentation of the queryable method"
msgstr "クエリー可能なメソッドのドキュメント"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:348
#, fuzzy
msgid ""
"The value of the `@Query` annotation is optional and would implicitly be "
"defaulted to the method name if absent."
msgstr "`@Query` アノテーションの値はオプションで、これがない場合は暗黙のうちにメソッド名がデフォルトになります。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:350
#, fuzzy
msgid ""
"This way we have created our first queryable API which we will later expand."
msgstr "このようにして、最初のクエリー可能なAPIを作成しました。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:351
#, no-wrap, fuzzy
msgid "Launch"
msgstr "打ち上げ"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:354
#, fuzzy
msgid "Launch the quarkus app:"
msgstr "quarkusアプリを起動します。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:184
#, no-wrap
msgid "./mvnw compile quarkus:dev\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:359
#, no-wrap, fuzzy
msgid "Introspect"
msgstr "内観"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:362
#, fuzzy
msgid ""
"The full schema of the GraphQL API can be retrieved by calling the following:"
""
msgstr "GraphQL APIの完全なスキーマは、以下のように呼び出すことで取得できます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:366
#, no-wrap
msgid "curl http://localhost:8080/graphql/schema.graphql\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:369
#, fuzzy
msgid "The server will return the complete schema of the GraphQL API."
msgstr "サーバーはGraphQL APIの完全なスキーマを返します。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:370
#, no-wrap, fuzzy
msgid "GraphiQL UI"
msgstr "グラフィQL UI"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:336
#, fuzzy
msgid "Experimental - not included in the MicroProfile specification"
msgstr "実験 - MicroProfile仕様には含まれていません。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:375
#, fuzzy
msgid ""
"GraphiQL UI is a great tool permitting easy interaction with your GraphQL "
"APIs."
msgstr "GraphiQL UIは、GraphQL APIを簡単に操作できる素晴らしいツールです。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:378
#, fuzzy
msgid ""
"The Quarkus `smallrye-graphql` extension ships with `GraphiQL` and enables "
"it by default in `dev` and `test` modes, but it can also be explicitly "
"configured for `production` mode as well."
msgstr ""
"Quarkus `smallrye-graphql` 拡張機能は `GraphiQL` と同梱されており、デフォルトでは `dev` と `test` "
"モードで有効になっていますが、 `production` モードでも明示的に設定することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:380
#, fuzzy
msgid "GraphiQL can be accessed from http://localhost:8080/graphql-ui/ ."
msgstr "GraphiQL は http://localhost:8080/graphql-ui/ からアクセスできます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:382
#, fuzzy
msgid "image:graphql-ui-screenshot01.png[alt=GraphQL UI]"
msgstr "image:graphql-ui-screenshot01.png[alt=GraphQL UI]"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:383
#, no-wrap, fuzzy
msgid "Query the GraphQL API"
msgstr "GraphQL API に問い合わせる"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:386
#, fuzzy
msgid "Now visit the GraphiQL page that has been deployed in `dev` mode."
msgstr "ここで、 `dev` モードでデプロイされた GraphiQL のページにアクセスします。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:388
#, fuzzy
msgid "Enter the following query to GraphiQL and press the `play` button:"
msgstr "GraphiQLに以下のクエリを入力し、 `play` ボタンを押します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:399
#, no-wrap
msgid ""
"query allFilms {\n"
"  allFilms {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:405
#, fuzzy
msgid ""
"Since our query contains all the fields in the `Film` class we will retrieve "
"all the fields in our response. Since GraphQL API responses are client "
"determined, the client can choose which fields it will require."
msgstr ""
"クエリには `Film` クラスのすべてのフィールドが含まれているので、レスポンスに含まれるすべてのフィールドを取得します。GraphQL API "
"のレスポンスはクライアントが決定するので、クライアントはどのフィールドを必要とするかを選択することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:409
#, fuzzy
msgid ""
"Let's assume that our client only requires `title` and `releaseDate` making "
"the previous call to the API `Over-fetching` of unnecessary data."
msgstr ""
"私たちのクライアントは `title` と `releaseDate` のみを必要とし、API `Over-fetching` "
"への前回の呼び出しで不要なデータを作っていると仮定してみましょう。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:411
#, fuzzy
msgid "Enter the following query into GraphiQL and hit the `play` button:"
msgstr "GraphiQLに以下のクエリを入力し、 `play` ボタンを押します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:420
#, no-wrap
msgid "query allFilms {\n"
"  allFilms {\n"
"    title\n"
"    releaseDate\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:424
#, fuzzy
msgid ""
"Notice in the response we have only retrieved the required fields.  "
"Therefore, we have prevented `Over-fetching`."
msgstr "レスポンスでは、必須フィールドのみを取得していることに注意してください。そのため、 `Over-fetching`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:427
#, fuzzy
msgid ""
"Let's continue to expand our GraphQL API by adding the following to the "
"`FilmResource` class."
msgstr "引き続き、 `FilmResource` クラスに以下を追加して GraphQL API を拡張してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:435
#, no-wrap
msgid ""
"    @Query\n"
"    @Description(\"Get a Films from a galaxy far far away\")\n"
"    public Film getFilm(@Name(\"filmId\") int id) {\n"
"        return service.getFilm(id);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:440
#, fuzzy
msgid ""
"Notice how we have excluded the value in the `@Query` annotation.  "
"Therefore, the name of the query is implicitly set as the method name "
"excluding the `get`."
msgstr "`@Query` アノテーションの値を除外したことに注目してください。したがって、クエリの名前は暗黙のうちに `get`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:442
#, fuzzy
msgid "This query will allow the client to retrieve the film by id."
msgstr "このクエリは、クライアントがIDでフィルムを検索することを可能にします。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:444
#, fuzzy
msgid "Enter the following into `GraphiQL` and make a request."
msgstr "`GraphiQL` に以下を入力してリクエストしてください。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:455
#, no-wrap
msgid ""
"query getFilm {\n"
"  film(filmId: 1) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:460
#, fuzzy
msgid ""
"The `film` query method requested fields can be determined as such in our "
"previous example. This way we can retrieve individual film information."
msgstr ""
"`film` "
"クエリメソッドで要求されたフィールドは、先ほどの例のように決定することができます。このようにして、個々のフィルム情報を取得することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:464
#, fuzzy
msgid ""
"However, say our client requires both films with filmId `0` and `1`.  In a "
"REST API the client would have to make two calls to the API.  Therefore, the "
"client would be `Under-fetching`."
msgstr ""
"しかし、クライアントが filmId `0` と `1` の両方のフィルムを要求しているとします。REST "
"APIでは、クライアントはAPIへの呼び出しを2回行う必要があります。したがって、クライアントは `Under-fetching`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:466
#, fuzzy
msgid "In GraphQL it is possible to make multiple queries at once."
msgstr "GraphQLでは、一度に複数のクエリを作成することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:468
#, fuzzy
msgid "Enter the following into GraphiQL to retrieve two films:"
msgstr "GraphiQLに以下のように入力して、2つのフィルムを取得します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:485 upstream/_guides/microprofile-graphql.adoc:592
#, no-wrap
msgid ""
"query getFilms {\n"
"  film0: film(filmId: 0) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"  film1: film(filmId: 1) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:488
#, fuzzy
msgid ""
"This enabled the client to fetch the required data in a single request."
msgstr "これにより、クライアントは1回のリクエストで必要なデータを取得できるようになりました。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:489
#, no-wrap, fuzzy
msgid "Expanding the API"
msgstr "APIの拡張"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:493
#, fuzzy
msgid ""
"Until now, we have created a GraphQL API to retrieve film data.  We now want "
"to enable the clients to retrieve the `Hero` data of the `Film`."
msgstr ""
"今までは、映画のデータを取得するためのGraphQL APIを作成していました。今度はクライアントが `Hero` のデータを取得できるようにしたい "
"`Film`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:495 upstream/_guides/microprofile-graphql.adoc:601
#: upstream/_guides/microprofile-graphql.adoc:664
#, fuzzy
msgid "Add the following to our `FilmResource` class:"
msgstr "`FilmResource` クラスに以下を追加します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:501
#, no-wrap
msgid ""
"    public List<Hero> heroes(@Source Film film) { // <1>\n"
"        return service.getHeroesByFilm(film);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:504
#, fuzzy
msgid ""
"Enable `List<Hero>` data to be added to queries that respond with `Film`"
msgstr "で応答するクエリに `List&amp;lt;Hero&amp;gt;` データを追加できるようにします。 `Film`"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:508
#, fuzzy
msgid ""
"By adding this method we have effectively changed the schema of the GraphQL "
"API.  Although the schema has changed the previous queries will still work.  "
"Since we only expanded the API to be able to retrieve the `Hero` data of the "
"`Film`."
msgstr ""
"このメソッドを追加することで、実質的に GraphQL API "
"のスキーマを変更しました。スキーマが変更されても、以前のクエリはまだ動作します。私たちは、 `Hero` のデータを取得できるように API "
"を拡張しただけなので、 `Film`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:510
#, fuzzy
msgid "Enter the following into GraphiQL to retrieve the film and hero data."
msgstr "GraphiQLに以下のように入力して、映画やヒーローのデータを取得します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:528
#, no-wrap
msgid ""
"query getFilmHeroes {\n"
"  film(filmId: 1) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"    heroes {\n"
"      name\n"
"      height\n"
"      mass\n"
"      darkSide\n"
"      lightSaber\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:531
#, fuzzy
msgid "The response now includes the heroes of the film."
msgstr "今の反応は、この映画の主人公たちも含めて。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:532
#, no-wrap, fuzzy
msgid "Batching"
msgstr "バッチ処理"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:536
#, fuzzy
msgid ""
"When you are exposing a `Collection` return like our `getAllFilms`, you "
"might want to use the batch form of the above, to more efficiently fetch the "
"heroes:"
msgstr ""
"`getAllFilms` のように `Collection` "
"のリターンを公開している場合、より効率的にヒーローを取得するために、上記のバッチ形式を使用した方が良いかもしれません。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:542
#, no-wrap
msgid ""
"    public List<List<Hero>> heroes(@Source List<Film> films) { // <1>\n"
"        // Here fetch all hero lists\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:545
#, fuzzy
msgid ""
"Here receive the films as a batch, allowing you to fetch the corresponding "
"heroes."
msgstr "ここでは、対応するヒーローを取得することができ、バッチとしてフィルムを受信します。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:546
#, no-wrap, fuzzy
msgid "Reactive"
msgstr "反応性"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:549
#, fuzzy
msgid ""
"Queries can be made reactive by using `Uni`, or `CompletionStage` as a "
"return type, for example:"
msgstr ""
"クエリは、例えば `Uni` や `CompletionStage` をリターンタイプとして使用することで、リアクティブにすることができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:557
#, no-wrap
msgid ""
"    @Query\n"
"    @Description(\"Get a Films from a galaxy far far away\")\n"
"    public Uni<Film> getFilm(@Name(\"filmId\") int id) {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:560
#, fuzzy
msgid ""
"Due to the underlying library, graphql-java, `Uni` is creating a "
"`CompletionStage` under the hood."
msgstr ""
"基盤となるライブラリであるgraphql-javaのせいで、 `Uni` 、 `CompletionStage` 、アンダーフードを作成しています。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:562
#, fuzzy
msgid "Or you can use `CompletionStage`:"
msgstr "または、 `CompletionStage`."

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:570
#, no-wrap
msgid ""
"    @Query\n"
"    @Description(\"Get a Films from a galaxy far far away\")\n"
"    public CompletionStage<Film> getFilm(@Name(\"filmId\") int id) {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:573
#, fuzzy
msgid ""
"Using `Uni` or `CompletionStage` means that when a request contains more "
"than one query, they will be executed concurrently."
msgstr ""
"`Uni` や `CompletionStage` "
"を使うということは、リクエストに複数のクエリが含まれている場合、それらが同時に実行されることを意味します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:575
#, fuzzy
msgid ""
"For instance, the query below will fetch `film0` and `film1` concurrently:"
msgstr "例えば、以下のクエリは `film0` と `film1` を同時に取得します。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:594
#, no-wrap, fuzzy
msgid "Mutations"
msgstr "変異"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:597
#, fuzzy
msgid "Mutations are used when data is created, updated or deleted."
msgstr "突然変異は、データの作成、更新、削除の際に使用されます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:599
#, fuzzy
msgid "Let's now add the ability to add and delete heroes to our GraphQL API."
msgstr "それでは、GraphQL APIにヒーローを追加・削除する機能を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:609
#, no-wrap
msgid ""
"    @Mutation\n"
"    public Hero createHero(Hero hero) {\n"
"        service.addHero(hero);\n"
"        return hero;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:614
#, no-wrap
msgid ""
"    @Mutation\n"
"    public Hero deleteHero(int id) {\n"
"        return service.deleteHero(id);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:617
#, fuzzy
msgid "Enter the following into `GraphiQL` to insert a `Hero`:"
msgstr "`GraphiQL` に以下のように入力すると、 `Hero`."

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:635
#, no-wrap
msgid ""
"mutation addHero {\n"
"  createHero(hero: {\n"
"      name: \"Han\",\n"
"      surname: \"Solo\"\n"
"      height: 1.85\n"
"      mass: 80\n"
"      darkSide: false\n"
"      episodeIds: [4, 5, 6]\n"
"  \t}\n"
"  )\n"
"  {\n"
"    name\n"
"    surname\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:638
#, fuzzy
msgid "By using this mutation we have created a `Hero` entity in our service."
msgstr "この突然変異を使用して、私たちのサービスに `Hero` エンティティを作成しました。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:643
#, fuzzy
msgid ""
"Notice how in the response we have retrieved the `name` and `surname` of the "
"created Hero. This is because we selected to retrieve these fields in the "
"response within the `{ }` in the mutation query.  This can easily be a "
"server side generated field that the client may require."
msgstr ""
"レスポンスでは、作成したヒーローの `name` と `surname` を取得していることに注目してください。これは、突然変異クエリの `{ }` "
"でこれらのフィールドを取得するように選択したためです。これは、クライアントが必要とするサーバー側のフィールドを簡単に生成することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:645
#, fuzzy
msgid "Let's now try deleting an entry:"
msgstr "それでは、エントリーを削除してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:653
#, no-wrap
msgid "mutation DeleteHero {\n"
"  deleteHero(id :3){\n"
"    name\n"
"    surname\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:657
#, fuzzy
msgid ""
"Similar to the `createHero` mutation method we also retrieve the `name` and "
"`surname` of the hero we have deleted which is defined in `{ }`."
msgstr "`createHero` `{ }` 突然変異法と同様に、削除したヒーローの と も取得します。 `name` `surname`"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:658
#, no-wrap, fuzzy
msgid "Creating Queries by fields"
msgstr "フィールドによるクエリの作成"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:662
#, fuzzy
msgid ""
"Queries can also be done on individual fields. For example, let's create a "
"method to query heroes by their last name."
msgstr "クエリは、個々のフィールドに対しても行うことができます。例えば、ヒーローの姓名判断でクエリを行うメソッドを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:671
#, no-wrap
msgid ""
"    @Query\n"
"    public List<Hero> getHeroesWithSurname(@DefaultValue(\"Skywalker\") "
"String surname) {\n"
"        return service.getHeroesBySurname(surname);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:675
#, fuzzy
msgid ""
"By using the `@DefaultValue` annotation we have determined that the surname "
"value will be `Skywalker` when the parameter is not provided."
msgstr ""
"`@DefaultValue` アノテーションを使用することで、パラメータが提供されていない場合、苗字の値は `Skywalker` "
"になると判断しています。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:677
#, fuzzy
msgid "Test the following queries with GraphiQL:"
msgstr "以下のクエリをGraphiQLでテストします。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:694
#, no-wrap
msgid ""
"query heroWithDefaultSurname {\n"
"  heroesWithSurname{\n"
"    name\n"
"    surname\n"
"    lightSaber\n"
"  }\n"
"}\n"
"query heroWithSurnames {\n"
"  heroesWithSurname(surname: \"Vader\") {\n"
"    name\n"
"    surname\n"
"    lightSaber\n"
"  }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:696
#, no-wrap, fuzzy
msgid "Context"
msgstr "文脈"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:699
#, fuzzy
msgid ""
"You can get information about the GraphQL request anywhere in your code, "
"using this experimental, SmallRye specific feature:"
msgstr "この実験的な SmallRye 特有の機能を使えば、コードのどこにいても GraphQL リクエストに関する情報を得ることができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:704
#, no-wrap
msgid "@Inject\n"
"Context context;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:707
#, fuzzy
msgid "The context object allows you to get:"
msgstr "コンテキストオブジェクトで取得できます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:709
#, fuzzy
msgid "the original request (Query/Mutation)"
msgstr "元のリクエスト (クエリ/ミューテーション)"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:710
#, fuzzy
msgid "the arguments"
msgstr "引数"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:711
#, fuzzy
msgid "the path"
msgstr "道筋"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:712
#, fuzzy
msgid "the selected fields"
msgstr "選択されたフィールド"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:713
#, fuzzy
msgid "any variables"
msgstr "任意の変数"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:715
#, fuzzy
msgid "This allows you to optimize the downstream queries to the datastore."
msgstr "これにより、データストアへのダウンストリームクエリを最適化することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:717
#, fuzzy
msgid ""
"See the https://javadoc.io/doc/io.smallrye/smallrye-graphql-api/latest/io/"
"smallrye/graphql/api/Context.html[JavaDoc] for more details."
msgstr ""
"詳細は link:https://javadoc.io/doc/io.smallrye/smallrye-graphql-api/latest/io/"
"smallrye/graphql/api/Context.html[JavaDoc]を参照してください。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:718
#, no-wrap, fuzzy
msgid "GraphQL-Java"
msgstr "グラフQL-Java"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:721
#, fuzzy
msgid ""
"This context object also allows you to fall down to the underlying https://"
"www.graphql-java.com/[graphql-java] features by using the leaky abstraction:"
msgstr ""
"このコンテキストオブジェクトはまた、リーキー抽象化を使用して、基礎となる link:https://www.graphql-java.com/"
"[graphql-javaの]機能にフォールダウンすることを可能にします。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:725
#, no-wrap
msgid ""
"DataFetchingEnvironment dfe = context.unwrap(DataFetchingEnvironment."
"class);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:728
#, fuzzy
msgid ""
"You can also get access to the underlying `graphql-java` during schema "
"generation, to add your own features directly:"
msgstr "また、スキーマの生成中に、スキーマの基礎となる `graphql-java` にアクセスして、独自の機能を直接追加することもできます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:732
#, no-wrap
msgid ""
"public GraphQLSchema.Builder addMyOwnEnum(@Observes GraphQLSchema.Builder "
"builder) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:739
#, no-wrap
msgid ""
"    // Here add your own features directly, example adding an Enum\n"
"    GraphQLEnumType myOwnEnum = GraphQLEnumType.newEnum()\n"
"            .name(\"SomeEnum\")\n"
"            .description(\"Adding some enum type\")\n"
"            .value(\"value1\")\n"
"            .value(\"value2\").build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:742
#, no-wrap
msgid "    return builder.additionalType(myOwnEnum);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:745
#, fuzzy
msgid "By using the `@Observer` you can add anything to the Schema builder."
msgstr "`@Observer` を使用することで、スキーマビルダーに何でも追加することができます。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:746
#, no-wrap, fuzzy
msgid "Map to Scalar"
msgstr "スカラーへの地図"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:750
#, fuzzy
msgid ""
"Another SmallRye specific experimental feature, allows you to map an "
"existing scalar (that is mapped by the implementation to a certain Java "
"type) to another type, or to map complex object, that would typically create "
"a `Type` or `Input` in GraphQL, to an existing scalar."
msgstr ""
"もう一つのSmallRye特有の実験的な機能として、既存のスカラ（実装によって特定のJava型にマップされている）を別の型にマップしたり、複雑なオブジェクトをマップしたりすることができます（通常はGraphQLで "
"`Type` や `Input` を作成します）。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:751
#, no-wrap, fuzzy
msgid "Mapping an existing Scalar to another type:"
msgstr "既存のスカラを別のタイプにマッピングします。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:756
#, no-wrap
msgid "public class Movie {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:759
#, no-wrap
msgid "    @ToScalar(Scalar.Int.class)\n"
"    Long idLongThatShouldChangeToInt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:762 upstream/_guides/microprofile-graphql.adoc:777
#, no-wrap
msgid "    // ....\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:765
#, fuzzy
msgid ""
"Above will map the `Long` java type to an `Int` Scalar type, rather than the "
"https://download.eclipse.org/microprofile/microprofile-graphql-1.0/"
"microprofile-graphql.html#scalars[default] `BigInteger`."
msgstr ""
"上記の例では、 `Long` java 型を link:https://download.eclipse.org/microprofile/"
"microprofile-graphql-1.0/microprofile-graphql.html#scalars[デフォルトの] "
"`BigInteger`.NET Framework 型ではなく `Int` Scalar 型にマップします。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:766
#, no-wrap, fuzzy
msgid "Mapping a complex object to a Scalar type:"
msgstr "複雑なオブジェクトをスカラー型にマッピングします。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:771
#, no-wrap
msgid "public class Person {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:774
#, no-wrap
msgid "    @ToScalar(Scalar.String.class)\n"
"    Phone phone;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:780
#, fuzzy
msgid ""
"This will, rather than creating a `Type` or `Input` in GraphQL, map to a "
"String scalar."
msgstr "これにより、GraphQLで `Type` や `Input` を作成するのではなく、Stringスカラーにマッピングされます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:784
#, fuzzy
msgid ""
"To be able to do the above, the `Phone` object needs to have a constructor "
"that takes a String (or `Int` / `Date` / etc.), or have a setter method for "
"the String (or `Int` / `Date` / etc.), or have a `fromString` (or `fromInt` /"
" `fromDate` - depending on the Scalar type) static method."
msgstr ""
"上記を行うためには、 `Phone` オブジェクトが String (または `Int` / `Date` / など) "
"を受け取るコンストラクタを持つか、String (または `Int` / `Date` / など) のセッターメソッドを持つか、 "
"`fromString` (または `fromInt` / `fromDate` - Scalar の型によって異なります) "
"のスタティックメソッドを持つ必要があります。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:786
#, fuzzy
msgid "For example:"
msgstr "例えば"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:790
#, no-wrap
msgid "public class Phone {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:792
#, no-wrap
msgid "    private String number;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:794
#, no-wrap
msgid "    // Getters and setters....\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:801
#, no-wrap
msgid ""
"    public static Phone fromString(String number) {\n"
"        Phone phone = new Phone();\n"
"        phone.setNumber(number);\n"
"        return phone;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:804
#, fuzzy
msgid ""
"See more about the `@ToScalar` feature in the https://javadoc.io/static/io."
"smallrye/smallrye-graphql-api/1.0.6/index.html?io/smallrye/graphql/api/"
"ToScalar.html[JavaDoc]."
msgstr ""
"link:https://javadoc.io/static/io.smallrye/smallrye-graphql-api/1.0.6/index."
"html?io/smallrye/graphql/api/ToScalar.html[JavaDoc]の「 `@ToScalar` "
"」機能については、こちらをご覧ください。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:805
#, no-wrap, fuzzy
msgid "Error code"
msgstr "エラーコード"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:808
#, fuzzy
msgid ""
"You can add an error code on the error output in the GraphQL response by "
"using the (SmallRye specific) `@ErrorCode`:"
msgstr "(SmallRye特有の) `@ErrorCode`.GraphQLレスポンスのエラー出力にエラーコードを追加することができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:815
#, no-wrap
msgid ""
"@ErrorCode(\"some-business-error-code\")\n"
"public class SomeBusinessException extends RuntimeException {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:818
#, fuzzy
msgid ""
"When `SomeBusinessException` occurs, the error output will contain the Error "
"code:"
msgstr "`SomeBusinessException` が発生した場合、エラー出力にはエラーコードが含まれます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:845
#, no-wrap
msgid ""
"{\n"
"    \"errors\": [\n"
"        {\n"
"            \"message\": \"Unexpected failure in the system. Jarvis is "
"working to fix it.\",\n"
"            \"locations\": [\n"
"                {\n"
"                    \"line\": 2,\n"
"                    \"column\": 3\n"
"                }\n"
"            ],\n"
"            \"path\": [\n"
"                \"annotatedCustomBusinessException\"\n"
"            ],\n"
"            \"extensions\": {\n"
"                \"exception\": \"io.smallrye.graphql.test.apps.error.api."
"ErrorApi$AnnotatedCustomBusinessException\",\n"
"                \"classification\": \"DataFetchingException\",\n"
"                \"code\": \"some-business-error-code\" <1>\n"
"            }\n"
"        }\n"
"    ],\n"
"    \"data\": {\n"
"        ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:848
#, fuzzy
msgid "The error code"
msgstr "エラーコード"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:853
#, fuzzy
msgid ""
"MicroProfile GraphQL enables clients to retrieve the exact data that is "
"required preventing `Over-fetching` and `Under-fetching`."
msgstr ""
"MicroProfile GraphQLを使用すると、クライアントは、 `Over-fetching` と `Under-fetching` "
"を防ぐために必要なデータを正確に取得することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:856
#, fuzzy
msgid ""
"The GraphQL API can be expanded without breaking previous queries enabling "
"easy API `evolution`."
msgstr ""
"GraphQL API は、以前のクエリを壊すことなく拡張することができ、簡単に API を利用することができます `evolution`."

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1253
#, no-wrap, fuzzy
msgid "Configuration Reference"
msgstr "設定リファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/sending-emails.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Sending emails"
msgstr "Quarkus - メールの送信"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:11
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can send emails using "
"an SMTP server."
msgstr "このガイドでは、QuarkusアプリケーションがSMTPサーバーを使用して電子メールを送信する方法を説明します。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:18
#, fuzzy
msgid "The SMTP hostname, port and credentials, and an email address"
msgstr "SMTPホスト名、ポート、資格情報、および電子メール アドレス。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:22
#, fuzzy
msgid "GraalVM installed if you want to run in native mode."
msgstr "ネイティブモードで動作させたい場合は、GraalVMをインストールします。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:27
#, fuzzy
msgid ""
"In this guide, we are going to see how you can send emails from a Quarkus "
"application.  It covers simple emails, attachments, inlined attachments, the "
"reactive and imperative APIs..."
msgstr ""
"このガイドでは、Quarkusアプリケーションからメールを送信する方法を見ていきます。シンプルな電子メール、添付ファイル、インラインの添付ファイル、反応型と命令型のAPIをカバーしています。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:31
#, fuzzy
msgid "Create a new project with the following command:"
msgstr "以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:39
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=sending-email-quickstart \\\n"
"    -Dextensions=\"mailer\"\n"
"cd sending-email-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:41
#, fuzzy
msgid "If you already have an existing project, add the `mailer` extension:"
msgstr "既存のプロジェクトがある場合は、 `mailer` の拡張子を追加してください。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:45
#, no-wrap
msgid "./mvnw quarkus:add-extensions -Dextensions=\"mailer\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:56
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-mailer</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:47
#, no-wrap, fuzzy
msgid "Configuring the mailer"
msgstr "メーラーの設定"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:51
#, fuzzy
msgid ""
"The Quarkus mailer is using SMTP. In the `src/main/resources/application."
"properties` file, you need to configure the host, port, username, password "
"as well as the other configuration aspect.  Note that the password can also "
"be configured using system properties and environment variables."
msgstr ""
"QuarkusのメーラーはSMTPを使用しています。 `src/main/resources/application.properties` "
"ファイルでは、ホスト、ポート、ユーザー名、パスワードだけでなく、他の設定面も設定する必要があります。パスワードは、システムのプロパティや環境変数を使って設定することもできるので注意してください。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:53
#, fuzzy
msgid "Here is an example using _sendgrid_:"
msgstr "ここでは _sendgridを_使用した例を示します。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:74
#, no-wrap
msgid ""
"quarkus.mailer.from=test@quarkus.io\n"
"quarkus.mailer.host=smtp.sendgrid.net\n"
"quarkus.mailer.port=465\n"
"quarkus.mailer.ssl=true\n"
"quarkus.mailer.username=....\n"
"quarkus.mailer.password=....\n"
"quarkus.mailer.mock=false\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/mailer.adoc:82
#, fuzzy
msgid ""
"It is recommended to encrypt any sensitive data, such as the `quarkus.mailer."
"password`.  One approach is to save the value into a secure store like "
"HashiCorp Vault, and refer to it from the configuration.  Assuming for "
"instance that Vault contains key `mail-password` at path `myapps/myapp/"
"myconfig`, then the mailer extension can be simply configured as:"
msgstr ""
"`quarkus.mailer.password` "
"のようなセンシティブなデータは暗号化しておくことをお勧めします。一つの方法としては、HashiCorp Vault "
"のような安全なストアに値を保存し、設定から参照するという方法があります。例えば、Vault がパス `myapps/myapp/myconfig` "
"にキー `mail-password` を含んでいると仮定すると、メーラーの拡張子は単純に次のように設定することができます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:88
#, no-wrap
msgid ""
"...\n"
"# path within the kv secret engine where is located the application "
"sensitive configuration\n"
"quarkus.vault.secret-config-kv-path=myapps/myapp/myconfig\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:91
#, no-wrap
msgid "...\n"
"quarkus.mailer.password=${mail-password}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:94
#, fuzzy
msgid ""
"Please note that the password value is evaluated only once, at startup time. "
"If `mail-password` was changed in Vault, the only way to get the new value "
"would be to restart the application."
msgstr ""
"パスワードの値は、起動時に一度だけ評価されますのでご注意ください。Vault で `mail-password` "
"が変更された場合、新しい値を取得するにはアプリケーションを再起動するしかありません。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:66
#, fuzzy
msgid ""
"For more information about the Mailer extension configuration please refer "
"to the <<configuration-reference, Configuration Reference>>."
msgstr "メーラー拡張設定の詳細については、 link:#configuration-reference[設定リファレンスを]参照してください。"

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:67
#, no-wrap, fuzzy
msgid "Sending simple emails"
msgstr "簡単なメールの送信"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:70
#, fuzzy
msgid ""
"In a JAX-RS resource, or in a bean, you can inject the mailer as follows:"
msgstr "JAX-RSリソース内、またはビーン内では、以下のようにメーラーを注入することができます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:75
#, no-wrap
msgid "@Inject\n"
"Mailer mailer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:78
#, no-wrap
msgid "@Inject\n"
"ReactiveMailer reactiveMailer;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:81
#, fuzzy
msgid "There are 2 APIs:"
msgstr "APIは2つあります。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:83
#, fuzzy
msgid ""
"`io.quarkus.mailer.Mailer` provides the imperative (blocking and "
"synchronous) API;"
msgstr "`io.quarkus.mailer.Mailer` は、必須（ブロッキングと同期）APIを提供しています。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:116
#, fuzzy
msgid ""
"`io.quarkus.mailer.reactive.ReactiveMailer` provides the reactive (non-"
"blocking and asynchronous) API"
msgstr ""
"`io.quarkus.mailer.reactive.ReactiveMailer` は反応的な (ノンブロッキングで非同期の) API "
"を提供しています。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:86
#, fuzzy
msgid ""
"The two APIs are equivalent feature-wise. Actually the `Mailer` "
"implementation is built on top of the `ReactiveMailer` implementation."
msgstr "2つのAPIは機能的には同等です。実際には `Mailer` の実装は `ReactiveMailer` の実装の上に構築されています。"

#. type: Block title
#: upstream/_guides/amqp.adoc:345
#, no-wrap, fuzzy
msgid "Deprecation"
msgstr "非推奨"

#. type: delimited block =
#: upstream/_guides/mailer.adoc:123
#, fuzzy
msgid ""
"`io.quarkus.mailer.ReactiveMailer` is deprecated in favor of `io.quarkus."
"mailer.reactive.ReactiveMailer`."
msgstr ""
"`io.quarkus.mailer.ReactiveMailer` は `io.quarkus.mailer.reactive."
"ReactiveMailer` に代わって非推奨となりました。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:137
#, no-wrap, fuzzy
msgid "Mutiny"
msgstr "反乱"

#. type: delimited block =
#: upstream/_guides/mailer.adoc:129
#, fuzzy
msgid ""
"The reactive mailer uses Mutiny reactive types, if you're not familiar with "
"them, read the link:getting-started-reactive#mutiny[Getting Started with "
"Reactive guide] first."
msgstr ""
"リアクティブメーラーはMutiny link:getting-started-reactive#mutiny[リアクティブタイプ]を使用しています。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:88
#, fuzzy
msgid "To send a simple email, proceed as follows:"
msgstr "簡単なメールを送信するには、以下のように進めます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:139
#, no-wrap
msgid ""
"// Imperative API:\n"
"mailer.send(Mail.withText(\"to@acme.org\", \"A simple email from quarkus\", "
"\"This is my body.\"));\n"
"// Reactive API:\n"
"Uni<Void> stage = reactiveMailer.send(Mail.withText(\"to@acme.org\", \"A "
"reactive email from quarkus\", \"This is my body.\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:98
#, fuzzy
msgid "For example, you can use the `Mailer` in a JAX-RS endpoint as follows:"
msgstr "例えば、JAX-RS のエンドポイントで `Mailer` を使用すると、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:107
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/simple\")\n"
"public Response sendASimpleEmail() {\n"
"    mailer.send(Mail.withText(\"to@acme.org\", \"A simple email from "
"quarkus\", \"This is my body\"));\n"
"    return Response.accepted().build();\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:160
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/async\")\n"
"public CompletionStage<Response> sendASimpleEmailAsync() {\n"
"    return reactiveMailer.send(\n"
"            Mail.withText(\"to@acme.org\", \"A reactive email from "
"quarkus\", \"This is my body\"))\n"
"            .subscribeAsCompletionStage()\n"
"            .thenApply(x -> Response.accepted().build());\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/mailer.adoc:165
#, fuzzy
msgid ""
"With the `quarkus-resteasy-mutiny` extension, you can return an instance of "
"`Uni` directly."
msgstr "`quarkus-resteasy-mutiny` 拡張モジュールを使用すると、 `Uni` のインスタンスを直接返すことができます。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:118
#, fuzzy
msgid ""
"With such a JAX-RS resource, you can check that everything is working with:"
msgstr "このようなJAX-RSリソースがあれば、すべてが動作していることを確認することができます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:123
#, no-wrap
msgid "curl http://localhost:8080/simple\n"
"curl http://localhost:8080/async\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:128
#, fuzzy
msgid ""
"You can create new `io.quarkus.mailer.Mail` instances from the constructor "
"or from the `Mail.withText` and `Mail.withHtml` helper methods. The `Mail` "
"instance lets you add recipients (to, cc, or bcc), set the subject, headers, "
"sender (from) address..."
msgstr ""
"コンストラクタ、または `Mail.withText` と `Mail.withHtml` ヘルパーメソッドから、新しい `io.quarkus."
"mailer.Mail` インスタンスを作成できます。 `Mail` インスタンスでは、受信者 (to, cc, bcc) の追加、件名、ヘッダ、送信者 "
"(from) アドレスの設定などを行うことができます。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:130
#, fuzzy
msgid "You can also send several `Mail` objects in one call:"
msgstr "一度の呼び出しで複数の `Mail` オブジェクトを送信することもできます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:134
#, no-wrap
msgid "mailer.send(mail1, mail2, mail3);\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:136
#, no-wrap, fuzzy
msgid "Sending attachments"
msgstr "添付ファイルの送信"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:139
#, fuzzy
msgid ""
"To send attachment, just use the `addAttachment` methods on the `io.quarkus."
"mailer.Mail` instance:"
msgstr ""
"添付ファイルを送信するには、 `io.quarkus.mailer.Mail` インスタンスの `addAttachment` "
"メソッドを使用するだけです。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:151
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/attachment\")\n"
"public Response sendEmailWithAttachment() {\n"
"    mailer.send(Mail.withText(\"to@acme.org\", \"An email from quarkus with "
"attachment\",\n"
"            \"This is my body\")\n"
"            .addAttachment(\"my-file.txt\",\n"
"                \"content of my file\".getBytes(), \"text/plain\"));\n"
"    return Response.accepted().build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:154
#, fuzzy
msgid ""
"Attachments can be created from raw bytes (as shown in the snippet) or files."
""
msgstr "添付ファイルは、（スニペットに示すように）生のバイトから作成することも、ファイルから作成することもできます。"

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:155
#, no-wrap, fuzzy
msgid "Sending HTML emails with inlined attachments"
msgstr "インライン付きの添付ファイルでHTMLメールを送信する"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:159
#, fuzzy
msgid ""
"When sending HTML email, you can add inlined attachments.  For example, you "
"can send an image with your email, and this image will be displayed in the "
"mail content. If you put the image file into resources folder, you should "
"specify the full path to the file. \"e.g.\" \"META-INF/resources/quarkus-"
"logo.png\" otherwise quarkus will lookup in the root folder of the project"
msgstr ""
"HTMLメールを送信する際に、インラインの添付ファイルを追加することができます。例えば、メールに画像を添付して送信すると、この画像がメールの内容に表示されます。画像ファイルをリソースフォルダに入れる場合は、ファイルのフルパスを指定する必要があります。\"例\"\"META-"
"INF/resources/quarkus-logo.png\" でない場合、quarkusはプロジェクトのルートフォルダを検索します。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:174
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/html\")\n"
"public Response sendingHTML() {\n"
"    String body = \"<strong>Hello!</strong>\" + \"\\n\" +\n"
"        \"<p>Here is an image for you: <img src=\\\"cid:my-image@quarkus."
"io\\\"/></p>\" +\n"
"        \"<p>Regards</p>\";\n"
"    mailer.send(Mail.withHtml(\"to@acme.org\", \"An email in HTML\", body)\n"
"        .addInlineAttachment(\"quarkus-logo.png\",\n"
"            new File(\"quarkus-logo.png\"),\n"
"            \"image/png\", \"<my-image@quarkus.io>\"));\n"
"    return Response.accepted().build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:180
#, fuzzy
msgid ""
"Note the _content-id_ format and reference.  By spec, when you create the "
"inline attachment, the content-id must be structured as follows: "
"`<id@domain>`.  If you don't wrap your content-id between `<>`, it is "
"automatically wrapped for you.  When you want to reference your attachment, "
"for instance in the `src` attribute, use `cid:id@domain` (without the `<` "
"and `>`)."
msgstr ""
"content _-id の_形式と参照に注意してください。仕様上、インライン添付ファイルを作成する際には、content-"
"idは以下のように構成する必要があります。 `&amp;lt;id@domain&amp;gt;`. `&amp;lt;&amp;gt;` の間に "
"content-id を挟まない場合は、自動的にラップされます。添付ファイルを参照したい場合、例えば `src` 属性で参照したい場合は `cid:"
"id@domain` を使用してください（ `&amp;lt;` と `&amp;gt;` は使用しないでください）。"

#. type: Title ==
#: upstream/_guides/mailer.adoc:231
#, no-wrap, fuzzy
msgid "Message Body Based on Qute Templates"
msgstr "Quteテンプレートをベースにしたメッセージボディ"

#. type: Plain text
#: upstream/_guides/mailer.adoc:234
#, fuzzy
msgid ""
"It's also possible to inject a mail template, where the message body is "
"created automatically using link:qute[Qute templates]."
msgstr "また、 link:qute[Quteのテンプレートを]使ってメッセージ本文が自動的に作成されるメールテンプレートを注入することも可能です。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:239
#, no-wrap
msgid "@Path(\"\")\n"
"public class MailingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:244
#, no-wrap
msgid ""
"    @CheckedTemplate\n"
"    class Templates {\n"
"        public static native MailTemplateInstance hello(String name); <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:257
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/mail\")\n"
"    public CompletionStage<Response> send() {\n"
"        // the template looks like: Hello {name}! <2>\n"
"        return Templates.hello(\"John\")\n"
"           .to(\"to@acme.org\") <3>\n"
"           .subject(\"Hello from Qute template\")\n"
"           .send() <4>\n"
"           .subscribeAsCompletionStage()\n"
"           .thenApply(x -> Response.accepted().build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:260
#, fuzzy
msgid ""
"By convention, the enclosing class name and method names are used to locate "
"the template. In this particular case, we will use the `MailingResource/"
"hello.html` and `MailingResource/hello.txt` templates to create the message "
"body."
msgstr ""
"慣例では、テンプレートの場所を特定するには、クラス名とメソッド名を囲んだ部分が使用されます。この例では、 `MailingResource/hello."
"html` および `MailingResource/hello.txt` テンプレートを使用してメッセージ本文を作成します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:261 upstream/_guides/mailer.adoc:288
#, fuzzy
msgid "Set the data used in the template."
msgstr "テンプレートで使用するデータを設定します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:262 upstream/_guides/mailer.adoc:287
#, fuzzy
msgid "Create a mail template instance and set the recipient."
msgstr "メールテンプレートのインスタンスを作成し、受信者を設定します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:263 upstream/_guides/mailer.adoc:289
#, fuzzy
msgid ""
"`MailTemplate.send()` triggers the rendering and, once finished, sends the e-"
"mail via a `Mailer` instance."
msgstr ""
"`MailTemplate.send()` はレンダリングをトリガーし、レンダリングが完了すると `Mailer` "
"インスタンスを経由して電子メールを送信します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:265 upstream/_guides/mailer.adoc:291
#, fuzzy
msgid ""
"Injected mail templates are validated during build. If there is no matching "
"template in `src/main/resources/templates` the build fails."
msgstr ""
"インジェクションされたメールテンプレートはビルド中に検証されます。 `src/main/resources/templates` "
"に一致するテンプレートがない場合、ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:267
#, fuzzy
msgid "You can also do this without type-safe templates:"
msgstr "タイプセーフのテンプレートがなくてもできます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:272
#, no-wrap
msgid "@Inject\n"
"MailTemplate hello; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:284
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/mail\")\n"
"public CompletionStage<Response> send() {\n"
"    return hello.to(\"to@acme.org\") <2>\n"
"       .subject(\"Hello from Qute template\")\n"
"       // the template looks like: Hello {name}!\n"
"       .data(\"name\", \"John\") <3>\n"
"       .send() <4>\n"
"       .subscribeAsCompletionStage()\n"
"       .thenApply(x -> Response.accepted().build());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:286
#, fuzzy
msgid ""
"If there is no `@ResourcePath` qualifier provided, the field name is used to "
"locate the template. In this particular case, we will use the `hello.html` "
"and `hello.txt` templates to create the message body."
msgstr ""
"`@ResourcePath` の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この場合、 `hello."
"html` および `hello.txt` テンプレートを使用してメッセージ本文を作成します。"

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:181
#, no-wrap, fuzzy
msgid "Testing email sending"
msgstr "メール送信のテスト"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:186
#, fuzzy
msgid ""
"Because it is very inconvenient to send emails during development and "
"testing, you can set the `quarkus.mailer.mock` boolean configuration to "
"`true` to not actually send emails but print them on stdout and collect them "
"in a `MockMailbox` bean instead.  This is the default if you are running "
"Quarkus in `DEV` or `TEST` mode."
msgstr ""
"開発中やテスト中にメールを送信するのは非常に不便なので、 `quarkus.mailer.mock` のブール設定を `true` "
"に設定して、実際にはメールを送信せずに標準出力に印刷して、代わりに `MockMailbox` ビーンに収集することができます。これは、 `DEV` "
"または `TEST` モードでQuarkusを実行している場合のデフォルトです。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:188
#, fuzzy
msgid ""
"You can then write tests to verify that your emails were sent, for example, "
"by a REST endpoint:"
msgstr "そして、テストを書いて、例えばRESTエンドポイントでメールが送信されたかどうかを確認することができます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:193
#, no-wrap
msgid "@QuarkusTest\n"
"class MailTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:195
#, no-wrap
msgid "    private static final String TO = \"foo@quarkus.io\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:198
#, no-wrap
msgid "    @Inject\n"
"    MockMailbox mailbox;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:203
#, no-wrap
msgid "    @BeforeEach\n"
"    void init() {\n"
"        mailbox.clear();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:213
#, no-wrap
msgid ""
"    @Test\n"
"    void testTextMail() throws MessagingException, IOException {\n"
"        // call a REST endpoint that sends email\n"
"        given()\n"
"        .when()\n"
"        .get(\"/send-email\")\n"
"        .then()\n"
"           .statusCode(202)\n"
"           .body(is(\"OK\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:220
#, no-wrap
msgid ""
"        // verify that it was sent\n"
"        List<Mail> sent = mailbox.getMessagesSentTo(TO);\n"
"        assertThat(sent).hasSize(1);\n"
"        Mail actual = sent.get(0);\n"
"        assertThat(actual.getText()).contains(\"Wake up!\");\n"
"        assertThat(actual.getSubject()).isEqualTo(\"Alarm!\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:224
#, no-wrap
msgid ""
"        assertThat(mailbox.getTotalMessagesSent()).isEqualTo(6);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:226
#, no-wrap, fuzzy
msgid "Gmail specific configuration"
msgstr "Gmail特有の設定"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:229
#, fuzzy
msgid ""
"If you want to use the Gmail SMTP server, first create a dedicated password "
"in `Google Account > Security > App passwords` or go to https://myaccount."
"google.com/apppasswords."
msgstr ""
"GmailのSMTPサーバーを利用する場合は、まず、 `Google Account &amp;gt; Security &amp;gt; App "
"passwords` で専用のパスワードを作成するか、 https://myaccount.google.com/apppasswords 。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:231
#, fuzzy
msgid ""
"When done, you can configure your Quarkus application by adding the "
"following properties to your `application.properties`:"
msgstr ""
"完了したら、 `application.properties`."
"Quarkusアプリケーションに以下のプロパティを追加して、Quarkusアプリケーションを設定することができます。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:233
#, fuzzy
msgid "With TLS:"
msgstr "TLSで。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:354
#, no-wrap
msgid ""
"quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN "
"LOGIN\n"
"quarkus.mailer.from=YOUREMAIL@gmail.com\n"
"quarkus.mailer.host=smtp.gmail.com\n"
"quarkus.mailer.port=587\n"
"quarkus.mailer.start-tls=REQUIRED\n"
"quarkus.mailer.username=YOUREMAIL@gmail.com\n"
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:245
#, fuzzy
msgid "Or with SSL:"
msgstr "もしくはSSLで。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:367
#, fuzzy
msgid ""
"  quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 "
"PLAIN LOGIN quarkus.mailer.from=YOUREMAIL@gmail.com quarkus.mailer.host=smtp."
"gmail.com quarkus.mailer.port=465 quarkus.mailer.ssl=true quarkus.mailer."
"username=YOUREMAIL@gmail.com quarkus.mailer.password="
"YOURGENERATEDAPPLICATIONPASSWORD"
msgstr ""
"<pre>quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 "
"PLAIN LOGIN quarkus.mailer.from=YOUREMAIL@gmail.com quarkus.mailer.host=smtp."
"gmail.com quarkus.mailer.port=465 quarkus.mailer.ssl=true quarkus.mailer."
"username=YOUREMAIL@gmail.com quarkus.mailer.password="
"YOURGENERATEDAPPLICATIONPASSWORD quarkus.mailer.username=YOUREMAIL@gmail.com "
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD</pre>"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:374
#, no-wrap
msgid ""
"[NOTE]\n"
"====\n"
"The `quarkus.mailer.auth-methods` configuration option is needed for the "
"Quarkus mailer to support password authentication with Gmail.\n"
"By default both the mailer and Gmail default to `XOAUTH2` which requires "
"registering an application, getting tokens, etc.\n"
"====\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:256
#, no-wrap, fuzzy
msgid "Using SSL with native executables"
msgstr "ネイティブ実行ファイルでSSLを使用する"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:379
msgid ""
"Note that if you enable SSL for the mailer and you want to build a native "
"executable, you will need to enable the SSL support.  Please refer to the "
"link:native-and-ssl[Using SSL With Native Executables] guide for more "
"information."
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:261
#, no-wrap, fuzzy
msgid "Using the underlying Vert.x Mail Client"
msgstr "基盤となる Vert.x メールクライアントの使用"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:265
#, fuzzy
msgid ""
"The Quarkus Mailer is implemented on top of the https://vertx.io/docs/vertx-"
"mail-client/java/[Vert.x Mail Client], providing an asynchronous and non-"
"blocking way to send emails.  If you need fine control on how the mail is "
"sent, for instance if you need to retrieve the message ids, you can inject "
"the underlying client, and use it directly:"
msgstr ""
"Quarkus Mailerは、 link:https://vertx.io/docs/vertx-mail-client/java/[Vert."
"xメールクライアントの]上に実装されており、非同期でノンブロッキングな方法でメールを送信することができます。メールの送信方法を細かく制御する必要がある場合、例えばメッセージのIDを取得する必要がある場合など、基礎となるクライアントを注入して直接使用することができます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:386
msgid "[source, java]"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:388
#, fuzzy
msgid "@Inject MailClient client;"
msgstr "メールクライアントのクライアントをインジェクトします。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:391
#, no-wrap
msgid "Three API flavors are exposed:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:396
#, no-wrap
msgid ""
"* the Mutiny client (`io.vertx.mutiny.ext.mail.MailClient`)\n"
"* the Axle client (`io.vertx.axle.ext.mail.MailClient`), using "
"`CompletionStage` and Reactive Streams `Publisher` - deprecated, it is "
"recommended to switch to the Mutiny client\n"
"* the RX Java 2 client (`io.vertx.reactivex.ext.mail.MailClient`) - "
"deprecated, it is recommended to switch to the Mutiny client\n"
"* the bare client (`io.vertx.ext.mail.MailClient`)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:398
#, no-wrap
msgid ""
"Check the link:vertx[Using Vert.x guide] for further details about these "
"different APIs and how to select the most suitable for you.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:401
#, no-wrap
msgid ""
"The retrieved `MailClient` is configured using the configuration key "
"presented above.\n"
"You can also create your own instance, and pass your own configuration.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:286
#, fuzzy
msgid ""
"This guide has shown how you can send emails from a Quarkus application.  "
"The _mailer_ extension works in JVM and native mode."
msgstr ""
"このガイドでは、Quarkusアプリケーションからメールを送信する方法を紹介しました。 _メーラー_拡張機能は、JVMとネイティブモードで動作します。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:409
msgid "[[configuration-reference]]"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:289
#, no-wrap, fuzzy
msgid "Mailer Configuration Reference"
msgstr "メーラー設定リファレンス"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:411
msgid ""
"include::{generated-dir}/config/quarkus-mailer.adoc[opts=optional, "
"leveloffset=+1]"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/infinispan-client.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Infinispan Client"
msgstr "Quarkus - Infinispanクライアント"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:12
#, fuzzy
msgid ""
"Infinispan is an in memory data grid that allows running in a server outside "
"of application processes. This extension provides functionality to allow the "
"client that can connect to said server when running in Quarkus."
msgstr ""
"Infinispanは、アプリケーションプロセス以外のサーバーでの実行を可能にするメモリ内データグリッドです。この拡張機能は、Quarkusで実行しているときに、クライアントがサーバーに接続できるようにする機能を提供します。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:15
#, fuzzy
msgid ""
"More information can be found about Infinispan at https://infinispan.org and "
"the client/server at https://infinispan.org/docs/dev/user_guide/user_guide."
"html#client_server"
msgstr ""
"Infinispan についての詳細は https://infinispan.org に、クライアント/サーバーについては https://"
"infinispan.org/docs/dev/user_guide/user_guide.html#client_server に記載されています。"

#. type: Title ==
#: upstream/_guides/security-properties.adoc:24
#, no-wrap
msgid "Configuration"
msgstr "構成"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:20
#, fuzzy
msgid ""
"Once you have your Quarkus project configured you can add the `infinispan-"
"client` extension to your project by running the following from the command "
"line in your project base directory."
msgstr ""
"Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリのコマンドラインから以下を実行して、 `infinispan-client` "
"拡張機能をプロジェクトに追加することができます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:24
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"infinispan-client\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:27
#, fuzzy
msgid "This will add the following to your pom.xml"
msgstr "これにより、以下が pom.xml に追加されます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:34
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-infinispan-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:39
#, fuzzy
msgid ""
"The Infinispan client is configurable in the `application.properties` file "
"that can be provided in the `src/main/resources` directory. These are the "
"properties that can be configured in this file:"
msgstr ""
"Infinispan クライアントは、 `src/main/resources` ディレクトリで提供される `application."
"properties` ファイルで設定できます。このファイルで設定できるプロパティは以下の通りです。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:45
#, fuzzy
msgid ""
"It is also possible to configure a `hotrod-client.properties` as described "
"in the Infinispan user guide. Note that the `hotrod-client.properties` "
"values overwrite any matching property from the other configuration values "
"(eg. near cache).  This properties file is build time only and if it is "
"changed, requires a full rebuild."
msgstr ""
"Infinispan ユーザーガイドに記載されているように `hotrod-client.properties` を設定することも可能です。 "
"`hotrod-client.properties` "
"の値は、他の設定値（例：ニアキャッシュ）から一致するプロパティを上書きすることに注意してください。このプロパティファイルはビルド時のみのもので、変更された場合は完全に再構築する必要があります。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:46
#, no-wrap, fuzzy
msgid "Serialization (Key Value types support)"
msgstr "連載（キーバリュー型のサポート"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:51
#, fuzzy
msgid ""
"By default the client will support keys and values of the following types: "
"byte[], primitive wrappers (eg. Integer, Long, Double etc.), String, Date "
"and Instant. User types require some additional steps that are detailed here."
" Let's say we have the following user classes:"
msgstr ""
"デフォルトでは、クライアントは以下の型のキーと値をサポートします: byte[]、プリミティブラッパー(例: "
"Integer、Long、Doubleなど)、String、Date、Instant。ユーザー型については、ここで詳しく説明している追加のステップが必要です。以下のようなユーザクラスがあるとします。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:52
#: upstream/_guides/infinispan-client.adoc:96
#, no-wrap, fuzzy
msgid "Author.java"
msgstr "作成者.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:58
#, no-wrap
msgid ""
"public class Author {\n"
"   private final String name;\n"
"   private final String surname;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:65
#, no-wrap
msgid ""
"   public Author(String name, String surname) {\n"
"      this.name = Objects.requireNonNull(name);\n"
"      this.surname = Objects.requireNonNull(surname);\n"
"   }\n"
"   // Getter/Setter/equals/hashCode/toString omitted\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:67
#: upstream/_guides/infinispan-client.adoc:116
#, no-wrap, fuzzy
msgid "Book.java"
msgstr "Book.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:75
#, no-wrap
msgid ""
"public class Book {\n"
"   private final String title;\n"
"   private final String description;\n"
"   private final int publicationYear;\n"
"   private final Set<Author> authors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:84
#, no-wrap
msgid ""
"   public Book(String title, String description, int publicationYear, "
"Set<Author> authors) {\n"
"      this.title = Objects.requireNonNull(title);\n"
"      this.description = Objects.requireNonNull(description);\n"
"      this.publicationYear = publicationYear;\n"
"      this.authors = Objects.requireNonNull(authors);\n"
"   }\n"
"   // Getter/Setter/equals/hashCode/toString omitted\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:87
#, fuzzy
msgid ""
"Serialization of user types uses a library based on protobuf, called "
"Protostream."
msgstr "ユーザータイプのシリアライズは、Protostreamと呼ばれるprotobufをベースにしたライブラリを使用します。"

#. type: Title ===
#: upstream/_guides/infinispan-client.adoc:88
#, no-wrap, fuzzy
msgid "Annotation based Serialization"
msgstr "アノテーションに基づくシリアライゼーション"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:93
#, fuzzy
msgid ""
"This can be done automatically by adding protostream annotations to your "
"user classes.  In addition a single Initializer annotated interface is "
"required which controls how the supporting classes are generated."
msgstr ""
"これは、ユーザクラスに protostream "
"アノテーションを追加することで自動的に行うことができます。さらに、サポートするクラスがどのように生成されるかを制御するために、単一の "
"Initializer アノテーションされたインターフェイスが必要です。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:95
#, fuzzy
msgid "Here is an example of how the preceding classes should be changed:"
msgstr "ここでは、先行するクラスをどのように変更するかの例を示します。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:104
#, no-wrap
msgid ""
"    @ProtoFactory\n"
"    public Author(String name, String surname) {\n"
"        this.name = Objects.requireNonNull(name);\n"
"        this.surname = Objects.requireNonNull(surname);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:109
#, no-wrap
msgid ""
"    @ProtoField(number = 1)\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:114
#, no-wrap
msgid ""
"    @ProtoField(number = 2)\n"
"    public String getSurname() {\n"
"        return surname;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:126
#, no-wrap
msgid ""
"    @ProtoFactory\n"
"    public Book(String title, String description, int publicationYear, "
"Set<Author> authors) {\n"
"        this.title = Objects.requireNonNull(title);\n"
"        this.description = Objects.requireNonNull(description);\n"
"        this.publicationYear = publicationYear;\n"
"        this.authors = Objects.requireNonNull(authors);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:131
#, no-wrap
msgid ""
"    @ProtoField(number = 1)\n"
"    public String getTitle() {\n"
"        return title;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:136
#, no-wrap
msgid ""
"    @ProtoField(number = 2)\n"
"    public String getDescription() {\n"
"        return description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:141
#, no-wrap
msgid ""
"    @ProtoField(number = 3, defaultValue = \"-1\")\n"
"    public int getPublicationYear() {\n"
"        return publicationYear;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:146
#, no-wrap
msgid ""
"    @ProtoField(number = 4)\n"
"    public Set<Author> getAuthors() {\n"
"        return authors;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:149
#, fuzzy
msgid ""
"If your classes have only mutable fields, then the `ProtoFactory` annotation "
"is not required, assuming your class has a no arg constructor."
msgstr "クラスが mutable フィールドしかない場合は、 `ProtoFactory` アノテーションは必要ありません。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:152
#, fuzzy
msgid ""
"Then all that is required is a very simple `SerializationContextInitializer` "
"interface with an annotation on it to specify configuration settings"
msgstr ""
"必要なのは、非常にシンプルな `SerializationContextInitializer` "
"インターフェイスにアノテーションを付けて設定を指定するだけです。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:153
#, no-wrap, fuzzy
msgid "BookContextInitializer.java"
msgstr "BookContextInitializer.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:159
#, no-wrap
msgid ""
"@AutoProtoSchemaBuilder(includeClasses = { Book.class, Author.class }, "
"schemaPackageName = \"book_sample\")\n"
"interface BookContextInitializer extends SerializationContextInitializer {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:164
#, fuzzy
msgid ""
"So in this case we will automatically generate the marshaller and schemas "
"for the included classes and place them in the schema package automatically. "
"The package does not have to be provided, but if you utilize querying, you "
"must know the generated package."
msgstr ""
"そこで今回は、含まれるクラスのマーシャラーとスキーマを自動生成して、スキーマパッケージに自動で配置します。パッケージは用意する必要はありませんが、クエリを利用する場合は生成されたパッケージを知っておく必要があります。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:166
#, fuzzy
msgid ""
"In Quarkus the `schemaFileName` and `schemaFilePath` attributes should NOT "
"be set on the `AutoProtoSchemaBuilder` annotation, setting either will cause "
"native runtime to error."
msgstr ""
"Quarkusでは、 `schemaFileName` と `schemaFilePath` 属性は、 `AutoProtoSchemaBuilder` "
"アノテーションに設定すべきではありません。"

#. type: Title ===
#: upstream/_guides/infinispan-client.adoc:167
#, no-wrap, fuzzy
msgid "User written serialization"
msgstr "ユーザーが書いたシリアル化"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:173
#, fuzzy
msgid ""
"The previous method is suggested for any case when the user can annotate "
"their classes.  Unfortunately the user may not be able to annotate all "
"classes they will put in the cache. In this case you must define your schema "
"and create your own Marshaller(s)  yourself."
msgstr ""
"前の方法は、ユーザが自分のクラスにアノテーションを付けることができる場合のために提案されています。残念ながら、ユーザーはキャッシュに入れるすべてのクラスにアノテーションを付けることができないかもしれません。このような場合はスキーマを定義し、自分で独自のマーシャルを作成しなければなりません。"

#. type: Labeled list
#: upstream/_guides/infinispan-client.adoc:174
#, no-wrap, fuzzy
msgid "Protobuf schema"
msgstr "プロトバフスキーマ"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:175
#, fuzzy
msgid "You can supply a protobuf schema through either one of two ways."
msgstr "2つの方法のいずれかでprotobufスキーマを提供することができます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:176
#, fuzzy
msgid "Proto File"
msgstr "プロトファイル"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:179
#, fuzzy
msgid ""
"+ You can put the `.proto` file in the `META-INF` directory of the project. "
"These files will automatically be picked up at initialization time."
msgstr ""
"+ プロジェクトの `META-INF` ディレクトリに `.proto` "
"ファイルを置くことができます。これらのファイルは、初期化時に自動的にピックアップされます。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:180
#, no-wrap, fuzzy
msgid "library.proto"
msgstr "ライブラリープロト"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:183
#, no-wrap
msgid "package book_sample;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:188
#, no-wrap
msgid ""
"message Book {\n"
"  required string title = 1;\n"
"  required string description = 2;\n"
"  required int32 publicationYear = 3; // no native Date type available in "
"Protobuf\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:191
#, no-wrap
msgid "  repeated Author authors = 4;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:196
#, no-wrap
msgid ""
"message Author {\n"
"  required string name = 1;\n"
"  required string surname = 2;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:198
#, fuzzy
msgid "In Code"
msgstr "コードでは"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:201
#, fuzzy
msgid ""
"+ Or you can define the proto schema directly in user code by defining a "
"produced bean of type `org.infinispan.protostream.FileDescriptorSource`."
msgstr ""
"`org.infinispan.protostream.FileDescriptorSource`+ "
"または、ユーザコードで直接protoスキーマを定義することができます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:221
#, no-wrap
msgid ""
"   @Produces\n"
"   FileDescriptorSource bookProtoDefinition() {\n"
"      return FileDescriptorSource.fromString(\"library.proto\", \"package "
"book_sample;\\n\" +\n"
"            \"\\n\" +\n"
"            \"message Book {\\n\" +\n"
"            \"  required string title = 1;\\n\" +\n"
"            \"  required string description = 2;\\n\" +\n"
"            \"  required int32 publicationYear = 3; // no native Date type "
"available in Protobuf\\n\" +\n"
"            \"\\n\" +\n"
"            \"  repeated Author authors = 4;\\n\" +\n"
"            \"}\\n\" +\n"
"            \"\\n\" +\n"
"            \"message Author {\\n\" +\n"
"            \"  required string name = 1;\\n\" +\n"
"            \"  required string surname = 2;\\n\" +\n"
"            \"}\");\n"
"   }\n"
msgstr ""

#. type: Labeled list
#: upstream/_guides/infinispan-client.adoc:222
#, no-wrap, fuzzy
msgid "User Marshaller"
msgstr "ユーザーマーシャラー"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:226
#, fuzzy
msgid ""
"The last thing to do is to provide a `org.infinispan.protostream."
"MessageMarshaller` implementation for each user class defined in the proto "
"schema. This class is then provided via `@Produces` in a similar fashion to "
"the code based proto schema definition above."
msgstr ""
"最後にすべきことは、proto スキーマで定義された各ユーザークラスの `org.infinispan.protostream."
"MessageMarshaller` 実装を提供することです。このクラスは、上記のコードベースの proto スキーマの定義と同様の方法で "
"`@Produces` を介して提供されます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:228
#, fuzzy
msgid "Here is the Marshaller class for our Author & Book classes."
msgstr "こちらは、著者＆本のクラスのマーシャラークラスです。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:230
#, fuzzy
msgid ""
"The type name must match the `<protobuf package>.<protobuf message>` "
"exactly!"
msgstr ""
"タイプ名は `&amp;lt;protobuf package&amp;gt;.&amp;lt;protobuf message&amp;gt;` "
"と正確に一致している必要があります!"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:231
#, no-wrap, fuzzy
msgid "AuthorMarshaller.java"
msgstr "AuthorMarshaller.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:235
#, no-wrap
msgid "public class AuthorMarshaller implements MessageMarshaller<Author> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:240
#, no-wrap
msgid ""
"   @Override\n"
"   public String getTypeName() {\n"
"      return \"book_sample.Author\";\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:245
#, no-wrap
msgid ""
"   @Override\n"
"   public Class<? extends Author> getJavaClass() {\n"
"      return Author.class;\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:251
#, no-wrap
msgid ""
"   @Override\n"
"   public void writeTo(ProtoStreamWriter writer, Author author) throws "
"IOException {\n"
"      writer.writeString(\"name\", author.getName());\n"
"      writer.writeString(\"surname\", author.getSurname());\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:259
#, no-wrap
msgid ""
"   @Override\n"
"   public Author readFrom(ProtoStreamReader reader) throws IOException {\n"
"      String name = reader.readString(\"name\");\n"
"      String surname = reader.readString(\"surname\");\n"
"      return new Author(name, surname);\n"
"   }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:261
#, no-wrap, fuzzy
msgid "BookMarshaller.java"
msgstr "BookMarshaller.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:265
#, no-wrap
msgid "public class BookMarshaller implements MessageMarshaller<Book> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:270
#, no-wrap
msgid ""
"   @Override\n"
"   public String getTypeName() {\n"
"      return \"book_sample.Book\";\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:275
#, no-wrap
msgid ""
"   @Override\n"
"   public Class<? extends Book> getJavaClass() {\n"
"      return Book.class;\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:283
#, no-wrap
msgid ""
"   @Override\n"
"   public void writeTo(ProtoStreamWriter writer, Book book) throws "
"IOException {\n"
"      writer.writeString(\"title\", book.getTitle());\n"
"      writer.writeString(\"description\", book.getDescription());\n"
"      writer.writeInt(\"publicationYear\", book.getPublicationYear());\n"
"      writer.writeCollection(\"authors\", book.getAuthors(), Author.class);\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:293
#, no-wrap
msgid ""
"   @Override\n"
"   public Book readFrom(ProtoStreamReader reader) throws IOException {\n"
"      String title = reader.readString(\"title\");\n"
"      String description = reader.readString(\"description\");\n"
"      int publicationYear = reader.readInt(\"publicationYear\");\n"
"      Set<Author> authors = reader.readCollection(\"authors\", new "
"HashSet<>(), Author.class);\n"
"      return new Book(title, description, publicationYear, authors);\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:296
#, fuzzy
msgid "And you pass the marshaller by defining the following:"
msgstr "そして、以下のように定義してマーシャラーをパスします。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:303
#, no-wrap
msgid ""
"   @Produces\n"
"   MessageMarshaller authorMarshaller() {\n"
"      return new AuthorMarshaller();\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:308
#, no-wrap
msgid ""
"   @Produces\n"
"   MessageMarshaller bookMarshaller() {\n"
"      return new BookMarshaller();\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:310
#, fuzzy
msgid ""
"The above produced Marshaller method MUST return `MessageMarshaller` without "
"types or else it will not be found."
msgstr ""
"上記のように生成されたMarshallerメソッドは、型なしで `MessageMarshaller` を返さなければなりません(MUST)。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:311
#, no-wrap, fuzzy
msgid "Dependency Injection"
msgstr "依存性注入"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:317
#, fuzzy
msgid ""
"As you saw above we support the user injecting Marshaller configuration. You "
"can do the inverse with the Infinispan client extension providing injection "
"for `RemoteCacheManager` and `RemoteCache` objects.  There is one global "
"`RemoteCacheManager` that takes all of the configuration parameters setup in "
"the above sections."
msgstr ""
"上で見たように、Marshaller の設定をユーザーがインジェクションすることをサポートしています。Infinispan "
"クライアント拡張機能を使用すると、 `RemoteCacheManager` と `RemoteCache` "
"オブジェクトにインジェクションを行うことができます。上記のセクションで設定したすべての設定パラメータを受け取るグローバル "
"`RemoteCacheManager` があります。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:320
#, fuzzy
msgid ""
"It is very simple to inject these components. All you need to do is to add "
"the Inject annotation to the field, constructor or method. In the below code "
"we utilize field and constructor injection."
msgstr ""
"これらのコンポーネントを注入するのは非常に簡単です。必要なのは、フィールド、コンストラクタ、またはメソッドにインジェクションアノテーションを追加するだけです。以下のコードでは、フィールドとコンストラクタのインジェクションを利用しています。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:321
#, no-wrap, fuzzy
msgid "SomeClass.java"
msgstr "SomeClass.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:327
#, no-wrap
msgid ""
"    @Inject SomeClass(RemoteCacheManager remoteCacheManager) {\n"
"       this.remoteCacheManager = remoteCacheManager;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:330
#, no-wrap
msgid "    @Inject @Remote(\"myCache\")\n"
"    RemoteCache<String, Book> cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:332
#, no-wrap
msgid "    RemoteCacheManager remoteCacheManager;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:337
#, fuzzy
msgid ""
"If you notice the `RemoteCache` declaration has an additional optional "
"annotation named `Remote`.  This is a qualifier annotation allowing you to "
"specify which named cache that will be injected. This annotation is not "
"required and if it is not supplied, the default cache will be injected."
msgstr ""
"`RemoteCache` 宣言に `Remote` "
"というオプションのアノテーションが追加されていることにお気づきでしょうか。これは、注入される名前付きキャッシュを指定するための修飾子アノテーションです。このアノテーションは必須ではなく、指定しなかった場合はデフォルトのキャッシュが注入されます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:339
#, fuzzy
msgid ""
"Other types may be supported for injection, please see other sections for "
"more information"
msgstr "その他のタイプは注入のためにサポートされている場合がありますが、詳細については他のセクションを参照してください。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:340
#, no-wrap, fuzzy
msgid "Querying"
msgstr "問い合わせ"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:345
#, fuzzy
msgid ""
"The Infinispan client supports both indexed and non indexed querying as long "
"as the `ProtoStreamMarshaller` is configured above. This allows the user to "
"query based on the properties of the proto schema."
msgstr ""
"Infinispan クライアントは、上記の `ProtoStreamMarshaller` "
"が設定されている限り、インデックス付きと非インデックス付きの両方のクエリをサポートしています。これにより、ユーザはプロトスキーマのプロパティに基づいてクエリを行うことができます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:350
#, fuzzy
msgid ""
"Query builds upon the proto definitions you can configure when setting up "
"the `ProtoStreamMarshaller`.  Either method of Serialization above will "
"automatically register the schema with the server at startup, meaning that "
"you will automatically gain the ability to query objects stored in the "
"remote Infinispan Server."
msgstr ""
"Query は、 `ProtoStreamMarshaller` "
"の設定時に設定できるプロト定義に基づいて構築されます。上記のいずれのシリアライズ方法でも、起動時に自動的にスキーマをサーバーに登録し、リモートの "
"Infinispan サーバーに保存されているオブジェクトをクエリする機能を自動的に得ることができます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:352
#, fuzzy
msgid ""
"You can read more about this at https://infinispan.org/docs/stable/titles/"
"developing/developing.html#query_dsl."
msgstr ""
"これについては、 https://infinispan.org/docs/stable/titles/developing/developing."
"html#query_dsl 。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:355
#, fuzzy
msgid ""
"You can use either the Query DSL or the Ickle Query language with the "
"Quarkus Infinispan client extension."
msgstr "Quarkus Infinispanクライアントエクステンションでは、クエリDSLまたはIckleクエリ言語のいずれかを使用できます。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:356
#, no-wrap, fuzzy
msgid "Counters"
msgstr "カウンター"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:360
#, fuzzy
msgid ""
"Infinispan also has a notion of counters and the Quarkus Infinispan client "
"supports them out of the box."
msgstr ""
"Infinispanにはカウンターという概念もあり、Quarkus Infinispanのクライアントはそれらを箱から出してサポートしています。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:364
#, fuzzy
msgid ""
"The Quarkus Infinispan client extension allows for Dependency Injection of "
"the `CounterManager` directly. All you need to do is annotate your field, "
"constructor or method and you get it with no fuss. You can then use counters "
"as you would normally."
msgstr ""
"Quarkus Infinispanクライアント拡張機能を使用すると、 `CounterManager` "
"の依存性インジェクションを直接行うことができます。必要なのは、フィールド、コンストラクタ、メソッドにアノテーションを付けるだけで、手間をかけずにインジェクションが可能になります。そして、通常のようにカウンターを使用することができます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:369
#, no-wrap
msgid "@Inject\n"
"CounterManager counterManager;\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:371
#, no-wrap, fuzzy
msgid "Near Caching"
msgstr "ニアキャッシング"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:377
#, fuzzy
msgid ""
"Near caching is disabled by default, but you can enable it by setting the "
"profile config property `quarkus.infinispan-client.near-cache-max-entries` "
"to a value greater than 0. You can also configure a regular expression so "
"that only a subset of caches have near caching applied through the `quarkus."
"infinispan-client.near-cache-name-pattern` attribute."
msgstr ""
"ニア・キャッシングは既定では無効になっていますが、プロファイル構成プロパティ `quarkus.infinispan-client.near-cache-"
"max-entries` を 0 より大きい値に設定することで有効にすることができます。 また、正規表現を構成して、キャッシュのサブセットのみが "
"`quarkus.infinispan-client.near-cache-name-pattern` "
"属性を通じてニア・キャッシングを適用するようにすることもできます。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:378
#, no-wrap, fuzzy
msgid "Encryption"
msgstr "暗号化"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:381
#, fuzzy
msgid "Encryption at this point requires additional steps to get working."
msgstr "この時点での暗号化には、作業を開始するための追加のステップが必要です。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:385
#, fuzzy
msgid ""
"The first step is to configure the `hotrod-client.properties` file to point "
"to your truststore and/or keystore. This is further detailed at https://"
"infinispan.org/docs/dev/user_guide/user_guide.html#hr_encryption."
msgstr ""
"最初のステップは、 `hotrod-client.properties` ファイルが truststore および/または keystore "
"を指すように設定することです。これは https://infinispan.org/docs/dev/user_guide/user_guide."
"html#hr_encryption  でさらに詳しく説明されています。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:388
#, fuzzy
msgid ""
"The Infinispan Client extension enables SSL by default. You can read more "
"about this at link:native-and-ssl[Using SSL With Native Executables]."
msgstr ""
"Infinispanクライアント拡張機能は、デフォルトでSSLを有効にします。これについての詳細は link:native-and-ssl[Using "
"SSL With Native Executables] を参照してください。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:389
#, no-wrap, fuzzy
msgid "Authentication"
msgstr "認証"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:393
#, fuzzy
msgid ""
"This chart illustrates what mechanisms have been verified to be working "
"properly with the Quarkus Infinispan Client extension."
msgstr "この図は、Quarkus Infinispanクライアント拡張機能で正常に動作することが確認されているメカニズムを示しています。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:394
#, no-wrap, fuzzy
msgid "Mechanisms"
msgstr "メカニズム"

#. type: Table
#: upstream/_guides/infinispan-client.adoc:413
#, no-wrap, fuzzy
msgid ""
"| Name | Verified\n"
"\n"
"| DIGEST-MD5\n"
"| [green]*Y*\n"
"\n"
"| PLAIN\n"
"| [green]*Y*\n"
"\n"
"| EXTERNAL\n"
"| [green]*Y*\n"
"\n"
"| GSSAPI\n"
"| [red]*N*\n"
"\n"
"| Custom\n"
"| [red]*N*\n"
"\n"
msgstr "| 名前｜名前｜検証済み"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:417
#, fuzzy
msgid ""
"The guide for configuring these can be found at https://infinispan.org/docs/"
"dev/user_guide/user_guide.html#authentication.  However you need to "
"configure these through the `hotrod-client.properties` file if using "
"Dependency Injection."
msgstr ""
"これらを設定するためのガイドは https://infinispan.org/docs/dev/user_guide/user_guide."
"html#authentication  にあります。ただし、依存性インジェクションを使用する場合は `hotrod-client."
"properties` ファイルから設定する必要があります。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:418
#, no-wrap, fuzzy
msgid "Additional Features"
msgstr "追加機能"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:422
#, fuzzy
msgid ""
"The Infinispan Client has additional features that were not mentioned here. "
"This means this feature was not tested in a Quarkus environment and they may "
"or may not work. Please let us know if you need these added!"
msgstr ""
"Infinispanクライアントには、ここでは触れられていない追加機能があります。これは、この機能がQuarkus環境でテストされていないことを意味します。これらの機能を追加する必要がある場合は、ご連絡ください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/reactive-event-bus.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using the event bus"
msgstr "Quarkus - イベントバスの使用"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:13
#, fuzzy
msgid ""
"Quarkus allows different beans to interact using asynchronous events, thus "
"promoting loose-coupling.  The messages are sent to _virtual addresses_.  It "
"offers 3 types of delivery mechanism:"
msgstr ""
"Quarkusでは、異なるビーンが非同期イベントを使用して相互作用することができるため、ゆるやかなカップリングが促進されます。メッセージは "
"_仮想アドレス_に送信されます。3種類の配信メカニズムを提供しています。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:15
#, fuzzy
msgid ""
"point-to-point - send the message, one consumer receives it. If several "
"consumers listen to the address, a round robin is applied;"
msgstr ""
"point-to-point - メッセージを送信し、1 "
"つのコンシューマがそれを受信します。複数の消費者がアドレスを聞いている場合、ラウンドロビンが適用されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:16
#, fuzzy
msgid ""
"publish/subscribe - publish a message, all the consumers listening to the "
"address are receiving the message;"
msgstr "publish/subscribe - メッセージを公開し、アドレスを聞いているすべての消費者がメッセージを受信します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:17
#, fuzzy
msgid ""
"request/reply - send the message and expect a response. The receiver can "
"respond to the message in an asynchronous-fashion"
msgstr "request/reply - メッセージを送信し、応答を期待します。受信者は非同期的にメッセージに応答することができます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:19
#, fuzzy
msgid ""
"All these delivery mechanism are non-blocking, and are providing one of the "
"fundamental brick to build reactive applications."
msgstr "これらの配信メカニズムはすべてノンブロッキングであり、反応型アプリケーションを構築するための基本的なレンガの1つを提供しています。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:22
#, fuzzy
msgid ""
"The asynchronous message passing feature allows replying to messages which "
"is not supported by Reactive Messaging.  However, it is limited to single-"
"event behavior (no stream) and to local messages."
msgstr ""
"非同期メッセージパッシング機能は、Reactive "
"Messagingではサポートされていないメッセージへの返信を可能にします。ただし、シングルイベント動作(ストリームなし)とローカルメッセージに限定されます。"

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:23
#, no-wrap, fuzzy
msgid "Installing"
msgstr "インストール"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:27
#, fuzzy
msgid ""
"This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` "
"extension to use this feature.  If you are creating a new project, set the "
"`extensions` parameter are follows:"
msgstr ""
"この仕組みはVert.x EventBusを利用しているので、この機能を利用するには `vertx` "
"拡張機能を有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメータを以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:36
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vertx-quickstart \\\n"
"    -Dextensions=\"vertx,resteasy-mutiny\" \\\n"
"    -DnoExamples\n"
"cd vertx-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:40
#, fuzzy
msgid ""
"If you have an already created project, the `vertx` extension can be added "
"to an existing Quarkus project with the `add-extension` command:"
msgstr ""
"すでに作成済みのプロジェクトがある場合は、 `vertx` 拡張機能を既存のQuarkusプロジェクトに追加するには、 `add-extension` "
"コマンドを使用します。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:44
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"vertx,resteasy-mutiny\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:47
#, fuzzy
msgid ""
"Otherwise, you can manually add this to the dependencies section of your "
"`pom.xml` file:"
msgstr "そうでなければ、 `pom.xml` ファイルの依存関係セクションに手動で追加することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:54
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:56
#, no-wrap, fuzzy
msgid "Consuming events"
msgstr "消費イベント"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:59
#, fuzzy
msgid "To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:"
msgstr "イベントを消費するには、 `io.quarkus.vertx.ConsumeEvent` アノテーションを使用します。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:63
#: upstream/_guides/reactive-event-bus.adoc:111
#: upstream/_guides/reactive-event-bus.adoc:222
#: upstream/_guides/reactive-event-bus.adoc:296
#: upstream/_guides/reactive-event-bus.adoc:333
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:65
#: upstream/_guides/reactive-event-bus.adoc:113
#: upstream/_guides/reactive-event-bus.adoc:335
#, no-wrap
msgid "import io.quarkus.vertx.ConsumeEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:134
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:70
#: upstream/_guides/reactive-event-bus.adoc:121
#: upstream/_guides/reactive-event-bus.adoc:340
#, no-wrap
msgid "@ApplicationScoped\n"
"public class GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:76
#, no-wrap
msgid ""
"    @ConsumeEvent                           // <1>\n"
"    public String consume(String name) {    // <2>\n"
"        return name.toUpperCase();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:78
#, fuzzy
msgid ""
"If not set, the address is the fully qualified name of the bean, for "
"instance, in this snippet it's `org.acme.vertx.GreetingService`."
msgstr ""
"設定されていない場合、アドレスはビーンの完全修飾名となり、例えばこのスニペットでは `org.acme.vertx.GreetingService`."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:79
#, fuzzy
msgid ""
"The method parameter is the message body. If the method returns _something_ "
"it's the message response."
msgstr "メソッドのパラメータはメッセージ本体です。メソッドが _何かを_返す場合は、それがメッセージのレスポンスになります。"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:84
#, fuzzy
msgid ""
"By default, the code consuming the event must be _non-blocking_, as it's "
"called on the Vert.x event loop.  If your processing is blocking, use the "
"`blocking` attribute:"
msgstr ""
"デフォルトでは、Vert.x イベントループで呼び出されるため、イベントを消費するコードは "
"_ノン_ブロッキングでなければなりません。処理がブロッキングされている場合は、 `blocking` 属性を使用してください。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:91
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\", blocking = true)\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:94
#, fuzzy
msgid ""
"Alternatively, you can annotate your method with `@io.smallrye.common."
"annotation.Blocking`:"
msgstr "あるいは、メソッドに `@io.smallrye.common.annotation.Blocking` と注釈を付けることもできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:101
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\")\n"
"@Blocking\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:104
#, fuzzy
msgid ""
"When using `@Blocking`, it ignores the value of the `blocking` attribute of "
"`@ConsumeEvent`."
msgstr "`@Blocking` を使用する場合、 `@ConsumeEvent` の `blocking` 属性の値は無視されます。"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:107
#, fuzzy
msgid ""
"Asynchronous processing is also possible by returning either an `io.smallrye."
"mutiny.Uni` or a `java.util.concurrent.CompletionStage`:"
msgstr ""
"`io.smallrye.mutiny.Uni` または `java.util.concurrent.CompletionStage`.NET "
"のどちらかを返すことで、非同期処理も可能です。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:118
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:127
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public CompletionStage<String> consume(String name) {\n"
"        // return a CompletionStage completed when the processing is "
"finished.\n"
"        // You can also fail the CompletionStage explicitly\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:134
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public Uni<String> process(String name) {\n"
"        // return an Uni completed when the processing is finished.\n"
"        // You can also fail the Uni explicitly\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:140
#, fuzzy
msgid ""
"The previous example uses Mutiny reactive types, if you're not familiar with "
"them, we recommend reading the link:getting-started-reactive#mutiny[Getting "
"Started with Reactive guide]."
msgstr ""
"前の例では Mutiny リアクティブタイプを使用していますが、もしよく知らないのであれば、 link:getting-started-"
"reactive#mutiny[Reactive の入門ガイド]を読むことをお勧めします。"

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:142
#, no-wrap, fuzzy
msgid "Configuring the address"
msgstr "アドレスの設定"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:145
#, fuzzy
msgid "The `@ConsumeEvent` annotation can be configured to set the address:"
msgstr "`@ConsumeEvent` アノテーションでアドレスを設定することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:152
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")               // <1>\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:154
#, fuzzy
msgid "Receive the messages sent to the `greeting` address"
msgstr "`greeting` アドレスに送信されたメッセージを受信する"

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:155
#, no-wrap, fuzzy
msgid "Replying"
msgstr "返事をする"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:159
#, fuzzy
msgid ""
"The _return_ value of a method annotated with `@ConsumeEvent` is used as "
"response to the incoming message.  For instance, in the following snippet, "
"the returned `String` is the response."
msgstr ""
"`@ConsumeEvent` でアノテーションされたメソッドの "
"_戻り_値が、着信メッセージに対するレスポンスとして使用されます。例えば、次のスニペットでは、 `String` がレスポンスとして返されます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:166
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:169
#, fuzzy
msgid ""
"You can also return a `Uni<T>` or a `CompletionStage<T>` to handle "
"asynchronous reply:"
msgstr ""
"また、 `Uni&amp;lt;T&amp;gt;` や `CompletionStage&amp;lt;T&amp;gt;` "
"を返すことで、非同期返信を処理することもできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:176
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public Uni<String> consume2(String name) {\n"
"    return Uni.createFrom().item(() -> name.toUpperCase()).emitOn(executor);\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:181
#, fuzzy
msgid ""
"You can inject an `executor` if you use the Context Propagation extension:"
msgstr "Context Propagation 拡張機能を使えば、 `executor` を注入することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:184
#, no-wrap
msgid "@Inject Executor executor;\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:187
#, no-wrap, fuzzy
msgid "Implementing fire and forget interactions"
msgstr "fire and forgetインタラクションの実装"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:192
#, fuzzy
msgid ""
"You don't have to reply to received messages.  Typically for a _fire and "
"forget_ interaction, the messages are consumed and the sender does not need "
"to know about it.  To implement this, your consumer method just returns "
"`void`"
msgstr ""
"受信したメッセージに返信する必要はありません。通常、 _fire and "
"forget_インタラクションでは、メッセージは消費され、送信者はそれについて知る必要はありません。これを実装するには、 consumer メソッドは "
"`void`"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:199
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(String event) {\n"
"    // Do something with the event\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:201
#, no-wrap, fuzzy
msgid "Dealing with messages"
msgstr "メッセージへの対応"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:204
#, fuzzy
msgid ""
"As said above, this mechanism is based on the Vert.x event bus. So, you can "
"also use `Message` directly:"
msgstr "上でも述べたように、この仕組みはVert.xイベントバスをベースにしています。なので、直接 `Message` を使うこともできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:212
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(Message<String> msg) {\n"
"    System.out.println(msg.address());\n"
"    System.out.println(msg.body());\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:214
#, no-wrap, fuzzy
msgid "Sending messages"
msgstr "メッセージの送信"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:218
#, fuzzy
msgid ""
"Ok, we have seen how to receive messages, let's now switch to the _other "
"side_: the sender.  Sending and publishing messages use the Vert.x event bus:"
""
msgstr ""
"さて、メッセージを受信する方法を見てきましたが、次は送信者 _側_に切り替えましょう。メッセージの送信と公開は Vert.x イベントバスを使います。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:227
#: upstream/_guides/reactive-event-bus.adoc:301
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.core.eventbus.EventBus;\n"
"import io.vertx.mutiny.core.eventbus.Message;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:158
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:236
#: upstream/_guides/reactive-event-bus.adoc:310
#, no-wrap
msgid "@Path(\"/async\")\n"
"public class EventResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:239
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;                                       // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:248
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(@PathParam String name) {\n"
"        return bus.<String>request(\"greeting\", name)        // <2>\n"
"                .onItem().transform(Message::body);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:250
#, fuzzy
msgid "Inject the Event bus"
msgstr "イベントバスのインジェクト"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:251
#, fuzzy
msgid "Send a message to the address `greeting`. Message payload is `name`"
msgstr "アドレス `greeting` にメッセージを送信してください。メッセージのペイロードは `name`"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:253
#, fuzzy
msgid "The `EventBus` object provides methods to:"
msgstr "`EventBus` オブジェクトは、以下のメソッドを提供します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:255
#, fuzzy
msgid ""
"`send` a message to a specific address - one single consumer receives the "
"message."
msgstr "`send` 特定のアドレスへのメッセージ - 一人の消費者がメッセージを受信する。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:256
#, fuzzy
msgid ""
"`publish` a message to a specific address - all consumers receive the "
"messages."
msgstr "`publish` 特定のアドレスにメッセージを送る - すべての消費者がメッセージを受け取る。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:257
#, fuzzy
msgid "`send` a message and expect reply"
msgstr "`send` メッセージを送って返信を期待する"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:267
#, no-wrap
msgid ""
"// Case 1\n"
"bus.sendAndForget(\"greeting\", name)\n"
"// Case 2\n"
"bus.publish(\"greeting\", name)\n"
"// Case 3\n"
"Uni<String> response = bus.<String>request(\"address\", \"hello, how are "
"you?\")\n"
"        .onItem().transform(Message::body);\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:269
#, no-wrap, fuzzy
msgid "Putting things together - bridging HTTP and messages"
msgstr "物事をまとめる - HTTPとメッセージのブリッジング"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:275
#, fuzzy
msgid ""
"Let's revisit a greeting HTTP endpoint and use asynchronous message passing "
"to delegate the call to a separated bean.  It uses the request/reply "
"dispatching mechanism.  Instead of implementing the business logic inside "
"the JAX-RS endpoint, we are sending a message.  This message is consumed by "
"another bean and the response is sent using the _reply_ mechanism."
msgstr ""
"挨拶HTTPエンドポイントを再訪し、非同期メッセージパッシングを使用して分離されたビーンに呼び出しを委譲してみましょう。リクエスト/"
"レスポンスディスパッチの仕組みを利用しています。JAX-"
"RSエンドポイント内にビジネスロジックを実装する代わりに、メッセージを送信しています。このメッセージは別のBeanによって消費され、応答は "
"_応答_機構を使用して送信されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:277
#, fuzzy
msgid "First create a new project using:"
msgstr "まず、新しいプロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:286
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vertx-http-quickstart \\\n"
"    -Dextensions=\"vertx\" \\\n"
"    -DnoExamples\n"
"cd vertx-http-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:289
#, fuzzy
msgid ""
"You can already start the application in _dev mode_ using `./mvnw compile "
"quarkus:dev`."
msgstr "`./mvnw compile quarkus:dev` を使用して、すでに _開発者モード_でアプリケーションを起動することができます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:291
#, fuzzy
msgid "Then, creates a new JAX-RS resource with the following content:"
msgstr "そして、以下の内容のJAX-RSリソースを新規に作成します。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:293
#, no-wrap, fuzzy
msgid "src/main/java/org/acme/vertx/EventResource.java"
msgstr "src/main/java/org/acme/vertx/ventResource.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:313
#, no-wrap
msgid "    @Inject\n"
"    EventBus bus;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:322
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(@PathParam String name) {\n"
"        return bus.<String>request(\"greeting\", name)            // <1>\n"
"                .onItem().transform(Message::body);            // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:324
#, fuzzy
msgid "send the `name` to the `greeting` address and request a response"
msgstr "`name` `greeting` を送信し、回答を求める。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:325
#, fuzzy
msgid "when we get the response, extract the body and send it to the user"
msgstr "レスポンスを取得したら、本文を抽出してユーザーに送信します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:328
#, fuzzy
msgid ""
"If you call this endpoint, you will wait and get a timeout. Indeed, no one "
"is listening.  So, we need a consumer listening on the `greeting` address. "
"Create a `GreetingService` bean with the following content:"
msgstr ""
"このエンドポイントを呼び出すと、待っていてタイムアウトになります。確かに、誰も聞いていません。そこで、 `greeting` "
"アドレスでリスニングしているコンシューマーが必要です。以下の内容の `GreetingService` ビーンを作成します。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:330
#, no-wrap, fuzzy
msgid "src/main/java/org/acme/vertx/GreetingService.java"
msgstr "src/main/java/org/acme/vertx/GreetingService.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:345
#, no-wrap
msgid ""
"    @ConsumeEvent(\"greeting\")\n"
"    public String greeting(String name) {\n"
"        return \"Hello \" + name;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:350
#, fuzzy
msgid "This bean receives the name, and returns the greeting message."
msgstr "このBeanは名前を受け取り，挨拶メッセージを返します．"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:352
#, fuzzy
msgid ""
"Now, open your browser to http://localhost:8080/async/Quarkus, and you "
"should see:"
msgstr "さて、ブラウザを開いて http://localhost:8080/async/Quarkus 。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:356
#, no-wrap
msgid "Hello Quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:359
#, fuzzy
msgid ""
"To better understand, let's detail how the HTTP request/response has been "
"handled:"
msgstr "より理解しやすくするために、HTTPリクエスト/レスポンスがどのように処理されたかを詳しく見てみましょう。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:361
#, fuzzy
msgid "The request is received by the `hello` method"
msgstr "リクエストは `hello` メソッドで受信します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:362
#, fuzzy
msgid "a message containing the _name_ is sent to the event bus"
msgstr "_名前を_含むメッセージがイベントバスに送信されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:363
#, fuzzy
msgid "Another bean receives this message and computes the response"
msgstr "別のBeanはこのメッセージを受信して，応答を計算します．"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:364
#, fuzzy
msgid "This response is sent back using the reply mechanism"
msgstr "この応答は、リプライ機構を使用して返信されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:365
#, fuzzy
msgid ""
"Once the reply is received by the sender, the content is written to the HTTP "
"response"
msgstr "送信者が返信を受信すると、HTTPレスポンスに内容が書き込まれます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:367
#, fuzzy
msgid "This application can be packaged using:"
msgstr "このアプリケーションは、以下の方法でパッケージ化することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:371
#, no-wrap
msgid "./mvnw clean package\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:374
#, fuzzy
msgid "You can also compile it as a native executable with:"
msgstr "でネイティブ実行ファイルとしてコンパイルすることもできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:378
#, no-wrap
msgid "./mvnw clean package -Pnative\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:380
#, no-wrap, fuzzy
msgid "Using codecs"
msgstr "コーデックを使う"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:385
#, fuzzy
msgid ""
"The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses "
"codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default "
"codec for local delivery.  So you can exchange objects as follows:"
msgstr ""
"link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert."
"xイベントバスで]は、コーデックを使用してオブジェクトの _シリアライズ_と "
"_デシリアライズ_を行います。Quarkusでは、ローカル配信用のデフォルトのコーデックを提供しています。そのため、以下のようにオブジェクトを交換することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:395
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(@PathParam String name) {\n"
"    return bus.<String>request(\"greeting\", new MyName(name))\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:400
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\")\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \" + name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:403
#, fuzzy
msgid ""
"If you want to use a specific codec, you need to explicitly set it on both "
"ends:"
msgstr "特定のコーデックを使用したい場合は、両端で明示的に設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:414
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(@PathParam String name) {\n"
"    return bus.<String>request(\"greeting\", name,\n"
"        new DeliveryOptions().setCodecName(MyNameCodec.class.getName())) // "
"<1>\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:419
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\", codec = MyNameCodec.class)            // "
"<2>\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \"+name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:421
#, fuzzy
msgid "Set the name of the codec to use to send the message"
msgstr "メッセージの送信に使用するコーデックの名前を設定します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:421
#, fuzzy
msgid "Set the codec to use to receive the message"
msgstr "メッセージの受信に使用するコーデックを設定します。"

#. type: Title =
#: upstream/_guides/quarkus-intro.adoc:1
#, no-wrap, fuzzy
msgid "What is Quarkus"
msgstr "クォークスとは"

#.  tag::intro[]
#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:19
#, fuzzy
msgid ""
"Quarkus is a Cloud Native, Container First framework for writing Java "
"applications."
msgstr "Quarkusは、Javaアプリケーションを書くためのクラウドネイティブ、コンテナファーストのフレームワークです。"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:21
#, no-wrap, fuzzy
msgid "Container First"
msgstr "コンテナファースト"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:23
#, fuzzy
msgid ""
"Minimal footprint Java applications optimized for running in containers"
msgstr "コンテナでの実行に最適化されたミニマムフットプリントのJavaアプリケーション"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:23
#: upstream/_guides/quarkus-intro.adoc:56
#, no-wrap, fuzzy
msgid "Cloud Native"
msgstr "クラウドネイティブ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:25
#, fuzzy
msgid "Embraces 12 factor architecture in environments like Kubernetes"
msgstr "Kubernetesのような環境で12因子アーキテクチャを採用"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:25
#, no-wrap, fuzzy
msgid "Unify imperative and reactive"
msgstr "命令的なものと反応的なものを統一する"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:27
#, fuzzy
msgid ""
"Brings under one programming model non blocking and imperative styles of "
"development"
msgstr "ノンブロッキングと命令型の開発スタイルを1つのプログラミングモデルにまとめました。"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:27
#, no-wrap, fuzzy
msgid "Standards-based"
msgstr "標準化された"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:29
#, fuzzy
msgid ""
"Based on the standards and the libraries you love and use (RESTEasy, "
"Hibernate, Netty, Eclipse Vert.x, Apache Camel...)"
msgstr ""
"標準や愛用しているライブラリ（RESTEasy、Hibernate、Netty、Eclipse Vert.x、Apache Camel..."
"）に基づいています。"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:29
#, no-wrap, fuzzy
msgid "Microservice First"
msgstr "マイクロサービスファースト"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:31
#, fuzzy
msgid "Brings lightning fast startup time to Java applications"
msgstr "Javaアプリケーションの起動時間を大幅に短縮"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:31
#, no-wrap, fuzzy
msgid "Extreme productivity"
msgstr "極限の生産性"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:33
#, fuzzy
msgid ""
"Instant hot code replacement: don't allow build, deploy, boot delays disrupt "
"your flow"
msgstr "インスタントホットコードの置き換え: ビルド、デプロイ、ブートの遅延がフローを混乱させないようにする"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:33
#, no-wrap, fuzzy
msgid "Developer Joy"
msgstr "開発者の喜び"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:35
#, fuzzy
msgid ""
"Development-centric experience without compromises to bring your amazing "
"applications to life in no time"
msgstr "妥協のない開発中心の体験で、素晴らしいアプリケーションを短時間で実現"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:37
#, fuzzy
msgid "All under one framework."
msgstr "すべては一つの枠組みの下で。"

#.  end::intro[]
#. type: Title ==
#: upstream/_guides/quarkus-intro.adoc:40
#, no-wrap, fuzzy
msgid "Scratch pad"
msgstr "スクラッチパッド"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:44
#, fuzzy
msgid "Quarkus believes in developer Joy."
msgstr "クォークスは開発者のジョイを信じています。"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:48
#, fuzzy
msgid ""
"It unifies imperative and reactive.  It is a Microservice first toolkit."
msgstr "インプライベーティブとリアクティブを統一しています。マイクロサービスファーストのツールキットです。"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:51
#, fuzzy
msgid ""
"Standards based Quarkus brings all the standards and frameworks you love and "
"use: RESTEasy, Hibernate, Netty, vert.x, Camel...)"
msgstr ""
"標準ベースのQuarkusは、あなたが好きで使っているすべての標準やフレームワークを提供します。RESTEasy、Hibernate、Netty、vert."
"x、Camelなどです。)"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:53
#, fuzzy
msgid "Imperative and Reactive"
msgstr "強迫的と反応的"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:55
#, fuzzy
msgid "ahead-of-time native binary (executable binary)"
msgstr "先行ネイティブバイナリ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:57
#, fuzzy
msgid "Java"
msgstr "ジャワ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:58
#, fuzzy
msgid "modular"
msgstr "モジュラー"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:59
#, fuzzy
msgid "Substrate VM native"
msgstr "基板 VM ネイティブ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:61
#, fuzzy
msgid "Seamlessly build container optimal"
msgstr "シームレスに最適なコンテナを構築"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:63
#, fuzzy
msgid "Container affinity"
msgstr "コンテナとの親和性"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:65
#, fuzzy
msgid "Container optimal"
msgstr "コンテナの最適化"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:67
#, fuzzy
msgid "low memory"
msgstr "ローメモリ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:68
#, fuzzy
msgid "low startup time"
msgstr "低起動時間"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:69
#, fuzzy
msgid "ahead of time optimal"
msgstr "先行最適"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:71
#, fuzzy
msgid "Unifying Imperative and Reactive under one framework."
msgstr "ImperativeとReactiveを一つのフレームワークで統一する。"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:73
#, fuzzy
msgid "Usability"
msgstr "ユーザビリティ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:74
#, fuzzy
msgid "easy to use"
msgstr "使いやすい"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:75
#, fuzzy
msgid "productive environment"
msgstr "せいさんかんきょう"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:76
#, fuzzy
msgid "hot reload"
msgstr "ホットリロード"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:78
#, fuzzy
msgid "Standards based"
msgstr "標準化された"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amazon-ses.adoc:6
#, no-wrap
msgid "Quarkus - Amazon SES Client"
msgstr "Quarkus - Amazon SES クライアント"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:13
msgid ""
"Amazon Simple Email Service (SES) is a flexible and highly-scalable email "
"sending and receiving service.  Using SES, you can send emails with any type "
"of correspondence. You can find more information about SES at https://aws."
"amazon.com/ses/[the Amazon SES website]."
msgstr ""
"Amazon Simple Email "
"Service（SES）は、柔軟で拡張性の高いメール送受信サービスです。SESを利用することで、あらゆる対応でメールを送信することができます。SESの詳細については、 "
"link:https://aws.amazon.com/ses/[Amazon SESのウェブサイト]で確認できます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:16
msgid ""
"The SES extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/"
"developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the "
"1.x code base that offers two programming models (Blocking & Async)."
msgstr ""
"SESのエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-"
"guide/welcome.html[AWS Java SDK 2.x]をベースにしており、2つのプログラミングモデル（Blocking &amp; "
"Async）を提供する1.xのコードベースを大幅に書き換えています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:23
#, fuzzy
msgid "The Quarkus extension supports two programming models:"
msgstr "Quarkus拡張機能は、2つのプログラミングモデルをサポートしています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:25
#, fuzzy
msgid ""
"Blocking access using URL Connection HTTP client (by default) or the Apache "
"HTTP Client"
msgstr ""
"URL Connection HTTP クライアント (デフォルト) または Apache HTTP クライアントを使ってアクセスをブロックする"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:26
#, fuzzy
msgid ""
"https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async."
"html[Asynchronous programming] based on JDK's `CompletableFuture` objects "
"and the Netty HTTP client."
msgstr ""
"JDK の `CompletableFuture` オブジェクトと Netty HTTP クライアントをベースにした link:https://docs."
"aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async."
"html[非同期プログラミング]。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:25
msgid ""
"In this guide, we see how you can get your REST services to use SES locally "
"and on AWS."
msgstr "このガイドでは、RESTサービスを利用してローカルでAWS上でSESを利用する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:34
msgid "An AWS Account to access the SES service"
msgstr "SESサービスにアクセスするためのAWSアカウント"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:35
msgid "Docker for your system to run SES locally for testing purposes"
msgstr "テスト目的でローカルでSESを実行するためのDocker"

#. type: Title ==
#: upstream/_guides/amazon-ses.adoc:36
#, no-wrap
msgid "Set up SES locally"
msgstr "ローカルでSESを設定する"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:40
msgid ""
"The easiest way to start working with SES is to run a local instance as a "
"container.  However, local instance of SES is only mocks the SES APIs "
"without the actual email sending capabilities. You can still use it for this "
"guide to verify an API communication or integration test purposes."
msgstr ""
"SESを使い始める最も簡単な方法は、コンテナとしてローカルインスタンスを実行することです。しかし、SESのローカルインスタンスは、実際のメール送信機能を持たずにSESのAPIをモックしているに過ぎません。それでも、このガイドではAPI通信の検証や統合テストの目的で使用することができます。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:44
#, no-wrap
msgid ""
"docker run --rm --name local-ses -p 8012:4579 -e SERVICES=ses -e START_WEB=0 "
"-d localstack/localstack:0.11.1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:46
msgid "This starts a SES instance that is accessible on port `8012`."
msgstr "これは、ポート `8012` でアクセス可能な SES インスタンスを起動します。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:48
msgid "Create an AWS profile for your local instance using AWS CLI:"
msgstr "AWS CLIを使ってローカルインスタンスのAWSプロファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:55
#, no-wrap
msgid ""
"$ aws configure --profile localstack\n"
"AWS Access Key ID [None]: test-key\n"
"AWS Secret Access Key [None]: test-secret\n"
"Default region name [None]: us-east-1\n"
"Default output format [None]:\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-ses.adoc:57
#, no-wrap
msgid "Using SES on your AWS account"
msgstr "AWSアカウントでSESを使う"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:61
msgid ""
"Amazon applies certain restrictions to new Amazon SES accounts, mainly to "
"prevent fraud and abuse. All new accounts are in the Amazon SES *sandbox*.  "
"All the features of the Amazon SES are still available while in sandbox, but "
"a following restrictions applies:"
msgstr ""
"Amazonは、主に詐欺や悪用を防ぐために、Amazon SESの新規アカウントに一定の制限を適用しています。新規アカウントはすべてAmazon "
"SESの *サンドボックス*に入っています。サンドボックスにいる間もAmazon SESの機能はすべて利用できますが、以下の制限が適用されます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:62
msgid ""
"You can send mail to verified email addresses and domains or to the https://"
"docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-simulator."
"html[Amazon SES mailbox simulator]"
msgstr ""
"検証済みのメールアドレスやドメインにメールを送信したり、 link:https://docs.aws.amazon.com/ses/latest/"
"DeveloperGuide/send-email-simulator.html[Amazon "
"SESのメールボックスシミュレータ]にメールを送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:63
msgid "You can only send mail from verified email addresses and domains"
msgstr "検証済みのメールアドレスとドメインからのみメールを送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:64
msgid "You can send a maximum of 1 message per second."
msgstr "1秒間に最大1メッセージまで送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:66
msgid ""
"Going production, you'd need to get your account of the sandbox following "
"the https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-"
"access.html[Amazon procedure]."
msgstr ""
"本番にするには、 link:https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-"
"production-access.html[Amazonの手順]に沿ってサンドボックスのアカウントを取得する必要があります。"

#. type: Title ===
#: upstream/_guides/amazon-ses.adoc:67
#, no-wrap
msgid "Set up AWS SES"
msgstr "AWS SESの設定"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:71
msgid ""
"We assume you are going to use AWS SES sandbox for the sake of this guide. "
"But before sending any email, you must verify sender and recipient email "
"addresses using AWS CLI.  You can use your personal email or any temporary "
"email service available if you wish."
msgstr ""
"このガイドでは、AWS SESサンドボックスを使用することを想定しています。しかし、メールを送信する前に、AWS "
"CLIを使って送信者と受信者のメールアドレスを確認する必要があります。必要に応じて、個人のメールや利用可能な一時的なメールサービスを利用することができます。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:76
#, no-wrap
msgid ""
"aws ses verify-email-identity --email-address <sender@email.address>\n"
"aws ses verify-email-identity --email-address <recipient@email.address>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:78
msgid ""
"Now, you need to open a mailboxes of those email addresses in order to "
"follow confirmation procedure. Once email is approved you can use it in your "
"application."
msgstr "ここで、確認のためにメールアドレスのメールボックスを開く必要があります。メールが承認されれば、申請に使用することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:81
msgid ""
"If you are using local SES you still need to verify email addresses, "
"otherwise your send email in order to let local SES accepting your request.  "
"However, no emails to be send as it only mocks the service APIs."
msgstr ""
"ローカルSESを使用している場合は、メールアドレスを確認する必要がありますが、そうでない場合は、ローカルSESにリクエストを受け付けるためにメールを送信します。ただし、サービスのAPIをモックするだけなので、メールは送信されません。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:86
#, no-wrap
msgid ""
"aws ses verify-email-identity --email-address <sender@email.address> --"
"profile localstack --endpoint-url=http://localhost:8012\n"
"aws ses verify-email-identity --email-address <recipient@email.address> --"
"profile localstack --endpoint-url=http://localhost:8012\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:90
msgid ""
"The application built here allows sending text emails to the recipients that "
"are verified on AWS SES."
msgstr "ここで構築したアプリケーションでは、AWS SES上で確認された受信者にテキストメールを送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:97
msgid ""
"The solution is located in the `amazon-ses-quickstart` {quickstarts-tree-"
"url}/amazon-ses-quickstart[directory]."
msgstr ""
"ソリューションは `amazon-ses-quickstart` {quickstarts-tree-url}/amazon-ses-"
"quickstart[directory] にあります。"

#. type: Title ==
#: upstream/_guides/scheduler.adoc:40
#, no-wrap, fuzzy
msgid "Creating the Maven project"
msgstr "Mavenプロジェクトの作成"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:111
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=amazon-ses-quickstart \\\n"
"    -DclassName=\"org.acme.ses.QuarkusSesSyncResource\" \\\n"
"    -Dpath=\"/sync\" \\\n"
"    -Dextensions=\"resteasy-jackson,amazon-ses,resteasy-mutiny\"\n"
"cd amazon-ses-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:115
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS, "
"Mutiny and Amazon SES Client extensions.  After this, the `amazon-ses` "
"extension has been added to your `pom.xml` as well as the Mutiny support for "
"RESTEasy."
msgstr ""
"このコマンドは、RESTEasy/JAX-RS、Mutiny、Amazon SES "
"ClientエクステンションをインポートしたMavenディレクトリ構造を生成します。 `pom.xml` "
"この後、RESTEasyのMutinyサポートと同様に、 `amazon-ses` エクステンションが追加されています。"

#. type: Title ==
#: upstream/_guides/amazon-dynamodb.adoc:115
#, no-wrap, fuzzy
msgid "Creating JSON REST service"
msgstr "JSON RESTサービスの作成"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:119
msgid ""
"Lets create a `org.acme.ses.QuarkusSesSyncResource` that will provide an API "
"to send emails using the synchronous client."
msgstr ""
"同期クライアントを使用して電子メールを送信するためのAPIを提供する `org.acme.ses.QuarkusSesSyncResource` "
"を作成しましょう。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:123 upstream/_guides/amazon-ses.adoc:225
#, no-wrap
msgid "package org.acme.ses;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:132
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.acme.ses.model.Email;\n"
"import software.amazon.awssdk.services.ses.SesClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:137
#, no-wrap
msgid ""
"@Path(\"/sync\")\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class QuarkusSesSyncResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:140
#, no-wrap
msgid "    @Inject\n"
"    SesClient ses;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:152
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/email\")\n"
"    public String encrypt(Email data) {\n"
"        return ses.sendEmail(req -> req\n"
"            .source(data.getFrom())\n"
"            .destination(d -> d.toAddresses(data.getTo()))\n"
"            .message(msg -> msg\n"
"                .subject(sub -> sub.data(data.getSubject()))\n"
"                .body(b -> b.text(txt -> txt.data(data.getBody())))))."
"messageId();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-ses.adoc:154
#, no-wrap
msgid "Configuring SES clients"
msgstr "SESクライアントの設定"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:159
msgid ""
"Both SES clients (sync and async) are configurable via the `application."
"properties` file that can be provided in the `src/main/resources` directory. "
" Additionally, you need to add to the classpath a proper implementation of "
"the sync client. By default the extension uses the URL connection HTTP "
"client, so you need to add a URL connection client dependency to the `pom."
"xml` file:"
msgstr ""
"SES クライアント (sync と async) は、 `src/main/resources` ディレクトリにある `application."
"properties` "
"ファイルを介して設定可能です。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、拡張機能は URL 接続 "
"HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` ファイルに追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:329
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>software.amazon.awssdk</groupId>\n"
"    <artifactId>url-connection-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:169
msgid ""
"If you want to use Apache HTTP client instead, configure it as follows:"
msgstr "代わりにApache HTTPクライアントを使用したい場合は、以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:172
#, no-wrap
msgid "quarkus.ses.sync-client.type=apache\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:175
msgid "And add the following dependency to the application `pom.xml`:"
msgstr "そして、以下の依存関係をアプリケーションの `pom.xml`に追加します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:344
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>software.amazon.awssdk</groupId>\n"
"    <artifactId>apache-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:184
msgid "If you're going to use a local SES instance, configure it as follows:"
msgstr "ローカルのSESインスタンスを使用する場合は、以下のように設定します："

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:188
#, no-wrap
msgid "quarkus.ses.endpoint-override=http://localhost:8012\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:193
#, no-wrap
msgid ""
"quarkus.ses.aws.region=us-east-1\n"
"quarkus.ses.aws.credentials.type=static\n"
"quarkus.ses.aws.credentials.static-provider.access-key-id=test-key\n"
"quarkus.ses.aws.credentials.static-provider.secret-access-key=test-secret\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:196
msgid ""
"`quarkus.ses.aws.region` - It's required by the client, but since you're "
"using a local SES instance use `us-east-1` as it's a default region of "
"localstack's SES."
msgstr ""
"`quarkus.ses.aws.region` - "
"クライアントで必要ですが、ローカルのSESインスタンスを使用しているので、ローカルスタックのSESのデフォルトリージョンである `us-east-1` "
"を使用してください。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:197
msgid ""
"`quarkus.ses.aws.credentials.type` - Set `static` credentials provider with "
"any values for `access-key-id` and `secret-access-key`"
msgstr ""
"`quarkus.ses.aws.credentials.type` - `static` 資格情報プロバイダを設定し、 `access-key-id` "
"と `secret-access-key`を任意の値で設定します"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:198
msgid ""
"`quarkus.ses.endpoint-override` - Override the SES client to use a local "
"instance instead of an AWS service"
msgstr ""
"`quarkus.ses.endpoint-override` - SES クライアントをオーバーライドして AWS "
"サービスの代わりにローカルインスタンスを使うようにする"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:201
msgid ""
"If you want to work with an AWS account, you can simply remove or comment "
"out all Amazon SES related properties. By default, the SES client extension "
"will use the `default` credentials provider chain that looks for credentials "
"in this order:"
msgstr ""
"AWSアカウントで作業したい場合は、Amazon "
"SES関連のプロパティをすべて削除するかコメントアウトするだけです。デフォルトでは、SESクライアントエクステンションは、`default` "
"クレデンシャルプロバイダチェーンは使用し、以下の順番でクレデンシャルを検索します："

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:205
msgid "And the region from your AWS CLI profile will be used."
msgstr "そして、AWS CLIプロファイルからのリージョンが使用されます。"

#. type: Title ==
#: upstream/_guides/amazon-dynamodb.adoc:374
#, no-wrap, fuzzy
msgid "Next steps"
msgstr "次のステップ"

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:376
#, no-wrap, fuzzy
msgid "Packaging"
msgstr "パッケージング"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:212
msgid ""
"Packaging your application is as simple as `./mvnw clean package`.  It can "
"be run with `java -jar target/amazon-ses-quickstart-1.0-SNAPSHOT-runner.jar`."
""
msgstr ""
"アプリケーションのパッケージ化は `./mvnw clean package` のように簡単です。 `java -jar target/amazon-"
"ses-quickstart-1.0-SNAPSHOT-runner.jar` で実行できます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:383
#, fuzzy
msgid ""
"With GraalVM installed, you can also create a native executable binary: `./"
"mvnw clean package -Dnative`.  Depending on your system, that will take some "
"time."
msgstr ""
"GraalVMをインストールした状態で、ネイティブの実行バイナリを作成することもできます: `./mvnw clean package -"
"Dnative`.お使いのシステムにもよりますが、時間がかかります。"

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:384
#, no-wrap, fuzzy
msgid "Going asynchronous"
msgstr "非同期に行く"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:387
#, fuzzy
msgid ""
"Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the "
"asynchronous programming model out of the box."
msgstr "Quarkusの拡張機能で使われているAWS SDK v2.xのおかげで、非同期プログラミングモデルをすぐに使えるようになりました。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:221
msgid ""
"Create a `org.acme.ses.QuarkusSesAsyncResource` REST resource that will be "
"similar to our `QuarkusSesSyncResource` but using an asynchronous "
"programming model."
msgstr ""
"`org.acme.ses.QuarkusSesAsyncResource` RESTリソースを作成します。 "
"`QuarkusSesSyncResource` と似ていますが、非同期プログラミングモデルを使用しています。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:236
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.acme.ses.model.Email;\n"
"import software.amazon.awssdk.services.ses.SesAsyncClient;\n"
"import software.amazon.awssdk.services.ses.model.SendEmailResponse;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:241
#, no-wrap
msgid ""
"@Path(\"/async\")\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class QuarkusSesAsyncResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:244
#, no-wrap
msgid "    @Inject\n"
"    SesAsyncClient ses;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:259
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/email\")\n"
"    public Uni<String> encrypt(Email data) {\n"
"        return Uni.createFrom()\n"
"            .completionStage(\n"
"                ses.sendEmail(req -> req\n"
"                    .source(data.getFrom())\n"
"                    .destination(d -> d.toAddresses(data.getTo()))\n"
"                    .message(msg -> msg\n"
"                        .subject(sub -> sub.data(data.getSubject()))\n"
"                        .body(b -> b.text(txt -> txt.data(data."
"getBody()))))))\n"
"            .onItem().apply(SendEmailResponse::messageId);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:261
msgid ""
"We create `Uni` instances from the `CompletionStage` objects returned by the "
"asynchronous SES client, and then transform the emitted item."
msgstr ""
"非同期SESクライアントから返された `CompletionStage` オブジェクトから `Uni` "
"インスタンスを作成し、生成されたアイテムを変換します。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:263
msgid "And we need to add the Netty HTTP client dependency to the `pom.xml`:"
msgstr "そして、NETTY HTTPクライアント依存関係を `pom.xml`に追加する必要があります："

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:477
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>software.amazon.awssdk</groupId>\n"
"    <artifactId>netty-nio-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/performance-measure.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Measuring Performance"
msgstr "Quarkus - パフォーマンスの測定"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:11
#, fuzzy
msgid "This guide covers:"
msgstr "このガイドではカバーしています。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:13
#, fuzzy
msgid "how we measure memory usage"
msgstr "メモリ使用量の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:14
#, fuzzy
msgid "how we measure startup time"
msgstr "起動時間の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:15
#, fuzzy
msgid "which additional flags will Quarkus apply to native-image by default"
msgstr "Quarkusがデフォルトでネイティブイメージに適用する追加フラグ"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:18
#, fuzzy
msgid ""
"All of our tests are run on the same hardware for a given batch.  It goes "
"without saying but it's better when you say it."
msgstr "私たちのテストはすべて、与えられたバッチに対して同じハードウェアで実行されます。言うまでもないことですが、言ってくれた方がいいですよね。"

#. type: Title ==
#: upstream/_guides/performance-measure.adoc:19
#, no-wrap, fuzzy
msgid "How do we measure memory usage"
msgstr "メモリ使用量の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:24
#, fuzzy
msgid ""
"When measuring the footprint of a Quarkus application, we measure https://en."
"wikipedia.org/wiki/Resident_set_size[Resident Set Size (RSS)] and not the "
"JVM heap size which is only a small part of the overall problem.  The JVM "
"not only allocates native memory for heap (`-Xms`, `-Xmx`) but also "
"structures required by the jvm to run your application. Depending on the JVM "
"implementation, the total memory allocated for an application will include, "
"but not limited to:"
msgstr ""
"Quarkusアプリケーションのフットプリントを測定する際には、 link:https://en.wikipedia.org/wiki/"
"Resident_set_size[常駐セットサイズ（RSS）を]測定し、JVMのヒープサイズではなく、全体的な問題のほんの一部です。JVMは、ヒープ用のネイティブメモリ( "
"`-Xms`, `-"
"Xmx`)を割り当てるだけでなく、アプリケーションを実行するためにjvmが必要とする構造体も割り当てます。JVMの実装に応じて、アプリケーションに割り当てられる総メモリは、以下のものを含みますが、これに限定されません。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:26
#, fuzzy
msgid "Heap space"
msgstr "ヒープ空間"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:27
#, fuzzy
msgid "Class metadata"
msgstr "クラスのメタデータ"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:28
#, fuzzy
msgid "Thread stacks"
msgstr "スレッドスタック"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:29
#, fuzzy
msgid "Compiled code"
msgstr "コンパイルされたコード"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:30
#, fuzzy
msgid "Garbage collection"
msgstr "ゴミの収集"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:31
#, no-wrap, fuzzy
msgid "Native Memory Tracking"
msgstr "ネイティブメモリのトラッキング"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:34
#, fuzzy
msgid ""
"In order to view the native memory used by the JVM, you can enable the https:"
"//docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html[Native Memory "
"Tracking] (NMT) feature in hotspot;"
msgstr ""
"JVMで使用されているネイティブメモリを表示するには、hotspotでNMT( link:https://docs.oracle.com/javase/"
"8/docs/technotes/guides/vm/nmt-8.html[Native Memory Tracking])機能を有効にします。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:36
#, fuzzy
msgid "Enable NMT on the command line;"
msgstr "コマンドラインでNMTを有効にします。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:38
#, no-wrap, fuzzy
msgid " -XX:NativeMemoryTracking=[off | summary | detail] <1>\n"
msgstr ""
"<pre>-XX:NativeMemoryTracking=[off | summary | detail]<b class="
"\"conum\">(1)</b></pre>"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:40
#, fuzzy
msgid ""
"NOTE: this feature will add cause an approximately 5-10% performance "
"overhead"
msgstr ""
"<div class=\"title\">\n"
"  留意事項 \n"
"</div>  この機能は、約 5-10% のパフォーマンスオーバーヘッドを発生させます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:42
#, fuzzy
msgid ""
"It is then possible to use jcmd to dump a report of the native memory usage "
"of the Hotspot JVM running your application;"
msgstr "そして、jcmdを使ってアプリケーションを実行しているHotspot JVMのネイティブメモリ使用量のレポートをダンプすることができます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:44
#, no-wrap, fuzzy
msgid ""
" jcmd <pid> VM.native_memory [summary | detail | baseline | summary.diff | "
"detail.diff | shutdown] [scale= KB | MB | GB]\n"
msgstr ""
"<pre>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | "
"summary.diff | detail.diff | shutdown] [scale= KB | MB | GB] [scale= KB | MB "
"| GB</pre>"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:45
#, no-wrap, fuzzy
msgid "Cloud Native Memory Limits"
msgstr "クラウドネイティブのメモリ制限"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:49
#, fuzzy
msgid ""
"It is important to measure the whole memory to see the impact of a Cloud "
"Native application.  It is particularly true of container environments which "
"will kill a process based on its full RSS memory usage."
msgstr ""
"Cloud "
"Nativeアプリケーションの影響を見るためには、メモリ全体を測定することが重要です。特にコンテナ環境では、RSSメモリのフル使用量に基づいてプロセスを強制終了させてしまうことがあります。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:53
#, fuzzy
msgid ""
"Likewise, don't fall into the trap of only measuring private memory which is "
"what the process uses that is not shareable with other processes.  While "
"private memory might be useful in a environment deploying many different "
"applications (and thus sharing memory a lot), it is very misleading in "
"environments like Kubernetes/OpenShift."
msgstr ""
"同様に、他のプロセスと共有できないプロセスが使用しているプライベートメモリだけを測定するという罠にはまらないようにしましょう。プライベートメモリは、多くの異なるアプリケーションをデプロイする環境（したがってメモリを多く共有する）では有用かもしれませんが、Kubernetes/"
"OpenShiftのような環境では非常に誤解を招く可能性があります。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:54
#, no-wrap, fuzzy
msgid "Platform Specific Memory Reporting"
msgstr "プラットフォーム固有のメモリレポート"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:57
#, fuzzy
msgid ""
"In order to not incur the performance overhead of running with NVM enabled, "
"we measure the total RSS of an JVM application using tools specific to each "
"platform."
msgstr ""
"NVMを有効にして実行することによるパフォーマンスオーバーヘッドを発生させないために、各プラットフォームに特化したツールを使用して、JVMアプリケーションの総RSSを測定します。"

#. type: Labeled list
#: upstream/_guides/performance-measure.adoc:58
#, no-wrap, fuzzy
msgid "Linux"
msgstr "リナックス"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:61
#, fuzzy
msgid ""
"The linux https://linux.die.net/man/1/pmap[pmap] and https://linux.die.net/"
"man/1/ps[ps] tools provide a report on the native memory map for a process"
msgstr ""
"Linux の link:https://linux.die.net/man/1/pmap[pmap]と link:https://linux.die."
"net/man/1/ps[ps]ツールはプロセスのネイティブメモリマップのレポートを提供します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:65
#, no-wrap
msgid " $ ps -o pid,rss,command -p <pid>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:68
#, no-wrap
msgid ""
"   PID   RSS COMMAND\n"
" 11229 12628 ./target/getting-started-1.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:73
#, no-wrap
msgid " $ pmap -x <pid>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:87
#, no-wrap
msgid ""
" 13150:   /data/quarkus-application -Xmx100m -Xmn70m\n"
" Address           Kbytes     RSS   Dirty Mode  Mapping\n"
" 0000000000400000   55652   30592       0 r-x-- quarkus-application\n"
" 0000000003c58000       4       4       4 r-x-- quarkus-application\n"
" 0000000003c59000    5192    4628     748 rwx-- quarkus-application\n"
" 00000000054c0000     912     156     156 rwx--   [ anon ]\n"
" ...\n"
" 00007fcd13400000    1024    1024    1024 rwx--   [ anon ]\n"
" ...\n"
" 00007fcd13952000       8       4       0 r-x-- libfreebl3.so\n"
" ...\n"
" ---------------- ------- ------- -------\n"
" total kB         9726508  256092  220900\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:90
#, fuzzy
msgid "Each Memory region that has been allocated for the process is listed;"
msgstr "プロセスに割り当てられた各メモリ領域が一覧表示されます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:92
#, fuzzy
msgid "Address: Start address of virtual address space"
msgstr "アドレス。仮想アドレス空間の開始アドレス"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:93
#, fuzzy
msgid "Kbytes: Size (kilobytes) of virtual address space reserved for region"
msgstr "Kbytes（キロバイト）。リージョン用に予約された仮想アドレス空間のサイズ (キロバイト)"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:94
#, no-wrap, fuzzy
msgid ""
"RSS:     Resident set size (kilobytes).  This is the measure of how much "
"memory space is actually being used\n"
msgstr "RSSです。常駐セットサイズ（キロバイト）。これは、実際に使用されているメモリ領域の量を示す指標です。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:95
#, no-wrap, fuzzy
msgid "Dirty:   dirty pages (both shared and private) in kilobytes\n"
msgstr "ダーティ: ダーティなページ (共有およびプライベートの両方) をキロバイト単位で表示します。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:96
#, no-wrap, fuzzy
msgid "Mode:    Access mode for memory region\n"
msgstr "モード。メモリ領域のアクセスモード"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:97
#, no-wrap, fuzzy
msgid ""
"Mapping: Includes application regions and Shared Object (.so) mappings for "
"process\n"
msgstr "マッピング。プロセス用のアプリケーション領域と共有オブジェクト(.so)のマッピングを含む"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:99
#, fuzzy
msgid ""
"The Total RSS (kB) line reports the total native memory the process is using."
""
msgstr "Total RSS (kB)行は、プロセスが使用しているネイティブメモリの合計を報告します。"

#. type: Labeled list
#: upstream/_guides/performance-measure.adoc:100
#, no-wrap, fuzzy
msgid "macOS"
msgstr "マックオーエス"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:102
#, fuzzy
msgid ""
"On macOS, you can use `ps x -o pid,rss,command -p <PID>` which list the RSS "
"for a given process in KB (1024 bytes)."
msgstr ""
"macOSでは、特定のプロセスのRSSをKB(1024バイト)単位で一覧表示する `ps x -o pid,rss,command -p "
"&amp;lt;PID&amp;gt;` を使用することができます。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:106
#, no-wrap
msgid "$ ps x -o pid,rss,command -p 57160\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:109
#, no-wrap
msgid ""
"  PID    RSS COMMAND\n"
"57160 288548 /Applications/IntelliJ IDEA CE.app/Contents/jdk/Contents/Home/"
"jre/bin/java\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:112
#, fuzzy
msgid "Which means IntelliJ IDEA consumes 281,8 MB of resident memory."
msgstr "つまり、IntelliJ IDEAは281,8MBの常駐メモリを消費していることになります。"

#. type: Title ==
#: upstream/_guides/performance-measure.adoc:113
#, no-wrap, fuzzy
msgid "How do we measure startup time"
msgstr "起動時間の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:118
#, fuzzy
msgid ""
"Some frameworks use aggressive lazy initialization techniques.  It is "
"important to measure the startup time to first request to most accurately "
"reflect how long a framework needs to start.  Otherwise, you will miss the "
"time the framework _actually_ takes to initialize."
msgstr ""
"フレームワークの中には、アグレッシブな遅延初期化テクニックを使用しているものがあります。フレームワークを開始するために必要な時間を最も正確に反映させるために、最初のリクエストまでの起動時間を測定することが重要です。そうしないと、フレームワークが "
"_実際に_初期化にかかる時間を見逃してしまいます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:120
#, fuzzy
msgid "Here is how we measure startup time in our tests."
msgstr "ここでは、テストでの起動時間の測定方法を説明します。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:122
#, fuzzy
msgid ""
"We create a sample application that logs timestamps for certain points in "
"the application lifecycle."
msgstr "アプリケーションのライフサイクルの特定のポイントのタイムスタンプをログに記録するサンプルアプリケーションを作成します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:127
#, no-wrap
msgid "@Path(\"/\")\n"
"public class GreetingEndpoint {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:129
#, no-wrap
msgid "    private static final String template = \"Hello, %s!\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:138
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/greeting\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Greeting greeting(@QueryParam(\"name\") String name) {\n"
"        System.out.println(new SimpleDateFormat(\"HH:mm:ss.SSS\").format(new "
"java.util.Date(System.currentTimeMillis())));\n"
"        String suffix = name != null ? name : \"World\";\n"
"        return new Greeting(String.format(template, suffix));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:143
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent startup) {\n"
"        System.out.println(new SimpleDateFormat(\"HH:mm:ss.SSS\").format(new "
"Date()));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:146
#, fuzzy
msgid ""
"We start looping in a shell, sending requests to the rest endpoint of the "
"sample application we are testing."
msgstr "私たちはシェル内でループを開始し、テストしているサンプルアプリケーションの残りのエンドポイントにリクエストを送信します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:150
#, no-wrap
msgid ""
"$ while [[ \"$(curl -s -o /dev/null -w ''%{http_code}'' localhost:8080/api/"
"greeting)\" != \"200\" ]]; do sleep .00001; done\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:153
#, fuzzy
msgid ""
"In a separate terminal, we start the timing application that we are testing, "
"printing the time the application starts"
msgstr "別の端末で、テストしているタイミングアプリケーションを起動し、アプリケーションが起動した時刻を印刷します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:157
#, no-wrap
msgid "$ date +\"%T.%3N\" &&  ./target/quarkus-timing-runner\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:163
#, no-wrap
msgid ""
"10:57:32.508\n"
"10:57:32.512\n"
"2019-04-05 10:57:32,512 INFO  [io.quarkus] (main) Quarkus 0.11.0 started in "
"0.002s. Listening on: http://127.0.0.1:8080\n"
"2019-04-05 10:57:32,512 INFO  [io.quarkus] (main) Installed features: [cdi, "
"resteasy, resteasy-jackson]\n"
"10:57:32.537\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:166
#, fuzzy
msgid ""
"The difference between the final timestamp and the first timestamp is the "
"total startup time for the application to serve the first request."
msgstr "最終タイムスタンプと最初のタイムスタンプの差は、アプリケーションが最初のリクエストにサービスを提供するための総起動時間です。"

#. type: Title ==
#: upstream/_guides/performance-measure.adoc:167
#, no-wrap, fuzzy
msgid "Additional flags applied by Quarkus"
msgstr "Quarkusで適用される追加フラグ"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:170
#, fuzzy
msgid ""
"When Quarkus invokes GraalVM `native-image` it will apply some additional "
"flags by default."
msgstr "QuarkusがGraalVMを起動すると、 `native-image` デフォルトでいくつかの追加フラグが適用されます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:172
#, fuzzy
msgid ""
"You might want to know about the following ones in case you're comparing "
"performance properties with other builds."
msgstr "他のビルドと性能特性を比較する場合には、以下のようなものを知っておくと良いでしょう。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:173
#, no-wrap, fuzzy
msgid "Disable fallback images"
msgstr "フォールバック画像を無効にする"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:177
#, fuzzy
msgid ""
"Fallback native images are a feature of GraalVM to \"fall back\" to run your "
"application in the normal JVM, should the compilation to native code fail "
"for some reason."
msgstr ""
"フォールバックネイティブイメージは、何らかの理由でネイティブコードへのコンパイルに失敗した場合に、アプリケーションを通常のJVMで実行するために「フォールバック」するためのGraalVMの機能です。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:180
#, fuzzy
msgid ""
"Quarkus disables this feature by setting `-H:FallbackThreshold=0`: this will "
"ensure you get a compilation failure rather risking to not notice that the "
"application is unable to really run in native mode."
msgstr ""
"Quarkusは、 `-H:FallbackThreshold=0` "
"を設定することでこの機能を無効にします。これにより、アプリケーションが本当にネイティブモードで実行できないことに気づかないリスクを冒して、コンパイルに失敗することが確実になります。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:182
#, fuzzy
msgid ""
"If you instead want to just run in Java mode, that's totally possible: just "
"skip the native-image build and run it as a jar."
msgstr "代わりに Java モードで実行したい場合は、ネイティブイメージのビルドをスキップして jar として実行することも可能です。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:183
#, no-wrap, fuzzy
msgid "Disable Isolates"
msgstr "アイソレートを無効にする"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:186
#, fuzzy
msgid ""
"Isolates are a neat feature of GraalVM, but Quarkus isn't using them at this "
"stage."
msgstr "アイソレートはGraalVMの優れた機能ですが、Quarkusは現段階では使用していません。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:188
#, fuzzy
msgid "Disable via `-H:-SpawnIsolates`."
msgstr "`-H:-SpawnIsolates` で無効化する。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:189
#, no-wrap, fuzzy
msgid "Disable auto-registration of all Service Loader implementations"
msgstr "すべてのサービスローダ実装の自動登録を無効にする"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:193
#, fuzzy
msgid ""
"Quarkus extensions can automatically pick the right services they need, "
"while GraalVM's native-image defaults to include all services it's able to "
"find on the classpath."
msgstr ""
"Quarkusの拡張機能では、必要なサービスを自動的に選択することができますが、GraalVMのネイティブイメージのデフォルトでは、クラスパス上で見つけることができるすべてのサービスが含まれています。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:195
#, fuzzy
msgid ""
"We prefer listing services explicitly as it produces better optimised "
"binaries. Disable it as well by setting `-H:-UseServiceLoaderFeature`."
msgstr ""
"サービスを明示的にリストアップした方が最適化されたバイナリが生成されるので好ましいです。 `-H:-UseServiceLoaderFeature`."

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:196
#, no-wrap, fuzzy
msgid "Better default for Garbage Collection implementation"
msgstr "ガベージコレクションの実装のためのより良いデフォルト"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:199
#, fuzzy
msgid ""
"The default in GraalVM seems meant to optimise for short lived processes."
msgstr "GraalVMのデフォルトは、短命なプロセスに最適化することを意図しているようです。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:202
#, no-wrap, fuzzy
msgid ""
"Quarkus defaults to server applications, so we switch to a better default by "
"setting\n"
" `-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge."
"CollectionPolicy$BySpaceAndTime`.\n"
msgstr ""
"Quarkusのデフォルトはサーバーアプリケーションになっているので、 `-H:InitialCollectionPolicy=com.oracle."
"svm.core.genscavenge.CollectionPolicy$BySpaceAndTime`."

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:203
#, no-wrap, fuzzy
msgid "Others ..."
msgstr "その他..."

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:208
#, no-wrap, fuzzy
msgid ""
"This section is provided as high level guidance, but can't presume to be "
"comprehensive as some flags are controlled\n"
" dynamically by the extensions, the platform you're building on, "
"configuration details, your code and possibly\n"
" a combination of any of these.\n"
msgstr ""
"このセクションは高レベルのガイダンスとして提供されていますが、フラグのいくつかは拡張機能や構築しているプラットフォーム、設定の詳細、あなたのコード、そしておそらくこれらの組み合わせによって動的に制御されるため、包括的なものとは考えられません。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:211
#, fuzzy
msgid ""
"Generally speaking the ones listed here are those most likely to affect "
"performance metrics, but in the right circumstances one could observe non "
"negligible impact from the other flags too."
msgstr ""
"一般的に言えば、ここに挙げたものはパフォーマンス・メトリクスに影響を与える可能性が高いものですが、適切な状況下では、他のフラグからも無視できないほどの影響を受ける可能性があります。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:214
#, fuzzy
msgid ""
"If you're to investigate some differences in detail make sure to check what "
"Quarkus is invoking exactly: when the build plugin is producing a native "
"image, the full command lines are logged."
msgstr "ビルドプラグインがネイティブイメージを生成しているときには、コマンドライン全体がログに記録されます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cassandra.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using the Cassandra Client"
msgstr "Quarkus - Cassandraクライアントの使用"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:13
#, fuzzy
msgid ""
"Apache Cassandra® is a free and open-source, distributed, wide column store, "
"NoSQL database management system designed to handle large amounts of data "
"across many commodity servers, providing high availability with no single "
"point of failure."
msgstr ""
"Apache "
"Cassandra®は、フリーでオープンソースの分散型ワイドカラムストアのNoSQLデータベース管理システムで、多くのコモディティサーバーにまたがる大量のデータを処理するように設計されており、単一障害点のない高可用性を提供します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:15
#, fuzzy
msgid ""
"In this guide, we will see how you can get your REST services to use a "
"Cassandra database."
msgstr "このガイドでは、RESTサービスでCassandraデータベースを使用する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:25
#, fuzzy
msgid ""
"GraalVM installed with `GRAALVM_HOME` configured appropriately if you want "
"to use the native mode."
msgstr "ネイティブモードを使用したい場合は、 `GRAALVM_HOME` を適切に設定して GraalVM をインストールしてください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:27
#, fuzzy
msgid "Cassandra or Docker installed"
msgstr "CassandraまたはDockerのインストール"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:32
#, fuzzy
msgid ""
"The application built in this guide is quite simple: the user can add "
"elements in a list using a form, and the items list is updated."
msgstr ""
"このガイドで構築されたアプリケーションは非常にシンプルです：ユーザーはフォームを使用してリストに要素を追加することができ、アイテムリストが更新されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:34
#, fuzzy
msgid ""
"All the information between the browser and the server is formatted as JSON."
msgstr "ブラウザとサーバ間の情報はすべてJSON形式になっています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:36
#, fuzzy
msgid "The elements are stored in the Cassandra database."
msgstr "要素はカサンドラ・データベースに格納されています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:45
#, fuzzy
msgid ""
"The solution is located in the `quickstart` link:https://github.com/datastax/"
"cassandra-quarkus/tree/master/quickstart[directory]."
msgstr ""
"ソリューションは `quickstart`  link:https://github.com/datastax/cassandra-quarkus/"
"tree/master/quickstart[ディレクトリ]にあります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:50
#, fuzzy
msgid ""
"First, create a new Maven project and copy the `pom.xml` file that is "
"present in the `quickstart` directory."
msgstr ""
"まず、新しいMavenプロジェクトを作成し、 `quickstart` ディレクトリに存在する `pom.xml` ファイルをコピーします。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:53
#, fuzzy
msgid ""
"The `pom.xml` is importing the RESTEasy/JAX-RS, JSON-B, Context Propagation "
"and Cassandra Client extensions."
msgstr ""
"`pom.xml` は、RESTEasy/JAX-RS、JSON-B、Context "
"Propagation、Cassandraクライアント拡張機能をインポートしています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:57
#, fuzzy
msgid ""
"We will be building a REST application using the link:https://docs.datastax."
"com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] to "
"simplify the Data Access Layer code."
msgstr ""
"link:https://docs.datastax.com/en/developer/java-driver/latest/manual/"
"mapper[DataStax Object Mapper]を使ってRESTアプリケーションを構築し、Data Access "
"Layerのコードを簡略化していきます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:59
#, fuzzy
msgid ""
"The most important part of the `pom.xml` is adding the `cassandra-quarkus` "
"extension:"
msgstr "`pom.xml` で最も重要なのは、 `cassandra-quarkus` の拡張子を追加することです。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:67
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>com.datastax.oss.quarkus</groupId>\n"
"    <artifactId>cassandra-quarkus-client</artifactId>\n"
"    <version>${quarkus.version}</version>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:73
#, fuzzy
msgid ""
"Also make sure to follow the link:https://docs.datastax.com/en/developer/"
"java-driver/latest/manual/mapper/config/[instructions] on how to add an "
"annotation processor to the compiler configuration. When the project is "
"compiled, additional mapper classes are generated."
msgstr ""
"また、コンパイラの設定にアノテーションプロセッサを追加する方法の link:https://docs.datastax.com/en/developer/"
"java-driver/latest/manual/mapper/config/"
"[説明]にも必ず従ってください。プロジェクトがコンパイルされると、追加のマッパークラスが生成されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:98
#, fuzzy
msgid ""
"In this example, we will create an application to manage a list of fruits."
msgstr "この例では、果物のリストを管理するアプリケーションを作成します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:100
#, fuzzy
msgid "First, let's create the `Fruit` bean as follows:"
msgstr "まず、以下のように `Fruit` Bean を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:84
#, no-wrap
msgid "@Entity\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:88
#, no-wrap
msgid ""
"    @PartitionKey private String storeId;\n"
"    @ClusteringColumn private String name;\n"
"    private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:90
#, no-wrap
msgid "    public Fruit() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:96
#, no-wrap
msgid ""
"    public Fruit(String storeId, String name, String description) {\n"
"      this.storeId = storeId;\n"
"      this.name = name;\n"
"      this.description = description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:99
#, no-wrap
msgid "    // getters, setters, hashCode and equals omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:105
#, fuzzy
msgid ""
"We are using DataStax Java driver Object Mapper, which is why this class is "
"annotated with an `@Entity`. Also, the `storeId` field represents a "
"Cassandra partition key and `name` represents a clustering column, and so we "
"are using the corresponding annotations from the Object Mapper library.  It "
"will allow the Mapper to generate proper CQL queries underneath."
msgstr ""
"DataStax JavaドライバのObject Mapperを使用しているので、このクラスには `@Entity` "
"がアノテーションされています。また、 `storeId` フィールドは Cassandra パーティション・キーを表し、 `name` "
"はクラスタリング・カラムを表しているので、Object Mapper "
"ライブラリから対応するアノテーションを使用しています。これにより、Mapperはその下に適切なCQLクエリを生成することができるようになります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:107
#, fuzzy
msgid "Entity classes are required to have a default no-args constructor."
msgstr "エンティティクラスは、デフォルトの no-args コンストラクタを持つ必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:109
#, fuzzy
msgid "To leverage the Mapper logic in this app we need to create a DAO:"
msgstr "このアプリでMapperロジックを活用するには、DAOを作成する必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:116
#, no-wrap
msgid ""
"@Dao\n"
"public interface FruitDao {\n"
"  @Update\n"
"  void update(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:120
#, no-wrap
msgid "  @Select\n"
"  PagingIterable<Fruit> findById(String id);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:123
#, fuzzy
msgid "This class exposes operations that will be used in the REST service."
msgstr "このクラスは、RESTサービスで使用される操作を公開します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:125
#, fuzzy
msgid "Finally, the Mapper itself:"
msgstr "最後にMapperそのもの。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:133
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  @DaoFactory\n"
"  FruitDao fruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:138
#, fuzzy
msgid ""
"The mapper is responsible for constructing instances of `FruitDao`. In the "
"example above, the `FruitDao` instance will be connected to the same "
"keyspace as the underlying session. More on that below."
msgstr ""
"マッパーは `FruitDao` のインスタンスを構築する責任があります。上の例では、 `FruitDao` "
"のインスタンスは、基礎となるセッションと同じ鍵空間に接続されます。詳細は後述します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:142
#, fuzzy
msgid ""
"It is also possible to create DAO instances for different keyspaces. To "
"learn how, see link:https://docs.datastax.com/en/developer/java-driver/4.7/"
"manual/mapper/mapper/#dao-parameterization[DAO parameterization] in the "
"driver docs."
msgstr ""
"異なるキースペース用の DAO インスタンスを作成することも可能です。方法については、ドライバドキュメントの link:https://docs."
"datastax.com/en/developer/java-driver/4.7/manual/mapper/mapper/#dao-"
"parameterization[DAO パラメータ化]を参照してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:146
#, fuzzy
msgid ""
"Next, we need a component to create our DAO instances: `FruitDaoProducer`. "
"Indeed, Mapper and Dao instances are stateful objects, and should be created "
"only once, as application-scoped singletons.  This component will do exactly "
"that, leveraging Quarkus Dependency Injection container:"
msgstr ""
"次に、DAO インスタンスを作成するためのコンポーネントが必要です: `FruitDaoProducer`."
"実際、MapperとDaoインスタンスはステートフルオブジェクトであり、アプリケーションスコープ付きのシングルトンとして一度だけ作成する必要があります。このコンポーネントは、Quarkus "
"Dependency Injectionコンテナを利用して、まさにそれを行います。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:155
#, no-wrap
msgid ""
"import com.datastax.oss.driver.api.core.CqlIdentifier;\n"
"import com.datastax.oss.quarkus.runtime.api.config.CassandraClientConfig;\n"
"import com.datastax.oss.quarkus.runtime.api.session.QuarkusCqlSession;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.inject.Produces;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:157
#, no-wrap
msgid "public class FruitDaoProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:160
#, no-wrap
msgid ""
"  private final FruitDao fruitDao;\n"
"  private final FruitDaoReactive fruitDaoReactive;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:169
#, no-wrap
msgid ""
"  @Inject\n"
"  public FruitDaoProducer(QuarkusCqlSession session) {\n"
"    // create a mapper\n"
"    FruitMapper mapper = new FruitMapperBuilder(session).build();\n"
"    // instantiate our Daos\n"
"    fruitDao = mapper.fruitDao();\n"
"    fruitDaoReactive = mapper.fruitDaoReactive();\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:175
#, no-wrap
msgid ""
"  @Produces\n"
"  @ApplicationScoped\n"
"  FruitDao produceFruitDao() {\n"
"    return fruitDao;\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:182
#, no-wrap
msgid ""
"  @Produces\n"
"  @ApplicationScoped\n"
"  FruitDaoReactive produceFruitDaoReactive() {\n"
"    return fruitDaoReactive;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:186
#, fuzzy
msgid ""
"Note how the `QuarkusCqlSession` instance is injected automatically by the "
"cassandra-quarkus extension in the `FruitDaoProducer` constructor."
msgstr ""
"`QuarkusCqlSession` のインスタンスが `FruitDaoProducer` コンストラクタの cassandra-quarkus "
"拡張機能によって自動的に注入されていることに注意してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:189
#, fuzzy
msgid ""
"Also note that `FruitMapperBuilder` is one of the classes generated "
"automatically by the `java-driver-mapper-processor` annotation processor."
msgstr ""
"また、 `FruitMapperBuilder` は `java-driver-mapper-processor` "
"アノテーション・プロセッサによって自動的に生成されるクラスの一つであることにも注意してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:192
#, fuzzy
msgid ""
"Now create a `FruitService` that will be the business layer of our "
"application and store/load the fruits from the Cassandra database."
msgstr ""
"今、私たちのアプリケーションのビジネス層となる `FruitService` を作成し、Cassandraデータベースから果実を保存/ロードします。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:197
#, no-wrap
msgid "@ApplicationScoped\n"
"public class FruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:199
#, no-wrap
msgid "  private final FruitDao dao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:204
#, no-wrap
msgid ""
"  @Inject\n"
"  public FruitService(FruitDao dao) {\n"
"    this.dao = dao;\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:208
#, no-wrap
msgid "  public void save(Fruit fruit) {\n"
"    dao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:213
#, no-wrap
msgid ""
"  public List<Fruit> get(String id) {\n"
"    return dao.findById(id).all();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:217
#, fuzzy
msgid ""
"Note how the service receives a `FruitDao` instance in the constructor. This "
"DAO instance is provided by `FruitDaoProducer` and injected automatically."
msgstr ""
"サービスがコンストラクタで `FruitDao` インスタンスを受け取る様子に注目してください。この DAO インスタンスは "
"`FruitDaoProducer` によって提供され、自動的に注入されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:219
#, fuzzy
msgid ""
"The last missing piece is the REST API that will expose GET and POST methods:"
""
msgstr "最後の欠落した部分は、GETとPOSTメソッドを公開するREST APIです。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:139
#, no-wrap
msgid "@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:226
#, no-wrap
msgid "  private static final String STORE_NAME = \"acme\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:228
#, no-wrap
msgid "  @Inject FruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:235
#, no-wrap
msgid ""
"  @GET\n"
"  public List<FruitDto> list() {\n"
"    return fruitService.get(STORE_NAME).stream()\n"
"        .map(fruit -> new FruitDto(fruit.getName(), fruit.getDescription()))\n"
"        .collect(Collectors.toList());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:240
#, no-wrap
msgid ""
"  @POST\n"
"  public void add(FruitDto fruit) {\n"
"    fruitService.save(covertFromDto(fruit));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:245 upstream/_guides/cassandra.adoc:527
#, no-wrap
msgid ""
"  private Fruit covertFromDto(FruitDto fruitDto) {\n"
"    return new Fruit(fruitDto.getName(), fruitDto.getDescription(), "
"STORE_NAME);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:251
#, fuzzy
msgid ""
"The `list` and `add` operations are executed for the `storeId` \"acme\". "
"This is the partition key of our data model. We can easily retrieve all rows "
"from cassandra using that partition key.  They will be sorted by the "
"clustering column. `FruitResource` is using `FruitService` which "
"encapsulates the data access logic."
msgstr ""
"`list` と `add` の操作は、 `storeId` \"acme\" "
"に対して実行されます。これは、私たちのデータ・モデルのパーティション・キーです。このパーティション・キーを使用して、cassandraからすべての行を簡単に取得することができます。 "
"`FruitResource` は、データ・アクセス・ロジックをカプセル化した `FruitService` を使用しています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:257
#, fuzzy
msgid ""
"When creating the REST API we should not share the same entity object "
"between REST API and data access layers. They should not be coupled to allow "
"the API to evolve independently of the storage layer. This is the reason why "
"the API is using a `FruitDto` class. This class will be used by Quarkus to "
"convert JSON to java objects for client requests and java objects to JSON "
"for the responses. The translation is done by quarkus-resteasy extension."
msgstr ""
"REST APIを作成する際には、REST "
"APIとデータアクセス層の間で同じエンティティオブジェクトを共有すべきではありません。それらは、APIがストレージ層から独立して進化できるように結合されるべきではありません。これが、APIが "
"`FruitDto` "
"クラスを使用している理由です。このクラスは、Quarkusがクライアントのリクエストに対してはJSONをjavaオブジェクトに、レスポンスに対してはjavaオブジェクトをJSONに変換するために使用します。変換はquarkus-"
"resteasy拡張機能によって行われます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:261
#, no-wrap
msgid "public class FruitDto {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:264
#, no-wrap
msgid "  private String name;\n"
"  private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:266
#, no-wrap
msgid "  public FruitDto() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:273
#, no-wrap
msgid ""
"  public FruitDto(String name, String description) {\n"
"    this.name = name;\n"
"    this.description = description;\n"
"  }\n"
"  // getters and setters omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:277
#, fuzzy
msgid ""
"DTO classes used by the JSON serialization layer are required to have a "
"default no-arg constructor."
msgstr "JSON シリアライゼーションレイヤーで使用される DTO クラスは、デフォルトの no-arg コンストラクタを持つ必要があります。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:278
#, no-wrap, fuzzy
msgid "Configuring the Cassandra database"
msgstr "Cassandraデータベースの設定"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:280
#, no-wrap, fuzzy
msgid "Connecting to Apache Cassandra or DataStax Enterprise (DSE)"
msgstr "Apache CassandraまたはDataStax Enterprise（DSE）への接続"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:284
#, fuzzy
msgid ""
"The main properties to configure are: `contact-points`, to access the "
"Cassandra database, `local-datacenter`, which is required by the driver, and "
"– optionally – the keyspace to bind to."
msgstr ""
"構成する主なプロパティは次のとおりです。 `contact-points` 、Cassandraデータベースにアクセスするための `local-"
"datacenter` 、ドライバによって必要とされる 、そしてオプションでバインド先のキースペースです。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:286
#, fuzzy
msgid "A sample configuration should look like this:"
msgstr "設定のサンプルは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:292
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points={cassandra_ip}:9042\n"
"quarkus.cassandra.local-datacenter={dc_name}\n"
"quarkus.cassandra.keyspace={keyspace}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:296
#, fuzzy
msgid ""
"In this example, we are using a single instance running on localhost, and "
"the keyspace containing our data is `k1`:"
msgstr "この例では、ローカルホスト上で実行されている単一のインスタンスを使用しており、データを含む鍵空間は `k1`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:302
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points=127.0.0.1:9042\n"
"quarkus.cassandra.local-datacenter=datacenter1\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:306
#, fuzzy
msgid ""
"If your cluster requires plain text authentication, you can also provide two "
"more settings: `username` and `password`."
msgstr "クラスタでプレーンテキスト認証が必要な場合は、 `username` と `password`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:311
#, no-wrap
msgid ""
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:313
#, no-wrap, fuzzy
msgid "Connecting to a cloud DataStax Astra database"
msgstr "クラウドDataStax Astraデータベースへの接続"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:318
#, fuzzy
msgid ""
"When connecting to Astra, instead of providing a contact point and a "
"datacenter, you should provide `secure-connect-bundle`, which should point "
"to a valid path to an Astra secure connect bundle, as well as `username` "
"and`password`, since authentication is always required on Astra clusters."
msgstr ""
"`username` Astra に接続する際には、コンタクトポイントとデータセンターを提供する代わりに、 `secure-connect-"
"bundle` を提供する必要があります。 は Astra secure connect bundle への有効なパスを指している必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:320
#, fuzzy
msgid "A sample configuration for DataStax Astra should look like this:"
msgstr "DataStax Astraのサンプル構成は次のようになります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:327
#, no-wrap
msgid ""
"quarkus.cassandra.cloud.secure-connect-bundle=/path/to/secure-connect-bundle."
"zip\n"
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:329
#, no-wrap, fuzzy
msgid "Advanced driver configuration"
msgstr "高度なドライバ設定"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:336
#, fuzzy
msgid ""
"You can configure other Java driver settings using `application.conf` or "
"`application.json` files.  They need to be located in the classpath of your "
"application.  All settings will be passed automatically to the underlying "
"driver configuration mechanism.  Settings defined in `application."
"properties` with the `quarkus.cassandra` prefix will have priority over "
"settings defined in `application.conf` or `application.json`."
msgstr ""
"`application.conf` または `application.json` ファイルを使用して、他の Java "
"ドライバの設定を設定することができます。これらのファイルは、アプリケーションのクラスパスに配置する必要があります。すべての設定は、基礎となるドライバ設定メカニズムに自動的に渡されます。 "
"`application.properties` で `quarkus.cassandra` のプレフィックスを付けて定義された設定は、 "
"`application.conf` または `application.json` で定義された設定よりも優先されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:339
#, fuzzy
msgid ""
"To see the full list of settings, please refer to the link:https://docs."
"datastax.com/en/developer/java-driver/latest/manual/core/configuration/"
"reference/[driver settings reference]."
msgstr ""
"設定の全リストを見るには、 link:https://docs.datastax.com/en/developer/java-driver/latest/"
"manual/core/configuration/reference/[ドライバの設定リファレンスを]参照してください。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:340
#, no-wrap, fuzzy
msgid "Running a Cassandra Database"
msgstr "Cassandraデータベースの実行"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:344
#, fuzzy
msgid ""
"By default, `CassandraClient` is configured to access a local Cassandra "
"database on port 9042 (the default Cassandra port)."
msgstr ""
"デフォルトでは、 `CassandraClient` は、ポート 9042（デフォルトの Cassandra ポート）でローカル Cassandra "
"データベースにアクセスするように構成されています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:347
#, fuzzy
msgid ""
"Make sure that the setting `quarkus.cassandra.local-datacenter` matches the "
"datacenter of your Cassandra cluster."
msgstr ""
"設定 `quarkus.cassandra.local-datacenter` "
"が、Cassandraクラスタのデータセンターと一致していることを確認してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:350
#, fuzzy
msgid ""
"If you don't know the name of your local datacenter, this value can be found "
"by running the following CQL query: `SELECT data_center FROM system.local`."
msgstr ""
"ローカルのデータセンターの名前がわからない場合は、以下の CQL クエリを実行することでこの値を見つけることができます ： `SELECT "
"data_center FROM system.local`."

#. type: Plain text
#: upstream/_guides/cassandra.adoc:353
#, fuzzy
msgid ""
"If you want to use Docker to run a Cassandra database, you can use the "
"following command to launch one:"
msgstr "Dockerを使用してCassandraデータベースを起動したい場合は、以下のコマンドを使用して起動することができます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:366
#, no-wrap
msgid ""
"docker run \\\n"
"   --name local-cassandra-instance \\\n"
"   -p 7000:7000 \\\n"
"   -p 7001:7001 \\\n"
"   -p 7199:7199 \\\n"
"   -p 9042:9042 \\\n"
"   -p 9160:9160 \\\n"
"   -p 9404:9404 \\\n"
"   -d \\\n"
"   launcher.gcr.io/google/cassandra3\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:370
#, fuzzy
msgid ""
"Note that only the 9042 port is required. All others all optional but "
"provide enhanced features like JMX monitoring of the Cassandra instance."
msgstr ""
"9042ポートのみが必要であることに注意してください。他のすべてはオプションですが、CassandraインスタンスのJMX監視などの拡張機能を提供します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:373
#, fuzzy
msgid ""
"Next you need to create the keyspace and table that will be used by your "
"application. If you are using Docker, run the following commands:"
msgstr ""
"次に、アプリケーションで使用するキースペースとテーブルを作成する必要があります。Dockerを使用している場合は、以下のコマンドを実行します。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:378
#, no-wrap
msgid ""
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE KEYSPACE IF NOT "
"EXISTS k1 WITH replication = {'class':'SimpleStrategy', 'replication_factor':"
"1}\"\n"
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE TABLE IF NOT "
"EXISTS k1.fruit(store_id text, name text, description text, PRIMARY "
"KEY((store_id), name))\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:381
#, fuzzy
msgid ""
"If you're running Cassandra locally you can execute the cqlsh commands "
"directly:"
msgstr "ローカルでCassandraを実行している場合は、cqlshコマンドを直接実行できます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:386
#, no-wrap
msgid ""
"cqlsh -e \"CREATE KEYSPACE IF NOT EXISTS k1 WITH replication = {'class':"
"'SimpleStrategy', 'replication_factor':1}\n"
"cqlsh -e \"CREATE TABLE IF NOT EXISTS k1.fruit(store_id text, name text, "
"description text, PRIMARY KEY((store_id), name))\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:241
#, no-wrap, fuzzy
msgid "Creating a frontend"
msgstr "フロントエンドの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:391
#, fuzzy
msgid "Now let's add a simple web page to interact with our `FruitResource`."
msgstr "それでは、 `FruitResource` と対話するためのシンプルなウェブページを追加してみましょう。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:395
#, fuzzy
msgid ""
"Quarkus automatically serves static resources located under the `META-INF/"
"resources` directory.  In the `src/main/resources/META-INF/resources` "
"directory, add a `fruits.html` file with the content from this link:https://"
"github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/"
"resources/META-INF/resources/fruits.html[fruits.html] file in it."
msgstr ""
"Quarkusは、 `META-INF/resources` ディレクトリの下にある静的リソースを自動的に提供します。 `src/main/"
"resources/META-INF/resources` ディレクトリに、この link:https://github.com/datastax/"
"cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/"
"resources/fruits.html[fruits.html]ファイルの内容を含む `fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:248
#, fuzzy
msgid "You can now interact with your REST service:"
msgstr "これで、REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:399 upstream/_guides/cassandra.adoc:542
#, fuzzy
msgid "start Quarkus with `mvn clean quarkus:dev`"
msgstr "クォークスを起動する `mvn clean quarkus:dev`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:251
#, fuzzy
msgid "open a browser to `http://localhost:8080/fruits.html`"
msgstr ""
"ブラウザを開く `&lt;a href=\"http://localhost:8080/fruits.html\" class="
"\"bare\"&gt;http://localhost:8080/fruits.html&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:252
#, fuzzy
msgid "add new fruits to the list via the form"
msgstr "フォームを使って新しいフルーツをリストに追加します"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:403
#, no-wrap, fuzzy
msgid "Reactive Cassandra Client"
msgstr "リアクティブCassandraクライアント"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:407
#, fuzzy
msgid ""
"When using `QuarkusCqlSession` you have access to reactive variant of "
"methods that integrate with Quarkus and Mutiny."
msgstr ""
"`QuarkusCqlSession` を使用すると、Quarkus や Mutiny と統合された反応性のあるバリアントメソッドにアクセスできます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:410
#, fuzzy
msgid ""
"If you're not familiar with Mutiny, read the link:https://quarkus.io/guides/"
"getting-started-reactive[Getting Started with Reactive guide] first."
msgstr ""
"Mutinyに慣れていない場合は、まずGet link:https://quarkus.io/guides/getting-started-"
"reactive[ting Started with Reactiveガイド]を読んでください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:412
#, fuzzy
msgid ""
"Let's rewrite the previous example using reactive programming with Mutiny."
msgstr "先ほどの例をMutinyを使ったリアクティブプログラミングで書き換えてみましょう。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:414
#, fuzzy
msgid "Firstly, we need to implement the `@Dao` that works in a reactive way:"
msgstr "まずは、反応的に動作する `@Dao` を実装する必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:419
#, no-wrap
msgid "@Dao\n"
"public interface FruitDaoReactive {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:422
#, no-wrap
msgid "  @Update\n"
"  Uni<Void> updateAsync(Fruit fruitDao);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:426
#, no-wrap
msgid ""
"  @Select\n"
"  MutinyMappedReactiveResultSet<Fruit> findByIdAsync(String id);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:433
#, fuzzy
msgid ""
"Please note the usage of `MutinyMappedReactiveResultSet` - it is a "
"specialized `Mutiny` type converted from the original `Publisher` returned "
"by the driver, which also exposes a few extra methods, e.g. to obtain the "
"query execution info. If you don't need anything in that interface, you can "
"also simply declare your method to return `Multi`: `Multi<Fruit> "
"findByIdAsync(String id)`,"
msgstr ""
"`MutinyMappedReactiveResultSet` の使用法に注意してください - これは、ドライバが返すオリジナルの "
"`Publisher` から変換された `Mutiny` "
"型で、クエリの実行情報を取得するなど、いくつかの余分なメソッドを公開しています。このインターフェイスで何も必要としない場合は、単にメソッドを "
"`Multi` を返すように宣言することもできます : `Multi&amp;lt;Fruit&amp;gt; findByIdAsync(String "
"id)`."

#. type: Plain text
#: upstream/_guides/cassandra.adoc:436
#, fuzzy
msgid ""
"Similarly, the method `updateAsync` returns a `Uni` - it is automatically "
"converted from the original result set returned by the driver."
msgstr "同様に、メソッド `updateAsync` は `Uni` を返します。これは、ドライバが返す元の結果セットから自動的に変換されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:444
#, fuzzy
msgid ""
"The Cassandra driver uses the Reactive Streams `Publisher` API for reactive "
"calls. The Quarkus framework however uses Mutiny. Because of that, the "
"`CqlQuarkusSession` interface transparently converts the `Publisher` "
"instances returned by the driver into the reactive type `Multi`.  "
"`CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` "
"– in this case, the publisher is expected to emit at most one row, then "
"complete. This is suitable for write queries (they return no rows), or for "
"read queries guaranteed to return one row at most (count queries, for "
"example)."
msgstr ""
"Cassandraドライバは、リアクティブな呼び出しにReactive Streams `Publisher` "
"APIを使用します。しかし、QuarkusフレームワークはMutinyを使用しています。そのため、 `CqlQuarkusSession` "
"インターフェイスは、ドライバが返す `Publisher` インスタンスを透過的にリアクティブ型 `Multi` に変換します。 "
"`CqlQuarkusSession` は、 `Publisher` を `Uni` に変換することもできます - この場合、パブリッシャーは最大でも "
"1 行を返し、その後完了すると予想されます。これは、書き込みクエリ（行を返さない）や、最大でも 1 "
"行を返すことが保証されている読み込みクエリ（カウントクエリなど）に適しています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:446
#, fuzzy
msgid ""
"Next, we need to adapt the `FruitMapper` to construct a `FruitDaoReactive` "
"instance:"
msgstr "次に、 `FruitMapper` を適応させて `FruitDaoReactive` インスタンスを構築する必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:452
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  // the existing method omitted\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:456
#, no-wrap
msgid "  @DaoFactory\n"
"  FruitDaoReactive fruitDaoReactive();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:460
#, fuzzy
msgid ""
"Now, we can create a `FruitReactiveService` that leverages the reactive "
"`@Dao`:"
msgstr "これで、反応性のある `@Dao` を活用した `FruitReactiveService` を作成することができます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:465
#, no-wrap
msgid "@ApplicationScoped\n"
"public class FruitReactiveService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:467
#, no-wrap
msgid "  private final FruitDaoReactive fruitDao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:472
#, no-wrap
msgid ""
"  @Inject\n"
"  public FruitReactiveService(FruitDaoReactive fruitDao) {\n"
"    this.fruitDao = fruitDao;\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:476
#, no-wrap
msgid ""
"  public Uni<Void> add(Fruit fruit) {\n"
"    return fruitDao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:481
#, no-wrap
msgid ""
"  public Multi<Fruit> get(String id) {\n"
"    return fruitDao.findById(id);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:485
#, fuzzy
msgid ""
"The `get()` method above returns `Multi`, and the `add()` method returns "
"`Uni`; these types are compatible with the Quarkus reactive REST API."
msgstr ""
"上記の `get()` メソッドは `Multi` を返し、 `add()` メソッドは `Uni` を返します。これらのタイプは、Quarkus "
"のリアクティブ REST API と互換性があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:488
#, fuzzy
msgid ""
"To integrate the reactive logic with REST API, you need to have a dependency "
"to `quarkus-resteasy-mutiny`:"
msgstr "リアクティブロジックをREST APIと統合するには、 `quarkus-resteasy-mutiny`."

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:424
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-mutiny</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:498
#, fuzzy
msgid ""
"It provides an integration layer between `Multi`, `Uni` and the REST API."
msgstr "`Multi`, `Uni` と REST API との間の統合レイヤを提供します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:500
#, fuzzy
msgid "Finally, we can create a `FruitReactiveResource`:"
msgstr "最後に、 `FruitReactiveResource`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:509
#, no-wrap
msgid ""
"@Path(\"/reactive-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitReactiveResource {\n"
"  private static final String STORE_NAME = \"acme\";\n"
"  @Inject FruitReactiveService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:516
#, no-wrap
msgid ""
"  @GET\n"
"  public Multi<FruitDto> getAll() {\n"
"    return service\n"
"        .get(STORE_NAME)\n"
"        .map(fruit -> new FruitDto(fruit.getName(), fruit."
"getDescription()));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:522
#, no-wrap
msgid ""
"  @POST\n"
"  public Multi<FruitDto> add(FruitDto fruitDto) {\n"
"    Fruit fruit = covertFromDto(fruitDto);\n"
"    return service.add(fruit).then(ignored -> getAll());\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:530
#, fuzzy
msgid ""
"All methods exposed via REST interface are returning reactive types from the "
"Mutiny API."
msgstr "RESTインターフェースを介して公開されているすべてのメソッドは、Mutiny APIから反応型を返しています。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:531
#, no-wrap, fuzzy
msgid "Creating a reactive frontend"
msgstr "リアクティブなフロントエンドの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:538
#, fuzzy
msgid ""
"Now let's add a simple web page to interact with our `FruitReactiveResource`."
"  In the `src/main/resources/META-INF/resources` directory, add a `reactive-"
"fruits.html` file with the content from this link:https://github.com/"
"datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-"
"INF/resources/reactive-fruits.html[reactive-fruits.html] file in it."
msgstr ""
"ここで、 `FruitReactiveResource` と対話するための簡単なウェブページを追加してみましょう。 `src/main/"
"resources/META-INF/resources` ディレクトリに、この link:https://github.com/datastax/"
"cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/"
"resources/reactive-fruits.html[reactive-fruits.html]ファイルの内容を含む `reactive-"
"fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:540
#, fuzzy
msgid "You can now interact with your reactive REST service:"
msgstr "これで、リアクティブな REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:543
#, fuzzy
msgid "open a browser to `http://localhost:8080/reactive-fruits.html`"
msgstr ""
"ブラウザを開く `&lt;a href=\"http://localhost:8080/reactive-fruits.html\" class="
"\"bare\"&gt;http://localhost:8080/reactive-fruits.html&lt;/a&gt;`"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:546
#, no-wrap, fuzzy
msgid "Connection Health Check"
msgstr "接続の健康チェック"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:550
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-health` extension, `cassandra-"
"quarkus` will automatically add a readiness health check to validate the "
"connection to the cluster."
msgstr ""
"`quarkus-smallrye-health` 拡張モジュールを使用している場合、 `cassandra-quarkus` "
"はクラスタへの接続を検証するための準備状態の健康チェックを自動的に追加します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:553
#, fuzzy
msgid ""
"So when you access the `/health/ready` endpoint of your application you will "
"have information about the connection validation status."
msgstr "そのため、アプリケーションの `/health/ready` エンドポイントにアクセスすると、接続の検証状況に関する情報が表示されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:556
#, fuzzy
msgid ""
"This behavior can be disabled by setting the `quarkus.cassandra.health."
"enabled` property to `false` in your `application.properties`."
msgstr ""
"この動作は、 `application.properties` の `quarkus.cassandra.health.enabled` プロパティを "
"`false` に設定することで無効にできます。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:557
#, no-wrap, fuzzy
msgid "Metrics"
msgstr "メトリクス"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:561
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-metrics` extension, `cassandra-"
"quarkus` can provide metrics about QuarkusCqlSession and Cassandra nodes."
msgstr ""
"`quarkus-smallrye-metrics` 拡張機能を使用している場合、 `cassandra-quarkus` "
"は、QuarkusCqlSession と Cassandra ノードに関するメトリクスを提供できます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:564
#, fuzzy
msgid ""
"This behavior must first be enabled by setting the `quarkus.cassandra."
"metrics.enabled` property to `true` in your `application.properties`."
msgstr ""
"この動作を有効にするには、まず `application.properties`.NET Framework の `quarkus.cassandra."
"metrics.enabled` プロパティを `true` に設定する必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:566
#, fuzzy
msgid ""
"The next step that you need to do is set explicitly which metrics should be "
"enabled."
msgstr "次のステップでは、どのメトリクスを有効にするかを明示的に設定します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:571
#, fuzzy
msgid ""
"The `quarkus.cassandra.metrics.session-enabled` and `quarkus.cassandra."
"metrics.node-enabled` properties should be used for enabling metrics; the "
"former should contain a list of session-level metrics to enable, while the "
"latter should contain a list of node-level metrics to enable. Both "
"properties accept a comma-separated list of valid metric names."
msgstr ""
"`quarkus.cassandra.metrics.session-enabled` `quarkus.cassandra.metrics.node-"
"enabled` "
"前者は、有効にするセッションレベルのメトリクスのリストを含む必要があり、後者は有効にするノードレベルのメトリクスのリストを含む必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:574
#, fuzzy
msgid ""
"For example, to enable `session.connected-nodes`, `session.bytes-sent`, and "
"`node.pool.open-connections` you should add the following settings to your "
"`application.properties`:"
msgstr ""
"例えば、 `session.connected-nodes`, `session.bytes-sent`, `node.pool.open-"
"connections` を有効にするには、以下の設定を `application.properties`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:580
#, no-wrap
msgid ""
"quarkus.cassandra.metrics.enabled=true\n"
"quarkus.cassandra.metrics.session-enabled=connected-nodes,bytes-sent\n"
"quarkus.cassandra.metrics.node-enabled=pool.open-connections\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:585
#, fuzzy
msgid ""
"For the full list of available metrics, please refer to the link:https://"
"docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/"
"reference/[driver settings reference] and the `advanced.metrics` section."
msgstr ""
"利用可能なメトリクスの完全なリストについては、 link:https://docs.datastax.com/en/developer/java-"
"driver/latest/manual/core/configuration/reference/[ドライバの設定リファレンス]と `advanced."
"metrics` を参照してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:588
#, fuzzy
msgid ""
"When metrics are properly enabled and when you access the `/metrics` "
"endpoint of your application, you will see metric reports for all enabled "
"metrics."
msgstr ""
"メトリクスが適切に有効化され、アプリケーションの `/metrics` エンドポイントにアクセスすると、有効化されたすべてのメトリクスのメトリクス "
"レポートが表示されます。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:253
#, no-wrap, fuzzy
msgid "Building a native executable"
msgstr "ネイティブ実行ファイルの構築"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:592
#, fuzzy
msgid "You can use the Cassandra client in a native executable."
msgstr "ネイティブ実行ファイルでCassandraクライアントを使用することができます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:594
#, fuzzy
msgid ""
"You can build a native executable with the `mvn clean package -Dnative` "
"command."
msgstr "`mvn clean package -Dnative` コマンドでネイティブ実行ファイルをビルドすることができます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:596
#, fuzzy
msgid ""
"Running it is as simple as executing `./target/quickstart-1.0.0-SNAPSHOT-"
"runner`."
msgstr "実行は `./target/quickstart-1.0.0-SNAPSHOT-runner` を実行するだけで簡単です。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:260
#, fuzzy
msgid ""
"You can then point your browser to `http://localhost:8080/fruits.html` and "
"use your application."
msgstr ""
"その後、ブラウザを `&lt;a href=\"http://localhost:8080/fruits.html\" class="
"\"bare\"&gt;http://localhost:8080/fruits.html&lt;/a&gt;`とアプリケーションを使用します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:603
#, fuzzy
msgid ""
"Accessing a Cassandra database from a client application is easy with "
"Quarkus and the Cassandra extension, which provides configuration and native "
"support for the DataStax Java driver for Apache Cassandra."
msgstr ""
"クライアント・アプリケーションからのCassandraデータベースへのアクセスは、QuarkusとCassandra拡張機能で簡単に行えます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/software-transactional-memory.adoc:6
#, no-wrap, fuzzy
msgid "Using Software Transactional Memory in Quarkus"
msgstr "Quarkusでのソフトウェアトランザクションメモリの使用"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:20
#, fuzzy
msgid ""
"Software Transactional Memory (STM) has been around in research environments "
"since the late 1990's and has relatively recently started to appear in "
"products and various programming languages. We won't go into all of the "
"details behind STM but the interested reader could look at https://groups."
"csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].  "
"However, suffice it to say that STM offers an approach to developing "
"transactional applications in a highly concurrent environment with some of "
"the same characteristics of ACID transactions, which you've probably already "
"used through JTA. Importantly though, the Durability property is relaxed "
"(removed) within STM implementations, or at least made optional. This is not "
"the situation with JTA, where state changes are made durable to a relational "
"database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc."
"pdf[the X/Open XA standard]."
msgstr ""
"ソフトウェア・トランザクション・メモリ(STM)は、1990 "
"年代後半から研究環境に存在し、比較的最近になって製品や様々なプログラミング言語に登場し始めました。STM "
"の背後にあるすべての詳細については触れませんが，興味のある方は link:https://groups.csail.mit.edu/tds/papers/"
"Shavit/ShavitTouitou-podc95.pdf[この論文を]参照してください．しかし、STM は、JTA を通じて既に使用されている "
"ACID トランザクションと同じ特性を持つ、高度な同時実行環境でトランザクショ "
"ン・アプリケーションを開発するためのアプローチを提供していることは言うまでもありません。しかし、重要なことは、STM の実装では Durability "
"プロパティが緩和（削除）されているか、少なくともオプションになっていることです。これは、 link:https://pubs.opengroup.org/"
"onlinepubs/009680699/toc.pdf[X/Open XA "
"標準]をサポートするリレーショナル・データベースに対して状態の変更を耐久性のあるものにするという JTA の状況とは異なります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:24
#, fuzzy
msgid ""
"Note, the STM implementation provided by Quarkus is based on the https://"
"narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. "
"This document isn't meant to be a replacement for that project's "
"documentation so you may want to look at that for more detail. However, we "
"will try to focus more on how you can combine some of the key capabilities "
"into Quarkus when developing Kubernetes native applications and "
"microservices."
msgstr ""
"Quarkusが提供するSTMの実装は、 link:https://narayana.io/docs/project/index."
"html#d0e16066[Narayana "
"STMの]実装に基づいています。このドキュメントは、そのプロジェクトのドキュメントに代わるものではありませんので、詳細についてはそちらを参照してください。しかし、Kubernetesネイティブアプリケーションやマイクロサービスを開発する際に、主要な機能のいくつかをQuarkusにどのように組み合わせることができるかについて、より焦点を当ててみたいと思います。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:25
#, no-wrap, fuzzy
msgid "Why use STM with Quarkus?"
msgstr "なぜQuarkusでSTMを使うのか？"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:31
#, fuzzy
msgid ""
"Now you may still be asking yourself \"Why STM instead of JTA?\" or \"What "
"are the benefits to STM that I don't get from JTA?\" Let's try to answer "
"those or similar questions, with a particular focus on why we think they're "
"great for Quarkus, microservices and Kubernetes native applications. So in "
"no specific order ..."
msgstr ""
"今、あなたはまだ\"なぜJTAではなくSTMなのか？\"や\"JTAでは得られないSTMのメリットは何か？\"と自問自答しているかもしれません。ここでは、Quarkus、マイクロサービス、Kubernetesネイティブアプリケーションに最適だと思う理由を中心に、これらの質問や似たような質問に答えてみましょう。ということで、順不同で "
"..."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:40
#, fuzzy
msgid ""
"The goal of STM is to simplify object reads and writes from multiple threads/"
"protect state from concurrent updates. The Quarkus STM implementation will "
"safely manage any conflicts between these threads using whatever isolation "
"model has been chosen to protect that specific state instance (object in the "
"case of Quarkus). In Quarkus STM, there are two isolation implementations, "
"pessimistic (the default), which would cause conflicting threads to be "
"blocked until the original has completed its updates (committed or aborted "
"the transaction); then there's the optimistic approach which allows all of "
"the threads to proceed and checks for conflicts at commit time, where one or "
"more of the threads may be forced to abort if there have been conflicting "
"updates."
msgstr ""
"STMの目的は、複数のスレッドからのオブジェクトの読み書きを簡素化し、同時更新からステートを保護することです。QuarkusのSTM実装では、特定のステートインスタンス（Quarkusの場合はオブジェクト）を保護するために選択された分離モデルを使用して、これらのスレッド間の競合を安全に管理します。Quarkus "
"STMでは、2つの分離実装があります。悲観的なアプローチ（デフォルト）では、元のスレッドが更新を完了する（コミットまたはトランザクションを中止する）まで競合するスレッドがブロックされます。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:54
#, fuzzy
msgid ""
"STM objects have state but it doesn't need to be persistent (durable). In "
"fact the default behaviour is for objects managed within transactional "
"memory to be volatile, such that if the service or microservice within which "
"they are being used crashes or is spawned elsewhere, e.g., by a scheduler, "
"all state in memory is lost and the objects start from scratch. But surely "
"you get this and more with JTA (and a suitable transactional datastore) and "
"don't need to worry about restarting your application? Not quite. There's a "
"trade-off here: we're doing away with persistent state and the overhead of "
"reading from and then writing (and sync-ing) to the datastore during each "
"transaction. This makes updates to (volatile) state very fast but you still "
"get the benefits of atomic updates across multiple STM objects (e.g., "
"objects your team wrote then calling objects you inherited from another team "
"and requiring them to make all-or-nothing updates), as well as consistency "
"and isolation in the presence of concurrent threads/users (common in "
"distributed microservices architectures).  Furthermore, not all stateful "
"applications need to be durable - even when JTA transactions are used, it "
"tends to be the exception and not the rule. And as you'll see later, because "
"applications can optionally start and control transactions, it's possible to "
"build microservices which can undo state changes and try alternative paths."
msgstr ""
"STM "
"オブジェクトは状態を持っていますが、永続的（耐久性のある）である必要はありません。実際、デフォルトでは、トランザクションメモリ内で管理されているオブジェクトは揮発性であるため、使用されているサービスやマイクロサービスがクラッシュしたり、スケジューラなどで他の場所で生成されたりすると、メモリ内のすべての状態が失われ、オブジェクトはゼロから開始されます。しかし、確かに "
"JTA (と適切なトランザクションデータストア) "
"を使えば、これ以上のことが可能で、アプリケーションの再起動を心配する必要はないのでしょうか？そうではありません。ここではトレードオフがあります: "
"我々は永続的な状態と、各トランザクション中にデータストアから読み込んで書き込み(および同期)するオーバーヘッドを排除しています。これにより、（揮発性の）ステートへの更新は非常に高速になりますが、複数の "
"STM オブジェクト（例えば、自分のチームが書いたオブジェクトが、他のチームから継承したオブジェクトを呼び出して、オールオア "
"ナッシング更新を行う必要がある場合など）にまたがるアトミックな更新の利点を得ることができます。さらに、すべてのステートフルアプリケーションが耐久性を必要とするわけではありません "
"- JTA "
"トランザクションが使用される場合でも、それは例外であってルールではない傾向があります。後述するように、アプリケーションは任意でトランザクションを開始したり制御したりできるので、状態変化を元に戻したり、代替パスを試すことができるマイクロサービスを構築することが可能です。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:61
#, fuzzy
msgid ""
"Another benefit of STM is composability and modularity. You can write "
"concurrent Quarkus objects/services that can be easily composed with any "
"other services built using STM, without exposing the details of how the "
"objects/services are implemented. As we discussed earlier, this ability to "
"compose objects you wrote with those other teams may have written weeks, "
"months or years earlier, and have A, C and I properties can be hugely "
"beneficial. Furthermore, some STM implementations, including the one Quarkus "
"uses, support nested transactions and these allow changes made within the "
"context of a nested (sub) transaction to later be rolled back by the parent "
"transaction."
msgstr ""
"STMのもう1つの利点は、構成可能性とモジュール性です。オブジェクト/"
"サービスがどのように実装されているかの詳細を公開することなく、STMを使用して構築された他の任意のサービスと簡単に構成することができるQuarkusオブジェクト/"
"サービスを並行して書くことができます。先に説明したように、他のチームと一緒に書いたオブジェクトを、数週間、数ヶ月、数年前に書いたかもしれない、A、C、Iのプロパティを持つオブジェクトをコンパイルできるこの機能は、非常に有益なものになります。さらに、Quarkusが使用しているものを含むいくつかのSTM実装では、入れ子になったトランザクションをサポートしており、入れ子になった（サブ）トランザクションのコンテキスト内で行われた変更を、後で親トランザクションによってロールバックすることができます。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:66
#, fuzzy
msgid ""
"Although the default for STM object state is volatile, it is possible to "
"configure the STM implementation such that an object's state is durable. "
"Although it's possible to configure Narayana such that different backend "
"datastores can be used, including relational databases, the default is the "
"local operating system file system, which means you don't need to configure "
"anything else with Quarkus such as a database."
msgstr ""
"STMオブジェクトの状態のデフォルトは揮発性ですが、オブジェクトの状態が耐久性を持つようにSTMの実装を構成することができます。リレーショナルデータベースなど、さまざまなバックエンドのデータストアを使用できるようにNarayanaを設定することは可能ですが、デフォルトはローカルのオペレーティングシステムのファイルシステムであり、データベースのようなQuarkusで他の何かを設定する必要はありません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:70
#, fuzzy
msgid ""
"Many STM implementations allow \"plain old language objects\" to be made STM-"
"aware with little or no changes to the application code. You can build, test "
"and deploy applications without wanting them to be STM-aware and then later "
"add those capabilities if they become necessary and without much development "
"overhead at all."
msgstr ""
"多くの STM 実装では、アプリケーションコードをほとんど変更することなく、「古い言語オブジェクト」を STM "
"対応にすることができます。アプリケーションを STM "
"対応にすることを望まずに、アプリケーションを構築、テスト、デプロイし、必要に応じてそれらの機能を後から追加することができ、開発のオーバーヘッドをほとんど必要としません。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:71
#, no-wrap, fuzzy
msgid "Building STM applications"
msgstr "STMアプリケーションの構築"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:78
#, fuzzy
msgid ""
"There is also a fully worked example in the quickstarts which you may access "
"by cloning the Git repository: `git clone {quickstarts-clone-url}`, or by "
"downloading an {quickstarts-archive-url}[archive].  Look for the `software-"
"transactional-memory-quickstart` example. This will help to understand how "
"you can build STM-aware applications with Quarkus. However, before we do so "
"there are a few basic concepts which we need to cover."
msgstr ""
"Quickstarts には完全に動作する例もあり、Git リポジトリを複製してアクセスすることができます: `git clone "
"{quickstarts-clone-url}` あるいは {quickstarts-archive-url}[archive] "
"をダウンロードしてください。 `software-transactional-memory-quickstart` "
"の例を見てください。これで、Quarkusを使ってSTM対応アプリケーションを構築する方法を理解することができます。しかし、その前に、いくつかの基本的な概念を知っておく必要があります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:84
#, fuzzy
msgid ""
"Note, as you will see, STM in Quarkus relies on a number of annotations to "
"define behaviours. The lack of these annotations causes sensible defaults to "
"be assumed but it is important for the developer to understand what these "
"may be. Please refer to the https://narayana.io/docs/project/index."
"html#d0e16066[Narayana STM manual] and the https://narayana.io//docs/project/"
"index.html#d0e16133[STM annotations guide] for more details on all of the "
"annotations Narayana STM provides."
msgstr ""
"ご覧のように、QuarkusのSTMは、動作を定義するために多くのアノテーションに依存しています。これらのアノテーションがないために、適切なデフォルトが仮定されてしまいますが、開発者はこれらのアノテーションが何であるかを理解することが重要です。Narayana "
"STMが提供するすべてのアノテーションの詳細については、Naray link:https://narayana.io/docs/project/"
"index.html#d0e16066[ana STMマニュアル]と link:https://narayana.io//docs/project/"
"index.html#d0e16133[STMアノテーションガイド]を参照してください。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:87
#, no-wrap, fuzzy
msgid "Setting it up"
msgstr "設定する"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:90
#, fuzzy
msgid ""
"To use the extension include it as a dependency in your application pom:"
msgstr "この拡張機能を使用するには、アプリケーションの依存関係として pom にインクルードしてください。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:101
#, no-wrap
msgid ""
"<dependencies>\n"
"    <!-- STM extension -->\n"
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-narayana-stm</artifactId>\n"
"      <version>${quarkus.version}</version>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:103
#, no-wrap, fuzzy
msgid "Defining STM-aware classes"
msgstr "STM対応クラスの定義"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:111
#, fuzzy
msgid ""
"In order for the STM subsystem to have knowledge about which classes are to "
"be managed within the context of transactional memory it is necessary to "
"provide a minimal level of instrumentation. This occurs by categorising STM-"
"aware and STM-unaware classes through an interface boundary; specifically "
"all STM-aware objects must be instances of classes which inherit from "
"interfaces that themselves have been annotated to identify them as STM-aware."
" Any other objects (and their classes) which do not follow this rule will "
"not be managed by the STM subsystem and hence any of their state changes "
"will not be rolled back, for example."
msgstr ""
"STM "
"サブシステムが，トランザクションメモリのコンテキスト内でどのクラスが管理されるべきかを知るためには，最低限の手段を提供する必要があります．具体的には，すべての "
"STM 対応オブジェクトは，STM "
"対応であることを識別するために注釈が付けられたインタフェースを継承するクラスのインスタンスでなければなりません．このルールに従わない他のオブジェクト（およびそのクラス）は、STM "
"サブシステムによって管理されないため、例えば、それらの状態の変更はロールバックされません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:114
#, fuzzy
msgid ""
"The specific annotation that STM-aware application interfaces must use is "
"`org.jboss.stm.annotations.Transactional`.  For example:"
msgstr ""
"STM対応アプリケーションインタフェースが使用しなければならない特定のアノテーションは、 `org.jboss.stm.annotations."
"Transactional`.例えば、以下のようなものです。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:122
#, no-wrap
msgid ""
"@Transactional\n"
"public interface FlightService {\n"
"    int getNumberOfBookings();\n"
"    void makeBooking(String details);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:129
#, fuzzy
msgid ""
"Classes which implement this interface are able to use additional "
"annotations from Narayana to tell the STM subsystem about things such as "
"whether a method will modify the state of the object, or what state "
"variables within the class should be managed transactionally, e.g., some "
"instance variables may not need to be rolled back if a transaction aborts. "
"As mentioned earlier, if those annotations are not present then defaults are "
"chosen to guarantee safety, such as assuming all methods will modify state."
msgstr ""
"このインタフェースを実装したクラスは，Narayana "
"からの追加のアノテーションを使用して，メソッドがオブジェクトの状態を変更するかどうかや，クラス内のどの状態変数をトランザクション的に管理すべきか，例えば，トランザクションが中断した場合にロールバックする必要のないインスタンス変数があるなどのことを "
"STM "
"サブシステムに伝えることができます．前述のように、これらのアノテーションが存在しない場合は、すべてのメソッドが状態を変更すると仮定するなど、安全性を保証するためにデフォルトが選択されます。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:136
#, no-wrap
msgid ""
"public class FlightServiceImpl implements FlightService {\n"
"    @ReadLock\n"
"    public int getNumberOfBookings() { ... }\n"
"    public void makeBooking(String details) {...}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:140
#, no-wrap
msgid "    @NotState\n"
"    private int timesCalled;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:146
#, fuzzy
msgid ""
"For example, by using the `@ReadLock` annotation on the "
"`getNumberOfBookings` method, we are able to tell the STM subsystem that no "
"state modifications will occur in this object when it is used in the "
"transactional memory. Also, the `@NotState` annotation tells the system to "
"ignore `timesCalled` when transactions commit or abort, so this value only "
"changes due to application code."
msgstr ""
"例えば、 `getNumberOfBookings` メソッドに `@ReadLock` "
"アノテーションを使用することで、このオブジェクトがトランザクション・メモリで使用されているときに、状態の変更がこのオブジェクトでは発生しないことを "
"STM サブシステムに伝えることができます。また、 `@NotState` アノテーションは、トランザクションがコミットまたは中止されたときに "
"`timesCalled` を無視するようにシステムに指示するので、この値はアプリケーション・コードによってのみ変化します。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:149
#, fuzzy
msgid ""
"Please refer to the Narayana guide for details of how to exert finer grained "
"control over the transactional behaviour of objects that implement "
"interfaces marked with the `@Transactional` annotation."
msgstr ""
"`@Transactional` "
"アノテーションでマークされたインターフェイスを実装したオブジェクトのトランザクション動作をより細かく制御する方法の詳細については、ナラヤナガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:150
#, no-wrap, fuzzy
msgid "Creating STM objects"
msgstr "STMオブジェクトの作成"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:156
#, fuzzy
msgid ""
"The STM subsystem needs to be told about which objects it should be managing."
" The Quarkus (aka Narayana) STM implementation does this by providing "
"containers of transactional memory within which these object instances "
"reside. Until an object is placed within one of these STM containers it "
"cannot be managed within transactions and any state changes will not possess "
"the A, C, I (or even D) properties."
msgstr ""
"STMサブシステムは、どのオブジェクトを管理すべきかを伝える必要があります。Quarkus（別名ナラヤナ）のSTM実装は、これらのオブジェクトインスタンスが存在するトランザクションメモリのコンテナを提供することでこれを行います。オブジェクトがこれらのSTMコンテナ内に置かれるまでは、トランザクション内で管理することはできず、状態の変更はA、C、I（あるいはD）のプロパティを持たないことになります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:160
#, fuzzy
msgid ""
"Note, the term \"container\" was defined within the STM implementation years "
"before Linux containers came along. It may be confusing to use especially in "
"a Kubernetes native environment such as Quarkus, but hopefully the reader "
"can do the mental mapping."
msgstr ""
"注：\"コンテナ\"という用語は、Linuxコンテナが登場する何年も前にSTMの実装で定義されていました。特にQuarkusのようなKubernetesネイティブ環境で使用すると混乱するかもしれませんが、うまくいけば読者がメンタルマッピングをしてくれることを期待しています。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:166
#, fuzzy
msgid ""
"The default STM container (`org.jboss.stm.Container`) provides support for "
"volatile objects that can only be shared between threads in the same "
"microservice/JVM instance. When a STM-aware object is placed into the "
"container it returns a handle through which that object should then be used "
"in the future. It is important to use this handle as continuing to access "
"the object through the original reference will not allow the STM subsystem "
"to track access and manage state and concurrency control."
msgstr ""
"デフォルトの STM コンテナ ( `org.jboss.stm.Container`) は、同じマイクロサービス/JVM "
"インスタンス内のスレッド間でのみ共有可能な揮発性オブジェクトをサポートしています。STM "
"を意識したオブジェクトがコンテナに置かれると、そのオブジェクトが将来的に使用されるべきハンドルを返します。元の参照を介してオブジェクトにアクセスし続けると、STM "
"サブシステムがアクセスを追跡したり、状態や同時実行制御を管理したりすることができなくなるため、このハンドルを使用することが重要です。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:170
#, no-wrap
msgid "    import org.jboss.stm.Container;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:172
#, no-wrap
msgid "    ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:176
#, no-wrap
msgid ""
"    Container<FlightService> container = new Container<>(); <1>\n"
"    FlightServiceImpl instance = new FlightServiceImpl(); <2>\n"
"    FlightService flightServiceProxy = container.create(instance); <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:180
#, fuzzy
msgid ""
"You need to tell each Container about the type of objects for which it will "
"be responsible. In this example it will be instances that implement the "
"FlightService interface."
msgstr ""
"各コンテナに、それが担当するオブジェクトの種類を伝える必要があります。この例では、FlightService "
"インターフェースを実装したインスタンスになります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:182
#, fuzzy
msgid ""
"Then you create an instance that implements `FlightService`. You should not "
"use it directly at this stage because access to it is not being managed by "
"the STM subsystem."
msgstr ""
"次に、 `FlightService` を実装したインスタンスを作成します。この段階では、STM "
"サブシステムによってアクセスが管理されていないため、直接使用してはいけません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:184
#, fuzzy
msgid ""
"To obtain a managed instance, pass the original object to the STM "
"`container` which then returns a reference through which you will be able to "
"perform transactional operations. This reference can be used safely from "
"multiple threads."
msgstr ""
"管理されたインスタンスを取得するには、元のオブジェクトを STM `container` "
"に渡します。この参照は、複数のスレッドから安全に使用することができます。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:185
#, no-wrap, fuzzy
msgid "Defining transaction boundaries"
msgstr "トランザクションの境界を定義する"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:190
#, fuzzy
msgid ""
"Once an object is placed within an STM container the application developer "
"can manage the scope of transactions within which it is used. There are some "
"annotations which can be applied to the STM-aware class to have the "
"container automatically create a transaction whenever a specific method is "
"invoked."
msgstr ""
"一度オブジェクトをSTMコンテナ内に配置すると、アプリケーション開発者はそれが使用されるトランザクションの範囲を管理することができます。特定のメソッドが呼び出されたときにコンテナが自動的にトランザクションを作成するように、STM-"
"aware クラスに適用できるアノテーションがいくつかあります。"

#. type: Title ===
#: upstream/_guides/software-transactional-memory.adoc:191
#, no-wrap, fuzzy
msgid "Declarative approach"
msgstr "宣言的アプローチ"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:200
#, fuzzy
msgid ""
"If the `@NestedTopLevel` or `@Nested` annotation is placed on a method "
"signature then the STM container will start a new transaction when that "
"method is invoked and attempt to commit it when the method returns. If there "
"is a transaction already associated with the calling thread then each of "
"these annotations behaves slightly differently: the former annotation will "
"always create a new top-level transaction within which the method will "
"execute, so the enclosing transaction does not behave as a parent, i.e., the "
"nested top-level transaction will commit or abort independently; the latter "
"annotation will create a transaction with is properly nested within the "
"calling transaction, i.e., that transaction acts as the parent of this newly "
"created transaction."
msgstr ""
"`@NestedTopLevel` または `@Nested` アノテーションがメソッドのシグネチャに配置されている場合、STM "
"コンテナは、そのメソッドが呼び出されたときに新しいトランザク "
"ションを開始し、そのメソッドが戻ってきたときにコミットを試みます。前者のアノテーションは常にメソッドが実行される新しいトップレベルのトランザクションを作成し、その中でメソッドが実行されるため、そのトランザクションは親として動作しません。"

#. type: Title ===
#: upstream/_guides/software-transactional-memory.adoc:201
#, no-wrap, fuzzy
msgid "Programmatic approach"
msgstr "プログラム的アプローチ"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:204
#, fuzzy
msgid ""
"The application can programmatically start a transaction before accessing "
"the methods of STM objects:"
msgstr "アプリケーションは、STMオブジェクトのメソッドにアクセスする前に、プログラム的にトランザクションを開始することができます。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:208
#, no-wrap
msgid "AtomicAction aa = new AtomicAction(); <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:221
#, no-wrap
msgid ""
"aa.begin(); <2>\n"
"{\n"
"    try {\n"
"        flightService.makeBooking(\"BA123 ...\");\n"
"        taxiService.makeBooking(\"East Coast Taxis ...\"); <3>\n"
"        <4>\n"
"        aa.commit();\n"
"        <5>\n"
"    } catch (Exception e) {\n"
"        aa.abort(); <6>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:226
#, fuzzy
msgid ""
"An object for manually controlling transaction boundaries (AtomicAction and "
"many other useful classes are included in the extension).  Refer https://"
"narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction.html[to the "
"javadoc] for more detail."
msgstr ""
"トランザクションの境界を手動で制御するためのオブジェクト (AtomicAction と他の多くの便利なクラスが拡張機能に含まれています)。詳細は "
"link:https://narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction."
"html[javadoc]を参照してください。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:227
#, fuzzy
msgid "Programmatically begin a transaction."
msgstr "プログラムでトランザクションを開始します。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:230
#, fuzzy
msgid ""
"Notice that object updates can be composed which means that updates to "
"multiple objects can be committed together as a single action.  [Note that "
"it is also possible to begin nested transactions so that you can perform "
"speculative work which may then be abandoned without abandoning other work "
"performed by the outer transaction]."
msgstr ""
"オブジェクトの更新は、複数のオブジェクトへの更新を単一のアクションとしてまとめてコミットすることができるという意味で、構成することができることに注意してください。これは、複数のオブジェクトへの更新を一つのアクションにまとめてコミットすることができることを意味します。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:231
#, fuzzy
msgid ""
"Since the transaction has not yet been committed the changes made by the "
"flight and taxi services are not visible outside of the transaction."
msgstr "この取引はまだコミットされていないため、フライトやタクシーサービスによって行われた変更は、取引の外では見ることができません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:234
#, fuzzy
msgid ""
"Since the commit was successful the changes made by the flight and taxi "
"services are now visible to other threads.  Note that other transactions "
"that relied on the old state may or may not now incur conflicts when they "
"commit (the STM library provides a number of features for managing "
"conflicting behaviour and these are covered in the Narayana STM manual)."
msgstr ""
"コミットが成功したので、フライトサービスとタクシーサービスで行われた変更が他のスレッドから見えるようになりました。古い状態に依存していた他のトランザクションがコミットする際に競合が発生する可能性があることに注意してください（STM "
"ライブラリは競合する動作を管理するための多くの機能を提供しており、これらについては Narayana STM マニュアルに記載されています）。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:235
#, fuzzy
msgid ""
"Programmatically decide to abort the transaction which means that the "
"changes made by the flight and taxi services are discarded."
msgstr "プログラム的には、フライトやタクシーサービスによって行われた変更が破棄されることを意味するトランザクションを中止することを決定します。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:236
#, no-wrap, fuzzy
msgid "Distributed transactions"
msgstr "分散型トランザクション"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:241
#, fuzzy
msgid ""
"Sharing a transaction between multiple services is possible but is currently "
"an advanced use case only and the Narayana documentation should be consulted "
"if this behaviour is required. In particular, STM does not yet support the "
"features described in the link:context-propagation[Context Propagation "
"guide]."
msgstr ""
"複数のサービス間でトランザクションを共有することは可能ですが、現在のところ高度なユースケースのみであり、この動作が必要な場合はNarayanaのドキュメントを参照してください。特に、STMはコンテキスト伝搬 "
"link:context-propagation[ガイド]で説明されている機能をまだサポートしていません。"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:2
#, fuzzy
msgid "Java System Properties - `aws.accessKeyId` and `aws.secretAccessKey`"
msgstr "Javaシステムのプロパティ - `aws.accessKeyId` と `aws.secretAccessKey`"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:3
#, fuzzy
msgid ""
"Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`"
msgstr "環境変数 - `AWS_ACCESS_KEY_ID` と `AWS_SECRET_ACCESS_KEY`"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:4
#, fuzzy
msgid ""
"Credential profiles file at the default location (`~/.aws/credentials`) "
"shared by all AWS SDKs and the AWS CLI"
msgstr ""
"Credential profiles file at default location ( `~/.aws/credentials`) at all "
"AWS SDKs and AWS CLI shared by all AWS SDKs"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:5
#, fuzzy
msgid ""
"Credentials delivered through the Amazon ECS if the "
"`AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the "
"security manager has permission to access the variable,"
msgstr ""
"`AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` "
"環境変数が設定されていて、セキュリティマネージャーがその変数にアクセスする権限を持っている場合、Amazon ECS を通して配信されるクレデンシャル。"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:5
#, fuzzy
msgid ""
"Instance profile credentials delivered through the Amazon EC2 metadata "
"service"
msgstr "Amazon EC2メタデータサービスを通じて配信されるインスタンスプロファイルの資格情報"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/gradle-config.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Gradle Plugin Repositories"
msgstr "Quarkus - Gradleプラグインリポジトリ"

#.  tag::repositories[]
#. type: Plain text
#: upstream/_guides/gradle-config.adoc:12
#, fuzzy
msgid ""
"The Quarkus Gradle plugin is published to the https://plugins.gradle.org/"
"plugin/io.quarkus[Gradle Plugin Portal]."
msgstr ""
"Quarkus Gradleプラグインは、Gradle link:https://plugins.gradle.org/plugin/io."
"quarkus[プラグインポータル]に公開されています。"

#. type: Plain text
#: upstream/_guides/gradle-config.adoc:14
#, fuzzy
msgid "To use it, add the following to your `build.gradle` file:"
msgstr "使用するには、 `build.gradle` ファイルに以下を追加します。"

#. type: delimited block -
#: upstream/_guides/gradle-config.adoc:21
#, no-wrap
msgid "plugins {\n"
"    id 'java'\n"
"    id 'io.quarkus'\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/gradle-config.adoc:24
#, fuzzy
msgid ""
"You also need to add the following at the top of your `settings.gradle` file:"
""
msgstr "また、 `settings.gradle` ファイルの先頭に以下を追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/gradle-config.adoc:35
#, no-wrap
msgid ""
"pluginManagement {\n"
"    repositories {\n"
"        mavenCentral()\n"
"        gradlePluginPortal()\n"
"    }\n"
"    plugins {\n"
"      id 'io.quarkus' version \"${quarkusPluginVersion}\"\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/gradle-config.adoc:38
#, fuzzy
msgid ""
"the `plugins{}` method in `settings.gradle` is not supported in Gradle 5.x. "
"In this case make sure to explicitly declare the plugin version in the "
"`build.gradle` file like the example below:"
msgstr ""
"`settings.gradle` の `plugins{}` メソッドは Gradle 5.x ではサポートされていません。この場合、以下の例のように "
"`build.gradle` ファイルでプラグインのバージョンを明示的に宣言してください。"

#. type: delimited block -
#: upstream/_guides/gradle-config.adoc:45
#, no-wrap
msgid ""
"plugins {\n"
"    id 'java'\n"
"    id 'io.quarkus' version '{quarkus-version}'\n"
"}\n"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/spring-cloud-config-client.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Reading properties from Spring Cloud Config Server"
msgstr "Quarkus - Spring Cloud Config Serverからプロパティを読み込む"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:12
#, fuzzy
msgid ""
"This guide explains how your Quarkus application can read configuration "
"properties at runtime from the https://cloud.spring.io/spring-cloud-"
"config[Spring Cloud Config Server]."
msgstr ""
"このガイドでは、Quarkusアプリケーションが実行時に link:https://cloud.spring.io/spring-cloud-"
"config[Spring Cloud Config Server]から設定プロパティを読み込む方法について説明します。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:28
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step."
msgstr "次項の説明に従って、一歩一歩アプリを作成していくことをお勧めします。"

#. type: Title ==
#: upstream/_guides/spring-cloud-config-client.adoc:29
#, no-wrap, fuzzy
msgid "Stand up a Config Server"
msgstr "コンフィグサーバを立ち上げる"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:33
#, fuzzy
msgid ""
"To stand up the Config Server required for this guide, please follow the "
"instructions outlined https://github.com/spring-guides/gs-centralized-"
"configuration#stand-up-a-config-server[here].  The end result of that "
"process is a running Config Server that will provide the `Hello world` value "
"for a configuration property named `message` when the application querying "
"the server is named `a-bootiful-client`."
msgstr ""
"このガイドに必要な Config Server を立ち上げるには、 link:https://github.com/spring-guides/gs-"
"centralized-configuration#stand-up-a-config-"
"server[ここで]概説されている手順に従ってください。このプロセスの最終的な結果は、実行中のコンフィグサーバーで、サーバーを照会するアプリケーションの名前が "
"`a-bootiful-client` である場合、 `message` という名前のコンフィグプロパティに `Hello world` "
"の値を提供することになります。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:47
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=spring-cloud-config-quickstart \\\n"
"    -DclassName=\"org.acme.spring.cloud.config.client.GreetingResource\" \\\n"
"    -Dpath=\"/greeting\" \\\n"
"    -Dextensions=\"spring-cloud-config-client\"\n"
"cd spring-cloud-config-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:50
#, fuzzy
msgid ""
"This command generates a Maven project with a REST endpoint and imports the "
"`spring-cloud-config-client` extension."
msgstr ""
"このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、 `spring-cloud-config-client` "
"拡張子をインポートします。"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:53
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `spring-"
"cloud-config-client` extension to your project by running the following "
"command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `spring-"
"cloud-config-client` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:57
#, no-wrap
msgid ""
"./mvnw quarkus:add-extension -Dextensions=\"spring-cloud-config-client\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:67
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-spring-cloud-config-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/consul-config.adoc:80
#, no-wrap, fuzzy
msgid "GreetingController"
msgstr "グリーティングコントローラ"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:73
#, fuzzy
msgid ""
"The Quarkus Maven plugin automatically generated a `GreetingResource` JAX-RS "
"resource in the `src/main/java/org/acme/spring/cloud/config/client/"
"GreetingResource.java` file that looks like:"
msgstr ""
"Quarkus Mavenプラグインは、 `src/main/java/org/acme/spring/cloud/config/client/"
"GreetingResource.java` ファイル内の `GreetingResource` JAX-"
"RSリソースを自動的に生成して、次のように表示します。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:77
#: upstream/_guides/spring-cloud-config-client.adoc:99
#, no-wrap
msgid "package org.acme.spring.spring.cloud.config.client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:93
#: upstream/_guides/consul-config.adoc:115
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:96
#: upstream/_guides/consul-config.adoc:120
#, no-wrap
msgid "@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:103
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:106
#, fuzzy
msgid ""
"As we want to use configuration properties obtained from the Config Server, "
"we will update the `GreetingResource` to inject the `message` property. The "
"updated code will look like this:"
msgstr ""
"Config Serverから取得した設定プロパティを使用したいので、 `GreetingResource` を更新して `message` "
"プロパティを注入します。更新したコードは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:117
#, no-wrap
msgid "import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:112
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"message\", defaultValue=\"hello default\")\n"
"    String message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:130
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return message;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/consul-config.adoc:132
#, no-wrap, fuzzy
msgid "Configuring the application"
msgstr "アプリケーションの設定"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:124
#, fuzzy
msgid ""
"Quarkus provides various configuration knobs under the `quarkus.spring-cloud-"
"config` root. For the purposes of this guide, our Quarkus application is "
"going to be configured in `application.properties` as follows:"
msgstr ""
"Quarkusは、 `quarkus.spring-cloud-config` "
"ルートの下に様々な設定ノブを提供しています。このガイドの目的のために、私たちのQuarkusアプリケーションは以下のように `application."
"properties` で設定されることになっています。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:133
#, no-wrap
msgid ""
"# use the same name as the application name that was configured when "
"standing up the Config Server\n"
"quarkus.application.name=a-bootiful-client\n"
"# enable retrieval of configuration from the Config Server - this is off by "
"default\n"
"quarkus.spring-cloud-config.enabled=true\n"
"# configure the URL where the Config Server listens to HTTP requests - this "
"could have been left out since http://localhost:8888 is the default\n"
"quarkus.spring-cloud-config.url=http://localhost:8888\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/scheduler.adoc:204
#, no-wrap, fuzzy
msgid "Package and run the application"
msgstr "アプリケーションをパッケージ化して実行する"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:167
#, fuzzy
msgid ""
"Run the application with: `./mvnw compile quarkus:dev`.  Open your browser "
"to http://localhost:8080/greeting."
msgstr ""
"アプリケーションを実行するには、次の手順を実行します: `./mvnw compile quarkus:dev`.ブラウザを http://"
"localhost:8080/greeting  に開きます。"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:141
#, fuzzy
msgid ""
"The result should be: `Hello world` as it is the value obtained from the "
"Spring Cloud Config server."
msgstr "結果は、Spring Cloud Configサーバから取得した値なので、 `Hello world` となるはずです。"

#. type: Title ==
#: upstream/_guides/consul-config.adoc:170
#, no-wrap, fuzzy
msgid "Run the application as a native executable"
msgstr "アプリケーションをネイティブ実行ファイルとして実行する"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:173
#, fuzzy
msgid ""
"You can of course create a native image using the instructions of the link:"
"building-native-image[Building a native executable guide]."
msgstr ""
"もちろん、 link:building-native-"
"image[ネイティブ実行ファイルの構築ガイド]の指示を使ってネイティブイメージを作成することもできます。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:514
#, no-wrap, fuzzy
msgid "More Spring guides"
msgstr "その他のスプリングガイド"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:517
#, fuzzy
msgid ""
"Quarkus has more Spring compatibility features. See the following guides for "
"more details:"
msgstr "Quarkusには、より多くのSpring互換機能があります。詳細については、以下のガイドを参照してください。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:519
#, fuzzy
msgid "link:spring-di[Quarkus - Extension for Spring DI]"
msgstr "link:spring-di[Quarkus - 春のDIのための拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:152
#, fuzzy
msgid "link:spring-web[Quarkus - Extension for Spring Web]"
msgstr "link:spring-web[Quarkus - Spring Web用の拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:520
#, fuzzy
msgid "link:spring-data-jpa[Quarkus - Extension for Spring Data JPA]"
msgstr "link:spring-data-jpa[Quarkus - Spring Data JPAの拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:521
#, fuzzy
msgid "link:spring-security[Quarkus - Extension for Spring Security]"
msgstr "link:spring-security[Quarkus - Spring Securityのための拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:523
#, fuzzy
msgid ""
"link:spring-boot-properties[Quarkus - Extension for Spring Boot properties]"
msgstr "link:spring-boot-properties[Quarkus - Spring Bootプロパティの拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:524
#, fuzzy
msgid "link:spring-cache[Quarkus - Extension for Spring Cache]"
msgstr "link:spring-cache[Quarkus - Spring Cacheの拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:524
#, fuzzy
msgid "link:spring-scheduled[Quarkus - Extension for Spring Scheduled]"
msgstr "link:spring-scheduled[クオークス - 春の予定延長]"

#. type: Title ==
#: upstream/_guides/spring-cloud-config-client.adoc:159
#, no-wrap, fuzzy
msgid "Spring Cloud Config Client Reference"
msgstr "Spring Cloud Configクライアントリファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/microprofile-health.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - MicroProfile Health"
msgstr "Quarkus - MicroProfile Health"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:12
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize the "
"MicroProfile Health specification through the SmallRye Health extension."
msgstr ""
"このガイドでは、QuarkusアプリケーションがSmallRye Health拡張機能を使用してMicroProfile "
"Health仕様を利用する方法を説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:17
#, fuzzy
msgid ""
"MicroProfile Health allows applications to provide information about their "
"state to external viewers which is typically useful in cloud environments "
"where automated processes must be able to determine whether the application "
"should be discarded or restarted."
msgstr ""
"MicroProfile Health "
"は、アプリケーションの状態に関する情報を外部のビューアに提供することを可能にします。これは、自動プロセスがアプリケーションを破棄するか再起動するかを判断する必要があるクラウド環境において、一般的に有用です。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:32
#, fuzzy
msgid ""
"In this guide, we build a simple REST application that exposes MicroProfile "
"Health functionalities at the `/health/live` and `/health/ready` endpoints "
"according to the specification."
msgstr ""
"このガイドでは、仕様に従って `/health/live` および `/health/ready` エンドポイントで MicroProfile "
"Health 機能を公開するシンプルな REST アプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:37
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step. However, you can go right to the "
"completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:43
#, fuzzy
msgid ""
"The solution is located in the `microprofile-health-quickstart` {quickstarts-"
"tree-url}/microprofile-health-quickstart[directory]."
msgstr ""
"ソリューションは `microprofile-health-quickstart` {quickstarts-tree-url}/"
"microprofile-health-quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:55
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=microprofile-health-quickstart \\\n"
"    -Dextensions=\"health\"\n"
"cd microprofile-health-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:59
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `smallrye-health` "
"extension which is an implementation of the MicroProfile Health "
"specification used in Quarkus."
msgstr ""
"このコマンドは、Quarkusで使用されているMicroProfile Health仕様の実装である `smallrye-health` "
"拡張子をインポートして、Mavenプロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:62
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-health` extension to your project by running the following command "
"in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-health` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:66
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"smallrye-health\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:76
#: upstream/_guides/microprofile-health.adoc:368
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-health</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:78
#, no-wrap, fuzzy
msgid "Running the health check"
msgstr "健康チェックの実行"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:81
#, fuzzy
msgid ""
"Importing the `smallrye-health` extension directly exposes three REST "
"endpoints:"
msgstr "`smallrye-health` 拡張モジュールをインポートすると、3 つの REST エンドポイントが直接公開されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:83
#, fuzzy
msgid "`/health/live` - The application is up and running."
msgstr "`/health/live` - アプリケーションが起動しています。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:84
#, fuzzy
msgid "`/health/ready` - The application is ready to serve requests."
msgstr "`/health/ready` - アプリケーションはリクエストに応える準備ができています。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:85
#, fuzzy
msgid ""
"`/health` - Accumulating all health check procedures in the application."
msgstr "`/health` - アプリケーション内のすべての健康チェックの手順を蓄積します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:87
#, fuzzy
msgid "To check that the `smallrye-health` extension is working as expected:"
msgstr "`smallrye-health` の拡張子が正常に動作していることを確認するため。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:89
#, fuzzy
msgid "start your Quarkus application with `./mvnw compile quarkus:dev`"
msgstr "でQuarkusアプリケーションを起動します。 `./mvnw compile quarkus:dev`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:91
#, fuzzy
msgid ""
"access the `http://localhost:8080/health/live` endpoint using your browser "
"or `curl http://localhost:8080/health/live`"
msgstr ""
"アクセス `&lt;a href=\"http://localhost:8080/health/live\" class="
"\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;`エンドポイントを使用して、ブラウザまたは "
"`curl &lt;a href=\"http://localhost:8080/health/live\" class="
"\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:93
#, fuzzy
msgid ""
"All of the health REST endpoints return a simple JSON object with two fields:"
""
msgstr "すべてのヘルスRESTエンドポイントは、2つのフィールドを持つシンプルなJSONオブジェクトを返します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:95
#, fuzzy
msgid "`status` -- the overall result of all the health check procedures"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:96
#, fuzzy
msgid "`checks` -- an array of individual checks"
msgstr "`checks`减免Zs_2009-ASEMANSIBLEAN-减免Zs_2009-ASEMANSIANの個別チェックの配列。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:100
#, fuzzy
msgid ""
"The general `status` of the health check is computed as a logical AND of all "
"the declared health check procedures. The `checks` array is empty as we have "
"not specified any health check procedure yet so let's define some."
msgstr ""
"ヘルスチェックの一般的な `status` は、宣言されたすべてのヘルスチェックプロシージャの論理 AND として計算されます。 `checks` "
"の配列は、まだ何もヘルスチェックプロシージャを指定していないので空です。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:101
#, no-wrap, fuzzy
msgid "Creating your first health check"
msgstr "初めての健康チェックの作成"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:104
#, fuzzy
msgid "In this section, we create our first simple health check procedure."
msgstr "ここでは、最初に簡単な健康チェックの手順を作成します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:106
#, fuzzy
msgid "Create the `org.acme.microprofile.health.SimpleHealthCheck` class:"
msgstr "`org.acme.microprofile.health.SimpleHealthCheck` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:110
#: upstream/_guides/microprofile-health.adoc:164
#: upstream/_guides/microprofile-health.adoc:210
#: upstream/_guides/microprofile-health.adoc:281
#, no-wrap
msgid "package org.acme.microprofile.health;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:114
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import org.eclipse.microprofile.health.Liveness;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:120
#, no-wrap
msgid ""
"@Liveness\n"
"@ApplicationScoped <1> <2>\n"
"public class SimpleHealthCheck implements HealthCheck {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:126
#, no-wrap
msgid ""
"    @Override\n"
"    public HealthCheckResponse call() {\n"
"        return HealthCheckResponse.up(\"Simple health check\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:128
#, fuzzy
msgid ""
"It's recommended to annotate the health check class with "
"`@ApplicationScoped` or the `@Singleton` scope so that a single bean "
"instance is used for all health check requests."
msgstr ""
"ヘルスチェッククラスに `@ApplicationScoped` や `@Singleton` "
"スコープをアノテーションして、単一のビーンインスタンスがすべてのヘルスチェックリクエストに使用されるようにすることをお勧めします。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:129
#, fuzzy
msgid ""
"If a bean class annotated with one of the health check annotations declares "
"no scope then the `@Singleton` scope is used automatically."
msgstr ""
"ヘルスチェックアノテーションの一つでアノテーションされたビーンクラスがスコープを宣言しない場合、 `@Singleton` "
"スコープが自動的に使用されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:131
#, fuzzy
msgid ""
"As you can see, the health check procedures are defined as CDI beans that "
"implement the `HealthCheck` interface and are annotated with one of the "
"health check qualifiers, such as:"
msgstr ""
"ご覧のように、ヘルスチェックの手続きは `HealthCheck` インターフェイスを実装した CDI "
"ビーンズとして定義されており、ヘルスチェック修飾子のいずれかでアノテーションされています。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:133
#, fuzzy
msgid "`@Liveness` - the liveness check accessible at `/health/live`"
msgstr "`@Liveness` - ライブネスチェックにアクセスするには、以下のサイトを参照してください。 `/health/live`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:134
#, fuzzy
msgid "`@Readiness` - the readiness check accessible at `/health/ready`"
msgstr "`@Readiness` - 準備状況のチェックは以下のサイトからアクセスできます。 `/health/ready`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:138
#, fuzzy
msgid ""
"`HealthCheck` is a functional interface whose single method `call` returns a "
"`HealthCheckResponse` object which can be easily constructed by the fluent "
"builder API shown in the example."
msgstr ""
"`HealthCheck` は、単一メソッド `call` が `HealthCheckResponse` "
"オブジェクトを返す機能的なインターフェイスで、例に示した fluent ビルダー API で簡単に構築できます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:144
#, fuzzy
msgid ""
"As we have started our Quarkus application in dev mode simply repeat the "
"request to `http://localhost:8080/health/live` by refreshing your browser "
"window or by using `curl http://localhost:8080/health/live`. Because we "
"defined our health check to be a liveness procedure (with `@Liveness` "
"qualifier) the new health check procedure is now present in the `checks` "
"array."
msgstr ""
"開発モードでQuarkusアプリケーションを起動しているので、次のようなリクエストを繰り返します。 `&lt;a href=\"http://"
"localhost:8080/health/live\" class=\"bare\"&gt;http://localhost:8080/health/"
"live&lt;/a&gt;`ブラウザのウィンドウをリフレッシュするか `curl &lt;a href=\"http://localhost:8080/"
"health/live\" class=\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;`."
"ヘルスチェックをlivenessプロシージャ( `@Liveness` 修飾子付き)と定義したので、新しいヘルスチェックプロシージャは `checks` "
"配列に存在するようになりました。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:147
#, fuzzy
msgid ""
"Congratulations! You've created your first Quarkus health check procedure. "
"Let's continue by exploring what else can be done with the MicroProfile "
"Health specification."
msgstr ""
"おめでとうございます。最初のQuarkusヘルスチェック手順を作成しました。続けて、MicroProfile "
"Health仕様を使用して、他に何ができるのかを調べてみましょう。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:148
#, no-wrap, fuzzy
msgid "Adding a readiness health check procedure"
msgstr "準備健康チェックの手順を追加する"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:154
#, fuzzy
msgid ""
"In the previous section, we created a simple liveness health check procedure "
"which states whether our application is running or not. In this section, we "
"will create a readiness health check which will be able to state whether our "
"application is able to process requests."
msgstr ""
"前のセクションでは、アプリケーションが動作しているかどうかを示す、簡単な動作確認の手順を作成しました。このセクションでは、アプリケーションがリクエストを処理できるかどうかを示すことができるようにするための準備度チェックを作成します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:158
#, fuzzy
msgid ""
"We will create another health check procedure that simulates a connection to "
"an external service provider such as a database. For starters, we will "
"always return the response indicating the application is ready."
msgstr ""
"データベースのような外部サービス・プロバイダへの接続をシミュレートする別のヘルス・チェック・プロシージャを作成します。手始めに、アプリケーションの準備ができていることを示すレスポンスを常に返します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:160
#, fuzzy
msgid ""
"Create `org.acme.microprofile.health.DatabaseConnectionHealthCheck` class:"
msgstr ""
"`org.acme.microprofile.health.DatabaseConnectionHealthCheck` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:168
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import org.eclipse.microprofile.health.Readiness;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:174
#: upstream/_guides/microprofile-health.adoc:222
#, no-wrap
msgid ""
"@Readiness\n"
"@ApplicationScoped\n"
"public class DatabaseConnectionHealthCheck implements HealthCheck {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:180
#, no-wrap
msgid ""
"    @Override\n"
"    public HealthCheckResponse call() {\n"
"        return HealthCheckResponse.up(\"Database connection health check\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:190
#, fuzzy
msgid ""
"If you now rerun the health check at `http://localhost:8080/health/live` the "
"`checks` array will contain only the previously defined `SimpleHealthCheck` "
"as it is the only check defined with the `@Liveness` qualifier. However, if "
"you access `http://localhost:8080/health/ready` (in the browser or with "
"`curl http://localhost:8080/health/ready`) you will see only the `Database "
"connection health check` as it is the only health check defined with the "
"`@Readiness` qualifier as the readiness health check procedure."
msgstr ""
"でヘルスチェックを再実行した場合は `&lt;a href=\"http://localhost:8080/health/live\" class="
"\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;` `checks` の配列には、 "
"`@Liveness` の修飾子で定義された唯一のチェックなので、先に定義された `SimpleHealthCheck` だけが含まれます。しかし、もし "
"`&lt;a href=\"http://localhost:8080/health/ready\" class=\"bare\"&gt;http://"
"localhost:8080/health/ready&lt;/a&gt;`(ブラウザや `curl &lt;a href=\"http://"
"localhost:8080/health/ready\" class=\"bare\"&gt;http://localhost:8080/health/"
"ready&lt;/a&gt;`)では、 `Database connection health check` だけが表示されますが、これは "
"`@Readiness` の修飾子で定義された唯一のヘルスチェックであるため、レディネスヘルスチェックの手順として表示されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:192
#, fuzzy
msgid ""
"If you access `http://localhost:8080/health` you will get back both checks."
msgstr ""
"アクセスした場合 `&lt;a href=\"http://localhost:8080/health\" class=\"bare\"&gt;http:"
"//localhost:8080/health&lt;/a&gt;`あなたは両方の小切手を取り戻すでしょう。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:197
#, fuzzy
msgid ""
"More information about which health check procedures should be used in which "
"situation is detailed in the MicroProfile Health specification. Generally, "
"the liveness procedures determine whether the application should be "
"restarted while readiness procedures determine whether it makes sense to "
"contact the application with requests."
msgstr ""
"どのヘルスチェック手順をどのような状況で使用すべきかについての詳細は、MicroProfile "
"のヘルス仕様に詳述されています。一般的には、活性化の手順はアプリケーションを再起動すべきかどうかを決定し、準備の手順はアプリケーションにリクエストを連絡することが意味のあることかどうかを決定します。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:198
#, no-wrap, fuzzy
msgid "Negative health check procedures"
msgstr "ネガティブヘルスチェックの手順"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:204
#, fuzzy
msgid ""
"In this section, we extend our `Database connection health check` with the "
"option of stating that our application is not ready to process requests as "
"the underlying database connection cannot be established. For simplicity "
"reasons, we only determine whether the database is accessible or not by a "
"configuration property."
msgstr ""
"このセクションでは、 `Database connection health check` を拡張して、基礎となるデータベース接続が確立できないために、 "
"アプリケーションがリクエストを処理する準備ができていないことを示すオプションを追加しています。単純化のために、データベースにアクセスできるかどうかは設定プロパティでのみ判断します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:206
#, fuzzy
msgid ""
"Update the `org.acme.microprofile.health.DatabaseConnectionHealthCheck` "
"class:"
msgstr ""
"`org.acme.microprofile.health.DatabaseConnectionHealthCheck` クラスを更新します。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:216
#, no-wrap
msgid ""
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n"
"import org.eclipse.microprofile.health.Readiness;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:225
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"database.up\", defaultValue = \"false\")\n"
"    private boolean databaseUp;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:228
#, no-wrap
msgid "    @Override\n"
"    public HealthCheckResponse call() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:230
#, no-wrap
msgid ""
"        HealthCheckResponseBuilder responseBuilder = HealthCheckResponse."
"named(\"Database connection health check\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:238
#, no-wrap
msgid ""
"        try {\n"
"            simulateDatabaseConnectionVerification();\n"
"            responseBuilder.up();\n"
"        } catch (IllegalStateException e) {\n"
"            // cannot access the database\n"
"            responseBuilder.down();\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:241
#, no-wrap
msgid "        return responseBuilder.build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:248
#, no-wrap
msgid ""
"    private void simulateDatabaseConnectionVerification() {\n"
"        if (!databaseUp) {\n"
"            throw new IllegalStateException(\"Cannot contact database\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:255
#, fuzzy
msgid ""
"Until now we used a simplified method of building a `HealthCheckResponse` "
"through the `HealthCheckResponse#up(String)` (there is also "
"`HealthCheckResponse#down(String)`) which will directly build the response "
"object.  From now on, we utilize the full builder capabilities provided by "
"the `HealthCheckResponseBuilder` class."
msgstr ""
"これまでは、 `HealthCheckResponse#up(String)` ( `HealthCheckResponse#down(String)` "
"もあります) を通して `HealthCheckResponse` "
"を構築する単純な方法を使用していましたが、これはレスポンスオブジェクトを直接構築するものです。今後は、 "
"`HealthCheckResponseBuilder` クラスが提供する完全なビルダー機能を利用します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:260
#, fuzzy
msgid ""
"If you now rerun the readiness health check (at `http://localhost:8080/"
"health/ready`)  the overall `status` should be DOWN. You can also check the "
"liveness check at `http://localhost:8080/health/live` which will return the "
"overall `status` UP because it isn't influenced by the readiness checks."
msgstr ""
"今、準備状態の健康チェックを再実行した場合 ( `&lt;a href=\"http://localhost:8080/health/ready\" "
"class=\"bare\"&gt;http://localhost:8080/health/ready&lt;/a&gt;`) `status` "
"が全体的にダウンしているはずです。また、ライブネスチェックは `&lt;a href=\"http://localhost:8080/health/"
"live\" class=\"bare\"&gt;http://localhost:8080/health/live&lt;/"
"a&gt;`これは、準備チェックの影響を受けないので、全体の `status` UP を返します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:264
#, fuzzy
msgid ""
"As we shouldn't leave this application with a readiness check in a DOWN "
"state and because we are running Quarkus in dev mode you can add `database."
"up=true` in `src/main/resources/application.properties` and rerun the "
"readiness health check again"
msgstr ""
"このアプリケーションをDOWN状態でレディネスチェックをしたままにしておくべきではないし、Quarkusをdevモードで実行しているので、 "
"`database.up=true` を `src/main/resources/application.properties` "
"に追加して、レディネスヘルスチェックを再実行することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:265
#, fuzzy
msgid "it should be up again."
msgstr "また上がるはずです。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:267
#, no-wrap, fuzzy
msgid "Adding user-specific data to the health check response"
msgstr "ヘルスチェック応答にユーザー固有のデータを追加する"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:275
#, fuzzy
msgid ""
"In previous sections, we saw how to create simple health checks with only "
"the minimal attributes, namely, the health check name and its status (UP or "
"DOWN). However, the MicroProfile specification also provides a way for the "
"applications to supply arbitrary data in the form of key-value pairs sent to "
"the consuming end. This can be done by using the `withData(key, value)` "
"method of the health check response builder API."
msgstr ""
"前のセクションでは、最低限の属性、すなわちヘルスチェック名とそのステータス(UPまたはDOWN)だけで単純なヘルスチェックを作成する方法を見た。しかし、MicroProfile "
"仕様では、アプリケーションが任意のデータをキーと値のペアの形で消費側に送信する方法も提供しています。これは、ヘルスチェック応答ビルダ API の "
"`withData(key, value)` メソッドを使用して行うことができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:277
#, fuzzy
msgid ""
"Let's create a new health check procedure `org.acme.microprofile.health."
"DataHealthCheck`:"
msgstr "新しい健康チェックの手順を作ってみよう `org.acme.microprofile.health.DataHealthCheck`."

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:285
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.Liveness;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:291
#, no-wrap
msgid ""
"@Liveness\n"
"@ApplicationScoped\n"
"public class DataHealthCheck implements HealthCheck {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:301
#, no-wrap
msgid ""
"    @Override\n"
"    public HealthCheckResponse call() {\n"
"        return HealthCheckResponse.named(\"Health check with data\")\n"
"                .up()\n"
"                .withData(\"foo\", \"fooValue\")\n"
"                .withData(\"bar\", \"barValue\")\n"
"                .build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:307
#, fuzzy
msgid ""
"If you rerun the liveness health check procedure by accessing the `/health/"
"live` endpoint you can see that the new health check `Health check with "
"data` is present in the `checks` array. This check contains a new attribute "
"called `data` which is a JSON object consisting of the properties we have "
"defined in our health check procedure."
msgstr ""
"`/health/live` エンドポイントにアクセスして liveness ヘルスチェックプロシージャを再実行すると、 `checks` "
"配列に新しいヘルスチェック `Health check with data` が存在することがわかります。このチェックには `data` "
"という新しい属性が含まれており、これは、ヘルス・チェック・プロシージャで定義したプロパティで構成される JSON オブジェクトです。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:310
#, fuzzy
msgid ""
"This functionality is specifically useful in failure scenarios where you can "
"pass the error along with the health check response."
msgstr "この機能は、エラーをヘルスチェック応答と一緒に渡すことができる障害シナリオで特に有用です。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:322
#, no-wrap
msgid ""
"        try {\n"
"            simulateDatabaseConnectionVerification();\n"
"            responseBuilder.up();\n"
"        } catch (IllegalStateException e) {\n"
"            // cannot access the database\n"
"            responseBuilder.down()\n"
"                    .withData(\"error\", e.getMessage()); // pass the "
"exception message\n"
"        }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:324
#, no-wrap, fuzzy
msgid "Extension health checks"
msgstr "エクステンションの健康チェック"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:327
#, fuzzy
msgid ""
"Some extension may provide default health checks, including the extension "
"will automatically register its health checks."
msgstr "拡張機能によってはデフォルトのヘルスチェックを提供している場合があり、その場合は拡張機能が自動的にヘルスチェックを登録してくれます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:330
#, fuzzy
msgid ""
"For example, `quarkus-agroal` that is used to manage Quarkus datasource(s) "
"automatically register a readiness health check that will validate each "
"datasources: link:datasource#datasource-health-check[Datasource Health "
"Check]."
msgstr ""
"例えば、Quarkusのデータソースを管理するために使用されている `quarkus-agroal` "
"は、各データソースを検証するレディネスヘルスチェックを自動的に登録します。 link:datasource#datasource-health-"
"check[Datasource Health Check]."

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:332
#, fuzzy
msgid ""
"You can disable extension health check via the property `quarkus.health."
"extensions.enabled` so none will be automatically registered."
msgstr ""
"プロパティ `quarkus.health.extensions.enabled` "
"で拡張子の健康チェックを無効にすることができるので、何も自動的に登録されません。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:333
#, no-wrap, fuzzy
msgid "Health UI "
msgstr "健康UI"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:338
#, fuzzy
msgid "`health-ui` allows you to see your Health Checks in a Web GUI."
msgstr "`health-ui` では、Web GUI で健康診断を見ることができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:340
#, fuzzy
msgid ""
"The Quarkus `smallrye-health` extension ships with `health-ui` and enables "
"it by default in dev and test modes, but it can also be explicitly "
"configured for production mode as well."
msgstr ""
"Quarkus `smallrye-health` 拡張機能は `health-ui` "
"に同梱されており、開発モードとテストモードではデフォルトで有効になっていますが、本番モードでも明示的に設定することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:342
#, fuzzy
msgid "`health-ui` can be accessed from http://localhost:8080/health-ui/ ."
msgstr "`health-ui` は http://localhost:8080/health-ui/ からアクセスできます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:344
#, fuzzy
msgid "image:health-ui-screenshot01.png[alt=Health UI]"
msgstr "image:health-ui-screenshot01.png[alt=Health UI]"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:351
#, fuzzy
msgid ""
"MicroProfile Health provides a way for your application to distribute "
"information about its healthiness state to state whether or not it is able "
"to function properly.  Liveness checks are utilized to tell whether the "
"application should be restarted and readiness checks are used to tell "
"whether the application is able to process requests."
msgstr ""
"MicroProfile Health "
"は、アプリケーションが正常に機能するかどうかを示すために、アプリケーションの健康状態に関する情報を配布する方法を提供します。元気度チェックはアプリケーションを再起動すべきかどうかを伝えるために利用され、レディネスチェックはアプリケーションがリクエストを処理できるかどうかを伝えるために利用されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:353
#, fuzzy
msgid ""
"All that is needed to enable the MicroProfile Health features in Quarkus is:"
msgstr "QuarkusのMicroProfile Health機能を有効にするために必要なのは、これだけです。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:356
#, fuzzy
msgid ""
"adding the `smallrye-health` Quarkus extension to your project using the "
"`quarkus-maven-plugin`: +"
msgstr ""
"`smallrye-health` Quarkus拡張機能をプロジェクトに追加するには、 `quarkus-maven-plugin`.\n"
"<br>"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:359
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"health\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:362
#, fuzzy
msgid "or simply adding the following Maven dependency: +"
msgstr "または、単に以下のMaven依存関係を追加するだけです。\n"
"<br>"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security.adoc:6
#, no-wrap
msgid "Quarkus - Security Architecture and Guides"
msgstr "Quarkus - セキュリティアーキテクチャとガイド"

#. type: Plain text
#: upstream/_guides/security.adoc:11
msgid ""
"Quarkus Security provides the architecture, multiple authentication and "
"authorization mechanisms, and other tools for the developers to build a "
"production-quality security for their Quarkus applications."
msgstr ""
"Quarkus "
"Securityでは、開発者がQuarkusアプリケーションの商用品質のセキュリティを構築するためのアーキテクチャ、複数の認証および認可メカニズム、その他のツールを提供しています。"

#. type: Plain text
#: upstream/_guides/security.adoc:13
msgid ""
"This document provides a brief overview of Quarkus Security and links to the "
"individual guides."
msgstr "このドキュメントでは、Quarkus Securityの簡単な概要と、各ガイドへのリンクについて説明しています。"

#. type: Plain text
#: upstream/_guides/security.adoc:17
msgid ""
"`HttpAuthenticationMechanism` is the main entry into Quarkus HTTP Security."
msgstr "`HttpAuthenticationMechanism`  は、Quarkus HTTP Securityのメインエントリです。"

#. type: Plain text
#: upstream/_guides/security.adoc:20
msgid ""
"Quarkus Security Manager uses `HttpAuthenticationMechanism` to extract the "
"authentication credentials from the HTTP request and delegates to "
"`IdentityProvider` to complete the conversion of these credentials to "
"`SecurityIdentity`."
msgstr ""
"Quarkus Security Managerは、 `HttpAuthenticationMechanism`  "
"を使用してHTTPリクエストから認証資格情報を抽出し、 `IdentityProvider`  に委任して、これらの資格情報の "
"`SecurityIdentity`  への変換を完了させます。"

#. type: Plain text
#: upstream/_guides/security.adoc:22
msgid ""
"For example, the credentials may be coming with the HTTP `Authorization` "
"header, client HTTPS certificates or cookies."
msgstr ""
"例えば、資格情報は、HTTP `Authorization`  ヘッダー、クライアントの HTTPS "
"証明書、またはクッキーを使用している場合があります。"

#. type: Plain text
#: upstream/_guides/security.adoc:24
msgid ""
"`IdentityProvider` verifies the authentication credentials and maps them to "
"`SecurityIdentity` which contains the username, roles, the original "
"authentication credentials, and other attributes."
msgstr ""
"`IdentityProvider`  は認証資格情報を検証し、ユーザ名、ロール、元の認証資格情報、およびその他の属性を含む "
"`SecurityIdentity`  にマップします。"

#. type: Plain text
#: upstream/_guides/security.adoc:26
msgid ""
"For every authenticated resource, you can inject a `SecurityIdentity` "
"instance to get the authenticated identity information."
msgstr "認証済みリソースごとに、 `SecurityIdentity`  インスタンスを注入して、認証済みの ID 情報を取得することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:29
msgid ""
"In some other contexts you may have other parallel representations of the "
"same information (or parts of it) such as `SecurityContext` for JAX-RS or "
"`JsonWebToken` for JWT."
msgstr ""
"他の文脈では、JAX-RSであれば `SecurityContext`  、JWTであれば `JsonWebToken`  "
"のように、同じ情報（またはその一部）を他の別の表現で表現している場合があります。"

#. type: Title ==
#: upstream/_guides/security.adoc:30
#, no-wrap
msgid "Authentication mechanisms"
msgstr "認証メカニズム"

#. type: Plain text
#: upstream/_guides/security.adoc:33
msgid ""
"Quarkus supports several sources to load authentication information from."
msgstr "Quarkusは、認証情報をロードするためのいくつかのソースをサポートしています。"

#. type: Title ===
#: upstream/_guides/security.adoc:34
#, no-wrap
msgid "Basic and Form Authentication Mechanisms"
msgstr "基本認証とフォーム認証の仕組み"

#. type: Plain text
#: upstream/_guides/security.adoc:38
msgid ""
"Basic and Form HTTP-based authentication mechanisms are the core "
"authentication mechanisms supported in Quarkus.  Please see link:security-"
"built-in-authentication#basic-auth[Basic HTTP Authentication] and link:"
"security-built-in-authentication#form-auth[Form HTTP Authentication] for "
"more information."
msgstr ""
"Basic HTTPベースの認証メカニズムとForm "
"HTTPベースの認証メカニズムは、Quarkusでサポートされている主要な認証メカニズムです。詳細については、 link:security-built-"
"in-authentication#basic-auth[基本HTTP認証]と link:security-built-in-"
"authentication#form-auth[フォームHTTP認証]を参照してください。"

#. type: Title ===
#: upstream/_guides/security.adoc:39
#, no-wrap
msgid "Mutual TLS Authentication"
msgstr "相互TLS認証"

#. type: Plain text
#: upstream/_guides/security.adoc:42
msgid ""
"Quarkus provides Mutual TLS authentication so that you can authenticate "
"users based on their X.509 certificates."
msgstr "Quarkusは相互TLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。"

#. type: Plain text
#: upstream/_guides/security.adoc:44
msgid ""
"Please see link:security-built-in-authentication#mutual-tls[Mutual TLS "
"Authentication] for more information."
msgstr ""
"詳しくは link:security-built-in-authentication#mutual-tls[相互TLS認証] をご覧ください。"

#. type: Title ===
#: upstream/_guides/security.adoc:45
#, no-wrap
msgid "OpenId Connect"
msgstr "OpenId Connect"

#. type: Plain text
#: upstream/_guides/security.adoc:48
msgid ""
"`quarkus-oidc` extension provides a reactive, interoperable, multi-tenant "
"enabled OpenId Connect adapter which supports `Bearer Token` and "
"`Authorization Code Flow` authentication mechanisms."
msgstr ""
"`quarkus-oidc`  エクステンションは、 `Bearer Token`  および `Authorization Code Flow`  "
"認証メカニズムをサポートする、リアクティブで相互運用可能なマルチテナント対応の OpenId Connect アダプタを提供します。"

#. type: Plain text
#: upstream/_guides/security.adoc:51
msgid ""
"`Bearer Token` mechanism extracts the token from HTTP `Authorization` header."
"  `Authorization Code Flow` mechanism uses OpenId Connect Authorization Code "
"flow. It redirects the user to IDP to authenticate and completes the "
"authentication process after the user has been redirected back to Quarkus by "
"exchanging the provided code grant for ID, access and refresh tokens."
msgstr ""
"`Bearer Token`  メカニズムは、HTTP `Authorization`  ヘッダーからトークンを抽出します。 "
"`Authorization Code Flow`  メカニズムは、OpenId Connect Authorization Code "
"Flowを使用します。ユーザーをIDPにリダイレクトして認証を行い、提供されたCode "
"GrantをID、アクセストークン、リフレッシュトークンと交換することで、ユーザーがQuarkusにリダイレクトされた後に認証プロセスを完了させます。"

#. type: Plain text
#: upstream/_guides/security.adoc:53
msgid ""
"ID and access `JWT` tokens are verified with the refreshable `JWK` key set "
"but both JWT and opaque (binary) tokens can be introspected remotely."
msgstr ""
"ID とアクセス `JWT` トークンは、リフレッシュ可能な `JWK` キーセットで検証されますが、JWT と不透明な (バイナリの) "
"トークンの両方をリモートで検証することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:55
msgid ""
"See the link:security-openid-connect[Using OpenID Connect to Protect Service "
"Applications] guide for more information about `Bearer Token` authentication "
"mechanism."
msgstr ""
"`Bearer Token` 認証メカニズムの詳細については、 link:security-openid-connect[Using OpenID "
"Connect to Protect Service Applications]ガイドを参照してください。"

#. type: Plain text
#: upstream/_guides/security.adoc:57
msgid ""
"See the link:security-openid-connect-web-authentication[Using OpenID Connect "
"to Protect Web Application] guide for more information about `Authorization "
"Code Flow` authentication mechanism."
msgstr ""
"`Authorization Code Flow`  認証メカニズムの詳細については、 link:security-openid-connect-web-"
"authentication[Using OpenID Connect to Protect Web Application]ガイドを参照してください。"

#. type: delimited block =
#: upstream/_guides/security.adoc:61
msgid ""
"Both `quarkus-oidc` `Bearer` and `Authorization Code Flow` Authentication "
"mechanisms use <<smallrye-jwt, SmallRye JWT>> to represent JWT tokens as "
"Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken`."
msgstr ""
"`quarkus-oidc` の`Bearer` と `Authorization Code Flow`  認証メカニズムはいずれも link:"
"#smallrye-jwt[SmallRye JWT ]を使用して、JWT トークンを Microprofile JWT `org.eclipse."
"microprofile.jwt.JsonWebToken` として表現しています。"

#. type: Plain text
#: upstream/_guides/security.adoc:64
msgid ""
"See link:security-openid-connect-multitenancy[Using OpenID Connect Multi-"
"Tenancy] for more information about multiple tenants which can support "
"`Bearer` or `Authorization Code Flow` authentication mechanism and "
"configured statically or dynamically."
msgstr ""
"`Bearer`  または `Authorization Code Flow`  "
"認証メカニズムをサポートし、静的または動的に設定できる複数のテナントの詳細については、 link:security-openid-connect-"
"multitenancy[OpenID Connect マルチテナントの使用]を参照してください。"

#. type: delimited block =
#: upstream/_guides/security.adoc:69
msgid ""
"If you would like to have Quarkus OIDC extension enabled at runtime then set "
"`quarkus.oidc.tenant-enabled=false` at build time and re-enable it at "
"runtime using a system property.  See also link:security-openid-connect-"
"multitenancy#disable-tenant[Disabling Tenant Configurations] for more "
"information about managing the individual tenant configurations in the multi-"
"tenant OIDC deployments."
msgstr ""
"実行時にQuarkus OIDCエクステンションを有効にしたい場合は、ビルド時に `quarkus.oidc.tenant-enabled=false` "
"を設定し、システムプロパティを使用して実行時に再度有効にします。マルチテナントOIDCデプロイメントでの個々のテナント設定の管理の詳細については、テナント "
"link:security-openid-connect-multitenancy#disable-tenant[設定の無効化]も参照してください。"

#. type: Plain text
#: upstream/_guides/security.adoc:72
msgid ""
"If you use Keycloak and Bearer tokens then also see the link:security-"
"keycloak-authorization[Using Keycloak to Centralize Authorization] guide."
msgstr ""
"Keycloak と Bearer トークンを使用する場合は、 link:security-keycloak-authorization[Using "
"Keycloak to Centralize Authorization]ガイドも参照してください。"

#. type: delimited block =
#: upstream/_guides/security.adoc:76
msgid ""
"If you need to configure Keycloak programmatically then consider using https:"
"//www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak "
"Admin REST API] with the help of the `quarkus-keycloak-admin-client` "
"extension."
msgstr ""
"Keycloakをプログラムで設定する必要がある場合は、 `quarkus-keycloak-admin-client` "
"エクステンションの助けを借りて、 link:https://www.keycloak.org/docs/latest/"
"server_development/#admin-rest-api[Keycloak Admin REST API]の使用を検討してください。"

#. type: Title ===
#: upstream/_guides/security.adoc:79
#, no-wrap
msgid "SmallRye JWT"
msgstr "SmallRye JWT"

#. type: Plain text
#: upstream/_guides/security.adoc:82
msgid ""
"`quarkus-smallrye-jwt` provides Microprofile JWT 1.1.1 implementation and "
"many more options to verify signed and encrypted `JWT` tokens and represent "
"them as `org.eclipse.microprofile.jwt.JsonWebToken`."
msgstr ""
"`quarkus-smallrye-jwt` はMicroprofile JWT 1.1.1.1 の実装と、署名・暗号化された `JWT` "
"トークンを検証し、 `org.eclipse.microprofile.jwt.JsonWebToken` "
"として表現するための多くのオプションを提供します。"

#. type: Plain text
#: upstream/_guides/security.adoc:84
msgid ""
"It provides an alternative to `quarkus-oidc` Bearer Token Authentication "
"Mechanism. It can currently verify only `JWT` tokens using the PEM keys or "
"refreshable `JWK` key set."
msgstr ""
"それは `quarkus-oidc` ベアラートークン認証メカニズムに代わるものを提供します。現在、PEM 鍵または更新可能な `JWK` "
"鍵セットを使用して `JWT` トークンのみを検証することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:86
msgid ""
"Additionally it provides `JWT Generation API` for creating `signed`, `inner-"
"signed` and/or `encrypted` `JWT` tokens with ease."
msgstr ""
"さらに、 `JWT Generation API` を提供して、 `signed` , `inner-signed` , および/または "
"`encrypted` `JWT`トークンを簡単に作成することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:88
msgid ""
"See the link:security-jwt[Using SmallRye JWT] guide for more information."
msgstr "詳細については、 link:security-jwt[Using SmallRye JWT]ガイドを参照してください。"

#. type: Title ===
#: upstream/_guides/security.adoc:89
#, no-wrap
msgid "OAuth2"
msgstr "OAuth2"

#. type: Plain text
#: upstream/_guides/security.adoc:92
msgid ""
"`quarkus-elytron-security-oauth2` provides an alternative to `quarkus-oidc` "
"Bearer Token Authentication Mechanism. It is based on `Elytron` and is "
"primarily meant for introspecting the opaque tokens remotely."
msgstr ""
"`quarkus-elytron-security-oauth2`  は `quarkus-oidc`  Bearer Token "
"認証メカニズムの代替手段を提供します。これは `Elytron` "
"をベースにしており、主に不透明なトークンをリモートでイントロスペクトするためのものです。"

#. type: Plain text
#: upstream/_guides/security.adoc:94
msgid "See the link:security-oauth2[Using OAuth2] guide for more information."
msgstr "詳細については、 link:security-oauth2[OAuth2 の使用]ガイドを参照してください。"

#. type: Title ===
#: upstream/_guides/security.adoc:95
#, no-wrap
msgid "LDAP"
msgstr "LDAP"

#. type: Plain text
#: upstream/_guides/security.adoc:98
msgid ""
"Please see the link:security-ldap[Authenticate with LDAP] guide for more "
"information about LDAP authentication mechanism."
msgstr ""
"LDAP認証メカニズムの詳細については、 link:security-ldap[Authenticate with LDAP]ガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:100
#, no-wrap
msgid "Identity Providers"
msgstr "アイデンティティ・プロバイダー"

#. type: Plain text
#: upstream/_guides/security.adoc:103
msgid ""
"`IdentityProvider` converts the authentication credentials provided by "
"`HttpAuthenticationMechanism` to `SecurityIdentity`."
msgstr ""
"`IdentityProvider`  は、 `HttpAuthenticationMechanism`  が提供する認証資格情報を "
"`SecurityIdentity`  に変換します。"

#. type: Plain text
#: upstream/_guides/security.adoc:106
msgid ""
"Some extensions such as `OIDC`, `OAuth2`, `SmallRye JWT`, `LDAP` have the "
"inlined `IdentityProvider` implementations which are specific to the "
"supported authentication flow.  For example, `quarkus-oidc` uses its own "
"`IdentityProvider` to convert a token to `SecurityIdentity`."
msgstr ""
"`OIDC` , `OAuth2` , `SmallRye JWT` , `LDAP`  "
"などのエクステンションには、サポートされている認証フローに固有の `IdentityProvider` のインライン実装があります。例えば、 "
"`quarkus-oidc` は独自の `IdentityProvider` を使用してトークンを `SecurityIdentity` に変換します。"

#. type: Plain text
#: upstream/_guides/security.adoc:108
msgid ""
"If you use `Basic` or `Form` HTTP-based authentication then you have to add "
"an `IdentityProvider` which can convert a user name and password to "
"`SecurityIdentity`."
msgstr ""
"`Basic` または `Form` HTTP ベースの認証を使用している場合は、ユーザー名とパスワードを `SecurityIdentity` "
"に変換できる `IdentityProvider` を追加する必要があります。"

#. type: Plain text
#: upstream/_guides/security.adoc:111
msgid ""
"See link:security-jpa[JPA IdentityProvider] and link:security-jdbc[JDBC "
"IdentityProvider] for more information.  You can also use link:security-"
"testing#configuring-user-information[User Properties IdentityProvider] for "
"testing."
msgstr ""
"詳細は、 link:security-jpa[JPA IdentityProvider]および link:security-jdbc[JDBC "
"IdentityProvider]を参照してください。また、テストに link:security-testing#configuring-user-"
"information[User Properties IdentityProvider を]使用することもできます。"

#. type: Title ==
#: upstream/_guides/security.adoc:112
#, no-wrap
msgid "Combining Authentication Mechanisms"
msgstr "認証メカニズムの組み合わせ"

#. type: Plain text
#: upstream/_guides/security.adoc:116
msgid ""
"One can combine multiple authentication mechanisms if they get the "
"authentication credentials from the different sources.  For example, "
"combining built-in `Basic` and `quarkus-oidc` `Bearer` authentication "
"mechanisms is allowed, but combining `quarkus-oidc` `Bearer` and `smallrye-"
"jwt` authentication mechanisms is not allowed because both will attempt to "
"verify the token extracted from the HTTP `Authorization Bearer` scheme."
msgstr ""
"異なるソースから認証証明書を取得する場合、複数の認証メカニズムを組み合わせることができます。例えば、組み込みの `Basic`  と `Bearer`  "
" `quarkus-oidc`  認証機構を組み合わせることはできますが、 `quarkus-oidc`   `Bearer`  と `smallrye-"
"jwt`  認証機構を組み合わせることはできません。なぜなら、両方とも HTTP `Authorization Bearer`  "
"スキームから抽出されたトークンを検証しようとするからです。"

#. type: Title ==
#: upstream/_guides/security.adoc:117
#, no-wrap
msgid "Proactive Authentication"
msgstr "プロアクティブ認証"

#. type: Plain text
#: upstream/_guides/security.adoc:121
msgid ""
"By default, Quarkus does what we call proactive authentication. This means "
"that if an incoming request has a credential then that request will always "
"be authenticated (even if the target page does not require authentication)."
msgstr ""
"デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます（ターゲットページが認証を必要としない場合でも）。"

#. type: Plain text
#: upstream/_guides/security.adoc:123
msgid ""
"See link:security-built-in-authentication#proactive-authentication[Proactive "
"Authentication] for more information."
msgstr ""
"詳細については、 link:security-built-in-authentication#proactive-"
"authentication[プロアクティブ認証]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:124
#, no-wrap
msgid "Authorization"
msgstr "認可"

#. type: Plain text
#: upstream/_guides/security.adoc:127
msgid ""
"See link:security-authorization[Security Authorization] for more information "
"about Role Based Access Control and other authorization options."
msgstr ""
"役割ベースのアクセス制御およびその他の認可オプションの詳細については、 link:security-"
"authorization[セキュリティ認可]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:128
#, no-wrap
msgid "Customization and other useful tips"
msgstr "カスタマイズやその他の便利なヒント"

#. type: Plain text
#: upstream/_guides/security.adoc:131
msgid ""
"Quarkus Security is highly customizable. One can register custom "
"``HttpAuthenticationMechanism``s, ``IdentityProvider``s and "
"``SecurityidentityAugmentor``s."
msgstr ""
"Quarkus Securityは、高度なカスタマイズが可能です。カスタム `HttpAuthenticationMechanism` 、 "
"`IdentityProvider` 、 `SecurityidentityAugmentor` を登録することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:133
msgid ""
"See link:security-customization[Security Customization] for more information "
"about customizing Quarkus Security and other useful tips about the reactive "
"security, registering the security providers, etc."
msgstr ""
"Quarkus "
"Securityのカスタマイズの詳細や、リアクティブセキュリティ、セキュリティプロバイダーの登録などの便利なヒントについては、セキュリティの link:"
"security-customization[カスタマイズ]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:134
#, no-wrap
msgid "Secure connections with SSL"
msgstr "SSLによる安全な接続"

#. type: Plain text
#: upstream/_guides/security.adoc:137
msgid ""
"See the link:http-reference#ssl[Supporting secure connections with SSL] "
"guide for more information."
msgstr "詳細については、 link:http-reference#ssl[SSL による安全な接続のサポート]ガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:138
#, no-wrap
msgid "Cross-Origin Resource Sharing"
msgstr "クロスオリジンリソース共有"

#. type: Plain text
#: upstream/_guides/security.adoc:141
msgid ""
"If you plan to make your Quarkus application accessible to another "
"application running on a different domain, you will need to configure CORS "
"(Cross-Origin Resource Sharing). Please read the link:http-reference#cors-"
"filter[HTTP CORS documentation] for more information."
msgstr ""
"Quarkusアプリケーションを別のドメインで実行している別のアプリケーションにアクセスできるようにする場合は、CORS（Cross-Origin "
"Resource Sharing）を設定する必要があります。詳細については、 link:http-reference#cors-filter[HTTP "
"CORSのドキュメント]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:142
#, no-wrap
msgid "SameSite cookies"
msgstr "SameSiteクッキー"

#. type: Plain text
#: upstream/_guides/security.adoc:145
msgid ""
"Please see link:vertx#same-site-cookie for information about adding a https:/"
"/developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/"
"SameSite[SameSite] cookie property to any of the cookies set by a Quarkus "
"endpoint."
msgstr ""
"Quarkusのエンドポイントによって設定されたCookieに link:https://developer.mozilla.org/en-US/"
"docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite]Cookieプロパティを追加する方法については、 "
"link:vertx#sam-site-cookie を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:146
#, no-wrap
msgid "Testing"
msgstr "テスト"

#. type: Plain text
#: upstream/_guides/security.adoc:149
msgid ""
"See link:security-testing[Security Testing] for more information about "
"testing Quarkus Security."
msgstr ""
"Quarkus Securityのテストの詳細については、 link:security-testing[セキュリティのテスト]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:150
#, no-wrap
msgid "Secret Engines"
msgstr "シークレットエンジン"

#. type: Title ===
#: upstream/_guides/security.adoc:151
#, no-wrap
msgid "Vault"
msgstr "Vault"

#. type: Plain text
#: upstream/_guides/security.adoc:152
msgid ""
"Quarkus provides a very comprehensive HashiCorp Vault support, please see "
"the link:vault[Quarkus and HashiCorp Vault] documentation for more "
"information."
msgstr ""
"Quarkusは非常に包括的な HashiCorp Vault のサポートを提供しています。詳しくは link:vault[Quarkus and "
"HashiCorp Vault] のドキュメントを参照下さい。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:21
#, fuzzy
msgid "Apache Maven 3.6.2+"
msgstr "Apache Maven 3.6.2+"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:38
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=sending-email-quickstart \\\n"
"    -Dextensions=\"mailer\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:62
#, no-wrap
msgid ""
"quarkus.mailer.from=test@quarkus.io\n"
"quarkus.mailer.host=smtp.sendgrid.net\n"
"quarkus.mailer.port=465\n"
"quarkus.mailer.ssl=true\n"
"quarkus.mailer.username=....\n"
"quarkus.mailer.password=....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:84
#, fuzzy
msgid ""
"`io.quarkus.mailer.ReactiveMailer` provides the reactive (non-blocking and "
"asynchronous) API"
msgstr ""
"`io.quarkus.mailer.ReactiveMailer` は反応的な (ノンブロッキングで非同期の) API を提供しています。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:95
#, no-wrap
msgid ""
"// Imperative API:\n"
"mailer.send(Mail.withText(\"to@acme.org\", \"A simple email from quarkus\", "
"\"This is my body.\"));\n"
"// Reactive API:\n"
"CompletionStage<Void> stage = reactiveMailer.send(Mail.withText(\"to@acme."
"org\", \"A reactive email from quarkus\", \"This is my body.\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:115
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/async\")\n"
"public CompletionStage<Response> sendASimpleEmailAsync() {\n"
"    return reactiveMailer.send(\n"
"            Mail.withText(\"to@acme.org\", \"A reactive email from "
"quarkus\", \"This is my body\"))\n"
"            .thenApply(x -> Response.accepted().build());\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:242
#, no-wrap
msgid ""
"quarkus.mailer.from=YOUREMAIL@gmail.com\n"
"quarkus.mailer.host=smtp.gmail.com\n"
"quarkus.mailer.port=587\n"
"quarkus.mailer.start-tls=REQUIRED\n"
"quarkus.mailer.username=YOUREMAIL@gmail.com\n"
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:254
#, no-wrap
msgid ""
"quarkus.mailer.from=YOUREMAIL@gmail.com\n"
"quarkus.mailer.host=smtp.gmail.com\n"
"quarkus.mailer.port=465\n"
"quarkus.mailer.ssl=true\n"
"quarkus.mailer.username=YOUREMAIL@gmail.com\n"
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:260
#, fuzzy
msgid ""
"Note that if you enable SSL for the mailer and you want to build a native "
"executable, you will need to enable the SSL support.  Please refer to the "
"native-and-ssl-guide.html[Using SSL With Native Executables] guide for more "
"information."
msgstr ""
"メーラーのSSLを有効にして、ネイティブ実行ファイルを構築する場合は、SSL対応を有効にする必要がありますのでご注意ください。詳しくは、native-"
"and-ssl-guide.html[Using SSL With Native Executables]ガイドを参照してください。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:269
#, no-wrap
msgid "@Inject MailClient client;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:272
#, fuzzy
msgid "Three API flavors are exposed:"
msgstr "3つのAPIフレーバーが公開されています。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:274
#, fuzzy
msgid ""
"the Axle client (`io.vertx.axle.ext.mail.MailClient`), using "
"`CompletionStage` and Reactive Streams `Publisher`"
msgstr ""
"Axle クライアント ( `io.vertx.axle.ext.mail.MailClient`) を使用して、 `CompletionStage` "
"と Reactive Streams を使用します。 `Publisher`"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:275
#, fuzzy
msgid "the RX Java 2 client (`io.vertx.reactivex.ext.mail.MailClient`)"
msgstr "RX Java 2 クライアント ( `io.vertx.reactivex.ext.mail.MailClient`)"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:276
#, fuzzy
msgid "the bare client (`io.vertx.ext.mail.MailClient`)"
msgstr "ベアクライアント ( `io.vertx.ext.mail.MailClient`)"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:278
#, fuzzy
msgid ""
"Check the link:using-vertx.html[Using Vert.x guide] for further details "
"about these different APIs and how to select the most suitable for you."
msgstr ""
"これらの異なる API の詳細と、あなたに最も適した API を選択する方法については、 link:using-vertx.html[Using "
"Vert.x ガイドを]確認してください。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:281
#, fuzzy
msgid ""
"The retrieved `MailClient` is configured using the configuration key "
"presented above.  You can also create your own instance, and pass your own "
"configuration."
msgstr ""
"取得した `MailClient` は、上記で提示した設定キーを使用して設定します。また、独自のインスタンスを作成し、独自の設定を渡すこともできます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/grpc.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus gRPC"
msgstr "クォークラスジーアールピーシー"

#. type: Plain text
#: upstream/_guides/grpc.adoc:13
#, fuzzy
msgid ""
"https://grpc.io/[gRPC] is a high-performance RPC framework.  It can "
"efficiently connect services implemented using various languages and "
"frameworks.  It is also applicable in the last mile of distributed computing "
"to connect devices, mobile applications, and browsers to backend services."
msgstr ""
"link:https://grpc.io/"
"[gRPCは]高性能なRPCフレームワークです。様々な言語やフレームワークを使って実装されたサービスを効率的に接続することができます。また、デバイスやモバイルアプリケーション、ブラウザとバックエンドサービスを接続するために、分散コンピューティングのラストワンマイルにも適用可能です。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:16
#, fuzzy
msgid ""
"In general, gRPC uses HTTP/2, TLS, and https://developers.google.com/"
"protocol-buffers[Protobuf (Protocol Buffers)].  In a microservice "
"architecture, gRPC is an efficient, type-safe alternative to HTTP."
msgstr ""
"一般的に、gRPCはHTTP/2、TLS、 link:https://developers.google.com/protocol-"
"buffers[Protobuf（プロトコルバッファ）を]使用します。マイクロサービスアーキテクチャでは、gRPCはHTTPに代わる効率的で型安全な代替手段です。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:19
#, fuzzy
msgid "The Quarkus gRPC extension integrate gRPC in Quarkus application.  It:"
msgstr "QuarkusのgRPC拡張機能は、QuarkusアプリケーションにgRPCを統合します。それは"

#. type: Plain text
#: upstream/_guides/grpc.adoc:21
#, fuzzy
msgid "supports implementing gRPC services"
msgstr "gRPCサービスの実装をサポートしています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:22
#, fuzzy
msgid "supports consuming gRPC services"
msgstr "gRPC サービスの消費をサポートしています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:23
#, fuzzy
msgid ""
"integrates with the reactive engine from Quarkus as well as the reactive "
"development model"
msgstr "は、Quarkusのリアクティブエンジンやリアクティブ開発モデルと統合されています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:24
#, fuzzy
msgid ""
"allows plain-text communication as well as TLS, and TLS with mutual "
"authentication"
msgstr "平文通信に加えてTLS、相互認証付きのTLSも可能です。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:26
#, fuzzy
msgid ""
"Quarkus gRPC is based on https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC]."
""
msgstr ""
"Quarkus gRPCは link:https://vertx.io/docs/vertx-grpc/java/[Vert.x "
"gRPCを]ベースにしています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:28
#, fuzzy
msgid "link:./grpc-getting-started.adoc[Getting Started]"
msgstr "link:./grpc-getting-started.adoc[はじめに]"

#. type: Plain text
#: upstream/_guides/grpc.adoc:29
#, fuzzy
msgid "link:./grpc-service-implementation.adoc[Implementing a gRPC Service]"
msgstr "link:./grpc-service-implementation.adoc[gRPCサービスの実装]"

#. type: Plain text
#: upstream/_guides/grpc.adoc:29
#, fuzzy
msgid "link:./grpc-service-consumption.adoc[Consuming a gRPC Service]"
msgstr "link:./grpc-service-consumption.adoc[gRPC サービスを消費する]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/tika.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using Apache Tika"
msgstr "Quarkus - Apache Tikaの使用"

#. type: Plain text
#: upstream/_guides/tika.adoc:11
#, fuzzy
msgid ""
"This guide explains how your Quarkus application can use https://tika.apache."
"org/[Apache Tika] to parse the documents."
msgstr ""
"このガイドでは、Quarkusアプリケーションが link:https://tika.apache.org/[Apache "
"Tika]を使用してドキュメントを解析する方法について説明します。"

#. type: Plain text
#: upstream/_guides/tika.adoc:13
#, fuzzy
msgid ""
"https://tika.apache.org/[Apache Tika] is a content analysis toolkit which is "
"used to parse the documents in PDF, Open Document, Excel and many other well "
"known binary and text formats using a simple uniform API. Both the document "
"text and properties (metadata) are available once the document has been "
"parsed."
msgstr ""
"link:https://tika.apache.org/[Apache Tika は]コンテンツ分析ツールキットで、シンプルな統一 API を使って "
"PDF, Open Document, Excel "
"やその他多くのよく知られたバイナリやテキスト形式の文書を解析するのに使われます。文書のテキストとプロパティ (メタデータ) "
"の両方が、文書が解析されると利用可能になります。"

#. type: delimited block =
#: upstream/_guides/tika.adoc:17
#, fuzzy
msgid ""
"If you are planning to run the application as a native executable and parse "
"documents that may have been created with charsets different than the "
"standard ones supported in Java such as `UTF-8` then you should configure "
"Quarkus Maven Plugin to get the native image generator include all the "
"charsets available to the JVM:"
msgstr ""
"アプリケーションをネイティブ実行ファイルとして実行し、 `UTF-8` "
"のようなJavaでサポートされている標準の文字セットとは異なる文字セットで作成された可能性のあるドキュメントを解析する場合は、Quarkus Maven "
"Pluginを設定して、ネイティブイメージジェネレータがJVMで利用可能なすべての文字セットを含むようにする必要があります。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:35
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-maven-plugin</artifactId>\n"
"    <executions>\n"
"        <execution>\n"
"            <id>native-image</id>\n"
"            <goals>\n"
"                <goal>native-image</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <addAllCharsets>true</addAllCharsets>\n"
"                ...\n"
"            </configuration>\n"
"        </execution>\n"
"    </executions>\n"
"</plugin>\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/tika.adoc:44
#, fuzzy
msgid "less than 20 minutes"
msgstr "二十分弱"

#. type: delimited block =
#: upstream/_guides/tika.adoc:48
#, fuzzy
msgid "Docker"
msgstr "ドッカー"

#. type: delimited block =
#: upstream/_guides/tika.adoc:49
#, fuzzy
msgid ""
"link:building-native-image[GraalVM installed if you want to run in native "
"mode]"
msgstr "link:building-native-image[ネイティブモードで動作させたい場合は、GraalVMをインストールしてください。]"

#. type: delimited block =
#: upstream/_guides/tika.adoc:58
#, fuzzy
msgid ""
"The solution is located in the `tika-quickstart` {quickstarts-tree-url}/tika-"
"quickstart[directory]."
msgstr ""
"ソリューションは `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory] "
"にあります。"

#. type: Plain text
#: upstream/_guides/tika.adoc:62
#, fuzzy
msgid ""
"The provided solution contains a few additional elements such as tests and "
"testing infrastructure."
msgstr "提供されるソリューションには、テストやテストのインフラストラクチャなど、いくつかの追加要素が含まれています。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:78
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme.example \\\n"
"    -DprojectArtifactId=tika-quickstart \\\n"
"    -DclassName=\"org.acme.tika.TikaParserResource\" \\\n"
"    -Dpath=\"/parse\" \\\n"
"    -Dextensions=\"tika,resteasy\"\n"
"cd tika-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:81
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `tika` and `resteasy` "
"extensions."
msgstr "このコマンドは、 `tika` と `resteasy` の拡張子をインポートして、Maven プロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/tika.adoc:84
#, fuzzy
msgid ""
"If you already have your Quarkus project configured you can add the `tika` "
"and `resteasy` extensions to your project by running the following command "
"in your project base directory."
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで次のコマンドを実行することで、 `tika` と "
"`resteasy` の拡張子をプロジェクトに追加できます。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:88
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"tika,resteasy\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:102
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-tika</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/tika.adoc:104
#, no-wrap, fuzzy
msgid "Examine the generated JAX-RS resource"
msgstr "生成されたJAX-RSリソースを調べる"

#. type: Plain text
#: upstream/_guides/tika.adoc:107
#, fuzzy
msgid ""
"Open the `src/main/java/org/acme/tika/TikaParserResource.java` file and see "
"the following content:"
msgstr ""
"`src/main/java/org/acme/tika/TikaParserResource.java` "
"ファイルを開くと、以下のような内容が表示されます。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:111 upstream/_guides/tika.adoc:135
#, no-wrap
msgid "package org.acme.tika;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:119
#, no-wrap
msgid "@Path(\"/parse\")\n"
"public class TikaParserResource {\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/tika.adoc:128
#, no-wrap, fuzzy
msgid "Update the JAX-RS resource"
msgstr "JAX-RSリソースの更新"

#. type: Plain text
#: upstream/_guides/tika.adoc:131
#, fuzzy
msgid ""
"Next update `TikaParserResource` to accept and parse PDF and OpenDocument "
"format documents:"
msgstr ""
"次に `TikaParserResource` を更新して、PDF および OpenDocument 形式の文書を受け入れて解析するようにします。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:139
#, no-wrap
msgid ""
"import java.io.InputStream;\n"
"import java.time.Duration;\n"
"import java.time.Instant;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:146
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:149
#, no-wrap
msgid "import io.quarkus.tika.TikaParser;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:153
#, no-wrap
msgid ""
"@Path(\"/parse\")\n"
"public class TikaParserResource {\n"
"    private static final Logger log = Logger.getLogger(TikaParserResource."
"class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:156
#, no-wrap
msgid "    @Inject\n"
"    TikaParser parser;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:163
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/text\")\n"
"    @Consumes({\"application/pdf\", \"application/vnd.oasis.opendocument."
"text\"})\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String extractText(InputStream stream) {\n"
"        Instant start = Instant.now();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:165
#, no-wrap
msgid "        String text = parser.getText(stream);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:167
#, no-wrap
msgid "        Instant finish = Instant.now();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:169
#, no-wrap
msgid ""
"        log.info(Duration.between(start, finish).toMillis() + \" mls have "
"passed\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:173
#, no-wrap
msgid "        return text;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:176
#, fuzzy
msgid ""
"As you can see the JAX-RS resource method was renamed to `extractText`, "
"`@GET` annotation was replaced with `POST` and `@Path(/text)` annotation was "
"added, and `@Consumes` annotation shows that PDF and OpenDocument media type "
"formats can now be accepted. An injected `TikaParser` is used to parse the "
"documents and report the extracted text. It also measures how long does it "
"take to parse a given document."
msgstr ""
"ご覧のように、JAX-RSのリソースメソッドの名前が `extractText` に変更され、 `@GET` アノテーションが `POST` "
"に置き換わり、 `@Path(/text)` アノテーションが追加され、 `@Consumes` アノテーションでは、PDF と "
"OpenDocument のメディアタイプのフォーマットが受け入れられるようになったことが示されています。注入された `TikaParser` "
"は、文書を解析し、抽出されたテキストを報告するために使用されます。また、与えられた文書を解析するのにどのくらいの時間がかかるかを測定します。"

#. type: Title ==
#: upstream/_guides/tika.adoc:177
#, no-wrap, fuzzy
msgid "Run the application"
msgstr "アプリケーションの実行"

#. type: Plain text
#: upstream/_guides/tika.adoc:180
#, fuzzy
msgid "Now we are ready to run our application. Use:"
msgstr "これで、アプリケーションを実行する準備が整いました。使用してください。"

#. type: Plain text
#: upstream/_guides/tika.adoc:187
#, fuzzy
msgid "and you should see output similar to:"
msgstr "のような出力が表示されるはずです。"

#. type: Block title
#: upstream/_guides/tika.adoc:188
#, no-wrap, fuzzy
msgid "quarkus:dev Output"
msgstr "quarkus:dev 出力"

#. type: delimited block -
#: upstream/_guides/tika.adoc:206
#, no-wrap
msgid ""
"$ ./mvnw clean compile quarkus:dev\n"
"[INFO] Scanning for projects...\n"
"[INFO]\n"
"INFO] --------------------< org.acme.example:apache-tika >-------------------"
"-\n"
"[INFO] Building apache-tika 1.0-SNAPSHOT\n"
"[INFO] --------------------------------[ jar ]-------------------------------"
"--\n"
"...\n"
"Listening for transport dt_socket at address: 5005\n"
"2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning "
"quarkus augmentation\n"
"2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running "
"without servlet container.\n"
"2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-"
"undertow to run Resteasy within a servlet container\n"
"2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus "
"augmentation completed in 549ms\n"
"2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT "
"started in 1.361s. Listening on: http://0.0.0.0:8080\n"
"2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. "
"Live Coding activated.\n"
"2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, "
"resteasy, tika]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:209
#, fuzzy
msgid ""
"Now that the REST endpoint is running, we can get it to parse PDF and "
"OpenDocument documents using a command line tool like curl:"
msgstr ""
"REST エンドポイントが実行されているので、curl のようなコマンドラインツールを使用して PDF や OpenDocument "
"ドキュメントを解析することができます。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:214
#, no-wrap
msgid ""
"$ curl -X POST -H \"Content-type: application/pdf\" --data-binary @target/"
"classes/quarkus.pdf http://localhost:8080/parse/text\n"
"Hello Quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:217
#, fuzzy
msgid "and"
msgstr "そして"

#. type: delimited block -
#: upstream/_guides/tika.adoc:222
#, no-wrap
msgid ""
"$ curl -X POST -H \"Content-type: Content-type: application/vnd.oasis."
"opendocument.text\" --data-binary @target/classes/quarkus.odt http://"
"localhost:8080/parse/text\n"
"Hello Quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:228
#, fuzzy
msgid ""
"You can build a native executable with the usual command `./mvnw package -"
"Pnative`.  Running it is as simple as executing `./target/tika-quickstart-1."
"0-SNAPSHOT-runner`."
msgstr ""
"通常のコマンド `./mvnw package -Pnative` でネイティブの実行ファイルをビルドできます。実行は `./target/tika-"
"quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/spring-web.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Quarkus Extension for Spring Web API"
msgstr "Quarkus - Spring Web API用のQuarkus拡張機能"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:12
#, fuzzy
msgid ""
"While users are encouraged to use JAX-RS annotation for defining REST "
"endpoints, Quarkus provides a compatibility layer for Spring Web in the form "
"of the `spring-web` extension."
msgstr ""
"ユーザーはRESTエンドポイントの定義にJAX-RSアノテーションを使用することが推奨されていますが、QuarkusはSpring "
"Web用の互換性レイヤーを `spring-web` 拡張の形で提供しています。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:14
#, fuzzy
msgid ""
"This guide explains how a Quarkus application can leverage the well known "
"Spring Web annotations to define RESTful services."
msgstr ""
"このガイドでは、Quarkusアプリケーションがよく知られているSpring "
"Webアノテーションを活用してRESTfulサービスを定義する方法について説明します。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:35
#, fuzzy
msgid ""
"The solution is located in the `spring-web-quickstart` {quickstarts-tree-"
"url}/spring-web-quickstart[directory]."
msgstr ""
"ソリューションは `spring-web-quickstart` {quickstarts-tree-url}/spring-web-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:49
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=spring-web-quickstart \\\n"
"    -DclassName=\"org.acme.spring.web.GreetingController\" \\\n"
"    -Dpath=\"/greeting\" \\\n"
"    -Dextensions=\"spring-web\"\n"
"cd spring-web-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:52
#, fuzzy
msgid ""
"This command generates a Maven project with a REST endpoint and imports the "
"`spring-web` extension."
msgstr "このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、 `spring-web` 拡張子をインポートします。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:55
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `spring-"
"web` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `spring-"
"web` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:59
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"spring-web\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:69
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-spring-web</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:75
#, fuzzy
msgid ""
"The Quarkus maven plugin automatically generated a controller with the "
"Spring Web annotations to define our REST endpoint (instead of the JAX-RS "
"ones used by default)  The `src/main/java/org/acme/spring/web/"
"GreetingController.java` file looks as follows:"
msgstr ""
"Quarkusのmavenプラグインは、RESTエンドポイントを定義するためのSpring "
"Webアノテーションを持つコントローラを自動的に生成しました（デフォルトで使用されているJAX-RSのものではなく） `src/main/java/"
"org/acme/spring/web/GreetingController.java` ファイルは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:79 upstream/_guides/spring-web.adoc:102
#: upstream/_guides/spring-web.adoc:175
#, no-wrap
msgid "package org.acme.spring.web;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:83
#, no-wrap
msgid ""
"import org.springframework.web.bind.annotation.GetMapping;\n"
"import org.springframework.web.bind.annotation.RequestMapping;\n"
"import org.springframework.web.bind.annotation.RestController;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:87 upstream/_guides/spring-web.adoc:150
#, no-wrap
msgid ""
"@RestController\n"
"@RequestMapping(\"/greeting\")\n"
"public class GreetingController {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:93
#, no-wrap
msgid ""
"    @GetMapping\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/spring-web.adoc:95
#, no-wrap, fuzzy
msgid "GreetingControllerTest"
msgstr "グリーティングコントローラテスト"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:98
#, fuzzy
msgid "Note that a test for the controller has been created as well:"
msgstr "コントローラのテストも作成されていることに注意してください。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:184
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:108 upstream/_guides/spring-web.adoc:181
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:111 upstream/_guides/spring-web.adoc:184
#, no-wrap
msgid "@QuarkusTest\n"
"public class GreetingControllerTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:120
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/greeting\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:130
#, fuzzy
msgid "The result should be: `{\"message\": \"hello\"}`."
msgstr "結果は `{\"message\": \"hello\"}`."

#. type: Title ==
#: upstream/_guides/spring-web.adoc:135
#, no-wrap, fuzzy
msgid "Going further with an endpoint returning JSON"
msgstr "JSONを返すエンドポイントでさらに進む"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:139
#, fuzzy
msgid ""
"The `GreetingController` above was an example of a very simple endpoint. In "
"many cases however it is required to return JSON content.  The following "
"example illustrates how that could be achieved using a Spring RestController:"
""
msgstr ""
"上の `GreetingController` "
"は非常にシンプルなエンドポイントの例です。しかし多くの場合、JSONコンテンツを返す必要があります。次の例は、Spring "
"RestControllerを使ってどのように実現できるかを示しています。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:146
#, no-wrap
msgid ""
"import org.springframework.web.bind.annotation.GetMapping;\n"
"import org.springframework.web.bind.annotation.PathVariable;\n"
"import org.springframework.web.bind.annotation.RequestMapping;\n"
"import org.springframework.web.bind.annotation.RestController;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:155
#, no-wrap
msgid ""
"    @GetMapping(\"/{name}\")\n"
"    public Greeting hello(@PathVariable(name = \"name\") String name) {\n"
"        return new Greeting(\"hello \" + name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:158
#, no-wrap
msgid ""
"    public static class Greeting {\n"
"        private final String message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:162
#, no-wrap
msgid ""
"        public Greeting(String message) {\n"
"            this.message = message;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:168
#, no-wrap
msgid ""
"        public String getMessage(){\n"
"            return message;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:171
#, fuzzy
msgid "The corresponding test could look like:"
msgstr "対応するテストは次のようになります。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:193
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/greeting/quarkus\")\n"
"          .then()\n"
"            .statusCode(200)\n"
"            .body(\"message\", is(\"hello quarkus\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:198
#, fuzzy
msgid ""
"It should be noted that when using the Spring Web support in Quarkus, link:"
"https://github.com/FasterXML/jackson[Jackson] is automatically added to the "
"classpath and properly setup."
msgstr ""
"注意すべきは、QuarkusでSpring Webサポートを使用する場合、 link:https://github.com/FasterXML/"
"jackson[Jacksonは]自動的にクラスパスに追加され、適切に設定されることです。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:199
#, no-wrap, fuzzy
msgid "Adding OpenAPI and Swagger-UI"
msgstr "OpenAPIとSwagger-UIの追加"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:202
#, fuzzy
msgid ""
"You can add support for link:https://www.openapis.org/[OpenAPI] and link:"
"https://swagger.io/tools/swagger-ui/[Swagger-UI] by using the `quarkus-"
"smallrye-openapi` extension."
msgstr ""
"`quarkus-smallrye-openapi` の拡張子を使用して、 link:https://www.openapis.org/"
"[OpenAPI]と link:https://swagger.io/tools/swagger-ui/[Swagger-"
"UI]のサポートを追加することができます。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:204
#, fuzzy
msgid "Add the extension by running this command:"
msgstr "このコマンドを実行して拡張子を追加します。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:208
#, no-wrap
msgid ""
"./mvnw quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-smallrye-"
"openapi\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:218
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-openapi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:221
#, fuzzy
msgid ""
"This is enough to generate a basic OpenAPI schema document from your REST "
"Endpoints:"
msgstr "これは、REST エンドポイントから基本的な OpenAPI スキーマドキュメントを生成するのに十分です。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:225
#, no-wrap
msgid "curl http://localhost:8080/openapi\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:228
#, fuzzy
msgid "You will see the generated OpenAPI schema document:"
msgstr "生成された OpenAPI スキーマドキュメントが表示されます。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:231 upstream/_guides/spring-web.adoc:314
#, no-wrap
msgid "---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:268
#, no-wrap
msgid ""
"openapi: 3.0.1\n"
"info:\n"
"  title: Generated API\n"
"  version: \"1.0\"\n"
"paths:\n"
"  /greeting:\n"
"    get:\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                type: string\n"
"  /greeting/{name}:\n"
"    get:\n"
"      parameters:\n"
"      - name: name\n"
"        in: path\n"
"        required: true\n"
"        schema:\n"
"          type: string\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                $ref: '#/components/schemas/Greeting'\n"
"components:\n"
"  schemas:\n"
"    Greeting:\n"
"      type: object\n"
"      properties:\n"
"        message:\n"
"          type: string\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:271
#, fuzzy
msgid ""
"Also see link:https://quarkus.io/guides/openapi-swaggerui[the OpenAPI Guide]"
msgstr ""
"link:https://quarkus.io/guides/openapi-swaggerui[OpenAPIガイド]も参照してください。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:272
#, no-wrap, fuzzy
msgid "Adding MicroProfile OpenAPI Annotations"
msgstr "MicroProfile OpenAPIアノテーションの追加"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:276
#, fuzzy
msgid ""
"You can use link:https://github.com/eclipse/microprofile-open-"
"api[MicroProfile OpenAPI] to better document your schema, example, adding "
"the following to the class level of the `GreetingController`:"
msgstr ""
"link:https://github.com/eclipse/microprofile-open-api[MicroProfile OpenAPI "
"を]使用してスキーマをより良く文書化することができます。例えば、 `GreetingController`.NET Framework "
"のクラスレベルに以下を追加します。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:291
#, no-wrap
msgid ""
"@OpenAPIDefinition(\n"
"    info = @Info(\n"
"        title=\"Greeting API\",\n"
"        version = \"1.0.1\",\n"
"        contact = @Contact(\n"
"            name = \"Greeting API Support\",\n"
"            url = \"http://exampleurl.com/contact\",\n"
"            email = \"techsupport@example.com\"),\n"
"        license = @License(\n"
"            name = \"Apache 2.0\",\n"
"            url = \"http://www.apache.org/licenses/LICENSE-2.0.html\"))\n"
")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:294
#, fuzzy
msgid "And describe your endpoints like this:"
msgstr "そして、エンドポイントをこのように記述してください。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:302
#, no-wrap
msgid ""
"@Tag(name = \"Hello\", description = \"Just say hello\")\n"
"@GetMapping(produces=MediaType.TEXT_PLAIN_VALUE)\n"
"public String hello() {\n"
"    return \"hello\";\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:308
#, no-wrap
msgid ""
"@GetMapping(value = \"/{name}\", produces=MediaType.APPLICATION_JSON_VALUE)\n"
"@Tag(name = \"Hello to someone\", description = \"Just say hello to "
"someone\")\n"
"public Greeting hello(@PathVariable(name = \"name\") String name) {\n"
"    return new Greeting(\"hello \" + name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:311
#, fuzzy
msgid "will generate this OpenAPI schema:"
msgstr "はこのOpenAPIスキーマを生成します。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:367
#, no-wrap
msgid ""
"openapi: 3.0.1\n"
"info:\n"
"  title: Greeting API\n"
"  contact:\n"
"    name: Greeting API Support\n"
"    url: http://exampleurl.com/contact\n"
"    email: techsupport@example.com\n"
"  license:\n"
"    name: Apache 2.0\n"
"    url: http://www.apache.org/licenses/LICENSE-2.0.html\n"
"  version: 1.0.1\n"
"tags:\n"
"- name: Hello\n"
"  description: Just say hello\n"
"- name: Hello to someone\n"
"  description: Just say hello to someone\n"
"paths:\n"
"  /greeting:\n"
"    get:\n"
"      tags:\n"
"      - Hello\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                type: string\n"
"  /greeting/{name}:\n"
"    get:\n"
"      tags:\n"
"      - Hello to someone\n"
"      parameters:\n"
"      - name: name\n"
"        in: path\n"
"        required: true\n"
"        schema:\n"
"          type: string\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                $ref: '#/components/schemas/Greeting'\n"
"components:\n"
"  schemas:\n"
"    Greeting:\n"
"      type: object\n"
"      properties:\n"
"        message:\n"
"          type: string\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/spring-web.adoc:369
#, no-wrap, fuzzy
msgid "Using Swagger UI"
msgstr "SwaggerのUIを使う"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:373
#, fuzzy
msgid ""
"Swagger UI is included by default when running in `Dev` or `Test` mode, and "
"can optionally added to `Prod` mode.  See link:https://quarkus.io/guides/"
"openapi-swaggerui#use-swagger-ui-for-development[the Swagger UI] Guide for "
"more details."
msgstr ""
"Swagger UIは、 `Dev` または `Test` モードで実行しているときにデフォルトで含まれており、オプションで `Prod` "
"モードに追加することができます。詳細については、 link:https://quarkus.io/guides/openapi-"
"swaggerui#use-swagger-ui-for-development[Swagger]UIガイドを参照してください。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:375
#, fuzzy
msgid ""
"Navigate to link:http://localhost:8080/swagger-ui/[localhost:8080/swagger-ui/"
"] and you will see the Swagger UI screen:"
msgstr ""
"link:http://localhost:8080/swagger-ui/[localhost:8080/swagger-ui/"
"]に移動すると、Swagger UIの画面が表示されます。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:377
#, fuzzy
msgid "image:spring-web-guide-screenshot01.png[alt=Swagger UI]"
msgstr "image:spring-web-guide-screenshot01.png[alt=Swagger UI]"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:378
#, no-wrap, fuzzy
msgid "Supported Spring Web functionalities"
msgstr "サポートされているSpring Webの機能"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:382
#, fuzzy
msgid ""
"Quarkus currently supports a subset of the functionalities that Spring Web "
"provides. More specifically Quarkus supports the REST related features of "
"Spring Web (think of `@RestController` instead of `@Controller`)."
msgstr ""
"Quarkusは現在、Spring Webが提供する機能のサブセットをサポートしています。より具体的には、QuarkusはSpring "
"WebのREST関連機能をサポートしています（ `@Controller` ではなく、 `@RestController` と考えてください）。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:383
#, no-wrap, fuzzy
msgid "Annotations"
msgstr "アノテーション"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:386
#, fuzzy
msgid "The table below summarizes the supported annotations:"
msgstr "下の表は、サポートされているアノテーションをまとめたものです。"

#. type: Block title
#: upstream/_guides/spring-web.adoc:387
#, no-wrap, fuzzy
msgid "Supported Spring Web annotation"
msgstr "サポートされているSpring Webアノテーション"

#. type: Table
#: upstream/_guides/spring-web.adoc:424
#, no-wrap, fuzzy
msgid ""
"|Name|Comments\n"
"\n"
"|@RestController\n"
"|\n"
"\n"
"|@RequestMapping\n"
"|\n"
"|@GetMapping\n"
"|\n"
"|@PostMapping\n"
"|\n"
"|@PutMapping\n"
"|\n"
"|@DeleteMapping\n"
"|\n"
"|@PatchMapping\n"
"|\n"
"|@RequestParam\n"
"|\n"
"|@RequestHeader\n"
"|\n"
"|@MatrixVariable\n"
"|\n"
"|@PathVariable\n"
"|\n"
"|@CookieValue\n"
"|\n"
"|@RequestBody\n"
"|\n"
"|@ResponseStatus\n"
"|\n"
"|@ExceptionHandler\n"
"|Can only be used in a @RestControllerAdvice class, not on a per-controller "
"basis\n"
"|@RestControllerAdvice\n"
"|Only the @ExceptionHandler capability is supported\n"
msgstr "|名前|コメント"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:426
#, no-wrap, fuzzy
msgid "Controller method return types"
msgstr "コントローラメソッドの戻り値の型"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:429 upstream/_guides/spring-web.adoc:444
#, fuzzy
msgid "The following method return types are supported:"
msgstr "以下のメソッドの戻り値の型がサポートされています。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:431
#, fuzzy
msgid "Primitive types"
msgstr "原始型"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:432
#, fuzzy
msgid ""
"String (which will be used as a literal, no Spring MVC view support is "
"provided)"
msgstr "文字列 (リテラルとして使用されます。Spring MVC ビューのサポートはありません)"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:433
#, fuzzy
msgid "POJO classes which will be serialized via JSON"
msgstr "JSON 経由でシリアライズされる POJO クラス"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:434 upstream/_guides/spring-web.adoc:446
#, fuzzy
msgid "`org.springframework.http.ResponseEntity`"
msgstr "`org.springframework.http.ResponseEntity`"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:435
#, no-wrap, fuzzy
msgid "Controller method parameter types"
msgstr "コントローラメソッドのパラメータの種類"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:440
#, fuzzy
msgid ""
"In addition to the method parameters that can be annotated with the "
"appropriate Spring Web annotations from the previous table, `javax.servlet."
"http.HttpServletRequest` and `javax.servlet.http.HttpServletResponse` are "
"also supported.  For this to function however, users need to add the "
"`quarkus-undertow` dependency."
msgstr ""
"前の表の適切なSpring Webアノテーションでアノテーションできるメソッドパラメータに加えて、 `javax.servlet.http."
"HttpServletRequest` と `javax.servlet.http.HttpServletResponse` "
"もサポートされています。ただし、これを機能させるためには `quarkus-undertow` 依存関係を追加する必要があります。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:441
#, no-wrap, fuzzy
msgid "Exception handler method return types"
msgstr "例外ハンドラメソッドの戻り値の型"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:447
#, fuzzy
msgid "`java.util.Map`"
msgstr "`java.util.Map`"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:449
#, fuzzy
msgid ""
"Other return types mentioned in the Spring `https://docs.spring.io/spring-"
"framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html[ExceptionHandler javadoc]` are not supported."
msgstr ""
"Springで言及されている他の戻り値の型 `&lt;a href=\"https://docs.spring.io/spring-framework/"
"docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html\"&gt;ExceptionHandler javadoc&lt;/a&gt;`はサポートされていません。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:450
#, no-wrap, fuzzy
msgid "Exception handler method parameter types"
msgstr "例外ハンドラメソッドのパラメータタイプ"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:453
#, fuzzy
msgid "The following parameter types are supported, in arbitrary order:"
msgstr "以下のパラメータタイプがサポートされています。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:455
#, fuzzy
msgid ""
"An exception argument: declared as a general `Exception` or as a more "
"specific exception. This also serves as a mapping hint if the annotation "
"itself does not narrow the exception types through its `value()`."
msgstr ""
"例外引数：一般的な `Exception` として宣言された例外、またはより具体的な例外として宣言された例外。これは、アノテーション自体が "
"`value()`."

#. type: Plain text
#: upstream/_guides/spring-web.adoc:456
#, fuzzy
msgid ""
"Request and/or response objects (typically from the Servlet API). You may "
"choose any specific request/response type, e.g. `ServletRequest` / "
"`HttpServletRequest`. To use Servlet API, the `quarkus-undertow` dependency "
"needs to be added."
msgstr ""
"リクエストおよび/またはレスポンスオブジェクト (通常はサーブレット API から)。 `ServletRequest` "
"`HttpServletRequest`特定のリクエスト/レスポンスタイプを選択することができます。Servlet API を使用するには "
"`quarkus-undertow` 依存関係を追加する必要があります。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:458
#, fuzzy
msgid ""
"Other parameter types mentioned in the Spring `https://docs.spring.io/spring-"
"framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html[ExceptionHandler javadoc]` are not supported."
msgstr ""
"Springで言及されている他のパラメータタイプ `&lt;a href=\"https://docs.spring.io/spring-"
"framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html\"&gt;ExceptionHandler javadoc&lt;/a&gt;`はサポートされていません。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:459
#, no-wrap, fuzzy
msgid "Important Technical Note"
msgstr "重要な技術的注意事項"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:465
#, fuzzy
msgid ""
"Please note that the Spring support in Quarkus does not start a Spring "
"Application Context nor are any Spring infrastructure classes run.  Spring "
"classes and annotations are only used for reading metadata and / or are used "
"as user code method return types or parameter types.  What that means for "
"end users, is that adding arbitrary Spring libraries will not have any "
"effect. Moreover Spring infrastructure classes (like `org.springframework."
"beans.factory.config.BeanPostProcessor` for example) will not be executed."
msgstr ""
"QuarkusのSpringサポートは、Springアプリケーションコンテキストを起動したり、Springインフラストラクチャクラスを実行したりしないことに注意してください。Springクラスやアノテーションは、メタデータの読み込みや、ユーザーコードのメソッドの戻り値の型やパラメータの型として使用されるだけです。これはエンドユーザーにとって何を意味するかというと、任意のSpringライブラリを追加しても何の効果もないということです。さらに、Springのインフラストラクチャクラス(例えば "
"`org.springframework.beans.factory.config.BeanPostProcessor` のような)は実行されません。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:466
#, no-wrap, fuzzy
msgid "Conversion Table"
msgstr "変換テーブル"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:469
#, fuzzy
msgid ""
"The following table shows how Spring Web annotations can be converted to JAX-"
"RS annotations."
msgstr "次の表は、Spring WebアノテーションをJAX-RSアノテーションに変換する方法を示しています。"

#. type: Table
#: upstream/_guides/spring-web.adoc:512
#, no-wrap, fuzzy
msgid ""
"|Spring |JAX-RS |Comments\n"
"\n"
"|@RequestController\n"
"|\n"
"|There is no equivalent in JAX-RS. Annotating a class with @Path suffices\n"
"\n"
"|@RequestMapping(path=\"/api\")\n"
"|@Path(\"/api\")\n"
"|\n"
"\n"
"|@RequestMapping(consumes=\"application/json\")\n"
"|@Consumes(\"application/json\")\n"
"|\n"
"\n"
"|@RequestMapping(produces=\"application/json\")\n"
"|@Produces(\"application/json\")\n"
"|\n"
"\n"
"|@RequestParam\n"
"|@QueryParam\n"
"|\n"
"\n"
"|@PathVariable\n"
"|@PathParam\n"
"|\n"
"\n"
"|@RequestBody\n"
"|\n"
"|No equivalent in JAX-RS. Method parameters corresponding to the body of the "
"request are handled in JAX-RS without requiring any annotation\n"
"\n"
"|@RestControllerAdvice\n"
"|\n"
"|No equivalent in JAX-RS\n"
"\n"
"|@ResponseStatus\n"
"|\n"
"|No equivalent in JAX-RS\n"
"\n"
"|@ExceptionHandler\n"
"|\n"
"|No equivalent annotation in JAX-RS. Exceptions are handled by implementing "
"`javax.ws.rs.ext.ExceptionMapper`\n"
msgstr "|春｜JAX-RS｜コメント"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:522
#, fuzzy
msgid ""
"link:spring-cloud-config-client[Quarkus - Reading properties from Spring "
"Cloud Config Server]"
msgstr ""
"link:spring-cloud-config-client[Quarkus - Spring Cloud Config "
"Serverからプロパティを読み込む]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/tooling.adoc:6
#, no-wrap
msgid "Quarkus - Using our Tooling"
msgstr "Quarkus - ツールを使用する"

#. type: Plain text
#: upstream/_guides/tooling.adoc:12
msgid ""
"Quarkus comes with a toolchain enabling developers from live reload all the "
"way down to deploying a Kubernetes application.  In this guide, we will "
"explore:"
msgstr ""
"Quarkusには、開発者がライブリロードからKubernetesアプリケーションのデプロイまでを可能にするツールチェーンが付属しています。このガイドでは、以下を探検していきます："

#. type: Plain text
#: upstream/_guides/tooling.adoc:14
msgid "how to use link:maven-tooling[Maven] as a build tool"
msgstr "ビルドツールとしての link:maven-tooling[Maven]の使い方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:15
msgid "how to use link:gradle-tooling[Gradle] as a build tool"
msgstr "ビルドツールとしての link:gradle-tooling[Gradle]の使い方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:16
msgid "how to use the native CLI for your toolchain (coming soon)"
msgstr "ネイティブCLIのツールチェーンとしての使い方 (近日公開予定)"

#. type: Plain text
#: upstream/_guides/tooling.adoc:17
msgid "how to create and scaffold a new project"
msgstr "新規プロジェクトの作り方とスキャフォールド（足場）の作り方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:18
msgid "how to deal with extensions"
msgstr "エクステンションの扱い方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:19
msgid "how to enable live reload"
msgstr "ライブリロードを有効にする方法"

#. type: Plain text
#: upstream/_guides/tooling.adoc:20
msgid "how to develop your application in your IDE"
msgstr "IDEでアプリケーションを開発する方法"

#. type: Plain text
#: upstream/_guides/tooling.adoc:21
msgid "how to compile your application natively"
msgstr "アプリケーションをネイティブにコンパイルする方法"

#. type: Title ==
#: upstream/_guides/tooling.adoc:23
#, no-wrap
msgid "Choosing your build tool"
msgstr "ビルドツールの選択"

#. type: Plain text
#: upstream/_guides/tooling.adoc:28
msgid ""
"Quarkus comes with a toolchain to help you at all development stages.  You "
"can use Maven or Gradle as build tool.  And we offer a native CLI that is "
"convenient to use (coming soon)."
msgstr ""
"Quarkusには、すべての開発段階で役立つツールチェーンが付属しています。ビルドツールとしてMavenやGradleを使うことができます。また、使い勝手の良いネイティブCLIも提供しています（近日公開予定）。"

#. type: Plain text
#: upstream/_guides/tooling.adoc:30
msgid "link:maven-tooling[Maven]"
msgstr "link:maven-tooling[Maven]"

#. * link:cli-tooling[CLI]
#. type: Plain text
#: upstream/_guides/tooling.adoc:31
msgid "link:gradle-tooling[Gradle]"
msgstr "link:gradle-tooling[Gradle]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amqp.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using AMQP with Reactive Messaging"
msgstr "Quarkus - リアクティブメッセージングでAMQPを使用する"

#. type: Plain text
#: upstream/_guides/amqp.adoc:12
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize "
"MicroProfile Reactive Messaging to interact with AMQP."
msgstr ""
"このガイドでは、QuarkusアプリケーションがMicroProfile Reactive "
"Messagingを利用してAMQPと対話する方法を説明します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:24
#, fuzzy
msgid ""
"A running AMQP 1.0 broker, or Docker Compose to start a development cluster"
msgstr "実行中のAMQP 1.0ブローカー、またはDocker Composeで開発クラスタを起動する"

#. type: Plain text
#: upstream/_guides/amqp.adoc:33
#, fuzzy
msgid ""
"In this guide, we are going to generate (random) prices in one component.  "
"These prices are written in an AMQP queue (`prices`).  A second component "
"reads from the `prices` queue and apply some magic conversion to the price.  "
"The result is sent to an in-memory stream consumed by a JAX-RS resource.  "
"The data is sent to a browser using server-sent events."
msgstr ""
"このガイドでは、1つのコンポーネントで(ランダムな)価格を生成します。これらの価格はAMQPキュー( "
"`prices`)に書き込まれます。2番目のコンポーネントは `prices` "
"キューから読み込み、価格にいくつかの魔法の変換を適用します。その結果は、JAX-"
"RSリソースによって消費されるインメモリストリームに送られます。データは、サーバーから送られたイベントを使ってブラウザに送られます。"

#. type: Target for macro image
#: upstream/_guides/amqp.adoc:34
#, no-wrap
msgid "amqp-guide-architecture.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:44
#, fuzzy
msgid ""
"The solution is located in the `amqp-quickstart` {quickstarts-tree-url}/amqp-"
"quickstart[directory]."
msgstr ""
"ソリューションは `amqp-quickstart` {quickstarts-tree-url}/amqp-quickstart[directory] "
"にあります。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:56
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=amqp-quickstart \\\n"
"    -Dextensions=\"amqp\"\n"
"cd amqp-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:59
#, fuzzy
msgid ""
"This command generates a Maven project, importing the Reactive Messaging and "
"AMQP connector extensions."
msgstr "このコマンドは、Reactive MessagingとAMQPコネクタ拡張をインポートしてMavenプロジェクトを生成します。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:60
#, no-wrap, fuzzy
msgid "Starting an AMQP broker"
msgstr "AMQPブローカーの開始"

#. type: Plain text
#: upstream/_guides/amqp.adoc:64
#, fuzzy
msgid ""
"Then, we need an AMQP broker.  You can follow the instructions from the "
"https://activemq.apache.org/components/artemis/[Apache Artemis web site] or "
"create a `docker-compose.yaml` file with the following content:"
msgstr ""
"次に、AMQPブローカーが必要です。 link:https://activemq.apache.org/components/artemis/"
"[Apache ArtemisのWebサイト]の指示に従うか、以下の内容の `docker-compose.yaml` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:70
#, no-wrap
msgid ""
"# A docker compose file to start an Artemis AMQP broker\n"
"# more details on https://github.com/vromero/activemq-artemis-docker.\n"
"version: '2'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:72
#, no-wrap
msgid "services:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:82
#, no-wrap
msgid ""
"  artemis:\n"
"    image: vromero/activemq-artemis:2.8.0-alpine\n"
"    ports:\n"
"      - \"8161:8161\"\n"
"      - \"61616:61616\"\n"
"      - \"5672:5672\"\n"
"    environment:\n"
"      ARTEMIS_USERNAME: quarkus\n"
"      ARTEMIS_PASSWORD: quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:85
#, fuzzy
msgid "Once created, run `docker-compose up`."
msgstr "作成したら、 `docker-compose up` を実行します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:87
#, fuzzy
msgid "This is a development cluster, do not use in production."
msgstr "これは開発クラスタであり、生産では使用しないでください。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:88
#, no-wrap, fuzzy
msgid "The price generator"
msgstr "価格発生装置"

#. type: Plain text
#: upstream/_guides/amqp.adoc:91
#, fuzzy
msgid ""
"Create the `src/main/java/org/acme/amqp/PriceGenerator.java` file, with the "
"following content:"
msgstr "以下の内容の `src/main/java/org/acme/amqp/PriceGenerator.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:95 upstream/_guides/amqp.adoc:137
#: upstream/_guides/amqp.adoc:178
#, no-wrap
msgid "package org.acme.amqp;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:98
#, no-wrap
msgid "import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:103
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:110
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random prices every 5 seconds.\n"
" * The prices are written to a AMQP queue (prices). The AMQP configuration "
"is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:152
#, no-wrap
msgid "    private Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:119
#, no-wrap
msgid ""
"    @Outgoing(\"generated-price\")                        // <1>\n"
"    public Multi<Integer> generate() {                  // <2>\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
"                .onOverflow().drop()\n"
"                .map(tick -> random.nextInt(100));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:124
#, fuzzy
msgid ""
"Instruct Reactive Messaging to dispatch the items from returned stream to "
"`generated-price`."
msgstr ""
"返されたストリームから `generated-price` にアイテムをディスパッチするように Reactive Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:125
#, fuzzy
msgid ""
"The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ "
"every 5 seconds."
msgstr "このメソッドは、5秒ごとにランダムな _価格を_放出する Mutiny _ストリーム_( `Multi`) を返します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:128
#, fuzzy
msgid ""
"The method returns a _Reactive Stream_. The generated items are sent to the "
"stream named `generated-price`.  This stream is mapped to an AMQP queue "
"using the `application.properties` file that we will create soon."
msgstr ""
"このメソッドは、 _Reactive ストリーム_を返します。生成されたアイテムは `generated-price` "
"という名前のストリームに送られます。このストリームは、近日中に作成する `application.properties` ファイルを使用して AMQP "
"キューにマッピングされます。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:129
#, no-wrap, fuzzy
msgid "The price converter"
msgstr "価格コンバーター"

#. type: Plain text
#: upstream/_guides/amqp.adoc:133
#, fuzzy
msgid ""
"The price converter reads the prices from AMQP, and transforms them.  Create "
"the `src/main/java/org/acme/amqp/PriceConverter.java` file with the "
"following content:"
msgstr ""
"価格コンバータは、AMQPから価格を読み込んで変換します。以下の内容の `src/main/java/org/acme/amqp/"
"PriceConverter.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:141
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:150
#, no-wrap
msgid ""
"/**\n"
" * A bean consuming data from the \"prices\" AMQP queue and applying some "
"conversion.\n"
" * The result is pushed to the \"my-data-stream\" stream which is an in-"
"memory stream.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConverter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:152
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:159
#, no-wrap
msgid ""
"    @Incoming(\"prices\")                                  // <1>\n"
"    @Outgoing(\"my-data-stream\")                          // <2>\n"
"    @Broadcast                                           // <3>\n"
"    public double process(int priceInUsd) {\n"
"        return priceInUsd * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:164
#, fuzzy
msgid "Indicates that the method consumes the items from the `prices` channel"
msgstr "メソッドが `prices` チャンネルのアイテムを消費することを示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:165
#, fuzzy
msgid ""
"Indicates that the objects returned by the method are sent to the `my-data-"
"stream` channel"
msgstr "メソッドによって返されたオブジェクトが `my-data-stream` チャンネルに送られることを示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:166
#, fuzzy
msgid "Indicates that the item are dispatched to all _subscribers_"
msgstr "アイテムがすべての _加入者_に発送されていることを示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:169
#, fuzzy
msgid ""
"The `process` method is called for every AMQP messages from the `prices` "
"queue (configured in the application configuration).  Every result is sent "
"to the `my-data-stream` in-memory stream."
msgstr ""
"`process` メソッドは、 `prices` キュー(アプリケーション設定で設定されている)からの AMQP "
"メッセージごとに呼び出されます。すべての結果は `my-data-stream` のインメモリストリームに送信されます。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:170
#, no-wrap, fuzzy
msgid "The price resource"
msgstr "価格資源"

#. type: Plain text
#: upstream/_guides/amqp.adoc:174
#, fuzzy
msgid ""
"Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/"
"java/org/acme/amqp/PriceResource.java` file with the following content:"
msgstr ""
"最後に、ストリームをJAX-RSリソースにバインドしてみましょう。以下の内容の `src/main/java/org/acme/amqp/"
"PriceResource.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:181
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:193
#, no-wrap
msgid ""
"/**\n"
" * A simple resource retrieving the \"in-memory\" \"my-data-stream\" and "
"sending the items as server-sent events.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:196
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"my-data-stream\") Publisher<Double> prices;         // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:202
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:210
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)                     // <2>\n"
"    public Publisher<Double> stream() {                         // <3>\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:212
#, fuzzy
msgid "Injects the `my-data-stream` channel using the `@Channel` qualifier"
msgstr "`@Channel` の修飾子を使って `my-data-stream` チャンネルを注入します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:213
#, fuzzy
msgid "Indicates that the content is sent using `Server Sent Events`"
msgstr "を使用してコンテンツが送信されていることを示します。 `Server Sent Events`"

#. type: Plain text
#: upstream/_guides/amqp.adoc:214
#, fuzzy
msgid "Returns the stream (_Reactive Stream_)"
msgstr "ストリーム _（Reactive Stream_）を返します。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:215
#, no-wrap, fuzzy
msgid "Configuring the AMQP connector"
msgstr "AMQP コネクタの設定"

#. type: Plain text
#: upstream/_guides/amqp.adoc:219
#, fuzzy
msgid ""
"We need to configure the AMQP connector. This is done in the `application."
"properties` file.  The keys are structured as follows:"
msgstr ""
"AMQP コネクタを設定する必要があります。これは `application.properties` "
"ファイルで行います。キーは以下のように構成されています。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:221
#, fuzzy
msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgstr "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"

#. type: Plain text
#: upstream/_guides/amqp.adoc:223
#, fuzzy
msgid ""
"The `channel-name` segment must match the value set in the `@Incoming` and "
"`@Outgoing` annotation:"
msgstr ""
"`channel-name` セグメントは、 `@Incoming` および `@Outgoing` "
"アノテーションで設定された値と一致する必要があります。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:224
#, fuzzy
msgid "`generated-price` -> sink in which we write the prices"
msgstr "`generated-price` → 価格を書いた流し"

#. type: Plain text
#: upstream/_guides/amqp.adoc:225
#, fuzzy
msgid "`prices` -> source in which we read the prices"
msgstr "`prices` → 価格を読み取ったソース"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:231
#, no-wrap
msgid ""
"# Configures the AMQP broker credentials.\n"
"amqp-username=quarkus\n"
"amqp-password=quarkus\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:235
#, no-wrap
msgid ""
"# Configure the AMQP connector to write to the `prices` address\n"
"mp.messaging.outgoing.generated-price.connector=smallrye-amqp\n"
"mp.messaging.outgoing.generated-price.address=prices\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:239
#, no-wrap
msgid ""
"# Configure the AMQP connector to read from the `prices` queue\n"
"mp.messaging.incoming.prices.connector=smallrye-amqp\n"
"mp.messaging.incoming.prices.durable=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:242
#, fuzzy
msgid ""
"More details about this configuration is available in the https://smallrye."
"io/smallrye-reactive-messaging/#_interacting_using_amqp[SmallRye Reactive "
"Messaging AMQP connector] documentation."
msgstr ""
"この設定の詳細については、 link:https://smallrye.io/smallrye-reactive-messaging/"
"#_interacting_using_amqp[SmallRye Reactive Messaging AMQP "
"コネクタの]ドキュメントを参照してください。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:244
#, fuzzy
msgid ""
"What about `my-data-stream`? This is an in-memory stream, not connected to a "
"message broker."
msgstr "`my-data-stream` はどうですか？これはインメモリストリームであり、メッセージブローカには接続されていません。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:245
#, no-wrap, fuzzy
msgid "The HTML page"
msgstr "HTMLページ"

#. type: Plain text
#: upstream/_guides/amqp.adoc:248
#, fuzzy
msgid "Final touch, the HTML page reading the converted prices using SSE."
msgstr "最後に、SSEを使って変換された価格を読み込んだHTMLページ。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:250
#, fuzzy
msgid ""
"Create the `src/main/resources/META-INF/resources/prices.html` file, with "
"the following content:"
msgstr ""
"以下の内容の `src/main/resources/META-INF/resources/prices.html` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:258
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"<head>\n"
"    <meta charset=\"UTF-8\">\n"
"    <title>Prices</title>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:266
#, no-wrap
msgid ""
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/"
"css/patternfly.min.css\">\n"
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/"
"css/patternfly-additions.min.css\">\n"
"</head>\n"
"<body>\n"
"<div class=\"container\">\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:281
#, no-wrap
msgid ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/"
"A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
"<script>\n"
"    var source = new EventSource(\"/prices/stream\");\n"
"    source.onmessage = function (event) {\n"
"        document.getElementById(\"content\").innerHTML = event.data;\n"
"    };\n"
"</script>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:284
#, fuzzy
msgid "Nothing spectacular here. On each received price, it updates the page."
msgstr "目を見張るようなものは何もありません。受信した価格ごとに、ページを更新します。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:285
#, no-wrap, fuzzy
msgid "Get it running"
msgstr "稼動させる"

#. type: Plain text
#: upstream/_guides/amqp.adoc:289
#, fuzzy
msgid ""
"If you followed the instructions, you should have the AMQP broker running.  "
"Then, you just need to run the application using:"
msgstr "指示に従えば、AMQPブローカーを実行しているはずです。あとは、アプリケーションを使用して実行するだけです。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:293
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:296
#, fuzzy
msgid "Open `http://localhost:8080/prices.html` in your browser."
msgstr ""
"開く `&lt;a href=\"http://localhost:8080/prices.html\" class=\"bare\"&gt;http:/"
"/localhost:8080/prices.html&lt;/a&gt;`をブラウザに表示してください。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:298
#, fuzzy
msgid ""
"If you started the AMQP broker with docker compose, stop it using `CTRL+C` "
"followed by `docker-compose down`."
msgstr ""
"docker composeでAMQPブローカーを起動した場合は、 `CTRL+C` に続いて `docker-compose down`."

#. type: Title ==
#: upstream/_guides/amqp.adoc:299
#, no-wrap, fuzzy
msgid "Running Native"
msgstr "ネイティブの実行"

#. type: Plain text
#: upstream/_guides/amqp.adoc:302
#, fuzzy
msgid "You can build the native executable with:"
msgstr "でネイティブ実行ファイルをビルドすることができます。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:306
#, no-wrap
msgid "./mvnw package -Pnative\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amqp.adoc:308
#, no-wrap, fuzzy
msgid "Imperative usage"
msgstr "強制的な使用法"

#. type: Plain text
#: upstream/_guides/amqp.adoc:311
#, fuzzy
msgid "Sometimes you need to have an imperative way of sending messages."
msgstr "時には、メッセージを送るための必須の方法が必要になることもあります。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:314
#, fuzzy
msgid ""
"For example, if you need to send a message to a stream from inside a REST "
"endpoint when receiving a POST request.  In this case, you cannot use "
"`@Outgoing` because your method has parameters."
msgstr ""
"例えば、POST リクエストを受信した際に、REST "
"エンドポイントの内部からストリームにメッセージを送信する必要がある場合。この場合、メソッドにはパラメータがあるため、 `@Outgoing` "
"を使用することはできません。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:316
#, fuzzy
msgid "For this, you can use an `Emitter`."
msgstr "そのためには、 `Emitter`."

#. type: delimited block -
#: upstream/_guides/amqp.adoc:321
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:327
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:330
#, no-wrap
msgid "@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:332
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:339
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:343
#, fuzzy
msgid ""
"The `Emitter` configuration is done the same way as the other stream "
"configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use "
"`@OnOverflow` to configure a back-pressure strategy."
msgstr ""
"`Emitter` の設定は、 `@Incoming` と `@Outgoing` が使用する他のストリームの設定と同じ方法で行います。さらに、 "
"`@OnOverflow` を使用して、バックプレッシャー戦略を設定することができます。"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:348
#, fuzzy
msgid ""
"The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye."
"reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging."
"annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr ""
"`io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive."
"messaging.annotations.Channel`, `io.smallrye.reactive.messaging.annotations."
"OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:350
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:351
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:352
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:354
#, fuzzy
msgid ""
"The new `Emitter.send` method returns a `CompletionStage` completed when the "
"produced message is acknowledged."
msgstr "新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると `CompletionStage` 完了を返します。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:356
#, no-wrap, fuzzy
msgid "Going further"
msgstr "さらに進む"

#. type: Plain text
#: upstream/_guides/amqp.adoc:360
#, fuzzy
msgid ""
"This guide has shown how you can interact with AMQP using Quarkus.  It "
"utilizes MicroProfile Reactive Messaging to build data streaming "
"applications."
msgstr ""
"このガイドでは、Quarkusを使用してAMQPと対話する方法を示しました。このガイドでは、MicroProfile Reactive "
"Messagingを利用してデータストリーミングアプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:363
#, fuzzy
msgid ""
"If you did the Kafka quickstart, you have realized that it's the same code.  "
"The only difference is the connector configuration."
msgstr "Kafka のクイックスタートをした人は、同じコードであることに気がついたはずです。違うのはコネクタの設定だけです。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:364
#, fuzzy
msgid ""
"If you want to go further check the documentation of https://smallrye.io/"
"smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation "
"used in Quarkus."
msgstr ""
"さらに詳しく知りたい場合は、Quarkusで使用されている実装である link:https://smallrye.io/smallrye-"
"reactive-messaging[SmallRye Reactive Messaging]のドキュメントを確認してください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amazon-dynamodb.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Amazon DynamoDB Client"
msgstr "Quarkus - Amazon DynamoDBクライアント"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:15
#, fuzzy
msgid ""
"DynamoDB is a scalable AWS managed *NoSQL* database.  It supports both key-"
"value and document data models, that enables to have a flexible schema for "
"your data.  This extension provides functionality that allows the client to "
"communicate with the service when running in Quarkus.  You can find more "
"information about DynamoDB at https://aws.amazon.com/dynamodb/[the Amazon "
"DynamoDB website]."
msgstr ""
"DynamoDBは、AWSで管理されているスケーラブルな "
"*NoSQL*データベースです。DynamoDBはキーバリューとドキュメントの両方のデータモデルをサポートしており、データに対して柔軟なスキーマを持つことができます。この拡張機能は、Quarkusで実行しているときにクライアントがサービスと通信できるようにする機能を提供します。DynamoDBの詳細については、 "
"link:https://aws.amazon.com/dynamodb/[Amazon DynamoDBのウェブサイト]で確認できます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:19
#, fuzzy
msgid ""
"The DynamoDB extension is based on https://docs.aws.amazon.com/sdk-for-java/"
"v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of "
"the 1.x code base that offers two programming models (Blocking & Async).  "
"Keep in mind it's actively developed and does not support yet all the "
"features available in SDK 1.x such as https://github.com/aws/aws-sdk-java-v2/"
"issues/36[Document APIs] or https://github.com/aws/aws-sdk-java-v2/issues/"
"35[Object Mappers]"
msgstr ""
"DynamoDBエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-"
"guide/welcome.html[AWS Java SDK 2.x]をベースにしています。1."
"xのコードベースを大幅に書き換えたもので、2つのプログラミングモデル（ブロッキングと非同期）を提供しています。この拡張機能は積極的に開発されており、 "
"link:https://github.com/aws/aws-sdk-java-v2/issues/36[ドキュメントAPI]や link:https:"
"//github.com/aws/aws-sdk-java-v2/issues/35[オブジェクトマッパー]のようなSDK 1."
"xで利用可能な機能はまだサポートしていないことを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:28
#, fuzzy
msgid ""
"In this guide, we see how you can get your REST services to use the DynamoDB "
"locally and on AWS."
msgstr "このガイドでは、RESTサービスでDynamoDBをローカルとAWS上で利用する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:37
#, fuzzy
msgid "An AWS Account to access the DynamoDB service"
msgstr "DynamoDBサービスにアクセスするためのAWSアカウント"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:38
#, fuzzy
msgid ""
"Optionally, Docker for your system to run DynamoDB locally for testing "
"purposes"
msgstr "オプションで、Dockerを使ってシステムをテスト用にローカルでDynamoDBを実行することができます。"

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:39
#, no-wrap, fuzzy
msgid "Setup DynamoDB locally"
msgstr "DynamoDBをローカルに設定する"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:42
#, fuzzy
msgid ""
"The easiest way to start working with DynamoDB is to run a local instance as "
"a container."
msgstr "DynamoDBで作業を始める最も簡単な方法は、ローカルインスタンスをコンテナとして実行することです。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:46
#, no-wrap
msgid ""
"docker run --publish 8000:8000 amazon/dynamodb-local:1.11.477 -jar "
"DynamoDBLocal.jar -inMemory -sharedDb\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:50
#, fuzzy
msgid ""
"This starts a DynamoDB instance that is accessible on port `8000`.  You can "
"check it's running by accessing the web shell on `http://localhost:8000/"
"shell`."
msgstr ""
"これは、ポート `8000` でアクセス可能な DynamoDB "
"インスタンスを起動します。のWebシェルにアクセスして、実行中であることを確認することができます。 `&lt;a href=\"http://"
"localhost:8000/shell\" class=\"bare\"&gt;http://localhost:8000/shell&lt;/"
"a&gt;`."

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:52
#, fuzzy
msgid ""
"Have a look at the https://docs.aws.amazon.com/amazondynamodb/latest/"
"developerguide/DynamoDBLocal.html[Setting Up DynamoDB Local guide] for other "
"options to run DynamoDB."
msgstr ""
"DynamoDBを実行するための他のオプションについては、 link:https://docs.aws.amazon.com/"
"amazondynamodb/latest/developerguide/DynamoDBLocal.html[Setting Up DynamoDB "
"Localガイドを]ご覧ください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:54
#, fuzzy
msgid "Open `http://localhost:8000/shell` in your browser."
msgstr ""
"開く `&lt;a href=\"http://localhost:8000/shell\" class=\"bare\"&gt;http://"
"localhost:8000/shell&lt;/a&gt;`をブラウザに表示してください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:56
#, fuzzy
msgid "Copy and paste the following code to the shell and run it:"
msgstr "以下のコードをシェルにコピー＆ペーストして実行してください。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:64
#, no-wrap
msgid ""
"var params = {\n"
"    TableName: 'QuarkusFruits',\n"
"    KeySchema: [{ AttributeName: 'fruitName', KeyType: 'HASH' }],\n"
"    AttributeDefinitions: [{  AttributeName: 'fruitName', AttributeType: "
"'S', }],\n"
"    ProvisionedThroughput: { ReadCapacityUnits: 1, WriteCapacityUnits: 1, }\n"
"};\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:68
#, no-wrap
msgid ""
"dynamodb.createTable(params, function(err, data) {\n"
"    if (err) ppJson(err);\n"
"    else ppJson(data);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:70
#, no-wrap
msgid "});\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:72
#, no-wrap, fuzzy
msgid "Set up Dynamodb on AWS"
msgstr "AWS上にDynamodbを設定する"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:76
#, fuzzy
msgid ""
"Before you can use the AWS SDKs with DynamoDB, you must get an AWS access "
"key ID and secret access key.  For more information, see https://docs.aws."
"amazon.com/amazondynamodb/latest/developerguide/SettingUp.DynamoWebService."
"html[Setting Up DynamoDB (Web Service)]."
msgstr ""
"DynamoDBでAWS SDKを利用する前に、AWSのアクセスキーIDとシークレットアクセスキーを取得する必要があります。詳しくは、 link:"
"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SettingUp."
"DynamoWebService.html[DynamoDB（Webサービス）]のセットアップを参照してください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:78
#, fuzzy
msgid "We recommend to use the AWS CLI to provision the table:"
msgstr "テーブルのプロビジョニングにはAWS CLIを利用することをお勧めします。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:85
#, no-wrap
msgid ""
"aws dynamodb create-table --table-name QuarkusFruits \\\n"
"                          --attribute-definitions AttributeName="
"fruitName,AttributeType=S \\\n"
"                          --key-schema AttributeName=fruitName,KeyType=HASH "
"\\\n"
"                          --provisioned-throughput ReadCapacityUnits="
"1,WriteCapacityUnits=1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:89
#, fuzzy
msgid ""
"The application built here allows to manage elements (fruits) stored in "
"Amazon DynamoDB."
msgstr "ここで構築したアプリケーションでは、Amazon DynamoDBに格納されている要素（果物）を管理することができます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:96
#, fuzzy
msgid ""
"The solution is located in the `amazon-dynamodb-quickstart` {quickstarts-"
"tree-url}/amazon-dynamodb-quickstart[directory]."
msgstr ""
"ソリューションは `amazon-dynamodb-quickstart` {quickstarts-tree-url}/amazon-dynamodb-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:110
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=amazon-dynamodb-quickstart \\\n"
"    -DclassName=\"org.acme.dynamodb.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jackson,amazon-dynamodb,resteasy-mutiny\"\n"
"cd amazon-dynamodb-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:114
#, fuzzy
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS, "
"Mutiny and DynamoDB Client extensions.  After this, the `amazon-dynamodb` "
"extension has been added to your `pom.xml` as well as the Mutiny support for "
"RESTEasy."
msgstr ""
"このコマンドは、RESTEasy/JAX-RS、Mutiny、DynamoDBクライアント拡張機能をインポートするMaven構造体を生成します。 "
"`pom.xml` この後、RESTEasyのMutinyサポートと同様に、 `amazon-dynamodb` 拡張機能が追加されています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:118
#, fuzzy
msgid ""
"In this example, we will create an application to manage a list of fruits. "
"The example application will demonstrate the two programming models "
"supported by the extension."
msgstr ""
"この例では、果物のリストを管理するアプリケーションを作成します。この例のアプリケーションでは、拡張機能でサポートされている2つのプログラミングモデルを実演します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:124
#: upstream/_guides/amazon-dynamodb.adoc:191
#: upstream/_guides/amazon-dynamodb.adoc:243
#: upstream/_guides/amazon-dynamodb.adoc:280
#: upstream/_guides/amazon-dynamodb.adoc:393
#: upstream/_guides/amazon-dynamodb.adoc:434
#, no-wrap
msgid "package org.acme.dynamodb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:127
#, no-wrap
msgid "import java.util.Map;\n"
"import java.util.Objects;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:130
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.RegisterForReflection;\n"
"import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:133
#, no-wrap
msgid "@RegisterForReflection\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:136
#, no-wrap
msgid "    private String name;\n"
"    private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:112
#, no-wrap
msgid "    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:148
#, no-wrap
msgid ""
"    public static Fruit from(Map<String, AttributeValue> item) {\n"
"        Fruit fruit = new Fruit();\n"
"        if (item != null && !item.isEmpty()) {\n"
"            fruit.setName(item.get(AbstractService.FRUIT_NAME_COL).s());\n"
"            fruit.setDescription(item.get(AbstractService.FRUIT_DESC_COL)."
"s());\n"
"        }\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:160
#, no-wrap
msgid ""
"    public String getDescription() {\n"
"        return description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:164
#, no-wrap
msgid ""
"    public void setDescription(String description) {\n"
"        this.description = description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:170
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean equals(Object obj) {\n"
"        if (!(obj instanceof Fruit)) {\n"
"            return false;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:172
#, no-wrap
msgid "        Fruit other = (Fruit) obj;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:175
#, no-wrap
msgid "        return Objects.equals(other.name, this.name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:181
#, no-wrap
msgid ""
"    @Override\n"
"    public int hashCode() {\n"
"        return Objects.hash(this.name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:185
#, fuzzy
msgid ""
"Nothing fancy. One important thing to note is that having a default "
"constructor is required by the JSON serialization layer. The static `from` "
"method creates a bean based on the `Map` object provided by the DynamoDB "
"client response."
msgstr ""
"派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことは、JSONシリアライゼーションレイヤーによって要求されるということです。static "
"`from` メソッドは、DynamoDB クライアントのレスポンスで提供される `Map` オブジェクトに基づいてビーンを作成します。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:187
#, fuzzy
msgid ""
"Now create a `org.acme.dynamodb.AbstractService` that will consist of helper "
"methods that prepare DynamoDB request objects for reading and adding items "
"to the table."
msgstr ""
"これで、テーブルにアイテムを読み込んで追加するためのDynamoDBリクエストオブジェクトを準備するヘルパーメソッドで構成される `org.acme."
"dynamodb.AbstractService` を作成します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:194
#, no-wrap
msgid "import java.util.HashMap;\n"
"import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:199
#, no-wrap
msgid ""
"import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n"
"import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n"
"import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n"
"import software.amazon.awssdk.services.dynamodb.model.ScanRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:201
#, no-wrap
msgid "public abstract class AbstractService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:204
#, no-wrap
msgid ""
"    public final static String FRUIT_NAME_COL = \"fruitName\";\n"
"    public final static String FRUIT_DESC_COL = \"fruitDescription\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:208
#, no-wrap
msgid ""
"    public String getTableName() {\n"
"        return \"QuarkusFruits\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:213
#, no-wrap
msgid ""
"    protected ScanRequest scanRequest() {\n"
"        return ScanRequest.builder().tableName(getTableName())\n"
"                .attributesToGet(FRUIT_NAME_COL, FRUIT_DESC_COL).build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:218
#, no-wrap
msgid ""
"    protected PutItemRequest putRequest(Fruit fruit) {\n"
"        Map<String, AttributeValue> item = new HashMap<>();\n"
"        item.put(FRUIT_NAME_COL, AttributeValue.builder().s(fruit.getName())."
"build());\n"
"        item.put(FRUIT_DESC_COL, AttributeValue.builder().s(fruit."
"getDescription()).build());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:224
#, no-wrap
msgid ""
"        return PutItemRequest.builder()\n"
"                .tableName(getTableName())\n"
"                .item(item)\n"
"                .build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:228
#, no-wrap
msgid ""
"    protected GetItemRequest getRequest(String name) {\n"
"        Map<String, AttributeValue> key = new HashMap<>();\n"
"        key.put(FRUIT_NAME_COL, AttributeValue.builder().s(name).build());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:236
#, no-wrap
msgid ""
"        return GetItemRequest.builder()\n"
"                .tableName(getTableName())\n"
"                .key(key)\n"
"                .attributesToGet(FRUIT_NAME_COL, FRUIT_DESC_COL)\n"
"                .build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:239
#, fuzzy
msgid ""
"Then, create a `org.acme.dynamodb.FruitSyncService` that will be the "
"business layer of our application and stores/loads the fruits from DynamoDB "
"using the synchronous client."
msgstr ""
"次に、アプリケーションのビジネスレイヤーとなる `org.acme.dynamodb.FruitSyncService` "
"を作成し、同期クライアントを使用して DynamoDB からフルーツを保存/ロードします。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:246
#, no-wrap
msgid "import java.util.List;\n"
"import java.util.stream.Collectors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:601
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:251
#, no-wrap
msgid "import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:254
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitSyncService extends AbstractService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:257
#, no-wrap
msgid "    @Inject\n"
"    DynamoDbClient dynamoDB;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:263
#, no-wrap
msgid ""
"    public List<Fruit> findAll() {\n"
"        return dynamoDB.scanPaginator(scanRequest()).items().stream()\n"
"                .map(Fruit::from)\n"
"                .collect(Collectors.toList());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:268
#, no-wrap
msgid ""
"    public List<Fruit> add(Fruit fruit) {\n"
"        dynamoDB.putItem(putRequest(fruit));\n"
"        return findAll();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:273
#, no-wrap
msgid ""
"    public Fruit get(String name) {\n"
"        return Fruit.from(dynamoDB.getItem(getRequest(name)).item());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:276
#, fuzzy
msgid "Now, edit the `org.acme.dynamodb.FruitResource` class as follows:"
msgstr "ここで、 `org.acme.dynamodb.FruitResource` クラスを以下のように編集します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:282
#, no-wrap
msgid "import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:289
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:295
#, no-wrap
msgid "    @Inject\n"
"    FruitSyncService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:300
#, no-wrap
msgid ""
"    @GET\n"
"    public List<Fruit> getAll() {\n"
"        return service.findAll();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:306
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}\")\n"
"    public Fruit getSingle(@PathParam(\"name\") String name) {\n"
"        return service.get(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:313
#, no-wrap
msgid ""
"    @POST\n"
"    public List<Fruit> add(Fruit fruit) {\n"
"        service.add(fruit);\n"
"        return getAll();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:316
#, fuzzy
msgid ""
"The implementation is pretty straightforward and you just need to define "
"your endpoints using the JAX-RS annotations and use the `FruitSyncService` "
"to list/add new fruits."
msgstr ""
"実装はとても簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義し、 `FruitSyncService` "
"を使って新しいフルーツをリストアップ/追加するだけです。"

#. type: Title ==
#: upstream/_guides/amazon-dynamodb.adoc:317
#, no-wrap, fuzzy
msgid "Configuring DynamoDB clients"
msgstr "DynamoDBクライアントの設定"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:322
#, fuzzy
msgid ""
"Both DynamoDB clients (sync and async) are configurable via the `application."
"properties` file that can be provided in the `src/main/resources` directory. "
" Additionally, you need to add to the classpath a proper implementation of "
"the sync client. By default the extension uses the `java.net.URLConnection` "
"HTTP client, so you need to add a URL connection client dependency to the "
"`pom.xml` file:"
msgstr ""
"DynamoDBクライアント(syncとasync)はどちらも、 `src/main/resources` ディレクトリで提供されている "
"`application.properties` "
"ファイルを介して設定可能です。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、拡張機能は `java.net."
"URLConnection` HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` "
"ファイルに追加する必要があります。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:332
#, fuzzy
msgid ""
"If you want to use the Apache HTTP client instead, configure it as follows:"
msgstr "代わりにApache HTTPクライアントを使いたい場合は、以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:335
#, no-wrap
msgid "quarkus.dynamodb.sync-client.type=apache\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:338
#, fuzzy
msgid "And add following dependency to the application `pom.xml`:"
msgstr "そして、以下の依存関係をアプリケーションに追加します `pom.xml`."

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:347
#, fuzzy
msgid ""
"If you're going to use a local DynamoDB instance, configure it as follows:"
msgstr "ローカルのDynamoDBインスタンスを使用する場合は、以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:351
#, no-wrap
msgid "quarkus.dynamodb.endpoint-override=http://localhost:8000\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:356
#, no-wrap
msgid ""
"quarkus.dynamodb.aws.region=eu-central-1\n"
"quarkus.dynamodb.aws.credentials.type=static\n"
"quarkus.dynamodb.aws.credentials.static-provider.access-key-id=test-key\n"
"quarkus.dynamodb.aws.credentials.static-provider.secret-access-key=test-"
"secret\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:359
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.region` - It's required by the client, but since "
"you're using a local DynamoDB instance you can pick any valid AWS region."
msgstr ""
"`quarkus.dynamodb.aws.region` - "
"クライアントが必要ですが、ローカルのDynamoDBインスタンスを使用しているので、有効なAWSリージョンを選ぶことができます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:360
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.credentials.type` - Set `static` credentials provider "
"with any values for `access-key-id` and `secret-access-key`"
msgstr ""
"`quarkus.dynamodb.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-"
"id` と任意の値で設定します。 `secret-access-key`"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:361
#, fuzzy
msgid ""
"`quarkus.dynamodb.endpoint-override` - Override the DynamoDB client to use a "
"local instance instead of an AWS service"
msgstr ""
"`quarkus.dynamodb.endpoint-override` - "
"DynamoDBクライアントをAWSサービスの代わりにローカルインスタンスを使用するようにオーバーライドする"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:363
#, fuzzy
msgid "If you want to work with an AWS account, you'd need to set it with:"
msgstr "AWSアカウントで作業したい場合は、AWSアカウントで設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:367
#, no-wrap
msgid ""
"quarkus.dynamodb.aws.region=<YOUR_REGION>\n"
"quarkus.dynamodb.aws.credentials.type=default\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:370
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.region` you should set it to the region where you "
"provisioned the DynamoDB table,"
msgstr ""
"`quarkus.dynamodb.aws.region` 、DynamoDBテーブルをプロビジョニングしたリージョンに設定する必要があります。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:371
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.credentials.type` - use the `default` credentials "
"provider chain that looks for credentials in this order:"
msgstr ""
"`quarkus.dynamodb.aws.credentials.type` - `default` "
"クレデンシャル・プロバイダ・チェーンを使用して、この順番でクレデンシャルを検索します。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:380
#, fuzzy
msgid ""
"Packaging your application is as simple as `./mvnw clean package`.  It can "
"be run with `java -jar target/amazon-dynamodb-quickstart-1.0-SNAPSHOT-runner."
"jar`."
msgstr ""
"アプリケーションのパッケージ化は `./mvnw clean package` のように簡単です。 `java -jar target/amazon-"
"dynamodb-quickstart-1.0-SNAPSHOT-runner.jar` で実行できます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:389
#, fuzzy
msgid ""
"Create a `org.acme.dynamodb.FruitAsyncService` that will be similar to our "
"`FruitSyncService` but using an asynchronous programming model."
msgstr ""
"`FruitSyncService` と同様の `org.acme.dynamodb.FruitAsyncService` "
"を作成しますが、非同期プログラミングモデルを使用します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:397
#, no-wrap
msgid ""
"import java.util.List;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.stream.Collectors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:403
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import software.amazon.awssdk.services.dynamodb.DynamoDbAsyncClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:406
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitAsyncService extends AbstractService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:409
#, no-wrap
msgid "    @Inject\n"
"    DynamoDbAsyncClient dynamoDB;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:414
#, no-wrap
msgid ""
"    public Uni<List<Fruit>> findAll() {\n"
"        return Uni.createFrom().completionStage(() -> dynamoDB."
"scan(scanRequest()))\n"
"                .onItem().transform(res -> res.items().stream().map(Fruit::"
"from).collect(Collectors.toList()));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:419
#, no-wrap
msgid ""
"    public Uni<List<Fruit>> add(Fruit fruit) {\n"
"        return Uni.createFrom().completionStage(() -> dynamoDB."
"putItem(putRequest(fruit)))\n"
"                .onItem().ignore().andSwitchTo(this::findAll);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:425
#, no-wrap
msgid ""
"    public Uni<Fruit> get(String name) {\n"
"        return Uni.createFrom().completionStage(() -> dynamoDB."
"getItem(getRequest(name)))\n"
"                .onItem().transform(resp -> Fruit.from(resp.item()));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:428
#, fuzzy
msgid ""
"In the previous code, we create `Uni` instances from the `CompletionStage` "
"objects returned by the asynchronous DynamoDB client, and then transform the "
"emitted item."
msgstr ""
"先ほどのコードでは、非同期のDynamoDBクライアントから返された `CompletionStage` オブジェクトから `Uni` "
"インスタンスを作成し、排出されたアイテムを変換しています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:430
#, fuzzy
msgid ""
"Then, create an asynchronous REST resource that consumes this async service:"
msgstr "次に、この非同期サービスを消費する非同期RESTリソースを作成します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:436
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:441
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.*;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:446
#, no-wrap
msgid ""
"@Path(\"/async-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitAsyncResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:449
#, no-wrap
msgid "    @Inject\n"
"    FruitAsyncService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:454
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<List<Fruit>> getAll() {\n"
"        return service.findAll();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:460
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}\")\n"
"    public Uni<Fruit> getSingle(@PathParam(\"name\") String name) {\n"
"        return service.get(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:467
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<List<Fruit>> add(Fruit fruit) {\n"
"        return service.add(fruit)\n"
"                .onItem().ignore().andSwitchTo(this::getAll);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:470
#, fuzzy
msgid "And add Netty HTTP client dependency to the `pom.xml`:"
msgstr "そして、 `pom.xml`.NETTY HTTPクライアントの依存関係を追加します。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/consul-config.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Reading properties from Consul"
msgstr "Quarkus - 領事からプロパティを読み取る"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:12
#, fuzzy
msgid ""
"This guide explains how your Quarkus application can read configuration "
"properties at runtime from https://www.consul.io[Consul]."
msgstr ""
"このガイドでは、Quarkusアプリケーションが実行時に link:https://www.consul."
"io[Consul]から設定プロパティを読み取る方法について説明します。"

#. type: Title ==
#: upstream/_guides/consul-config.adoc:29
#, no-wrap, fuzzy
msgid "Introduction"
msgstr "序章"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:33
#, fuzzy
msgid ""
"Consul is a versatile system which among other things, provides a "
"distributed Key-Value store that is used in many architectures as a source "
"of configuration for services.  This Key-Value store is what the `quarkus-"
"consul-config` extension interacts with in order to allow Quarkus "
"applications to read runtime configuration properties from Consul."
msgstr ""
"Consulは、サービスの設定のソースとして多くのアーキテクチャで使用されている分散型のキーバリューストアを提供する多目的システムです。このキーバリューストアは、Quarkus "
"アプリケーションが Consul から実行時の設定プロパティを読み込めるようにするために、 `quarkus-consul-config` "
"拡張機能が相互に作用するものです。"

#. type: Title ==
#: upstream/_guides/consul-config.adoc:34
#, no-wrap, fuzzy
msgid "Starting Consul"
msgstr "領事を開始する"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:37
#, fuzzy
msgid ""
"There are various ways to start Consul that vary in complexity, but for the "
"purposes of this guide, we elect to start a single Consul server with no "
"persistence via Docker, like so:"
msgstr ""
"Consul を起動する方法は複雑さによって様々ですが、このガイドの目的のために、Docker を介して永続性のない単一の Consul "
"サーバを起動することを選択します。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:41
#, no-wrap
msgid ""
"docker run --rm --name consul -p 8500:8500 -p 8501:8501 consul:1.7 agent -"
"dev -ui -client=0.0.0.0 -bind=0.0.0.0 --https-port=8501\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:44
#, fuzzy
msgid ""
"Please consult the https://www.consul.io/docs/install[documentation] to "
"learn more about the various Consul installation options."
msgstr ""
"様々なConsulのインストールオプションについては、 link:https://www.consul.io/docs/"
"install[ドキュメントを]参照してください。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:58
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=consul-config-quickstart \\\n"
"    -DclassName=\"org.acme.consul.config.GreetingResource\" \\\n"
"    -Dpath=\"/greeting\" \\\n"
"    -Dextensions=\"consul-config\"\n"
"cd consul-config-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:61
#, fuzzy
msgid ""
"This command generates a Maven project with a REST endpoint and imports the "
"`consul-config` extension."
msgstr "このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、 `consul-config` 拡張子をインポートします。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:64
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `consul-"
"config` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `consul-"
"config` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:68
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"consul-config\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:78
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-consul-config</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:84
#, fuzzy
msgid ""
"The Quarkus Maven plugin automatically generated a `GreetingResource` JAX-RS "
"resource in the `src/main/java/org/acme/consul/config/client/"
"GreetingResource.java` file that looks like:"
msgstr ""
"Quarkus Mavenプラグインは、 `src/main/java/org/acme/consul/config/client/"
"GreetingResource.java` ファイル内の `GreetingResource` JAX-"
"RSリソースを自動的に生成して、次のように表示します。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:88
#: upstream/_guides/consul-config.adoc:110
#, no-wrap
msgid "package org.acme.consul.config.client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:123
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"message\", defaultValue=\"Hello from default\")\n"
"    String message;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:135
#, fuzzy
msgid ""
"Quarkus provides various configuration knobs under the `quarkus.consul-"
"config` root. For the purposes of this guide, our Quarkus application is "
"going to be configured in `application.properties` as follows:"
msgstr ""
"Quarkusは、 `quarkus.consul-config` "
"ルートの下に様々な設定ノブを提供しています。このガイドの目的のために、私たちのQuarkusアプリケーションは以下のように `application."
"properties` で設定されることになっています。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:144
#, no-wrap
msgid ""
"# use the same name as the application name that was configured when "
"standing up the Config Server\n"
"quarkus.application.name=consul-test\n"
"# enable retrieval of configuration from Consul - this is off by default\n"
"quarkus.consul-config.enabled=true\n"
"# this is a key in Consul's KV store that the Quarkus application will read "
"and try to extract properties from\n"
"quarkus.consul-config.properties-value-keys=config/${quarkus.application."
"name}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/consul-config.adoc:146
#, no-wrap, fuzzy
msgid "Add Configuration to Consul"
msgstr "コンスルに設定を追加"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:150
#, fuzzy
msgid ""
"For the previous application configuration to work, we need to add a `config/"
"consul-test` key under Consul's Key Value store. The value of this key will "
"essentially be a properties \"file\" containing the application "
"configuration.  In this case we want to add the following data to the "
"`config/consul-test` key:"
msgstr ""
"以前のアプリケーション設定を動作させるためには、Consulのキーバリューストアの下に `config/consul-test` "
"キーを追加する必要があります。このキーの値は、基本的にはアプリケーションの設定を含むプロパティ「ファイル」になります。この場合、 `config/"
"consul-test` キーに以下のデータを追加したいと思います。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:154
#, no-wrap
msgid "greeting.message=Hello from Consul\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:158
#, fuzzy
msgid ""
"When adding this configuration from the UI, Consul will automatically "
"convert the data into the necessary base64 encoding. If you instead add the "
"configuration via the Consul's https://www.consul.io/api/kv.html#create-"
"update-key[REST API], make sure to first encode the previous data into "
"base64."
msgstr ""
"UI からこの設定を追加すると、Consul は自動的に必要な base64 エンコーディングにデータを変換します。代わりに Consul の link:"
"https://www.consul.io/api/kv.html#create-update-key[REST API "
"を]介して設定を追加する場合は、まず前のデータを base64 にエンコードするようにしてください。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:162
#, fuzzy
msgid ""
"In this use case we made the value of the key as a properties \"file\", "
"because we used `quarkus.consul-config.properties-value-keys` in the "
"application. The extension also provides the ability to use the raw values "
"of keys when `quarkus.consul-config.raw-value-keys` is used. Furthermore, "
"these two properties can be used simultaneously, while each one also "
"supports setting multiple keys."
msgstr ""
"このユースケースでは、アプリケーションで `quarkus.consul-config.properties-value-keys` "
"を使用しているため、キーの値をプロパティ「ファイル」にしました。また、この拡張機能では、 `quarkus.consul-config.raw-"
"value-keys` "
"を使用した場合に、キーの生の値を使用する機能を提供しています。さらに、この2つのプロパティは同時に使用することができ、それぞれが複数のキーの設定にも対応しています。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:169
#, fuzzy
msgid ""
"The result should be: `Hello from Consul` as it is the value obtained from "
"the Consul Key Value store."
msgstr "結果は、Consulキーバリューストアから取得した値なので、 `Hello from Consul` となるはずです。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/rest-json.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Writing JSON REST Services"
msgstr "Quarkus - JSON RESTサービスの記述"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:11
#, fuzzy
msgid "JSON is now the _lingua franca_ between microservices."
msgstr "JSONは今やマイクロサービス間の共通 _言語と_なっています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:13
#, fuzzy
msgid ""
"In this guide, we see how you can get your REST services to consume and "
"produce JSON payloads."
msgstr "このガイドでは、REST サービスが JSON ペイロードを消費して生成する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:15
#, fuzzy
msgid ""
"there is another guide if you need a link:rest-client[REST client] "
"(including support for JSON)."
msgstr "link:rest-client[REST クライアントが]必要な場合は、別のガイドがあります (JSON のサポートを含む)。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:28
#, fuzzy
msgid ""
"The application built in this guide is quite simple: the user can add "
"elements in a list using a form and the list is updated."
msgstr ""
"このガイドで構築されたアプリケーションは非常にシンプルです：ユーザーはフォームを使用してリストに要素を追加することができ、リストは更新されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:30
#, fuzzy
msgid ""
"All the information between the browser and the server are formatted as JSON."
""
msgstr "ブラウザとサーバ間の情報はすべてJSON形式で提供されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:39
#, fuzzy
msgid ""
"The solution is located in the `rest-json-quickstart` {quickstarts-tree-url}/"
"rest-json-quickstart[directory]."
msgstr ""
"ソリューションは `rest-json-quickstart` {quickstarts-tree-url}/rest-json-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:53
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json-quickstart \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jackson\"\n"
"cd rest-json-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:57
#, fuzzy
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS and "
"https://github.com/FasterXML/jackson[Jackson] extensions, and in particular "
"adds the following dependency:"
msgstr ""
"このコマンドは、RESTEasy/JAX-RSと link:https://github.com/FasterXML/"
"jackson[Jackson]拡張をインポートするMaven構造体を生成し、特に以下の依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:64
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:69
#, fuzzy
msgid ""
"To improve user experience, Quarkus registers the three Jackson https://"
"github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need "
"to do it manually."
msgstr ""
"ユーザーエクスペリエンスを向上させるために、Quarkusは3つのJackson link:https://github.com/FasterXML/"
"jackson-modules-java8[Java 8モジュールを]登録しているので、手動で登録する必要はありません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:72
#, fuzzy
msgid ""
"Quarkus also supports http://json-b.net/[JSON-B] so, if you prefer JSON-B "
"over Jackson, you can create a project relying on the RESTEasy JSON-B "
"extension instead:"
msgstr ""
"Quarkusは link:http://json-b.net/[JSON-B]もサポートしているので、JacksonよりもJSON-"
"Bが好きな場合は、代わりにRESTEasy JSON-B拡張機能に依存したプロジェクトを作成することができます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:82
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json-quickstart \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jsonb\"\n"
"cd rest-json-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:86
#, fuzzy
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS and "
"http://json-b.net/[JSON-B] extensions, and in particular adds the following "
"dependency:"
msgstr ""
"このコマンドは、RESTEasy/JAX-RSと link:http://json-b.net/[JSON-"
"B]拡張をインポートするMaven構造体を生成し、特に以下の依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:93
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:95
#, no-wrap, fuzzy
msgid "Creating your first JSON REST service"
msgstr "初めてのJSON RESTサービスの作成"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:104 upstream/_guides/rest-json.adoc:127
#: upstream/_guides/rest-json.adoc:311 upstream/_guides/rest-json.adoc:334
#: upstream/_guides/rest-json.adoc:464
#, no-wrap
msgid "package org.acme.rest.json;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:106
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:109 upstream/_guides/rest-json.adoc:316
#, no-wrap
msgid "    public String name;\n"
"    public String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:118
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"        this.name = name;\n"
"        this.description = description;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:121
#, fuzzy
msgid ""
"Nothing fancy. One important thing to note is that having a default "
"constructor is required by the JSON serialization layer."
msgstr ""
"派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことはJSONシリアライズレイヤーで必須であるということです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:123
#, fuzzy
msgid "Now, edit the `org.acme.rest.json.FruitResource` class as follows:"
msgstr "ここで、 `org.acme.rest.json.FruitResource` クラスを以下のように編集します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:131
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.LinkedHashMap;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:136
#, no-wrap
msgid ""
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:141
#, no-wrap
msgid ""
"    private Set<Fruit> fruits = Collections.newSetFromMap(Collections."
"synchronizedMap(new LinkedHashMap<>()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:146
#, no-wrap
msgid ""
"    public FruitResource() {\n"
"        fruits.add(new Fruit(\"Apple\", \"Winter fruit\"));\n"
"        fruits.add(new Fruit(\"Pineapple\", \"Tropical fruit\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:151
#, no-wrap
msgid "    @GET\n"
"    public Set<Fruit> list() {\n"
"        return fruits;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:157
#, no-wrap
msgid ""
"    @POST\n"
"    public Set<Fruit> add(Fruit fruit) {\n"
"        fruits.add(fruit);\n"
"        return fruits;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:164
#, no-wrap
msgid ""
"    @DELETE\n"
"    public Set<Fruit> delete(Fruit fruit) {\n"
"        fruits.removeIf(existingFruit -> existingFruit.name."
"contentEquals(fruit.name));\n"
"        return fruits;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:167
#, fuzzy
msgid ""
"The implementation is pretty straightforward and you just need to define "
"your endpoints using the JAX-RS annotations."
msgstr "実装は非常に簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義するだけです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:170
#, fuzzy
msgid ""
"The `Fruit` objects will be automatically serialized/deserialized by http://"
"json-b.net/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], "
"depending on the extension you chose when initializing the project."
msgstr ""
"`Fruit` オブジェクトは、プロジェクトの初期化時に選択した拡張子に応じて、 link:http://json-b.net/[JSON-B]または "
"link:https://github.com/FasterXML/jackson[Jackson] によって自動的にシリアライズ/"
"デシリアライズされます。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:177
#, fuzzy
msgid ""
"When a JSON extension is installed such as `quarkus-resteasy-jackson` or "
"`quarkus-resteasy-jsonb`, Quarkus will use the `application/json` media type "
"by default for most return values, unless the media type is explicitly set "
"via `@Produces` or `@Consumes` annotations (there are some exceptions for "
"well known types, such as `String` and `File`, which default to `text/plain` "
"and `application/octet-stream` respectively)."
msgstr ""
"`quarkus-resteasy-jackson` や `quarkus-resteasy-jsonb` などの JSON "
"拡張機能がインストールされている場合、メディアタイプが `@Produces` や `@Consumes` "
"アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` "
"メディアタイプをデフォルトで使用します（ `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` "
"と `application/octet-stream` がデフォルトとなっています）。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:180
#, fuzzy
msgid ""
"If you don't want JSON by default you can set `quarkus.resteasy-json.default-"
"json=false` and the default will change back to being auto-negotiated. If "
"you set this you will need to add `@Produces(MediaType.APPLICATION_JSON)` "
"and `@Consumes(MediaType.APPLICATION_JSON)` to your endpoints in order to "
"use JSON."
msgstr ""
"デフォルトでJSONを使用したくない場合は、 `quarkus.resteasy-json.default-json=false` "
"を設定すると、デフォルトは自動ネゴシエーションに戻ります。これを設定した場合、JSON を使用するためには `@Produces(MediaType."
"APPLICATION_JSON)` と `@Consumes(MediaType.APPLICATION_JSON)` "
"をエンドポイントに追加する必要があります。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:183
#, fuzzy
msgid ""
"If you don't rely on the JSON default, it is heavily recommended to annotate "
"your endpoints with the `@Produces` and `@Consumes` annotations to define "
"precisely the expected content-types.  It will allow to narrow down the "
"number of JAX-RS providers (which can be seen as converters) included in the "
"native executable."
msgstr ""
"JSON のデフォルトに頼らない場合は、エンドポイントに `@Produces` や `@Consumes` "
"のアノテーションを付けて、期待されるコンテンツタイプを正確に定義することを強くお勧めします。これにより、ネイティブ実行ファイルに含まれる JAX-RS "
"プロバイダ (コンバータとみなすことができます) の数を絞り込むことができます。"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:185
#, no-wrap, fuzzy
msgid "Configuring JSON support"
msgstr "JSONサポートの設定"

#. type: Title ====
#: upstream/_guides/rest-json.adoc:187
#, no-wrap, fuzzy
msgid "Jackson"
msgstr "ジャクソン"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:191
#, fuzzy
msgid ""
"Quarkus makes it very easy to configure various Jackson settings via CDI "
"beans. The simplest (and suggested) approach is to define a CDI bean of type "
"`io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson "
"configuration can be applied."
msgstr ""
"Quarkusは、CDIビーンを介して、様々なJacksonの設定を非常に簡単に設定することができます。最もシンプルな（そして推奨される）アプローチは、 "
"`io.quarkus.jackson.ObjectMapperCustomizer` 型の CDI ビーンを定義し、その中で、Jackson "
"の設定を適用することです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:193
#, fuzzy
msgid ""
"An example where a custom module needs to be registered would look like so:"
msgstr "カスタムモジュールを登録する必要がある場合の例は次のようになります。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:199
#, no-wrap
msgid ""
"import com.fasterxml.jackson.databind.ObjectMapper;\n"
"import io.quarkus.jackson.ObjectMapperCustomizer;\n"
"import javax.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:202
#, no-wrap
msgid ""
"@Singleton\n"
"public class RegisterCustomModuleCustomizer implements "
"ObjectMapperCustomizer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:207
#, no-wrap
msgid ""
"    public void customize(ObjectMapper mapper) {\n"
"        mapper.registerModule(new CustomModule());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:212
#, fuzzy
msgid ""
"Users can even provide their own `ObjectMapper` bean if they so choose.  If "
"this is done, it is very important to manually inject and apply all `io."
"quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that "
"produces `ObjectMapper`.  Failure to do so will prevent Jackson specific "
"customizations provided by various extensions from being applied."
msgstr ""
"ユーザーは、選択すれば自分の `ObjectMapper` ビーンを提供することもできます。この場合、 `ObjectMapper` を生成する CDI "
"プロデューサの中で、すべての `io.quarkus.jackson.ObjectMapperCustomizer` "
"ビーンを手動で注入して適用することが非常に重要です。これを怠ると、様々な拡張機能によって提供される Jackson "
"固有のカスタマイズが適用されなくなります。"

#. type: Title ====
#: upstream/_guides/rest-json.adoc:213
#, no-wrap, fuzzy
msgid "JSON-B"
msgstr "ジェイソンビー"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:216
#, fuzzy
msgid ""
"As stated above, Quarkus provides the option of using JSON-B instead of "
"Jackson via the use of the `quarkus-resteasy-jsonb` extension."
msgstr ""
"上記のように、Quarkusでは、 `quarkus-resteasy-jsonb` 拡張機能を使用することで、Jacksonの代わりにJSON-"
"Bを使用するオプションを提供しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:218
#, fuzzy
msgid ""
"Following the same approach as described in the previous section, JSON-B can "
"be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean."
msgstr ""
"前項と同様のアプローチで、 `io.quarkus.jsonb.JsonbConfigCustomizer` beanを使用してJSON-"
"Bを設定することができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:220
#, fuzzy
msgid ""
"If for example a custom serializer named `FooSerializer` for type `com."
"example.Foo` needs to be registered with JSON-B, the addition of a bean like "
"the following would suffice:"
msgstr ""
"例えば、 `FooSerializer` という名前のカスタムシリアライザを `com.example.Foo` タイプで JSON-B "
"で登録する必要がある場合、以下のようなビーンを追加すれば十分です。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:227
#, no-wrap
msgid ""
"import io.quarkus.jsonb.JsonbConfigCustomizer;\n"
"import javax.inject.Singleton;\n"
"import javax.json.bind.JsonbConfig;\n"
"import javax.json.bind.serializer.JsonbSerializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:230
#, no-wrap
msgid ""
"@Singleton\n"
"public class FooSerializerRegistrationCustomizer implements "
"JsonbConfigCustomizer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:235
#, no-wrap
msgid ""
"    public void customize(JsonbConfig config) {\n"
"        config.withSerializers(new FooSerializer());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:240
#, fuzzy
msgid ""
"A more advanced option would be to directly provide a bean of `javax.json."
"bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to "
"provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).  "
"If the latter approach is leveraged it is very important to manually inject "
"and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI "
"producer that produces `javax.json.bind.Jsonb`.  Failure to do so will "
"prevent JSON-B specific customizations provided by various extensions from "
"being applied."
msgstr ""
"より高度なオプションとしては、 `javax.json.bind.JsonbConfig` （ `Dependent` "
"スコープ付き）のビーンを直接提供するか、極端な場合には `javax.json.bind.Jsonb` （ `Singleton` "
"スコープ付き）のタイプのビーンを提供することが考えられます。後者のアプローチを利用する場合は、 `javax.json.bind.Jsonb` "
"を生成する CDI プロデューサに `io.quarkus.jsonb.JsonbConfigCustomizer` "
"ビーンをすべて手動で注入して適用することが非常に重要です。これを怠ると、様々な拡張機能によって提供される JSON-B "
"固有のカスタマイズが適用されなくなります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:246
#, fuzzy
msgid ""
"Now let's add a simple web page to interact with our `FruitResource`.  "
"Quarkus automatically serves static resources located under the `META-INF/"
"resources` directory.  In the `src/main/resources/META-INF/resources` "
"directory, add a `fruits.html` file with the content from this {quickstarts-"
"blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits."
"html[fruits.html] file in it."
msgstr ""
"ここで、 `FruitResource`.Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/"
"resources` ディレクトリの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/"
"resources` ディレクトリに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/"
"resources/META-INF/resources/fruits.html[fruits.html] ファイルの内容を含む `fruits."
"html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:250
#, fuzzy
msgid "start Quarkus with `./mvnw compile quarkus:dev`"
msgstr "クォークスを起動する `./mvnw compile quarkus:dev`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:256
#, fuzzy
msgid ""
"You can build a native executable with the usual command `./mvnw package -"
"Pnative`."
msgstr "通常のコマンド `./mvnw package -Pnative` でネイティブ実行ファイルをビルドすることができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:258
#, fuzzy
msgid ""
"Running it is as simple as executing `./target/rest-json-quickstart-1.0-"
"SNAPSHOT-runner`."
msgstr "実行は `./target/rest-json-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:261
#, no-wrap, fuzzy
msgid "About serialization"
msgstr "連載について"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:264
#, fuzzy
msgid ""
"JSON serialization libraries use Java reflection to get the properties of an "
"object and serialize them."
msgstr "JSONシリアライズライブラリは、Javaのリフレクションを使用してオブジェクトのプロパティを取得してシリアライズします。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:268
#, fuzzy
msgid ""
"When using native executables with GraalVM, all classes that will be used "
"with reflection need to be registered.  The good news is that Quarkus does "
"that work for you most of the time.  So far, we haven't registered any "
"class, not even `Fruit`, for reflection usage and everything is working fine."
""
msgstr ""
"GraalVMでネイティブ実行ファイルを使用する場合、リフレクションで使用されるすべてのクラスを登録する必要があります。良いニュースは、Quarkusがほとんどの場合、その作業を代行してくれるということです。これまでのところ、 "
"`Fruit` でさえ、リフレクトを使用するためのクラスを登録しておらず、すべてが正常に動作しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:271
#, fuzzy
msgid ""
"Quarkus performs some magic when it is capable of inferring the serialized "
"types from the REST methods.  When you have the following REST method, "
"Quarkus determines that `Fruit` will be serialized:"
msgstr ""
"Quarkusは、RESTメソッドからシリアライズされた型を推論することができる場合に、何らかのマジックを実行します。以下のようなRESTメソッドがある場合、Quarkusは、 "
"`Fruit` がシリアライズされると判断します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:278
#, no-wrap
msgid "@GET\n"
"public List<Fruit> list() {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:282
#, fuzzy
msgid ""
"Quarkus does that for you automatically by analyzing the REST methods at "
"build time and that's why we didn't need any reflection registration in the "
"first part of this guide."
msgstr "Quarkusは、ビルド時にRESTメソッドを分析することで、自動的にそのような処理を行ってくれます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:285
#, fuzzy
msgid ""
"Another common pattern in the JAX-RS world is to use the `Response` object.  "
"`Response` comes with some nice perks:"
msgstr ""
"JAX-RSの世界では、 `Response` オブジェクトを使用するのがもう一つの一般的なパターンです。 `Response` "
"にはいくつかの素晴らしい特典があります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:287
#, fuzzy
msgid ""
"you can return different entity types depending on what happens in your "
"method (a `Legume` or an `Error` for instance);"
msgstr "メソッドで何が起こるかによって異なるエンティティタイプを返すことができます (例えば `Legume` や `Error` )。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:288
#, fuzzy
msgid ""
"you can set the attributes of the `Response` (the status comes to mind in "
"the case of an error)."
msgstr "の属性を設定すると、 `Response` （エラーが発生した時にステータスが浮かんでくる）。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:290
#, fuzzy
msgid "Your REST method then looks like this:"
msgstr "RESTメソッドは次のようになります。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:297
#, no-wrap
msgid "@GET\n"
"public Response list() {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:301
#, fuzzy
msgid ""
"It is not possible for Quarkus to determine at build time the type included "
"in the `Response` as the information is not available.  In this case, "
"Quarkus won't be able to automatically register for reflection the required "
"classes."
msgstr ""
"`Response` "
"に含まれるタイプは情報がないため、Quarkusがビルド時に判断することはできません。この場合、Quarkusは必要なクラスを自動的に反映登録することができません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:303
#, fuzzy
msgid "This leads us to our next section."
msgstr "これが次のセクションにつながります。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:304
#, no-wrap, fuzzy
msgid "Using Response"
msgstr "レスポンスの利用"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:307
#, fuzzy
msgid ""
"Let's create the `Legume` class which will be serialized as JSON, following "
"the same model as for our `Fruit` class:"
msgstr "`Fruit` クラスと同じモデルに従って、JSON としてシリアライズされる `Legume` クラスを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:313
#, no-wrap
msgid "public class Legume {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:319
#, no-wrap
msgid "    public Legume() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:325
#, no-wrap
msgid ""
"    public Legume(String name, String description) {\n"
"        this.name = name;\n"
"        this.description = description;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:328
#, fuzzy
msgid ""
"Now let's create a `LegumeResource` REST service with only one method which "
"returns the list of legumes."
msgstr "それでは、マメ科植物のリストを返すメソッドを一つだけ持つ `LegumeResource` REST サービスを作成してみましょう。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:330
#, fuzzy
msgid "This method returns a `Response` and not a list of `Legume`."
msgstr "このメソッドは `Response` を返し、 `Legume` のリストではありません。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:338
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.LinkedHashSet;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:345
#, no-wrap
msgid ""
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:350
#, no-wrap
msgid ""
"@Path(\"/legumes\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class LegumeResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:352
#, no-wrap
msgid ""
"    private Set<Legume> legumes = Collections.synchronizedSet(new "
"LinkedHashSet<>());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:357
#, no-wrap
msgid ""
"    public LegumeResource() {\n"
"        legumes.add(new Legume(\"Carrot\", \"Root vegetable, usually "
"orange\"));\n"
"        legumes.add(new Legume(\"Zucchini\", \"Summer squash\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:363
#, no-wrap
msgid ""
"    @GET\n"
"    public Response list() {\n"
"        return Response.ok(legumes).build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:368
#, fuzzy
msgid ""
"Now let's add a simple web page to display our list of legumes.  In the `src/"
"main/resources/META-INF/resources` directory, add a `legumes.html` file with "
"the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/"
"resources/META-INF/resources/legumes.html[legumes.html] file in it."
msgstr ""
"ここで、マメ科植物のリストを表示するための簡単なウェブページを追加してみましょう。 `src/main/resources/META-INF/"
"resources` ディレクトリに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/"
"resources/META-INF/resources/legumes.html[legumes.html] ファイルの内容を含む `legumes."
"html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:370
#, fuzzy
msgid ""
"Open a browser to http://localhost:8080/legumes.html and you will see our "
"list of legumes."
msgstr ""
"ブラウザを開いて http://localhost:8080/legumes.html にアクセスすると、マメ科植物のリストが表示されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:372
#, fuzzy
msgid ""
"The interesting part starts when running the application as a native "
"executable:"
msgstr "興味深いのは、アプリケーションをネイティブ実行ファイルとして実行するときに始まります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:374 upstream/_guides/rest-json.adoc:405
#, fuzzy
msgid "create the native executable with `./mvnw package -Pnative`."
msgstr "`./mvnw package -Pnative` でネイティブ実行ファイルを作成します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:375 upstream/_guides/rest-json.adoc:406
#, fuzzy
msgid "execute it with `./target/rest-json-quickstart-1.0-SNAPSHOT-runner`"
msgstr "と共に実行する `./target/rest-json-quickstart-1.0-SNAPSHOT-runner`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:376 upstream/_guides/rest-json.adoc:407
#, fuzzy
msgid "open a browser and go to http://localhost:8080/legumes.html"
msgstr "ブラウザを開き、 http://localhost:8080/legumes.html"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:378
#, fuzzy
msgid "No legumes there."
msgstr "そこには豆類はありません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:381
#, fuzzy
msgid ""
"As mentioned above, the issue is that Quarkus was not able to determine the "
"`Legume` class will require some reflection by analyzing the REST endpoints. "
" The JSON serialization library tries to get the list of fields of `Legume` "
"and gets an empty list so it does not serialize the fields' data."
msgstr ""
"上記のように、Quarkusが `Legume` クラスを判断できなかったことが問題となっており、REST "
"エンドポイントを解析して何らかの反映が必要となります。JSONシリアライズライブラリは、 `Legume` "
"のフィールドのリストを取得しようとすると空のリストを取得するので、フィールドのデータをシリアライズしません。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:386
#, fuzzy
msgid ""
"At the moment, when JSON-B or Jackson tries to get the list of fields of a "
"class, if the class is not registered for reflection, no exception will be "
"thrown.  GraalVM will simply return an empty list of fields."
msgstr ""
"現時点では、JSON-"
"BやJacksonがクラスのフィールドのリストを取得しようとしたときに、そのクラスがReflectionに登録されていない場合、例外はスローされません。GraalVMは単に空のフィールドのリストを返します。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:388
#, fuzzy
msgid ""
"Hopefully, this will change in the future and make the error more obvious."
msgstr "うまくいけば、将来的にはこれが変化して、エラーがより明白になるでしょう。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:391
#, fuzzy
msgid ""
"We can register `Legume` for reflection manually by adding the "
"`@RegisterForReflection` annotation on our `Legume` class:"
msgstr ""
"`Legume` クラスに `@RegisterForReflection` アノテーションを追加することで、手動で `Legume` "
"をリフレクト用に登録することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:282
#: upstream/_guides/kafka-streams.adoc:329
#: upstream/_guides/kafka-streams.adoc:684
#, no-wrap
msgid "import io.quarkus.runtime.annotations.RegisterForReflection;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:399
#, no-wrap
msgid "@RegisterForReflection\n"
"public class Legume {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:402
#, fuzzy
msgid "Let's do that and follow the same steps as before:"
msgstr "それを実行して、今までと同じ手順を踏んでみましょう。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:404
#, fuzzy
msgid "hit `Ctrl+C` to stop the application"
msgstr "`Ctrl+C` を叩いてアプリケーションを停止させる"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:409
#, fuzzy
msgid "This time, you can see our list of legumes."
msgstr "今回はマメ科の一覧です。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:411
#, no-wrap, fuzzy
msgid "Being reactive"
msgstr "反応すること"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:415
#, fuzzy
msgid ""
"You can return _reactive types_ to handle asynchronous processing.  Quarkus "
"recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write "
"reactive and asynchronous code."
msgstr ""
"非同期処理を処理するためにリア _クティブ型を_返すことができます。Quarkusでは、リアクティブで非同期なコードを書くために link:https:/"
"/smallrye.io/smallrye-mutiny[Mutiny]の使用を推奨しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:417
#, fuzzy
msgid ""
"To integrate Mutiny and RESTEasy, you need to add the `quarkus-resteasy-"
"mutiny` dependency to your project:"
msgstr ""
"Mutiny と RESTEasy を統合するには、 `quarkus-resteasy-mutiny` "
"依存関係をプロジェクトに追加する必要があります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:427
#, fuzzy
msgid "Then, your endpoint can return `Uni` or `Multi` instances:"
msgstr "そして、エンドポイントは `Uni` や `Multi` のインスタンスを返すことができます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:436
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/{name}\")\n"
"public Uni<Fruit> getOne(@PathParam String name) {\n"
"    return findByName(name);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:441
#, no-wrap
msgid "@GET\n"
"public Multi<Fruit> getAll() {\n"
"    return findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:445
#, fuzzy
msgid ""
"Use `Uni` when you have a single result.  Use `Multi` when you have multiple "
"items that may be emitted asynchronously."
msgstr "単一の結果がある場合は `Uni` を使用します。 `Multi` は、非同期的に放出される可能性のある複数の項目がある場合に使用します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:447
#, fuzzy
msgid ""
"You can use `Uni` and `Response` to return asynchronous HTTP responses: "
"`Uni<Response>`."
msgstr ""
"`Uni` と `Response` を使用して、非同期 HTTP レスポンスを返すことができます: "
"`Uni&amp;lt;Response&amp;gt;`."

#. type: Plain text
#: upstream/_guides/rest-json.adoc:449
#, fuzzy
msgid ""
"More details about Mutiny can be found in the link:getting-started-"
"reactive#mutiny[Getting Started with Reactive guide]."
msgstr ""
"Mutinyについての詳細は、 link:getting-started-"
"reactive#mutiny[Reactiveの入門ガイド]に記載されています。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:451
#, no-wrap, fuzzy
msgid "HTTP filters and interceptors"
msgstr "HTTP フィルタとインターセプタ"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:457
#, fuzzy
msgid ""
"Both HTTP request and response can be intercepted by providing "
"`ContainerRequestFilter` or `ContainerResponseFilter` implementations "
"respectively. These filters are suitable for processing the metadata "
"associated with a message: HTTP headers, query parameters, media type, and "
"other metadata. They also have the capability to abort the request "
"processing, for instance when the user does not have the permissions to "
"access the endpoint."
msgstr ""
"HTTP リクエストとレスポンスの両方とも、それぞれ `ContainerRequestFilter` または "
"`ContainerResponseFilter` の実装を提供することで、 "
"傍受することができます。これらのフィルタは、メッセージに関連付けられたメタデータを処理するのに適しています。HTTP "
"ヘッダ、クエリパラメータ、メディアタイプ、その他のメタデータです。また、ユーザがエンドポイントにアクセスする権限を持っていない場合など、リクエスト処理を中止する機能も持っています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:460
#, fuzzy
msgid ""
"Let's use `ContainerRequestFilter` to add logging capability to our service. "
"We can do that by implementing `ContainerRequestFilter` and annotating it "
"with the `@Provider` annotation:"
msgstr ""
"`ContainerRequestFilter` を使用して、サービスにロギング機能を追加してみましょう。 "
"`ContainerRequestFilter` を実装して、 `@Provider` アノテーションをつけることで実現できます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:467
#, no-wrap
msgid ""
"import io.vertx.core.http.HttpServerRequest;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:473
#, no-wrap
msgid ""
"import javax.ws.rs.container.ContainerRequestContext;\n"
"import javax.ws.rs.container.ContainerRequestFilter;\n"
"import javax.ws.rs.core.Context;\n"
"import javax.ws.rs.core.UriInfo;\n"
"import javax.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:476
#, no-wrap
msgid ""
"@Provider\n"
"public class LoggingFilter implements ContainerRequestFilter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:478
#, no-wrap
msgid ""
"    private static final Logger LOG = Logger.getLogger(LoggingFilter."
"class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:481
#, no-wrap
msgid "    @Context\n"
"    UriInfo info;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:484
#, no-wrap
msgid "    @Context\n"
"    HttpServerRequest request;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:487
#, no-wrap
msgid ""
"    @Override\n"
"    public void filter(ContainerRequestContext context) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:491
#, no-wrap
msgid ""
"        final String method = context.getMethod();\n"
"        final String path = info.getPath();\n"
"        final String address = request.remoteAddress().toString();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:495
#, no-wrap
msgid ""
"        LOG.infof(\"Request %s %s from IP %s\", method, path, address);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:498
#, fuzzy
msgid ""
"Now, whenever a REST method is invoked, the request will be logged into the "
"console:"
msgstr "これで、RESTメソッドが呼び出されるたびに、リクエストがコンソールにログとして記録されるようになりました。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:505
#, no-wrap
msgid ""
"2019-06-05 12:44:26,526 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request GET /legumes from IP 127.0.0.1\n"
"2019-06-05 12:49:19,623 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request GET /fruits from IP 0:0:0:0:0:0:0:1\n"
"2019-06-05 12:50:44,019 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request POST /fruits from IP 0:0:0:0:0:0:0:1\n"
"2019-06-05 12:51:04,485 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request GET /fruits from IP 127.0.0.1\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:507
#, no-wrap, fuzzy
msgid "CORS filter"
msgstr "CORSフィルタ"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:512
#, fuzzy
msgid ""
"link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-"
"origin resource sharing] (CORS) is a mechanism that allows restricted "
"resources on a web page to be requested from another domain outside the "
"domain from which the first resource was served."
msgstr ""
"link:https://en.wikipedia.org/wiki/Cross-"
"origin_resource_sharing[クロスオリジンリソース共有]（CORS）は、ウェブページ上の制限されたリソースを、最初のリソースが提供されたドメイン以外の別のドメインから要求できるようにするメカニズムです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:515
#, fuzzy
msgid ""
"Quarkus comes with a CORS filter. Read the link:http-reference#cors-"
"filter[HTTP Reference Documentation] to learn how to use it."
msgstr ""
"QuarkusにはCORSフィルターが付属しています。使用方法については、 link:http-reference#cors-"
"filter[HTTPリファレンスドキュメント]を参照してください。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:516
#, no-wrap, fuzzy
msgid "GZip Support"
msgstr "GZipサポート"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:519
#, fuzzy
msgid ""
"Quarkus comes with GZip support (even though it is not enabled by default). "
"The following configuration knobs allow to configure GZip support."
msgstr ""
"QuarkusにはGZipサポートが搭載されています（デフォルトでは有効になっていませんが）。以下の設定ノブを使用して、GZipサポートを設定できます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:524
#, no-wrap
msgid ""
"quarkus.resteasy.gzip.enabled=true // <1>\n"
"quarkus.resteasy.gzip.max-input=10M // <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:527
#, fuzzy
msgid "Enable Gzip support."
msgstr "Gzipサポートを有効にします。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:529
#, fuzzy
msgid ""
"Configure the upper limit on deflated request body. This is useful to "
"mitigate potential attacks by limiting their reach. The default value is "
"`10M`.  This configuration option would recognize strings in this format "
"(shown as a regular expression): `[0-9]+[KkMmGgTtPpEeZzYy]?`. If no suffix "
"is given, assume bytes."
msgstr ""
"デフレーションされたリクエストボディの上限を設定します。これは、リーチを制限することで潜在的な攻撃を緩和するのに便利です。既定値は `10M` "
"です。この設定オプションは、以下の形式の文字列を認識します(正規表現で表示されます)： `[0-9]+[KkMmGgTtPpEeZzYy]?`."
"サフィックスが指定されていない場合は、バイトとみなします。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:530
#, no-wrap, fuzzy
msgid "Multipart Support"
msgstr "マルチパートサポート"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:533
#, fuzzy
msgid ""
"RESTEasy supports multipart via the https://docs.jboss.org/resteasy/docs/4.5."
"6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider]."
msgstr ""
"RESTEasyは link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/"
"html/Multipart.html[RESTEasy Multipart Provider]を介してマルチパートをサポートしています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:535
#, fuzzy
msgid ""
"Quarkus provides an extension called `quarkus-resteasy-multipart` to make "
"things easier for you."
msgstr "Quarkusは、 `quarkus-resteasy-multipart` という拡張機能を提供しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:537
#, fuzzy
msgid ""
"This extension slightly differs from the RESTEasy default behavior as the "
"default charset (if none is specified in your request) is UTF-8 rather than "
"US-ASCII."
msgstr ""
"この拡張機能は、デフォルトの文字セットが US-ASCII ではなく UTF-8 であるため、RESTEasy のデフォルトの動作とは若干異なります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:539
#, fuzzy
msgid ""
"You can configure this behavior with the following configuration properties:"
msgstr "この動作は、以下の構成プロパティで設定できます。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:542
#, no-wrap, fuzzy
msgid "Servlet compatibility"
msgstr "サーブレットの互換性"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:545
#, fuzzy
msgid ""
"In Quarkus, RESTEasy can either run directly on top of the Vert.x HTTP "
"server, or on top of Undertow if you have any servlet dependency."
msgstr ""
"Quarkusでは、RESTEasyはVert.x "
"HTTPサーバーの上で直接実行するか、サーブレットに依存している場合はUndertowの上で実行することができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:552
#, fuzzy
msgid ""
"As a result, certain classes, such as `HttpServletRequest` are not always "
"available for injection. Most use-cases for this particular class are "
"covered by JAX-RS equivalents, except for getting the remote client's IP. "
"RESTEasy comes with a replacement API which you can inject: https://docs."
"jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/"
"HttpRequest.html[`HttpRequest`], which has the methods https://docs.jboss."
"org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest."
"html#getRemoteAddress--[`getRemoteAddress()`] and https://docs.jboss.org/"
"resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest."
"html#getRemoteHost--[`getRemoteHost()`] to solve this problem."
msgstr ""
"その結果、 `HttpServletRequest` "
"のような特定のクラスが常にインジェクションに利用できるわけではありません。この特定のクラスのほとんどのユースケースは、リモートクライアントの IP "
"を取得することを除いて、JAX-RS と同等のものでカバーされています。RESTEasy には、インジェクション可能な代替 API が付属しています。  "
"link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/"
"resteasy/spi/HttpRequest.html[`HttpRequest`]これは以下のメソッドを持っています。  link:https://"
"docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/"
"HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`]そして  link:https://"
"docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/"
"HttpRequest.html#getRemoteHost--[`getRemoteHost()`]を解決するために、この問題を解決します。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:553
#, no-wrap, fuzzy
msgid "RESTEasy and REST Client interactions"
msgstr "RESTEasy と REST クライアントのインタラクション"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:557
#, fuzzy
msgid ""
"In Quarkus, the RESTEasy extension and link:rest-client[the REST Client "
"extension] share the same infrastructure.  One important consequence of this "
"consideration is that they share the same list of providers (in the JAX-RS "
"meaning of the word)."
msgstr ""
"Quarkusでは、RESTEasyエクステンションと link:rest-"
"client[RESTクライアントエクステンションは]同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、（JAX-"
"RSの意味での）プロバイダーのリストを共有しているということです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:560
#, fuzzy
msgid ""
"For instance, if you declare a `WriterInterceptor`, it will by default "
"intercept both the servers calls and the client calls, which might not be "
"the desired behavior."
msgstr ""
"例えば、 `WriterInterceptor` "
"を宣言した場合、デフォルトではサーバの呼び出しとクライアントの呼び出しの両方を傍受しますが、これは望ましい動作ではないかもしれません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:562
#, fuzzy
msgid ""
"However, you can change this default behavior and constrain a provider to:"
msgstr "しかし、このデフォルトの動作を変更してプロバイダを制約することができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:564
#, fuzzy
msgid ""
"only consider *server* calls by adding the `@ConstrainedTo(RuntimeType."
"SERVER)` annotation to your provider;"
msgstr ""
"プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 "
"*サーバ*コールのみを考慮します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:565
#, fuzzy
msgid ""
"only consider *client* calls by adding the `@ConstrainedTo(RuntimeType."
"CLIENT)` annotation to your provider."
msgstr ""
"プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 "
"*クライアントコール*のみを考慮します。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:566
#, no-wrap, fuzzy
msgid "What's Different from Jakarta EE Development"
msgstr "ジャカルタEE開発との違い"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:568
#, no-wrap, fuzzy
msgid "No Need for `Application` Class"
msgstr "`Application` クラスは不要"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:571
#, fuzzy
msgid ""
"Configuration via an application-supplied subclass of `Application` is "
"supported, but not required."
msgstr "`Application` のアプリケーションが提供するサブクラスによる設定もサポートされていますが、必須ではありません。"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:572
#, no-wrap, fuzzy
msgid "Only a single JAX-RS application"
msgstr "単一のJAX-RSアプリケーションのみ"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:576
#, fuzzy
msgid ""
"In contrast to JAX-RS (and RESTeasy) running in a standard servlet-"
"container, Quarkus only supports the deployment of a single JAX-RS "
"application.  If multiple JAX-RS `Application` classes are defined, the "
"build will fail with the message `Multiple classes have been annotated with "
"@ApplicationPath which is currently not supported`."
msgstr ""
"JAX-RS（およびRESTeasy）が標準のサーブレットコンテナで実行されているのとは対照的に、Quarkusは単一のJAX-"
"RSアプリケーションのデプロイのみをサポートしています。複数のJAX-RS `Application` クラスが定義されている場合、ビルドは "
"`Multiple classes have been annotated with @ApplicationPath which is "
"currently not supported`."

#. type: Plain text
#: upstream/_guides/rest-json.adoc:578
#, fuzzy
msgid ""
"If multiple JAX-RS applications are defined, the property `quarkus.resteasy."
"ignoreApplicationClasses=true` can be used to ignore all explicit "
"`Application` classes. This makes all resource-classes available via the "
"application-path as defined by `quarkus.resteasy.path` (default: `/`)."
msgstr ""
"複数の JAX-RS アプリケーションが定義されている場合、プロパティ `quarkus.resteasy."
"ignoreApplicationClasses=true` を使用して、すべての明示的な `Application` "
"クラスを無視することができます。これにより、すべてのリソースクラスが `quarkus.resteasy.path` "
"で定義されたアプリケーションパスを介して利用できるようになります（デフォルトは `/` ）。"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:579
#, no-wrap, fuzzy
msgid "Lifecycle of Resources"
msgstr "資源のライフサイクル"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:583
#, fuzzy
msgid ""
"In Quarkus all JAX-RS resources are treated as CDI beans.  It's possible to "
"inject other beans via `@Inject`, bind interceptors using bindings such as "
"`@Transactional`, define `@PostConstruct` callbacks, etc."
msgstr ""
"Quarkusでは、すべてのJAX-RSリソースはCDIビーンとして扱われます。 `@Inject` を介して他のビーンを注入したり、 "
"`@Transactional` のようなバインディングを使用してインターセプターをバインドしたり、 `@PostConstruct` "
"コールバックを定義したりすることが可能です。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:589
#, fuzzy
msgid ""
"If there is no scope annotation declared on the resource class then the "
"scope is defaulted.  The default scope can be controlled through the "
"`quarkus.resteasy.singleton-resources` property.  If set to `true` (default) "
"then a *single instance* of a resource class is created to service all "
"requests (as defined by `@javax.inject.Singleton`).  If set to `false` then "
"a *new instance* of the resource class is created per each request.  An "
"explicit CDI scope annotation (`@RequestScoped`, `@ApplicationScoped`, etc.) "
"always overrides the default behavior and specifies the lifecycle of "
"resource instances."
msgstr ""
"リソースクラスでスコープ注釈が宣言されていない場合は、スコープはデフォルトになります。デフォルトのスコープは `quarkus.resteasy."
"singleton-resources` プロパティで制御できます。 `true` (デフォルト) に設定すると、( `@javax.inject."
"Singleton` で定義されているように) すべてのリクエストにサービスを提供するためのリソースクラスの *単一のインスタンス*が作成されます。 "
"`false` に設定すると、各リクエストごとにリソースクラスの *新しい インスタンス*が作成されます。明示的な CDI スコープ注釈 ( "
"`@RequestScoped`, `@ApplicationScoped`, など) "
"は常にデフォルトの動作を上書きし、リソースインスタンスのライフサイクルを指定します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:593
#, fuzzy
msgid ""
"Creating JSON REST services with Quarkus is easy as it relies on proven and "
"well known technologies."
msgstr "Quarkusを使用したJSON RESTサービスの作成は、実績のあるよく知られたテクノロジーに依存しているため、簡単に行えます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:595
#, fuzzy
msgid ""
"As usual, Quarkus further simplifies things under the hood when running your "
"application as a native executable."
msgstr "いつものように、Quarkusは、アプリケーションをネイティブの実行ファイルとして実行する際に、その下での作業をさらに簡略化しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:596
#, fuzzy
msgid ""
"There is only one thing to remember: if you use `Response` and Quarkus can't "
"determine the beans that are serialized, you need to annotate them with "
"`@RegisterForReflection`."
msgstr ""
"覚えておくべきことは一つだけあります。 `Response` を使用していて、Quarkus がシリアライズされているビーンを特定できない場合は、 "
"`@RegisterForReflection`.NET を使って注釈を付ける必要があります。"

#. type: delimited block =
#: upstream/_guides/platform-include.adoc:4
#, fuzzy
msgid ""
"This extension is developed by a third party and is part of the Quarkus "
"Platform."
msgstr "この拡張機能はサードパーティによって開発されたもので、Quarkus Platformの一部です。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka-streams.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using Apache Kafka Streams"
msgstr "Quarkus - Apache Kafkaストリームの使用"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:11
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize the Apache "
"Kafka Streams API to implement stream processing applications based on "
"Apache Kafka."
msgstr ""
"このガイドでは、QuarkusアプリケーションがApache Kafka Streams APIを利用して、Apache "
"Kafkaベースのストリーム処理アプリケーションを実装する方法を説明します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:21
#, fuzzy
msgid "Docker Compose to start an Apache Kafka development cluster"
msgstr "Docker ComposeでApache Kafka開発クラスタを起動する"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:24
#, fuzzy
msgid ""
"It is recommended, that you have read the {quickstarts-tree-url}/kafka-"
"quickstart[Kafka quickstart] before."
msgstr ""
"事前に{quickstarts-tree-url}/kafka-quickstart[Kafka quickstart]を読んでおくことをお勧めします。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:29
#, fuzzy
msgid ""
"The Quarkus extension for Kafka Streams allows for very fast turnaround "
"times during development by supporting the Quarkus Dev Mode (e.g. via `./"
"mvnw compile quarkus:dev`).  After changing the code of your Kafka Streams "
"topology, the application will automatically be reloaded when the next input "
"message arrives."
msgstr ""
"Kafka Streams用のQuarkus拡張機能を使用すると、Quarkus Dev "
"Modeをサポートすることで、開発期間を非常に短縮することができます（例： `./mvnw compile quarkus:dev` "
"を参照）。Kafka Streamsトポロジーのコードを変更した後、次の入力メッセージが到着すると、アプリケーションが自動的にリロードされます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:32
#, fuzzy
msgid ""
"A recommended development set-up is to have some producer which creates test "
"messages on the processed topic(s) in fixed intervals, e.g. every second and "
"observe the streaming application's output topic(s) using a tool such as "
"`kafkacat`.  Using the dev mode, you'll instantly see messages on the output "
"topic(s) as produced by the latest version of your streaming application "
"when saving."
msgstr ""
"推奨される開発セットアップは、処理されたトピックに対して一定の間隔 (たとえば毎秒) でテストメッセージを作成するプロデューサを用意し、 "
"`kafkacat` のようなツールを使用してストリーミング "
"アプリケーションの出力トピックを観察することです。開発モードを使用すると、保存時にストリーミングアプリケーションの最新バージョンによって生成された出力トピッ "
"ク上のメッセージを即座に見ることができます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:34
#, fuzzy
msgid ""
"For the best development experience, we recommend applying the following "
"configuration settings to your Kafka broker:"
msgstr "最高の開発環境を実現するために、以下の設定を Kafka ブローカーに適用することをお勧めします。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:38
#, no-wrap
msgid "group.min.session.timeout.ms=250\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:41
#, fuzzy
msgid ""
"Also specify the following settings in your Quarkus `application.properties`:"
""
msgstr "また、以下の設定をQuarkusで指定します `application.properties`."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:46
#, no-wrap
msgid ""
"kafka-streams.consumer.session.timeout.ms=250\n"
"kafka-streams.consumer.heartbeat.interval.ms=200\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:49
#, fuzzy
msgid ""
"Together, these settings will ensure that the application can very quickly "
"reconnect to the broker after being restarted in dev mode."
msgstr "これらの設定を併用することで、アプリケーションを開発モードで再起動した後に、非常に迅速にブローカに再接続できるようになります。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:56
#, fuzzy
msgid ""
"In this guide, we are going to generate (random) temperature values in one "
"component (named `generator`).  These values are associated to given weather "
"stations and are written in a Kafka topic (`temperature-values`).  Another "
"topic (`weather-stations`) contains just the master data about the weather "
"stations themselves (id and name)."
msgstr ""
"このガイドでは、(ランダムな)温度値を 1 つのコンポーネント ( `generator`) "
"で生成します。これらの値は、与えられた気象観測所に関連付けられ、Kafka トピック ( `temperature-values`) "
"に書き込まれます。別のトピック ( `weather-stations`) には、気象観測所自体に関するマスターデータ (id と名前) "
"だけが格納されています。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:58
#, fuzzy
msgid ""
"A second component (`aggregator`) reads from the two Kafka topics and "
"processes them in a streaming pipeline:"
msgstr ""
"2 つ目のコンポーネント ( `aggregator`) は、2 つの Kafka トピックから読み込み、ストリーミングパイプラインで処理します。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:60
#, fuzzy
msgid "the two topics are joined on weather station id"
msgstr "ウェザーステーションIDでは、この2つのトピックが結合されています。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:61
#, fuzzy
msgid "per weather station the min, max and average temperature is determined"
msgstr "各気象台ごとに最低、最高、平均気温が決定されます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:62
#, fuzzy
msgid ""
"this aggregated data is written out to a third topic (`temperatures-"
"aggregated`)"
msgstr "この集約されたデータは、第三のトピック ( `temperatures-aggregated`) に書き出されます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:66
#, fuzzy
msgid ""
"The data can be examined by inspecting the output topic.  By exposing a "
"Kafka Streams https://kafka.apache.org/22/documentation/streams/developer-"
"guide/interactive-queries.html[interactive query], the latest result for "
"each weather station can alternatively be obtained via a simple REST query."
msgstr ""
"出力トピックを検査することで、データを調べることができます。Kafka Streams の link:https://kafka.apache.org/"
"22/documentation/streams/developer-guide/interactive-queries."
"html[対話型クエリを]公開することで、各気象観測所の最新の結果を単純な REST クエリで取得することができます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:68
#, fuzzy
msgid "The overall architecture looks like so:"
msgstr "全体的な建築はこんな感じです。"

#. type: Target for macro image
#: upstream/_guides/kafka-streams.adoc:69
#, no-wrap
msgid "kafka-streams-guide-architecture.png"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:79
#, fuzzy
msgid ""
"The solution is located in the `kafka-streams-quickstart` {quickstarts-tree-"
"url}/kafka-streams-quickstart[directory]."
msgstr ""
"ソリューションは `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-"
"quickstart[directory] にあります。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:80
#, no-wrap, fuzzy
msgid "Creating the Producer Maven Project"
msgstr "Producer Maven プロジェクトの作成"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:84
#, fuzzy
msgid ""
"First, we need a new project with the temperature value producer.  Create a "
"new project with the following command:"
msgstr "まず、温度値プロデューサを持つ新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:93
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-streams-quickstart-producer \\\n"
"    -Dextensions=\"kafka\" \\\n"
"    -DnoExamples \\\n"
"    && mv kafka-streams-quickstart-producer producer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:96
#, fuzzy
msgid ""
"This command generates a Maven project, importing the Reactive Messaging and "
"Kafka connector extensions."
msgstr "このコマンドは、Reactive Messaging と Kafka コネクタ拡張をインポートして Maven プロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:99
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-reactive-messaging-kafka` extension to your project by running the "
"following command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-reactive-messaging-kafka` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:103
#, no-wrap
msgid ""
"./mvnw quarkus:add-extension -Dextensions=\"quarkus-smallrye-reactive-"
"messaging-kafka\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:113
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:115
#, no-wrap, fuzzy
msgid "The Temperature Value Producer"
msgstr "温度値プロデューサー"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:119
#, fuzzy
msgid ""
"Create the `producer/src/main/java/org/acme/kafka/streams/producer/generator/"
"ValuesGenerator.java` file, with the following content:"
msgstr ""
"以下の内容の `producer/src/main/java/org/acme/kafka/streams/producer/generator/"
"ValuesGenerator.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:123
#, no-wrap
msgid "package org.acme.kafka.streams.producer.generator;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:132
#, no-wrap
msgid ""
"import java.math.BigDecimal;\n"
"import java.math.RoundingMode;\n"
"import java.time.Duration;\n"
"import java.time.Instant;\n"
"import java.util.Arrays;\n"
"import java.util.Collections;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:139
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.reactive.messaging.kafka.Record;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:148
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random temperature data every second.\n"
" * The values are written to a Kafka topic (temperature-values).\n"
" * Another topic contains the name of weather stations (weather-stations).\n"
" * The Kafka configuration is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class ValuesGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:150
#, no-wrap
msgid ""
"    private static final Logger LOG = Logger.getLogger(ValuesGenerator."
"class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:165
#, no-wrap
msgid ""
"    private List<WeatherStation> stations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                    new WeatherStation(1, \"Hamburg\", 13),\n"
"                    new WeatherStation(2, \"Snowdonia\", 5),\n"
"                    new WeatherStation(3, \"Boston\", 11),\n"
"                    new WeatherStation(4, \"Tokio\", 16),\n"
"                    new WeatherStation(5, \"Cusco\", 12),\n"
"                    new WeatherStation(6, \"Svalbard\", -7),\n"
"                    new WeatherStation(7, \"Porthsmouth\", 11),\n"
"                    new WeatherStation(8, \"Oslo\", 7),\n"
"                    new WeatherStation(9, \"Marrakesh\", 20)\n"
"            ));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:175
#, no-wrap
msgid ""
"    @Outgoing(\"temperature-values\")                                        "
"// <1>\n"
"    public Multi<Record<Integer, String>> generate() {\n"
"        return Multi.createFrom().ticks().every(Duration.ofMillis(500))    //"
" <2>\n"
"                .onOverflow().drop()\n"
"                .map(tick -> {\n"
"                    WeatherStation station = stations.get(random."
"nextInt(stations.size()));\n"
"                    double temperature = BigDecimal.valueOf(random."
"nextGaussian() * 15 + station.averageTemperature)\n"
"                            .setScale(1, RoundingMode.HALF_UP)\n"
"                            .doubleValue();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:180
#, no-wrap
msgid ""
"                    LOG.infov(\"station: {0}, temperature: {1}\", station."
"name, temperature);\n"
"                    return Record.of(station.id, Instant.now() + \";\" + "
"temperature);\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:190
#, no-wrap
msgid ""
"    @Outgoing(\"weather-stations\")                                          "
"// <3>\n"
"    public Multi<Record<Integer, String>> weatherStations() {\n"
"        return Multi.createFrom().items(stations.stream()\n"
"            .map(s -> Record.of(\n"
"                    s.id,\n"
"                    \"{ \\\"id\\\" : \" + s.id +\n"
"                    \", \\\"name\\\" : \\\"\" + s.name + \"\\\" }\"))\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:192
#, no-wrap
msgid "    private static class WeatherStation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:196
#, no-wrap
msgid "        int id;\n"
"        String name;\n"
"        int averageTemperature;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:204
#, no-wrap
msgid ""
"        public WeatherStation(int id, String name, int averageTemperature) {\n"
"            this.id = id;\n"
"            this.name = name;\n"
"            this.averageTemperature = averageTemperature;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:206
#, fuzzy
msgid ""
"Instruct Reactive Messaging to dispatch the items from the returned `Multi` "
"to `temperature-values`."
msgstr ""
"返却された `Multi` から `temperature-values` にアイテムを発送するように Reactive Messaging "
"に指示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:207
#, fuzzy
msgid ""
"The method returns a Mutiny _stream_ (`Multi`) emitting a random temperature "
"value every 0.5 seconds."
msgstr "このメソッドは、0.5 秒ごとにランダムな温度値を放出する Mutiny _ストリーム_( `Multi`) を返します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:208
#, fuzzy
msgid ""
"Instruct Reactive Messaging to dispatch the items from the returned `Multi` "
"(static list of weather stations) to `weather-stations`."
msgstr ""
"返された `Multi` (気象観測所の静的リスト) から `weather-stations` にアイテムをディスパッチするように Reactive "
"Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:210
#, fuzzy
msgid ""
"The two methods each return a _reactive stream_ whose items are sent to the "
"streams named `temperature-values` and `weather-stations`, respectively."
msgstr ""
"この 2 つのメソッドは、それぞれ `temperature-values` と `weather-stations` "
"という名前のストリームにアイテムが送信される _反応型ストリーム_を返します。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:211
#, no-wrap, fuzzy
msgid "Topic Configuration"
msgstr "トピック構成"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:215
#, fuzzy
msgid ""
"The two channels are mapped to Kafka topics using the Quarkus configuration "
"file `application.properties`.  For that, add the following to the file "
"`producer/src/main/resources/application.properties`:"
msgstr ""
"2つのチャンネルは、Quarkus設定ファイル `application.properties` "
"を使用してKafkaトピックにマッピングされます。そのためには、ファイル `producer/src/main/resources/"
"application.properties` に次のように追加します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:220
#, no-wrap
msgid ""
"# Configure the Kafka broker location\n"
"kafka.bootstrap.servers=localhost:9092\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:224
#, no-wrap
msgid ""
"mp.messaging.outgoing.temperature-values.connector=smallrye-kafka\n"
"mp.messaging.outgoing.temperature-values.key.serializer=org.apache.kafka."
"common.serialization.IntegerSerializer\n"
"mp.messaging.outgoing.temperature-values.value.serializer=org.apache.kafka."
"common.serialization.StringSerializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:228
#, no-wrap
msgid ""
"mp.messaging.outgoing.weather-stations.connector=smallrye-kafka\n"
"mp.messaging.outgoing.weather-stations.key.serializer=org.apache.kafka."
"common.serialization.IntegerSerializer\n"
"mp.messaging.outgoing.weather-stations.value.serializer=org.apache.kafka."
"common.serialization.StringSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:232
#, fuzzy
msgid ""
"This configures the Kafka bootstrap server, the two topics and the "
"corresponding (de-)serializers.  More details about the different "
"configuration options are available on the https://kafka.apache.org/"
"documentation/#producerconfigs[Producer configuration] and https://kafka."
"apache.org/documentation/#consumerconfigs[Consumer configuration] section "
"from the Kafka documentation."
msgstr ""
"これは、Kafka ブートストラップサーバ、2 つのトピック、および対応する "
"(脱)シリアライザを設定します。さまざまな設定オプションの詳細については、Kafka ドキュメントの link:https://kafka.apache."
"org/documentation/#producerconfigs[Producer 設定]と link:https://kafka.apache."
"org/documentation/#consumerconfigs[Consumer 設定]のセクションを参照してください。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:233
#, no-wrap, fuzzy
msgid "Creating the Aggregator Maven Project"
msgstr "アグリゲータMavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:238
#, fuzzy
msgid ""
"With the producer application in place, it's time to implement the actual "
"aggregator application, which will run the Kafka Streams pipeline.  Create "
"another project like so:"
msgstr ""
"プロデューサアプリケーションを用意したら、Kafka Streams "
"パイプラインを実行するアグリゲータアプリケーションを実装しましょう。このように別のプロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:247
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-streams-quickstart-aggregator \\\n"
"    -Dextensions=\"kafka-streams,resteasy-jackson\" \\\n"
"    -DnoExamples \\\n"
"    && mv kafka-streams-quickstart-aggregator aggregator\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:250
#, fuzzy
msgid ""
"This creates the `aggregator` project with the Quarkus extension for Kafka "
"Streams and with RESTEasy support for Jackson."
msgstr ""
"これにより、Kafka Streams用のQuarkus拡張機能とJackson用のRESTEasyサポートを備えた `aggregator` "
"プロジェクトが作成されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:253
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `kafka-"
"streams` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `kafka-"
"streams` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:257
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"kafka-streams\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:267
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-kafka-streams</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:269
#, no-wrap, fuzzy
msgid "The Pipeline Implementation"
msgstr "パイプラインの実装"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:273
#, fuzzy
msgid ""
"Let's begin the implementation of the stream processing application by "
"creating a few value objects for representing temperature measurements, "
"weather stations and for keeping track of aggregated values."
msgstr ""
"ストリーム処理アプリケーションの実装を開始しましょう。温度測定、気象観測所を表現し、集約された値を追跡するためのいくつかの値オブジェクトを作成することから始めましょう。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:276
#, fuzzy
msgid ""
"First, create the file `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/model/WeatherStation.java`, representing a weather station, with "
"the following content:"
msgstr ""
"まず、次の内容で、ファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/WeatherStation.java` を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:280
#: upstream/_guides/kafka-streams.adoc:298
#: upstream/_guides/kafka-streams.adoc:324
#: upstream/_guides/kafka-streams.adoc:682
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.model;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:285
#, no-wrap
msgid "@RegisterForReflection // <1>\n"
"public class WeatherStation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:289
#, no-wrap
msgid "    public int id;\n"
"    public String name;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:291
#, fuzzy
msgid ""
"By adding the `@RegisterForReflection` annotation, it is ensured that this "
"type can be instantiated reflectively when running the application in native "
"mode."
msgstr ""
"`@RegisterForReflection` "
"アノテーションを追加することで、ネイティブモードでアプリケーションを実行しているときに、この型が反射的にインスタンス化されることが保証されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:294
#, fuzzy
msgid ""
"Then the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/TemperatureMeasurement.java`, representing temperature measurements "
"for a given station:"
msgstr ""
"次に、指定されたステーションの温度測定値を表すファイル `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/model/TemperatureMeasurement.java` 。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:300
#: upstream/_guides/kafka-streams.adoc:367
#, no-wrap
msgid "import java.time.Instant;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:302
#, no-wrap
msgid "public class TemperatureMeasurement {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:307
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public Instant timestamp;\n"
"    public double value;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:316
#, no-wrap
msgid ""
"    public TemperatureMeasurement(int stationId, String stationName, Instant "
"timestamp,\n"
"            double value) {\n"
"        this.stationId = stationId;\n"
"        this.stationName = stationName;\n"
"        this.timestamp = timestamp;\n"
"        this.value = value;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:320
#, fuzzy
msgid ""
"And finally `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/Aggregation.java`, which will be used to keep track of the aggregated "
"values while the events are processed in the streaming pipeline:"
msgstr ""
"そして最後に `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/"
"Aggregation.java` 、イベントがストリーミング・パイプラインで処理されている間、集約された値を追跡するために使用されます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:327
#, no-wrap
msgid "import java.math.BigDecimal;\n"
"import java.math.RoundingMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:332
#, no-wrap
msgid "@RegisterForReflection\n"
"public class Aggregation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:340
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public double min = Double.MAX_VALUE;\n"
"    public double max = Double.MIN_VALUE;\n"
"    public int count;\n"
"    public double sum;\n"
"    public double avg;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:344
#, no-wrap
msgid ""
"    public Aggregation updateFrom(TemperatureMeasurement measurement) {\n"
"        stationId = measurement.stationId;\n"
"        stationName = measurement.stationName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:349
#, no-wrap
msgid ""
"        count++;\n"
"        sum += measurement.value;\n"
"        avg = BigDecimal.valueOf(sum / count)\n"
"                .setScale(1, RoundingMode.HALF_UP).doubleValue();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:352
#, no-wrap
msgid ""
"        min = Math.min(min, measurement.value);\n"
"        max = Math.max(max, measurement.value);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:356
#, no-wrap
msgid "        return this;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:361
#, fuzzy
msgid ""
"Next, let's create the actual streaming query implementation itself in the "
"`aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/"
"TopologyProducer.java` file.  All we need to do for that is to declare a CDI "
"producer method which returns the Kafka Streams `Topology`; the Quarkus "
"extension will take care of configuring, starting and stopping the actual "
"Kafka Streams engine."
msgstr ""
"次に、実際のストリーミングクエリの実装自体を `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/streams/TopologyProducer.java` ファイルで作成してみましょう。そのために必要なのは、Kafka "
"Streams `Topology` を返す CDI プロデューサメソッドを宣言することだけです。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:365
#: upstream/_guides/kafka-streams.adoc:598
#: upstream/_guides/kafka-streams.adoc:645
#: upstream/_guides/kafka-streams.adoc:869
#: upstream/_guides/kafka-streams.adoc:923
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.streams;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:370
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.inject.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:383
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.model.Aggregation;\n"
"import org.acme.kafka.streams.aggregator.model.TemperatureMeasurement;\n"
"import org.acme.kafka.streams.aggregator.model.WeatherStation;\n"
"import org.apache.kafka.common.serialization.Serdes;\n"
"import org.apache.kafka.streams.StreamsBuilder;\n"
"import org.apache.kafka.streams.Topology;\n"
"import org.apache.kafka.streams.kstream.Consumed;\n"
"import org.apache.kafka.streams.kstream.GlobalKTable;\n"
"import org.apache.kafka.streams.kstream.Materialized;\n"
"import org.apache.kafka.streams.kstream.Produced;\n"
"import org.apache.kafka.streams.state.KeyValueBytesStoreSupplier;\n"
"import org.apache.kafka.streams.state.Stores;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:385
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperSerde;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:388
#, no-wrap
msgid "@ApplicationScoped\n"
"public class TopologyProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:390
#, no-wrap
msgid ""
"    static final String WEATHER_STATIONS_STORE = \"weather-stations-"
"store\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:394
#, no-wrap
msgid ""
"    private static final String WEATHER_STATIONS_TOPIC = \"weather-"
"stations\";\n"
"    private static final String TEMPERATURE_VALUES_TOPIC = \"temperature-"
"values\";\n"
"    private static final String TEMPERATURES_AGGREGATED_TOPIC = "
"\"temperatures-aggregated\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:398
#, no-wrap
msgid ""
"    @Produces\n"
"    public Topology buildTopology() {\n"
"        StreamsBuilder builder = new StreamsBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:402
#, no-wrap
msgid ""
"        ObjectMapperSerde<WeatherStation> weatherStationSerde = new "
"ObjectMapperSerde<>(\n"
"                WeatherStation.class);\n"
"        ObjectMapperSerde<Aggregation> aggregationSerde = new "
"ObjectMapperSerde<>(Aggregation.class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:405
#, no-wrap
msgid ""
"        KeyValueBytesStoreSupplier storeSupplier = Stores."
"persistentKeyValueStore(\n"
"                WEATHER_STATIONS_STORE);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:409
#, no-wrap
msgid ""
"        GlobalKTable<Integer, WeatherStation> stations = builder."
"globalTable( // <1>\n"
"                WEATHER_STATIONS_TOPIC,\n"
"                Consumed.with(Serdes.Integer(), weatherStationSerde));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:436
#, no-wrap
msgid ""
"        builder.stream(                                                      "
" // <2>\n"
"                        TEMPERATURE_VALUES_TOPIC,\n"
"                        Consumed.with(Serdes.Integer(), Serdes.String())\n"
"                )\n"
"                .join(                                                       "
" // <3>\n"
"                        stations,\n"
"                        (stationId, timestampAndValue) -> stationId,\n"
"                        (timestampAndValue, station) -> {\n"
"                            String[] parts = timestampAndValue.split(\";\");\n"
"                            return new TemperatureMeasurement(station.id, "
"station.name,\n"
"                                    Instant.parse(parts[0]), Double."
"valueOf(parts[1]));\n"
"                        }\n"
"                )\n"
"                .groupByKey()                                                "
" // <4>\n"
"                .aggregate(                                                  "
" // <5>\n"
"                        Aggregation::new,\n"
"                        (stationId, value, aggregation) -> aggregation."
"updateFrom(value),\n"
"                        Materialized.<Integer, Aggregation> "
"as(storeSupplier)\n"
"                            .withKeySerde(Serdes.Integer())\n"
"                            .withValueSerde(aggregationSerde)\n"
"                )\n"
"                .toStream()\n"
"                .to(                                                         "
" // <6>\n"
"                        TEMPERATURES_AGGREGATED_TOPIC,\n"
"                        Produced.with(Serdes.Integer(), aggregationSerde)\n"
"                );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:440
#, no-wrap
msgid "        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:442
#, fuzzy
msgid ""
"The `weather-stations` table is read into a `GlobalKTable`, representing the "
"current state of each weather station"
msgstr "`weather-stations` テーブルは、各気象台の現在の状態を表す `GlobalKTable` に読み込まれます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:443
#, fuzzy
msgid ""
"The `temperature-values` topic is read into a `KStream`; whenever a new "
"message arrives to this topic, the pipeline will be processed for this "
"measurement"
msgstr ""
"`temperature-values` トピックは `KStream` "
"に読み込まれます。このトピックに新しいメッセージが到着するたびに、パイプラインはこの測定のために処理されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:444
#, fuzzy
msgid ""
"The message from the `temperature-values` topic is joined with the "
"corresponding weather station, using the topic's key (weather station id); "
"the join result contains the data from the measurement and associated "
"weather station message"
msgstr ""
"`temperature-values` トピックからのメッセージは、トピックのキー (ウェザーステーション ID) "
"を使用して、対応するウェザーステーションと結合されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:445
#, fuzzy
msgid "The values are grouped by message key (the weather station id)"
msgstr "値はメッセージキー（ウェザーステーションID）によってグループ化されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:446
#, fuzzy
msgid ""
"Within each group, all the measurements of that station are aggregated, by "
"keeping track of minimum and maximum values and calculating the average "
"value of all measurements of that station (see the `Aggregation` type)"
msgstr ""
"各グループ内では、最小値と最大値を追跡し、そのステーションのすべての測定値の平均値を計算することで、そのステーションのすべての測定値が集約されます（ "
"`Aggregation` タイプを参照）。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:447
#, fuzzy
msgid ""
"The results of the pipeline are written out to the `temperatures-aggregated` "
"topic"
msgstr "パイプラインの結果は `temperatures-aggregated` トピックに書き出しています。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:450
#, fuzzy
msgid ""
"The Kafka Streams extension is configured via the Quarkus configuration file "
"`application.properties`.  Create the file `aggregator/src/main/resources/"
"application.properties` with the following contents:"
msgstr ""
"Kafka Streamsの拡張子は、Quarkusの設定ファイル `application.properties` で設定します。ファイル "
"`aggregator/src/main/resources/application.properties` を以下の内容で作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:456
#, no-wrap
msgid ""
"quarkus.kafka-streams.bootstrap-servers=localhost:9092\n"
"quarkus.kafka-streams.application-server=${hostname}:8080\n"
"quarkus.kafka-streams.topics=weather-stations,temperature-values\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:463
#, no-wrap
msgid ""
"# pass-through options\n"
"kafka-streams.cache.max.bytes.buffering=10240\n"
"kafka-streams.commit.interval.ms=1000\n"
"kafka-streams.metadata.max.age.ms=500\n"
"kafka-streams.auto.offset.reset=earliest\n"
"kafka-streams.metrics.recording.level=DEBUG\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:470
#, fuzzy
msgid ""
"The options with the `quarkus.kafka-streams` prefix can be changed "
"dynamically at application startup, e.g. via environment variables or system "
"properties.  `bootstrap-servers` and `application-server` are mapped to the "
"Kafka Streams properties `bootstrap.servers` and `application.server`, "
"respectively.  `topics` is specific to Quarkus: the application will wait "
"for all the given topics to exist before launching the Kafka Streams engine. "
" This is to done to gracefully await the creation of topics that don't yet "
"exist at application startup time."
msgstr ""
"`quarkus.kafka-streams` `bootstrap-servers` と は、それぞれ Kafka Streams プロパティ と "
"にマップされます。 は Quarkus に固有のもので、アプリケーションは Kafka Streams "
"エンジンを起動する前に、指定したすべてのトピックが存在するのを待ちます。これは、アプリケーションの起動時にまだ存在しないトピックの作成を優雅に待つために行われます。 "
"`application-server` `bootstrap.servers` `application.server` `topics`"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:473
#, fuzzy
msgid ""
"All the properties within the `kafka-streams` namespace are passed through "
"as-is to the Kafka Streams engine.  Changing their values requires a rebuild "
"of the application."
msgstr ""
"`kafka-streams` ネームスペース内のすべてのプロパティは、そのまま Kafka Streams "
"エンジンに渡されます。プロパティの値を変更するには、アプリケーションの再構築が必要です。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:474
#, no-wrap, fuzzy
msgid "Building and Running the Applications"
msgstr "アプリケーションの構築と実行"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:477
#, fuzzy
msgid "We now can build the `producer` and `aggregator` applications:"
msgstr "`producer` と `aggregator` のアプリケーションを構築できるようになりました。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:482
#, no-wrap
msgid ""
"./mvnw clean package -f producer/pom.xml\n"
"./mvnw clean package -f aggregator/pom.xml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:487
#, fuzzy
msgid ""
"Instead of running them directly on the host machine using the Quarkus dev "
"mode, we're going to package them into container images and launch them via "
"Docker Compose.  This is done in order to demonstrate scaling the "
"`aggregator` aggregation to multiple nodes later on."
msgstr ""
"Quarkusのdevモードを使ってホストマシン上で直接実行するのではなく、コンテナイメージにパッケージ化してDocker "
"Compose経由で起動します。これは、後で `aggregator` のアグリゲーションを複数のノードにスケーリングすることを実証するために行います。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:490
#, fuzzy
msgid ""
"The `Dockerfile` created by Quarkus by default needs one adjustment for the "
"`aggregator` application in order to run the Kafka Streams pipeline.  To do "
"so, edit the file `aggregator/src/main/docker/Dockerfile.jvm` and replace "
"the line `FROM fabric8/java-alpine-openjdk8-jre` with `FROM fabric8/java-"
"centos-openjdk8-jdk`."
msgstr ""
"Quarkusがデフォルトで作成した `Dockerfile` は、Kafka Streamsパイプラインを実行するために、 `aggregator` "
"アプリケーションに1つの調整が必要です。そのためには、 `aggregator/src/main/docker/Dockerfile.jvm` "
"ファイルを編集して、 `FROM fabric8/java-alpine-openjdk8-jre` の行を `FROM fabric8/java-"
"centos-openjdk8-jdk` に置き換えます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:492
#, fuzzy
msgid ""
"Next create a Docker Compose file (`docker-compose.yaml`) for spinning up "
"the two applications as well as Apache Kafka and ZooKeeper like so:"
msgstr ""
"次に、2 つのアプリケーションを回転させるための Docker Compose ファイル ( `docker-compose.yaml`) "
"を作成し、Apache Kafka、ZooKeeper と同様に以下のようにします。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:496
#, no-wrap
msgid "version: '3.5'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:528
#, no-wrap
msgid ""
"services:\n"
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
"    networks:\n"
"      - kafkastreams-network\n"
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override "
"listeners=$${KAFKA_LISTENERS} --override advertised.listeners="
"$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect="
"$${KAFKA_ZOOKEEPER_CONNECT} --override num.partitions="
"$${KAFKA_NUM_PARTITIONS}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
"      KAFKA_NUM_PARTITIONS: 3\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:538
#, no-wrap
msgid ""
"  producer:\n"
"    image: quarkus-quickstarts/kafka-streams-producer:1.0\n"
"    build:\n"
"      context: producer\n"
"      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}\n"
"    environment:\n"
"      KAFKA_BOOTSTRAP_SERVERS: kafka:9092\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:548
#, no-wrap
msgid ""
"  aggregator:\n"
"    image: quarkus-quickstarts/kafka-streams-aggregator:1.0\n"
"    build:\n"
"      context: aggregator\n"
"      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}\n"
"    environment:\n"
"      QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS: kafka:9092\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:552
#, no-wrap
msgid "networks:\n"
"  kafkastreams-network:\n"
"    name: ks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:556
#, fuzzy
msgid ""
"To launch all the containers, building the `producer` and `aggregator` "
"container images, run `docker-compose up --build`."
msgstr ""
"`producer` と `aggregator` のコンテナイメージを構築して、すべてのコンテナを起動するには、 `docker-compose up "
"--build` を実行します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:558
#, fuzzy
msgid ""
"You should see log statements from the `producer` application about messages "
"being sent to the \"temperature-values\" topic."
msgstr ""
"`producer` アプリケーションから、\"temperature-values\" "
"トピックに送信されたメッセージに関するログステートメントが表示されるはずです。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:561
#, fuzzy
msgid ""
"Now run an instance of the _debezium/tooling_ image, attaching to the same "
"network all the other containers run in.  This image provides several useful "
"tools such as _kafkacat_ and _httpie_:"
msgstr ""
"ここで _debezium/"
"tooling_イメージのインスタンスを実行し、他のすべてのコンテナが実行しているのと同じネットワークにアタッチします。このイメージは、 "
"_kafkacat_や _httpie_ などの便利なツールを提供しています。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:565
#, no-wrap
msgid "docker run --tty --rm -i --network ks debezium/tooling:1.1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:568
#, fuzzy
msgid ""
"Within the tooling container, run _kafkacat_ to examine the results of the "
"streaming pipeline:"
msgstr "ツールコンテナ内で、 _kafkacatを_実行して、ストリーミングパイプラインの結果を調べます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:572
#, no-wrap
msgid "kafkacat -b kafka:9092 -C -o beginning -q -t temperatures-aggregated\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:577
#, no-wrap
msgid ""
"{\"avg\":34.7,\"count\":4,\"max\":49.4,\"min\":16.8,\"stationId\":"
"9,\"stationName\":\"Marrakesh\",\"sum\":138.8}\n"
"{\"avg\":15.7,\"count\":1,\"max\":15.7,\"min\":15.7,\"stationId\":"
"2,\"stationName\":\"Snowdonia\",\"sum\":15.7}\n"
"{\"avg\":12.8,\"count\":7,\"max\":25.5,\"min\":-13.8,\"stationId\":"
"7,\"stationName\":\"Porthsmouth\",\"sum\":89.7}\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:581
#, fuzzy
msgid ""
"You should see new values arrive as the producer continues to emit "
"temperature measurements, each value on the outbound topic showing the "
"minimum, maximum and average temperature values of the represented weather "
"station."
msgstr ""
"プロデューサが温度測定値を出力し続けると、新しい値が表示され、送信トピックの各値は、表現された気象観測所の最小、最大、および平均温度値を表示します。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:582
#, no-wrap, fuzzy
msgid "Interactive Queries"
msgstr "インタラクティブクエリ"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:590
#, fuzzy
msgid ""
"Subscribing to the `temperatures-aggregated` topic is a great way to react "
"to any new temperature values.  It's a bit wasteful though if you're just "
"interested in the latest aggregated value for a given weather station.  This "
"is where Kafka Streams interactive queries shine: they let you directly "
"query the underlying state store of the pipeline for the value associated to "
"a given key.  By exposing a simple REST endpoint which queries the state "
"store, the latest aggregation result can be retrieved without having to "
"subscribe to any Kafka topic."
msgstr ""
"`temperatures-aggregated` "
"のトピックを購読することは、新しい気温の値に反応するための素晴らしい方法です。しかし、特定の気象観測所の最新の集計値だけに興味がある場合には、少しもったいないです。そこで、Kafka "
"Streams の対話型クエリが威力を発揮します。ステートストアをクエリするシンプルな REST エンドポイントを公開することで、Kafka "
"トピックを購読しなくても最新の集計結果を取得することができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:592
#, fuzzy
msgid ""
"Let's begin by creating a new class `InteractiveQueries` in the file "
"`aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/"
"InteractiveQueries.java`:"
msgstr ""
"`InteractiveQueries` まず、ファイル `aggregator/src/main/java/org/acme/kafka/"
"streams/aggregator/streams/InteractiveQueries.java`."

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:594
#, fuzzy
msgid ""
"one more method to the `KafkaStreamsPipeline` class which obtains the "
"current state for a given key:"
msgstr "`KafkaStreamsPipeline` クラスに、与えられたキーの現在の状態を取得するメソッドをもう一つ追加しました。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:608
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.model.Aggregation;\n"
"import org.acme.kafka.streams.aggregator.model.WeatherStationData;\n"
"import org.apache.kafka.streams.KafkaStreams;\n"
"import org.apache.kafka.streams.errors.InvalidStateStoreException;\n"
"import org.apache.kafka.streams.state.QueryableStoreTypes;\n"
"import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:611
#, no-wrap
msgid "@ApplicationScoped\n"
"public class InteractiveQueries {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:614
#, no-wrap
msgid "    @Inject\n"
"    KafkaStreams streams;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:617
#, no-wrap
msgid ""
"    public GetWeatherStationDataResult getWeatherStationData(int id) {\n"
"        Aggregation result = getWeatherStationStore().get(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:625
#, no-wrap
msgid ""
"        if (result != null) {\n"
"            return GetWeatherStationDataResult.found(WeatherStationData."
"from(result)); // <1>\n"
"        }\n"
"        else {\n"
"            return GetWeatherStationDataResult.notFound();                   "
"          // <2>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:636
#, no-wrap
msgid ""
"    private ReadOnlyKeyValueStore<Integer, Aggregation> "
"getWeatherStationStore() {\n"
"        while (true) {\n"
"            try {\n"
"                return streams.store(TopologyProducer."
"WEATHER_STATIONS_STORE, QueryableStoreTypes.keyValueStore());\n"
"            } catch (InvalidStateStoreException e) {\n"
"                // ignore, store not ready yet\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:638
#, fuzzy
msgid ""
"A value for the given station id was found, so that value will be returned"
msgstr "指定された駅IDの値が見つかったので、その値が返されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:639
#, fuzzy
msgid ""
"No value was found, either because a non-existing station was queried or no "
"measurement exists yet for the given station"
msgstr "存在しないステーションがクエリされたか、指定されたステーションに測定がまだ存在しないため、値が見つかりませんでした。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:641
#, fuzzy
msgid ""
"Also create the method's return type in the file `aggregator/src/main/java/"
"org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java`:"
msgstr ""
"また、メソッドの戻り値の型もファイル `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/streams/GetWeatherStationDataResult.java`."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:648
#: upstream/_guides/kafka-streams.adoc:872
#, no-wrap
msgid "import java.util.Optional;\n"
"import java.util.OptionalInt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:650
#: upstream/_guides/kafka-streams.adoc:874
#, no-wrap
msgid "import org.acme.kafka.streams.aggregator.model.WeatherStationData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:652
#: upstream/_guides/kafka-streams.adoc:876
#, no-wrap
msgid "public class GetWeatherStationDataResult {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:655
#, no-wrap
msgid ""
"    private static GetWeatherStationDataResult NOT_FOUND =\n"
"            new GetWeatherStationDataResult(null);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:657
#, no-wrap
msgid "    private final WeatherStationData result;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:661
#, no-wrap
msgid ""
"    private GetWeatherStationDataResult(WeatherStationData result) {\n"
"        this.result = result;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:665
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult found(WeatherStationData data) "
"{\n"
"        return new GetWeatherStationDataResult(data);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:669
#: upstream/_guides/kafka-streams.adoc:902
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult notFound() {\n"
"        return NOT_FOUND;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:674
#, no-wrap
msgid ""
"    public Optional<WeatherStationData> getResult() {\n"
"        return Optional.ofNullable(result);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:678
#, fuzzy
msgid ""
"Also create `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/WeatherStationData.java`, which represents the actual aggregation "
"result for a weather station:"
msgstr ""
"また、気象台の実際の集計結果を表す `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/model/WeatherStationData.java` を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:687
#, no-wrap
msgid "@RegisterForReflection\n"
"public class WeatherStationData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:694
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public double min = Double.MAX_VALUE;\n"
"    public double max = Double.MIN_VALUE;\n"
"    public int count;\n"
"    public double avg;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:704
#, no-wrap
msgid ""
"    private WeatherStationData(int stationId, String stationName, double "
"min, double max,\n"
"            int count, double avg) {\n"
"        this.stationId = stationId;\n"
"        this.stationName = stationName;\n"
"        this.min = min;\n"
"        this.max = max;\n"
"        this.count = count;\n"
"        this.avg = avg;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:715
#, no-wrap
msgid ""
"    public static WeatherStationData from(Aggregation aggregation) {\n"
"        return new WeatherStationData(\n"
"                aggregation.stationId,\n"
"                aggregation.stationName,\n"
"                aggregation.min,\n"
"                aggregation.max,\n"
"                aggregation.count,\n"
"                aggregation.avg);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:719
#, fuzzy
msgid ""
"We now can add a simple REST endpoint (`aggregator/src/main/java/org/acme/"
"kafka/streams/aggregator/rest/WeatherStationEndpoint.java`), which invokes "
"`getWeatherStationData()` and returns the data to the client:"
msgstr ""
"これで、 `getWeatherStationData()` を呼び出してクライアントにデータを返すシンプルな REST エンドポイント ( "
"`aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/"
"WeatherStationEndpoint.java`) を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:723
#: upstream/_guides/kafka-streams.adoc:943
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.rest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:727
#: upstream/_guides/kafka-streams.adoc:947
#, no-wrap
msgid ""
"import java.net.URI;\n"
"import java.net.URISyntaxException;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:736
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:739
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.streams."
"GetWeatherStationDataResult;\n"
"import org.acme.kafka.streams.aggregator.streams.KafkaStreamsPipeline;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:743
#: upstream/_guides/kafka-streams.adoc:966
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Path(\"/weather-stations\")\n"
"public class WeatherStationEndpoint {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:746
#: upstream/_guides/kafka-streams.adoc:969
#, no-wrap
msgid "    @Inject\n"
"    InteractiveQueries interactiveQueries;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:751
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/data/{id}\")\n"
"    public Response getWeatherStationData(@PathParam(\"id\") int id) {\n"
"        GetWeatherStationDataResult result = interactiveQueries."
"getWeatherStationData(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:761
#, no-wrap
msgid ""
"        if (result.getResult().isPresent()) {  // <1>\n"
"            return Response.ok(result.getResult().get()).build();\n"
"        }\n"
"        else {\n"
"            return Response.status(Status.NOT_FOUND.getStatusCode(),\n"
"                    \"No data found for weather station \" + id).build();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:763
#, fuzzy
msgid ""
"Depending on whether a value was obtained, either return that value or a 404 "
"response"
msgstr "値が取得されたかどうかに応じて、その値を返すか、404 レスポンスを返すかのどちらかを選択します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:765
#, fuzzy
msgid ""
"With this code in place, it's time to rebuild the application and the "
"`aggregator` service in Docker Compose:"
msgstr "このコードを用意して、Docker Composeでアプリケーションと `aggregator` サービスを再構築しましょう。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:771
#, no-wrap
msgid ""
"./mvnw clean package -f aggregator/pom.xml\n"
"docker-compose stop aggregator\n"
"docker-compose up --build -d\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:776
#, fuzzy
msgid ""
"This will rebuild the `aggregator` container and restart its service.  Once "
"that's done, you can invoke the service's REST API to obtain the temperature "
"data for one of the existing stations.  To do so, you can use `httpie` in "
"the tooling container launched before:"
msgstr ""
"これにより、 `aggregator` コンテナが再構築され、サービスが再起動されます。これが完了したら、サービスの REST API "
"を呼び出して、既存のステーションの 1 つの温度データを取得することができます。そのためには、前に起動したツーリングコンテナで `httpie` "
"を使用します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:780
#, no-wrap
msgid "http aggregator:8080/weather-stations/data/1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:786
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 85\n"
"Content-Type: application/json\n"
"Date: Tue, 18 Jun 2019 19:29:16 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:795
#, no-wrap
msgid ""
"{\n"
"    \"avg\": 12.9,\n"
"    \"count\": 146,\n"
"    \"max\": 41.0,\n"
"    \"min\": -25.6,\n"
"    \"stationId\": 1,\n"
"    \"stationName\": \"Hamburg\"\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:797
#, no-wrap, fuzzy
msgid "Scaling Out"
msgstr "スケーリングアウト"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:804
#, fuzzy
msgid ""
"A very interesting trait of Kafka Streams applications is that they can be "
"scaled out, i.e. the load and state can be distributed amongst multiple "
"application instances running the same pipeline.  Each node will then "
"contain a subset of the aggregation results, but Kafka Streams provides you "
"with https://kafka.apache.org/22/documentation/streams/developer-guide/"
"interactive-queries.html#querying-remote-state-stores-for-the-entire-app[an "
"API] to obtain the information which node is hosting a given key.  The "
"application can then either fetch the data directly from the other instance, "
"or simply point the client to the location of that other node."
msgstr ""
"つまり、同じパイプラインを実行している複数のアプリケーションインスタンス間で負荷や状態を分散させることができます。各ノードには集約結果のサブセットが含まれますが、Kafka "
"Streams は、与えられたキーをホストしているノードの情報を取得するための link:https://kafka.apache.org/22/"
"documentation/streams/developer-guide/interactive-queries.html#querying-"
"remote-state-stores-for-the-entire-app[API "
"を]提供しています。アプリケーションは、他のインスタンスから直接データを取得するか、クライアントにその他のノードの場所を指定するだけです。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:806
#, fuzzy
msgid ""
"Launching multiple instances of the `aggregator` application will make look "
"the overall architecture like so:"
msgstr "`aggregator` アプリケーションの複数のインスタンスを起動すると、全体のアーキテクチャがこのようになります。"

#. type: Target for macro image
#: upstream/_guides/kafka-streams.adoc:807
#, no-wrap
msgid "kafka-streams-guide-architecture-distributed.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:810
#, fuzzy
msgid ""
"The `InteractiveQueries` class must be adjusted slightly for this "
"distributed architecture:"
msgstr "`InteractiveQueries` クラスは、この分散型アーキテクチャ用に少し調整する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:819
#, no-wrap
msgid ""
"public GetWeatherStationDataResult getWeatherStationData(int id) {\n"
"    StreamsMetadata metadata = streams.metadataForKey(                  // "
"<1>\n"
"            TopologyProducer.WEATHER_STATIONS_STORE,\n"
"            id,\n"
"            Serdes.Integer().serializer()\n"
"    );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:827
#, no-wrap
msgid ""
"    if (metadata == null || metadata == StreamsMetadata.NOT_AVAILABLE) {\n"
"        LOG.warn(\"Found no metadata for key {}\", id);\n"
"        return GetWeatherStationDataResult.notFound();\n"
"    }\n"
"    else if (metadata.host().equals(host)) {                            // "
"<2>\n"
"        LOG.info(\"Found data for key {} locally\", id);\n"
"        Aggregation result = getWeatherStationStore().get(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:845
#, no-wrap
msgid ""
"        if (result != null) {\n"
"            return GetWeatherStationDataResult.found(WeatherStationData."
"from(result));\n"
"        }\n"
"        else {\n"
"            return GetWeatherStationDataResult.notFound();\n"
"        }\n"
"    }\n"
"    else {                                                              // "
"<3>\n"
"        LOG.info(\n"
"            \"Found data for key {} on remote host {}:{}\",\n"
"            id,\n"
"            metadata.host(),\n"
"            metadata.port()\n"
"        );\n"
"        return GetWeatherStationDataResult.foundRemotely(metadata.host(), "
"metadata.port());\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:858
#, no-wrap
msgid ""
"public List<PipelineMetadata> getMetaData() {                           // "
"<4>\n"
"    return streams.allMetadataForStore(TopologyProducer."
"WEATHER_STATIONS_STORE)\n"
"            .stream()\n"
"            .map(m -> new PipelineMetadata(\n"
"                    m.hostInfo().host() + \":\" + m.hostInfo().port(),\n"
"                    m.topicPartitions()\n"
"                        .stream()\n"
"                        .map(TopicPartition::toString)\n"
"                        .collect(Collectors.toSet()))\n"
"            )\n"
"            .collect(Collectors.toList());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:860
#, fuzzy
msgid "The streams metadata for the given weather station id is obtained"
msgstr "与えられた気象観測所IDのストリームメタデータが取得されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:861
#, fuzzy
msgid ""
"The given key (weather station id) is maintained by the local application "
"node, i.e. it can answer the query itself"
msgstr "与えられたキー(測候所ID)はローカルのアプリケーションノードによって管理されています。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:862
#, fuzzy
msgid ""
"The given key is maintained by another application node; in this case the "
"information about that node (host and port) will be returned"
msgstr "与えられたキーは別のアプリケーションノードによって管理されています; この場合、そのノードに関する情報（ホストとポート）が返されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:863
#, fuzzy
msgid ""
"The `getMetaData()` method is added to provide callers with a list of all "
"the nodes in the application cluster."
msgstr "`getMetaData()` メソッドが追加され、アプリケーション・クラスタ内の全ノードのリストを呼び出し元に提供するようになりました。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:865
#, fuzzy
msgid "The `GetWeatherStationDataResult` type must be adjusted accordingly:"
msgstr "`GetWeatherStationDataResult` のタイプは、それに合わせて調整する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:879
#, no-wrap
msgid ""
"    private static GetWeatherStationDataResult NOT_FOUND =\n"
"            new GetWeatherStationDataResult(null, null, null);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:883
#, no-wrap
msgid ""
"    private final WeatherStationData result;\n"
"    private final String host;\n"
"    private final Integer port;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:890
#, no-wrap
msgid ""
"    private GetWeatherStationDataResult(WeatherStationData result, String "
"host,\n"
"            Integer port) {\n"
"        this.result = result;\n"
"        this.host = host;\n"
"        this.port = port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:894
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult found(WeatherStationData data) "
"{\n"
"        return new GetWeatherStationDataResult(data, null, null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:898
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult foundRemotely(String host, int "
"port) {\n"
"        return new GetWeatherStationDataResult(null, host, port);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:906
#, no-wrap
msgid ""
"    public Optional<WeatherStationData> getResult() {\n"
"        return Optional.ofNullable(result);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:910
#, no-wrap
msgid ""
"    public Optional<String> getHost() {\n"
"        return Optional.ofNullable(host);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:915
#, no-wrap
msgid ""
"    public OptionalInt getPort() {\n"
"        return port != null ? OptionalInt.of(port) : OptionalInt.empty();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:919
#, fuzzy
msgid ""
"Also the return type for `getMetaData()` must be defined (`aggregator/src/"
"main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java`):"
msgstr ""
"また、 `getMetaData()` のリターンタイプも定義する必要があります ( `aggregator/src/main/java/org/"
"acme/kafka/streams/aggregator/streams/PipelineMetadata.java`)。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:925
#, no-wrap
msgid "import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:927
#, no-wrap
msgid "public class PipelineMetadata {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:930
#, no-wrap
msgid "    public String host;\n"
"    public Set<String> partitions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:936
#, no-wrap
msgid ""
"    public PipelineMetadata(String host, Set<String> partitions) {\n"
"        this.host = host;\n"
"        this.partitions = partitions;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:939
#, fuzzy
msgid "Lastly, the REST endpoint class must be updated:"
msgstr "最後に、RESTエンドポイントクラスを更新する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:958
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:962
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.streams."
"GetWeatherStationDataResult;\n"
"import org.acme.kafka.streams.aggregator.streams.KafkaStreamsPipeline;\n"
"import org.acme.kafka.streams.aggregator.streams.PipelineMetadata;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:976
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/data/{id}\")\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Response getWeatherStationData(@PathParam(\"id\") int id) {\n"
"        GetWeatherStationDataResult result = interactiveQueries."
"getWeatherStationData(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:990
#, no-wrap
msgid ""
"        if (result.getResult().isPresent()) {                     // <1>\n"
"            return Response.ok(result.getResult().get()).build();\n"
"        }\n"
"        else if (result.getHost().isPresent()) {                  // <2>\n"
"            URI otherUri = getOtherUri(result.getHost().get(), result."
"getPort().getAsInt(),\n"
"                    id);\n"
"            return Response.seeOther(otherUri).build();\n"
"        }\n"
"        else {                                                    // <3>\n"
"            return Response.status(Status.NOT_FOUND.getStatusCode(),\n"
"                    \"No data found for weather station \" + id).build();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:997
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/meta-data\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<PipelineMetadata> getMetaData() {                 // <4>\n"
"        return interactiveQueries.getMetaData();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1007
#, no-wrap
msgid ""
"    private URI getOtherUri(String host, int port, int id) {\n"
"        try {\n"
"            return new URI(\"http://\" + host + \":\" + port + \"/weather-"
"stations/data/\" + id);\n"
"        }\n"
"        catch (URISyntaxException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1009
#, fuzzy
msgid "The data was found locally, so return it"
msgstr "データはローカルで見つかったので、それを返す"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1010
#, fuzzy
msgid ""
"The data is maintained by another node, so reply with a redirect (HTTP "
"status code 303) if the data for the given key is stored on one of the other "
"nodes."
msgstr ""
"データは他のノードで管理されているので、指定されたキーのデータが他のノードに保存されている場合は、リダイレクト(HTTPステータスコード303)で返信してください。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1011
#, fuzzy
msgid "No data was found for the given weather station id"
msgstr "データが見つかりませんでした。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1012
#, fuzzy
msgid ""
"Exposes information about all the hosts forming the application cluster"
msgstr "アプリケーションクラスタを形成しているすべてのホストの情報を表示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1015
#, fuzzy
msgid ""
"Now stop the `aggregator` service again and rebuild it.  Then let's spin up "
"three instances of it:"
msgstr "ここで再び `aggregator` サービスを停止して再構築します。そして、3つのインスタンスをスピンアップしてみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1021
#, no-wrap
msgid ""
"./mvnw clean package -f aggregator/pom.xml\n"
"docker-compose stop aggregator\n"
"docker-compose up --build -d --scale aggregator=3\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1026
#, fuzzy
msgid ""
"When invoking the REST API on any of the three instances, it might either be "
"that the aggregation for the requested weather station id is stored locally "
"on the node receiving the query, or it could be stored on one of the other "
"two nodes."
msgstr ""
"3つのインスタンスのいずれかでREST "
"APIを呼び出す場合、要求されたウェザーステーションIDの集約は、クエリを受信したノードにローカルに格納されるか、他の2つのノードのいずれかに格納されるかのどちらかであるかもしれません。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1030
#, fuzzy
msgid ""
"As the load balancer of Docker Compose will distribute requests to the "
"`aggregator` service in a round-robin fashion, we'll invoke the actual nodes "
"directly.  The application exposes information about all the host names via "
"REST:"
msgstr ""
"Docker Composeのロードバランサーがラウンドロビン方式で `aggregator` "
"サービスにリクエストを配信するので、実際のノードを直接呼び出すことにします。アプリケーションはREST経由ですべてのホスト名の情報を公開しています。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1034
#, no-wrap
msgid "http aggregator:8080/weather-stations/meta-data\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1040
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 202\n"
"Content-Type: application/json\n"
"Date: Tue, 18 Jun 2019 20:00:23 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1061
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        \"host\": \"2af13fe516a9:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-2\"\n"
"        ]\n"
"    },\n"
"    {\n"
"        \"host\": \"32cc8309611b:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-1\"\n"
"        ]\n"
"    },\n"
"    {\n"
"        \"host\": \"1eb39af8d587:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-0\"\n"
"        ]\n"
"    }\n"
"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1065
#, fuzzy
msgid ""
"Retrieve the data from one of the three hosts shown in the response (your "
"actual host names will differ):"
msgstr "レスポンスに表示されている 3 つのホストのうちの 1 つからデータを取得します (実際のホスト名は異なります)。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1069
#, no-wrap
msgid "http 2af13fe516a9:8080/weather-stations/data/1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1072
#, fuzzy
msgid ""
"If that node holds the data for key \"1\", you'll get a response like this:"
msgstr "そのノードがキー「1」のデータを保持している場合は、このようなレスポンスが得られます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1080
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 74\n"
"Content-Type: application/json\n"
"Date: Tue, 11 Jun 2019 19:16:31 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1089
#, no-wrap
msgid ""
"{\n"
"  \"avg\": 11.9,\n"
"  \"count\": 259,\n"
"  \"max\": 50.0,\n"
"  \"min\": -30.1,\n"
"  \"stationId\": 1,\n"
"  \"stationName\": \"Hamburg\"\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1092
#, fuzzy
msgid "Otherwise, the service will send a redirect:"
msgstr "そうでない場合、サービスはリダイレクトを送信します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1100
#, no-wrap
msgid ""
"HTTP/1.1 303 See Other\n"
"Connection: keep-alive\n"
"Content-Length: 0\n"
"Date: Tue, 18 Jun 2019 20:01:03 GMT\n"
"Location: http://1eb39af8d587:8080/weather-stations/data/1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1103
#, fuzzy
msgid ""
"You can also have _httpie_ automatically follow the redirect by passing the "
"`--follow option`:"
msgstr "また、 `--follow option` を渡すことで _httpie が_自動的にリダイレクトに従うようにすることもできます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1107
#, no-wrap
msgid "http --follow 2af13fe516a9:8080/weather-stations/data/1\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1109
#, no-wrap, fuzzy
msgid "Running Natively"
msgstr "ネイティブランニング"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1113
#, fuzzy
msgid ""
"The Quarkus extension for Kafka Streams enables the execution of stream "
"processing applications natively via GraalVM without further configuration."
msgstr ""
"Kafka "
"Streams用のQuarkus拡張機能を使用すると、GraalVMを介してストリーム処理アプリケーションをネイティブに実行することができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1116
#, fuzzy
msgid ""
"To run both the `producer` and `aggregator` applications in native mode, the "
"Maven builds can be executed using the `native` profile:"
msgstr ""
"`producer` と `aggregator` アプリケーションをネイティブモードで実行するには、 `native` プロファイルを使用して "
"Maven ビルドを実行できます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1121
#, no-wrap
msgid ""
"./mvnw clean package -f producer/pom.xml -Pnative -Dnative-image.container-"
"runtime=docker\n"
"./mvnw clean package -f aggregator/pom.xml -Pnative -Dnative-image.container-"
"runtime=docker\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1124
#, fuzzy
msgid ""
"Now create an environment variable named `QUARKUS_MODE` and with value set "
"to \"native\":"
msgstr "ここで、 `QUARKUS_MODE` という名前の環境変数を作成し、値を\"native\"に設定します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1128
#, no-wrap
msgid "export QUARKUS_MODE=native\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1133
#, fuzzy
msgid ""
"This is used by the Docker Compose file to use the correct `Dockerfile` when "
"building the `producer` and `aggregator` images.  The Kafka Streams "
"application can work with less than 50 MB RSS in native mode.  To do so, add "
"the `Xmx` option to the program invocation in `aggregator/src/main/docker/"
"Dockerfile.native`:"
msgstr ""
"これは、 `producer` と `aggregator` 画像をビルドする際に正しい `Dockerfile` を使用するために Docker "
"Compose ファイルで使用されます。Kafka Streams アプリケーションは、ネイティブモードでは 50 MB 未満の RSS "
"で動作します。そのためには、 `aggregator/src/main/docker/Dockerfile.native` のプログラム呼び出しに "
"`Xmx` オプションを追加します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1137
#, no-wrap
msgid "CMD [\"./application\", \"-Dquarkus.http.host=0.0.0.0\", \"-Xmx32m\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1141
#, fuzzy
msgid ""
"Now start Docker Compose as described above (don't forget to rebuild the "
"container images)."
msgstr "ここで、上記のようにDocker Composeを起動します（コンテナイメージの再構築を忘れずに）。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1142
#, no-wrap, fuzzy
msgid "Kafka Streams Health Checks"
msgstr "カフカストリームの健康診断"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1145
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka-"
"streams` will automatically add:"
msgstr ""
"`quarkus-smallrye-health` の拡張子を使用している場合は、 `quarkus-kafka-streams` "
"が自動的に追加されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1147
#, fuzzy
msgid ""
"a readiness health check to validate that all topics declared in the "
"`quarkus.kafka-streams.topics` property are created,"
msgstr ""
"`quarkus.kafka-streams.topics` "
"プロパティで宣言されたすべてのトピックが作成されているかどうかを検証するために、準備の健全性チェックを行います。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1148
#, fuzzy
msgid "a liveness health check based on the Kafka Streams state."
msgstr "カフカストリームの状態をもとにした活力健康診断。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1150
#, fuzzy
msgid ""
"So when you access the `/health` endpoint of your application you will have "
"information about the state of the Kafka Streams and the available and/or "
"missing topics."
msgstr ""
"そのため、アプリケーションの `/health` エンドポイントにアクセスすると、Kafka "
"ストリームの状態や、利用可能なトピックや不足しているトピックについての情報を得ることができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1152
#, fuzzy
msgid "This is an example of when the status is `DOWN`:"
msgstr "これは、ステータスが `DOWN`."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1155
#, no-wrap
msgid "curl -i http://aggregator:8080/health\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1159
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 454\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1180
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams state health check\",  <1>\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"state\": \"CREATED\"\n"
"            }\n"
"        },\n"
"        {\n"
"            \"name\": \"Kafka Streams topics health check\",  <2>\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"available_topics\": \"weather-stations,temperature-"
"values\",\n"
"                \"missing_topics\": \"hygrometry-values\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1182
#, fuzzy
msgid "Liveness health check. Also available at `/health/live` endpoint."
msgstr "活力のある健康チェック。 `/health/live` エンドポイントでもご利用いただけます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1183
#, fuzzy
msgid "Readiness health check. Also available at `/health/ready` endpoint."
msgstr "準備状態の健康チェック。 `/health/ready` エンドポイントでも利用可能。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1185
#, fuzzy
msgid ""
"So as you can see, the status is `DOWN` as soon as one of the `quarkus.kafka-"
"streams.topics` is missing or the Kafka Streams `state` is not `RUNNING`."
msgstr ""
"だから、ご覧のように、 `quarkus.kafka-streams.topics` のいずれかが欠けているか、カフカストリーム `state` が "
"`RUNNING` でないとすぐにステータスが `DOWN` になります。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1188
#, fuzzy
msgid ""
"If no topics are available, the `available_topics` key will not be present "
"in the `data` field of the `Kafka Streams topics health check`.  As well as "
"if no topics are missing, the `missing_topics` key will not be present in "
"the `data` field of the `Kafka Streams topics health check`."
msgstr ""
"トピックがない場合、 `Kafka Streams topics health check`.の `data` フィールドに "
"`available_topics` キーは表示されません。また、トピックがない場合は、 `Kafka Streams topics health "
"check` の `data` フィールドに `missing_topics` キーは表示されません。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1190
#, fuzzy
msgid ""
"You can of course disable the health check of the `quarkus-kafka-streams` "
"extension by setting the `quarkus.kafka-streams.health.enabled` property to "
"`false` in your `application.properties`."
msgstr ""
"`quarkus.kafka-streams.health.enabled` `false` もちろん、 `quarkus-kafka-streams` "
"拡張モジュールのヘルスチェックを無効にするには、 `application.properties`."

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1192
#, fuzzy
msgid ""
"Obviously you can create your liveness and readiness probes based on the "
"respective endpoints `/health/live` and `/health/ready`."
msgstr ""
"もちろん、それぞれのエンドポイント `/health/live` と `/health/ready` "
"に基づいて、活性度と準備状態のプローブを作成することができます。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:1193
#, no-wrap, fuzzy
msgid "Liveness health check"
msgstr "活性度チェック"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1196
#, fuzzy
msgid "Here is an example of the liveness check:"
msgstr "活力チェックの一例をご紹介します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1200
#, no-wrap
msgid "curl -i http://aggregator:8080/health/live\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1204
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 225\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1217
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams state health check\",\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"state\": \"CREATED\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1219
#, fuzzy
msgid "The `state` is coming from the `KafkaStreams.State` enum."
msgstr "`state` は `KafkaStreams.State` enum から来ています。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:1220
#, no-wrap, fuzzy
msgid "Readiness health check"
msgstr "準備状態の健康チェック"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1223
#, fuzzy
msgid "Here is an example of the readiness check:"
msgstr "ここでは、準備態勢チェックの一例をご紹介します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1227
#, no-wrap
msgid "curl -i http://aggregator:8080/health/ready\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1231
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 265\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1244
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams topics health check\",\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"missing_topics\": \"weather-stations,temperature-values\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1246
#, no-wrap, fuzzy
msgid "Going Further"
msgstr "さらなる飛躍を目指して"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1252
#, fuzzy
msgid ""
"This guide has shown how you can build stream processing applications using "
"Quarkus and the Kafka Streams APIs, both in JVM and native modes.  For "
"running your KStreams application in production, you could also add health "
"checks and metrics for the data pipeline.  Refer to the Quarkus guides on "
"link:micrometer[Micrometer], link:microprofile-metrics[MicroProfile "
"Metrics], and link:microprofile-health[health checks] to learn more."
msgstr ""
"このガイドでは、QuarkusとKafka Streams "
"APIを使用して、JVMとネイティブモードの両方でストリーム処理アプリケーションを構築する方法を紹介しました。KStreamsアプリケーションを本番環境で実行するために、データパイプラインのヘルスチェックやメトリクスを追加することもできます。詳細については、 "
"link:micrometer[マイクロメーター]、 link:microprofile-metrics[マイクロプロファイルメトリクス]、 link:"
"microprofile-health[ヘルスチェック]に関するQuarkusのガイドを参照してください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-properties.adoc:6
#, no-wrap
msgid "Quarkus - Using Security with .properties File"
msgstr "Quarkus - .propertiesファイルでセキュリティを使用する"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:13
msgid ""
"Quarkus provides support for properties file based authentication that is "
"intended for development and testing purposes. It is not recommended that "
"this be used in production as at present only plaintext and MD5 hashed "
"passwords are used, and properties files are generally too limited to use in "
"production."
msgstr ""
"Quarkusでは、開発とテストを目的としたプロパティファイルベースの認証をサポートしています。現在のところ、平文とMD5ハッシュ化されたパスワードしか使用されておらず、プロパティファイルは一般的に本番環境で使用するには制限が多すぎるため、本番環境で使用することはお勧めできません。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:15
msgid "Add the following to your `pom.xml`:"
msgstr "以下を `pom.xml` に追加してください："

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:22
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-elytron-security-properties-file</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:29
msgid ""
"The elytron-security-properties-file extension currently supports two "
"different realms for the storage of authentication and authorization "
"information. Both support storage of this information in properties files. "
"The following sections detail the specific configuration properties."
msgstr ""
"elytron-security-properties-file "
"拡張機能は、現在、認証と認可情報の保存のための2つの異なる領域をサポートしています。どちらもこの情報のプロパティファイルへの保存をサポートしています。以下のセクションでは、特定の設定プロパティについて詳しく説明します。"

#. type: Title ===
#: upstream/_guides/security-properties.adoc:32
#, no-wrap
msgid "Properties Files Realm Configuration"
msgstr "プロパティファイルレルム設定"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:35
msgid ""
"The properties files realm supports mapping of users to password and users "
"to roles with a combination of properties files. They are configured with "
"properties starting with `quarkus.security.users.file`."
msgstr ""
"プロパティファイルのレルムは、プロパティファイルの組み合わせを使用して、ユーザーをパスワードに、ユーザーをロールにマッピングすることをサポートしています。これらは "
"`quarkus.security.users.file` で始まるプロパティで構成されています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:36
#, no-wrap
msgid "example application.properties file section for property files realm"
msgstr "プロパティファイルレルムの application.properties ファイルセクションの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:44
#, no-wrap
msgid ""
"quarkus.security.users.file.enabled=true\n"
"quarkus.security.users.file.users=test-users.properties\n"
"quarkus.security.users.file.roles=test-roles.properties\n"
"quarkus.security.users.file.realm-name=MyRealm\n"
"quarkus.security.users.file.plain-text=true\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/security-properties.adoc:46
#, no-wrap
msgid "Users.properties"
msgstr "ユーザーズプロパティ"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:49
msgid ""
"The `quarkus.security.users.file.users` configuration property specifies a "
"classpath resource which is a properties file with a user to password "
"mapping, one per line. The following <<test-users-example>> illustrates the "
"format:"
msgstr ""
"`quarkus.security.users.file.users` "
"設定プロパティは、クラスパスリソースを指定します。これは、1行に1つずつ、ユーザーとパスワードをマッピングしたプロパティファイルです。以下の link:"
"#test-users-example[[test-users-example] は]そのフォーマットを示しています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:51
#, no-wrap
msgid "example test-users.properties file"
msgstr "例：test-users.propertiesファイル"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:58
#, no-wrap
msgid "scott=jb0ss <1>\n"
"jdoe=p4ssw0rd <2>\n"
"stuart=test\n"
"noadmin=n0Adm1n\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:60
msgid "User `scott` has password defined as `jb0ss`"
msgstr "ユーザー `scott` のパスワードは `jb0ss` と定義されています。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:61
msgid "User `jdoe` has password defined as `p4ssw0rd`"
msgstr "ユーザー `jdoe` のパスワードは `p4ssw0rd` と定義されています。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:65
msgid ""
"This file has the usernames and passwords stored in plain text, which is not "
"recommended. If plain-text is set to false (or omitted) in the config then "
"passwords must be stored in the form `MD5 ( username : realm : password )`. "
"This can be generated for the first example above by running the command "
"`echo -n scott:MyRealm:jb0ss | md5` from the command line."
msgstr ""
"このファイルには、ユーザ名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false "
"に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` "
"の形式で保存されなければなりません。これは上の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` "
"コマンドを実行することで生成することができます。"

#. type: Title ====
#: upstream/_guides/security-properties.adoc:66
#, no-wrap
msgid "Roles.properties"
msgstr "Roles.properties"

#. type: Block title
#: upstream/_guides/security-properties.adoc:68
#, no-wrap
msgid "example test-roles.properties file"
msgstr "例：test-roles.propertiesファイル"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:75
#, no-wrap
msgid ""
"scott=Admin,admin,Tester,user <1>\n"
"jdoe=NoRolesUser <2>\n"
"stuart=admin,user <3>\n"
"noadmin=user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:77
msgid ""
"User `scott` has been assigned the roles `Admin`, `admin`, `Tester` and "
"`user`"
msgstr "ユーザー `scott` には `Admin`, `admin`, `Tester` および `user`"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:78
msgid "User `jdoe` has been assigned the role `NoRolesUser`"
msgstr "ユーザー `jdoe` に役割が割り当てられています。 `NoRolesUser`"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:79
msgid "User `stuart` has been assigned the roles `admin` and `user`."
msgstr "ユーザー `stuart` には `admin` と `user` の役割が割り当てられています。"

#. type: Title ===
#: upstream/_guides/security-properties.adoc:80
#, no-wrap
msgid "Embedded Realm Configuration"
msgstr "エンベデッドレルムの設定"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:83
msgid ""
"The embedded realm also supports mapping of users to password and users to "
"roles. It uses the main `application.properties` Quarkus configuration file "
"to embed this information. They are configured with properties starting with "
"`quarkus.security.users.embedded`."
msgstr ""
"埋め込まれたレルムは、ユーザーのパスワードへのマッピングやユーザーのロールへのマッピングもサポートしています。この情報を埋め込むには、メインの "
"`application.properties` Quarkus設定ファイルを使用します。これらは、 `quarkus.security.users."
"embedded` で始まるプロパティで設定されます。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:85
msgid ""
"The following is an example application.properties file section illustrating "
"the embedded realm configuration:"
msgstr "以下は、組み込みレルムの設定を示すapplication.propertiesファイルのセクションの例です。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:86
#, no-wrap
msgid "example application.properties file section for embedded realm"
msgstr "埋め込みレルム用のapplication.propertiesファイルセクションの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:99
#, no-wrap
msgid ""
"quarkus.security.users.embedded.enabled=true\n"
"quarkus.security.users.embedded.plain-text=true\n"
"quarkus.security.users.embedded.users.scott=jb0ss\n"
"quarkus.security.users.embedded.users.stuart=test\n"
"quarkus.security.users.embedded.users.jdoe=p4ssw0rd\n"
"quarkus.security.users.embedded.users.noadmin=n0Adm1n\n"
"quarkus.security.users.embedded.roles.scott=Admin,admin,Tester,user\n"
"quarkus.security.users.embedded.roles.stuart=admin,user\n"
"quarkus.security.users.embedded.roles.jdoe=NoRolesUser\n"
"quarkus.security.users.embedded.roles.noadmin=user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:104
msgid ""
"As with the first example this file has the usernames and passwords stored "
"in plain text, which is not recommended. If plain-text is set to false (or "
"omitted) in the config then passwords must be stored in the form `MD5 ( "
"username : realm : password )`. This can be generated for the first example "
"above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the "
"command line."
msgstr ""
"最初の例と同様に、このファイルにはユーザ名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false "
"に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` "
"の形式で保存されなければなりません。これは上記の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` "
"コマンドを実行することで生成することができます。"

#. type: Title ====
#: upstream/_guides/security-properties.adoc:106
#, no-wrap
msgid "Embedded Users"
msgstr "組込ユーザー"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:109
msgid ""
"The user to password mappings are specified in the `application.properties` "
"file by properties keys of the form `quarkus.security.users.embedded.users."
"<user>=<password>`. The following <<password-example>> illustrates the "
"syntax with 4 user to password mappings:"
msgstr ""
"ユーザーからパスワードへのマッピングは、 `application.properties` ファイル内で `quarkus.security.users."
"embedded.users.&amp;lt;user&amp;gt;=&amp;lt;password&amp;gt;` "
"形式のプロパティキーで指定します。以下の link:#password-example[[password-example] は]、4 "
"つのユーザーからパスワードへのマッピングの構文を示しています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:111
#, no-wrap
msgid "Example Passwords"
msgstr "パスワードの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:118
#, no-wrap
msgid ""
"quarkus.security.users.embedded.users.scott=jb0ss # <1>\n"
"quarkus.security.users.embedded.users.stuart=test # <2>\n"
"quarkus.security.users.embedded.users.jdoe=p4ssw0rd\n"
"quarkus.security.users.embedded.users.noadmin=n0Adm1n\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:120
msgid "User `scott` has password `jb0ss`"
msgstr "ユーザー `scott` はパスワード `jb0ss` を持っています"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:121
msgid "User `stuart` has password `test`"
msgstr "ユーザー `stuart` はパスワード `test` を持っています"

#. type: Title ====
#: upstream/_guides/security-properties.adoc:122
#, no-wrap
msgid "Embedded Roles"
msgstr "組込ロール"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:125
msgid ""
"The user to role mappings are specified in the `application.properties` file "
"by properties keys of the form `quarkus.security.users.embedded.roles.<user>="
"role1[,role2[,role3[,...]]]`. The following <<roles-example>> illustrates "
"the syntax with 4 user to role mappings:"
msgstr ""
"ユーザとロールのマッピングは、 `application.properties` ファイルで `quarkus.security.users."
"embedded.roles.&amp;lt;user&amp;gt;=role1[,role2[,role3[,…​]]]` "
"形式のプロパティ・キーで指定されます。以下の link:#roles-example[[role-"
"example]]は、4つのユーザとロールをマッピングした構文を示しています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:127
#, no-wrap
msgid "Example Roles"
msgstr "ロールの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:134
#, no-wrap
msgid ""
"quarkus.security.users.embedded.roles.scott=Admin,admin,Tester,user # <1>\n"
"quarkus.security.users.embedded.roles.stuart=admin,user # <2>\n"
"quarkus.security.users.embedded.roles.jdoe=NoRolesUser\n"
"quarkus.security.users.embedded.roles.noadmin=user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:136
msgid "User `scott` has roles `Admin`, `admin`, `Tester`, and `user`"
msgstr "ユーザー `scott` には `Admin`, `admin`, `Tester`, および `user`"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:137
msgid "User `stuart` has roles `admin` and `user`"
msgstr "ユーザー `stuart` には `admin` と `user`"

#. type: Title ==
#: upstream/_guides/security-properties.adoc:138
#, no-wrap
msgid "References"
msgstr "参照"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:140
msgid "link:security[Quarkus Security]"
msgstr "link:security[Quarkusのセキュリティ]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/scheduler.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Scheduling Periodic Tasks"
msgstr "Quarkus - 定期的なタスクのスケジューリング"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:12
#, fuzzy
msgid ""
"Modern applications often need to run specific tasks periodically.  In this "
"guide, you learn how to schedule periodic tasks."
msgstr "最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクをスケジュールする方法を学びます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:14
#, fuzzy
msgid ""
"If you need a clustered scheduler use the link:quartz[Quartz extension]."
msgstr "クラスタ化されたスケジューラが必要な場合は、 link:quartz[Quartz拡張機能を]使用してください。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:20
#, fuzzy
msgid "less than 10 minutes"
msgstr "１０分足らず"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:28
#, fuzzy
msgid ""
"In this guide, we create a straightforward application accessible using HTTP "
"to get the current value of a counter.  This counter is periodically (every "
"10 seconds) incremented."
msgstr ""
"このガイドでは、カウンタの現在値を取得するためにHTTPを使用してアクセスできる簡単なアプリケーションを作成します。このカウンタは定期的に(10秒ごとに)インクリメントされます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:30
#, fuzzy
msgid "image:scheduling-task-architecture.png[alt=Architecture]"
msgstr "image:scheduling-task-architecture.png[alt=Architecture]"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:39
#, fuzzy
msgid ""
"The solution is located in the `scheduler-quickstart` {quickstarts-tree-url}/"
"scheduler-quickstart[directory]."
msgstr ""
"ソリューションは `scheduler-quickstart` {quickstarts-tree-url}/scheduler-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:53
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=scheduler-quickstart \\\n"
"    -DclassName=\"org.acme.scheduler.CountResource\" \\\n"
"    -Dpath=\"/count\" \\\n"
"    -Dextensions=\"scheduler\"\n"
"cd scheduler-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler.adoc:56
#, fuzzy
msgid "It generates:"
msgstr "生成します。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:58
#, fuzzy
msgid "the Maven structure"
msgstr "メイヴン構造体"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:59
#, fuzzy
msgid "a landing page accessible on `http://localhost:8080`"
msgstr ""
"ランディングページ `&lt;a href=\"http://localhost:8080\" class=\"bare\"&gt;http://"
"localhost:8080&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:60
#, fuzzy
msgid "example `Dockerfile` files for both `native` and `jvm` modes"
msgstr "`native` と `jvm` の両方のモードに対応した `Dockerfile` ファイルの例"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:61
#, fuzzy
msgid "the application configuration file"
msgstr "アプリケーション設定ファイル"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:62
#, fuzzy
msgid "an `org.acme.scheduler.CountResource` resource"
msgstr "`org.acme.scheduler.CountResource` リソース"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:63
#, fuzzy
msgid "an associated test"
msgstr "関連試験"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:65
#, fuzzy
msgid "The Maven project also imports the Quarkus scheduler extension."
msgstr "Mavenプロジェクトは、Quarkusスケジューラ拡張機能もインポートします。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:68
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`scheduler` extension to your project by running the following command in "
"your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`scheduler` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:72
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"scheduler\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:82
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-scheduler</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/scheduler.adoc:85
#, no-wrap, fuzzy
msgid "Creating a scheduled job"
msgstr "スケジュールされたジョブの作成"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:88
#, fuzzy
msgid ""
"In the `org.acme.scheduler` package, create the `CounterBean` class, with "
"the following content:"
msgstr "`org.acme.scheduler` パッケージで、以下の内容の `CounterBean` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:92 upstream/_guides/scheduler.adoc:152
#: upstream/_guides/scheduler.adoc:181
#, no-wrap
msgid "package org.acme.scheduler;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:97
#, no-wrap
msgid ""
"import java.util.concurrent.atomic.AtomicInteger;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
"import io.quarkus.scheduler.Scheduled;\n"
"import io.quarkus.scheduler.ScheduledExecution;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:100
#, no-wrap
msgid "@ApplicationScoped              // <1>\n"
"public class CounterBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:102
#, no-wrap
msgid "    private AtomicInteger counter = new AtomicInteger();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:106
#, no-wrap
msgid "    public int get() {  // <2>\n"
"        return counter.get();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:111
#, no-wrap
msgid ""
"    @Scheduled(every=\"10s\")     // <3>\n"
"    void increment() {\n"
"        counter.incrementAndGet(); // <4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:117
#, no-wrap
msgid ""
"    @Scheduled(cron=\"0 15 10 * * ?\") <5>\n"
"    void cronJob(ScheduledExecution execution) {\n"
"        counter.incrementAndGet();\n"
"        System.out.println(execution.getScheduledFireTime());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:124
#, no-wrap
msgid ""
"    @Scheduled(cron = \"{cron.expr}\") <6>\n"
"    void cronJobWithExpressionInConfig() {\n"
"       counter.incrementAndGet();\n"
"       System.out.println(\"Cron expression configured in application."
"properties\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler.adoc:126
#, fuzzy
msgid "Declare the bean in the _application_ scope"
msgstr "_アプリケーション_スコープでビーンを宣言する"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:127
#, fuzzy
msgid "The `get()` method allows retrieving the current value."
msgstr "`get()` メソッドでは、現在の値を取得することができます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:130
#, fuzzy
msgid ""
"Use the `@Scheduled` annotation to instruct Quarkus to run this method every "
"10 seconds provided a worker thread is available (Quarkus is using 10 worker "
"threads for the scheduler). If it is not available the method invocation "
"should be re-scheduled by default i.e it should be invoked as soon as "
"possible. The invocation of the scheduled method does not depend on the "
"status or result of the previous invocation."
msgstr ""
"`@Scheduled` "
"アノテーションを使用して、ワーカースレッドが利用可能であれば10秒ごとにこのメソッドを実行するようにQuarkusに指示します（Quarkusはスケジューラに10個のワーカースレッドを使用しています）。ワーカースレッドが利用できない場合は、メソッドの呼び出しをデフォルトで再スケジューリングする必要があります。スケジュールされたメソッドの呼び出しは、前回の呼び出しのステータスや結果には依存しません。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:131
#, fuzzy
msgid ""
"The code is pretty straightforward. Every 10 seconds, the counter is "
"incremented."
msgstr "コードはとても簡単です。10秒ごとにカウンタがインクリメントされます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:132
#, fuzzy
msgid ""
"Define a job with a cron-like expression. The annotated method is executed "
"at 10:15am every day."
msgstr "cronのような式でジョブを定義します。アノテーションされたメソッドは毎日午前10時15分に実行されます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:133
#, fuzzy
msgid ""
"Define a job with a cron-like expression `cron.expr` which is configurable "
"in `application.properties`."
msgstr "`cron.expr` `application.properties` で設定可能な cron-like 式 でジョブを定義します。"

#. type: Title ==
#: upstream/_guides/scheduler.adoc:134
#, no-wrap, fuzzy
msgid "Updating the application configuration file"
msgstr "アプリケーション設定ファイルの更新"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:137
#, fuzzy
msgid ""
"Edit the `application.properties` file and add the `cron.expr` configuration:"
""
msgstr "`application.properties` ファイルを編集し、 `cron.expr` の設定を追加します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:143
#, no-wrap
msgid ""
"# By default, the syntax used for cron expressions is based on Quartz - http:"
"//www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger."
"html\n"
"# You can change the syntax using the following property:\n"
"# quarkus.scheduler.cron-type=unix\n"
"cron.expr=*/5 * * * * ?\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/scheduler.adoc:145
#, no-wrap, fuzzy
msgid "Updating the resource and the test"
msgstr "リソースとテストの更新"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:148
#, fuzzy
msgid "Edit the `CountResource` class, and update the content to:"
msgstr "`CountResource` クラスを編集して、内容を更新します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:161
#, no-wrap
msgid "@Path(\"/count\")\n"
"public class CountResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:164
#, no-wrap
msgid "    @Inject\n"
"    CounterBean counter;            // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:172
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"count: \" + counter.get();  // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler.adoc:174
#, fuzzy
msgid "Inject the `CounterBean`"
msgstr "を注入します。 `CounterBean`"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:175
#, fuzzy
msgid "Send back the current counter value"
msgstr "現在のカウンタの値を送り返す"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:177
#, fuzzy
msgid ""
"We also need to update the tests. Edit the `CountResourceTest` class to "
"match:"
msgstr "テストも更新する必要があります。 `CountResourceTest` クラスを一致するように編集します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:187
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.containsString;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:190
#, no-wrap
msgid "@QuarkusTest\n"
"public class CountResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:199
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/count\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(containsString(\"count\")); // <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler.adoc:203
#, fuzzy
msgid "Ensure that the response contains `count`"
msgstr "レスポンスに以下が含まれていることを確認してください。 `count`"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:209
#, fuzzy
msgid ""
"Run the application with: `./mvnw compile quarkus:dev`.  In another "
"terminal, run `curl localhost:8080/count` to check the counter value.  After "
"a few seconds, re-run `curl localhost:8080/count` to verify the counter has "
"been incremented."
msgstr ""
"`./mvnw compile quarkus:dev` でアプリケーションを実行してください。別のターミナルで `curl localhost:"
"8080/count` を実行して、カウンタの値を確認します。数秒後に `curl localhost:8080/count` "
"を再実行して、カウンタがインクリメントされていることを確認します。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:212
#, fuzzy
msgid ""
"Observe the console to verify that the message `Cron expression configured "
"in application.properties` has been displayed indicating that the cron job "
"using an expression configured in `application.properties` has been "
"triggered."
msgstr ""
"コンソールを観察して、 `application.properties` で構成された式を使用する cron ジョブがトリガされたことを示すメッセージ "
"`Cron expression configured in application.properties` が表示されたことを確認します。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:215
#, fuzzy
msgid ""
"As usual, the application can be packaged using `./mvnw clean package` and "
"executed using the `-runner.jar` file.  You can also generate the native "
"executable with `./mvnw clean package -Pnative`."
msgstr ""
"いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` "
"ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative`."

#. type: Title ==
#: upstream/_guides/scheduler.adoc:217
#, no-wrap, fuzzy
msgid "Scheduler Configuration Reference"
msgstr "スケジューラ設定リファレンス"
