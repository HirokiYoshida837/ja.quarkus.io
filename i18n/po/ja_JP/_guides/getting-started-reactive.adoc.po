# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2021-01-27 17:23+0000\n"
"PO-Revision-Date: 2021-02-03 21:07+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: \n"
"Language-Team: \n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/getting-started-reactive.adoc:6
#, no-wrap
msgid "Quarkus - Getting started with Reactive"
msgstr "Quarkus - Reactiveのスタート"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:12
msgid "Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.  This guide covers:"
msgstr ""
"Quarkusでリアクティブアプリケーションを作成する方法を学習し、Quarkusによって提供される様々なリアクティブ機能を学びください。このガイドは以下をカバーしま"
"す:"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:14
msgid "A quick glance at the Quarkus engine and how it enables reactive"
msgstr "Quarkusエンジンを一目で確認し、リアクティブを可能にする方法"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:15
msgid "A brief introduction to Mutiny - the reactive programming library used by Quarkus"
msgstr "Mutinyの簡単な紹介 - Quarkusによって使用されているリアクティブプログラミングライブラリ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:16
msgid "The difference between RESTEasy, RESTEasy Reactive and Reactive Routes"
msgstr "RESTEasy、RESTEasy Reactive、リアクティブルートの違い"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:17
msgid "The bootstrap of a reactive application using RESTEasy Reactive"
msgstr "RESTEasy Reactive を使用したリアクティブアプリケーションのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:18
msgid "Creating a reactive JAX-RS endpoint (asynchronous, streams...)"
msgstr "JAX-RSエンドポイントの作成(非同期、ストリーム..."

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:19
msgid "Using reactive database access"
msgstr "リアクティブデータベースアクセスの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:20
msgid "Interacting with other reactive APIs"
msgstr "その他のリアクティブAPIの使用"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:21
#, no-wrap
msgid "Prerequisites"
msgstr "前提 条件"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:24
msgid "To complete this guide, you need:"
msgstr "このガイドを完成するには、以下が必要です:"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:26
msgid "less than 15 minutes"
msgstr "15 分未満"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:27
msgid "an IDE"
msgstr "IDE"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:28
msgid "JDK 8 or 11+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 8 または 11+ がインストールされ、適切 `JAVA_HOME` に設定されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:29
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:30
#, no-wrap
msgid "Solutions"
msgstr "ソリューション"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:33
msgid ""
"We recommend that you follow the instructions from <<bootstrapping-the-project,Bootstrapping project>> and onwards to create the application step by "
"step."
msgstr ""
"プロジェクトのブートストラップとそれに続く指示に link:#bootstrapping-the-project[] 従って、ステップバイステップでアプリケーションを作成することをお勧めし"
"ます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:35
msgid "However, you can go right to the completed example."
msgstr "しかし、完成した例をすぐ確認することができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:37
msgid "Download an {quickstarts-archive-url}[archive] or clone the git repository:"
msgstr "{quickstarts-archive-url}[アーカイブ] をダウンロードするか、gitレポジトリをクローンします:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:41
#, no-wrap
msgid "git clone {quickstarts-clone-url}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:44
msgid "The solutions are located in the `getting-started-reactive` and `getting-started-reactive-crud` directories."
msgstr "ソリューションはディレクトリーにあります `getting-started-reactive` `getting-started-reactive-crud` 。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:45
#, no-wrap
msgid "The multiple reactive facets of Quarkus"
msgstr "Quarkusの複数のリアクティブな面"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:51
msgid ""
"Quarkus is reactive.  If you look under the hood, you will find a reactive engine powering your Quarkus application.  This engine is Eclipse Vert.x "
"(https://vertx.io).  All network I/O passes through the non-blocking and reactive Vert.x engine."
msgstr ""
"Quarkusはリアクティブです。フードの下を見ていると、Quarkusアプリケーションに力を当てているリアクティブエンジンがあります。このエンジンは Eclipse Vert.x "
"https://vertx.io https://vertx.io です。すべてのネットワーク I/O がノンブロッキングおよびリアクティブ Vert.x エンジンを通過します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:53
msgid "image:quarkus-reactive-stack.png[alt=Quarkus is based on a reactive engine, 70%]"
msgstr "image:quarkus-reactive-stack.png[alt=\"Quarkus is based on a reactive engine\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:61
msgid ""
"Let's take 2 examples to explain how it works.  Imagine an incoming HTTP request.  The (Vert.x) HTTP server, embedded in Quarkus, receives the request "
"and then routes it to the application.  If the request targets an _imperative_ method (traditional JAX-RS, code annotated with `@Blocking`...), the "
"routing layer invokes the resource method in a _worker_ thread and writes the response when the data is available.  So far, nothing new or outstanding.  "
"The following picture depicts this behavior.  In this case, the application code is invoked on a worker thread, and the business logic can block that "
"thread."
msgstr ""
"2つの例を見て、その仕組みについて説明しましょう。受信 HTTP 要求をイメージします。Quarkusに埋め込まれた(Vert.x)HTTPサーバーは、リクエストを受信してアプリ"
"ケーションにルーティングします。要求が命令型メソッド __ (従来の JAX-RS、.. でアノテーションされたコード) をターゲットとする場合、ルーティングレイヤーは"
"ワーカースレッドでリソースメソッドを呼び出し、データが利用可能なときに応答を書き込みます。 `@Blocking` __ 今のところ、新しいものや未解決のものは何もあり"
"ません。次の図は、この動作を示しています。この例では、アプリケーションコードはワーカースレッドで呼び出され、ビジネスロジックは、そのスレッドをブロックす"
"ることができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:63
msgid "image:http-blocking-sequence.png[alt=Behavior when using the imperative routes, 70%]"
msgstr "image:http-blocking-sequence.png[alt=\"Behavior when using the imperative routes\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:65
msgid ""
"But, if the HTTP request targets a reactive method (JAX-RS using RESTEasy Reactive, reactive routes, `@Incoming` method not annotated with "
"`@Blocking`...), the routing layer invokes the route on the I/O thread giving lots of benefits such as higher concurrency and performance:"
msgstr ""
"しかし、HTTP リクエストがリアクティブメソッド (RESTEasy Reactive を使用した JAX-RS、リアクティブルート、アノテーションされていないメソッド. ) をターゲッ"
"トとする場合、ルーティングレイヤーは `@Incoming` I/O スレッド上のルートを呼び出し、並行処理の増加やパフォーマンスなどの多くの利点を提供します "
"`@Blocking` 。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:67
msgid "image:http-reactive-sequence.png[alt=Behavior when using the reactive routes, 70%]"
msgstr "image:http-reactive-sequence.png[alt=\"Behavior when using the reactive routes\", width=\"70%\"]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:74
msgid ""
"Because Quarkus uses the I/O thread to invoke your code, we save context-switches, avoid large thread pool management, and so improve the resource "
"utilization.  However, the code must **NOT** block that thread.  Why? Because, I/O threads are used to handle multiple concurrent requests.  As soon as "
"the handling of a request cannot make progress because it needs to execute some I/O, it schedules these I/O and passes a continuation.  It releases the "
"thread which can handle another request.  When the scheduled I/O complete, the continuation is executed, back on the I/O thread."
msgstr ""
"QuarkusはI/Oスレッドを使用してコードを呼び出すので、コンテキストスイッチを保存し、大きなスレッドプール管理を避け、リソースの使用率を向上します。しかし、"
"コードは、その *スレッドを* ブロックしてはいけずにしてください。なぜでしょうか。なぜなら、I/O スレッドは複数の同時要求を処理するために使用されます。要求"
"の処理が進み得ない場合、I/O の一部を実行する必要がある場合に、これらの I/O をスケジュールし、継続を渡します。別の要求を処理できるスレッドをリリースしま"
"す。スケジュールされた I/O が完了すると、I/O スレッドに戻って継続が実行されます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:78
msgid ""
"As a consequence, many Quarkus components are designed with reactive in mind, such as database access (PostgreSQL, MySQL, Mongo, etc.), application "
"services (mail, template engine, etc.), messaging (Kafka, AMQP, etc.) and so on.  But, to fully benefit from this model, the application code should be "
"written in a non-blocking manner.  That’s where having a reactive API is an ultimate weapon."
msgstr ""
"その結果、データベースアクセス(PostgreSQL、MySQL、Mongoなど)、アプリケーションサービス(メール、テンプレートエンジンなど)、メッセージング(Kafka、AMQPなど)"
"など、多くのQuarkusコンポーネントはリアクティブを念頭に置いて設計されています。しかし、このモデルの恩恵を完全に受けるには、アプリケーションコードをノンブ"
"ロッキングの方法で記述する必要があります。リアクティブAPIを持つことは最終的な武器です。"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:80
#, no-wrap
msgid "Mutiny - A reactive programming library"
msgstr "Mutiny - リアクティブプログラミングライブラリ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:84
msgid ""
"https://github.com/smallrye/smallrye-mutiny[Mutiny] is a reactive programming library allowing to express and compose asynchronous actions.  It offers "
"two types:"
msgstr ""
"link:https://github.com/smallrye/smallrye-mutiny[Mutinyは] 、非同期アクションを表現し、構成することを可能にするリアクティブプログラミングライブラリです。"
"これは、2つのタイプを提供します:"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:86
msgid "`io.smallrye.mutiny.Uni` - for asynchronous action providing 0 or 1 result"
msgstr "`io.smallrye.mutiny.Uni` - 0 または 1 の結果を提供する非同期アクションの場合"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:87
msgid "`io.smallrye.mutiny.Multi` - for multi-item (with back-pressure) streams"
msgstr "`io.smallrye.mutiny.Multi` - マルチアイテム(バックプレッシャー)ストリームの場合"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:90
msgid ""
"Both types are lazy and follow a subscription pattern.  The computation only starts once there is an actual need for it (i.e. a subscriber enlists)."
msgstr ""
"どちらのタイプもレイジーで、サブスクリプションパターンに従います。計算は、実際に必要がある場合(つまりサブスクライバーの enlists)が一度だけ始まります。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:97
#, no-wrap
msgid ""
"uni.subscribe().with(\n"
"    result -> System.out.println(\"result is \" + result),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:102
#, no-wrap
msgid ""
"multi.subscribe().with(\n"
"    item -> System.out.println(\"Got \" + item),\n"
"    failure -> failure.printStackTrace()\n"
");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:108
msgid ""
"Both `Uni` and `Multi` expose event-driven APIs: you express what you want to do upon a given event (success, failure, etc.).  These APIs are divided "
"into groups (types of operations) to make it more expressive and avoid having 100s of methods attached to a single class.  The main types of operations "
"are about reacting to failure, completion, manipulating items, extracting, or collecting them.  It provides a smooth coding experience, with a navigable "
"API, and the result does not require too much knowledge around reactive."
msgstr ""
"イベント駆動型APIと公開APIの両方:特定のイベント(成功、失敗など)に対して何をしたいかを `Uni` `Multi` 表現します。これらの API は、より表現力を高め、単一の"
"クラスに 100 数種類のメソッドがアタッチされるのを避けるために、グループ (操作のタイプ) に分割されます。操作の主なタイプは、失敗、完了、アイテムの操作、抽"
"出、または収集に対する反応です。これは、ナビ可能なAPIを使用して、スムーズなコーディング体験を提供し、その結果、リアクティブに関する多くの知識を必要としな"
"い。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:113
#, no-wrap
msgid ""
"httpCall\n"
"    .onFailure().recoverWithItem(\"my fallback\");\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:119
msgid ""
"You may wonder about Reactive Streams (https://www.reactive-streams.org/).  `Multi` implements Reactive Streams `Publisher`, and so implements the "
"Reactive Streams back-pressure mechanism.  `Uni` does not implement `Publisher` as the subscription to the `Uni` is enough to indicate you are "
"interested in the result.  It is again with the idea of simpler and smoother APIs in mind as the Reactive Streams subscription/request ceremony is more "
"complex."
msgstr ""
"Reactive Streams ( https://www.reactive-streams.org/ ) https://www.reactive-streams.org/ Reactive Streams を実装し、Reactive Streams のバックプレッシャー"
"メカニズムを実装します。その結果に興味を持っているかどうかを示すためには、サブスクリプションを実装するのに十分 `Multi` `Publisher` `Uni` `Publisher` "
"`Uni` ではないので、実装しません。リアクティブストリームの購読/リクエスト式は複雑化し、よりシンプルでスムーズなAPIを考え直しています。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:122
msgid ""
"Embracing the unification of reactive and imperative pillars from Quarkus, both `Uni` and `Multi` provide bridges to imperative constructs.  For "
"example, you can transform a `Multi` into an `Iterable` or _await_ the item produced by a `Uni`."
msgstr ""
"Quarkusからのリアクティブと命令型の柱の一本化を取り入れ、命令型構文へのブリッジ `Uni` `Multi` を提供します。例えば、aを変換したり `Multi` 、. `Iterable` "
"__ `Uni`"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:127
#, no-wrap
msgid ""
"// Block until the result is available\n"
"String result = uni.await().indefinitely();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:130
#, no-wrap
msgid ""
"// Transform an asynchronous stream into a blocking iterable\n"
"stream.subscribe().asIterable().forEach(s -> System.out.println(\"Item is \" + s));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:134
msgid ""
"At that point, if you are a RxJava or a Reactor user, you may wonder how you can use your familiar `Flowable`, `Single`, `Flux`, `Mono`...  Mutiny "
"allows converting `Unis` and `Multis` from and to RX Java and Reactor types:"
msgstr ""
"その時点で、RxJavaやRxJavaのユーザーの場合、おなじみの 「..」をどう使えるのかと疑問に思う `Flowable` `Single` `Flux` `Mono` かもしれない。Mutinyでは "
"`Unis` `Multis` 、RX Java型とリアクター型を変換および変換できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:139
#, no-wrap
msgid ""
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Flux<String> flux = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:144
msgid "But, what about Vert.x? Vert.x APIs are also available using Mutiny types.  The following snippet shows a usage of the Vert.x Web Client:"
msgstr "しかし、Vert.xは?Vert.x APIは、Mutinyタイプを使用して利用することもできます。次のスニペットは Vert.x Web Client の使い方を示しています:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:164
#, no-wrap
msgid ""
"// Use io.vertx.mutiny.ext.web.client.WebClient\n"
"client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"// ...\n"
"Uni<JsonObject> uni =\n"
"    client.get(\"/api/fruit/\" + name)\n"
"        .send()\n"
"        .onItem().transform(resp -> {\n"
"            if (resp.statusCode() == 200) {\n"
"                return resp.bodyAsJsonObject();\n"
"            } else {\n"
"                return new JsonObject()\n"
"                        .put(\"code\", resp.statusCode())\n"
"                        .put(\"message\", resp.bodyAsString());\n"
"            }\n"
"        });\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:167
msgid ""
"Last but not least, Mutiny has built-in integration with MicroProfile Context Propagation so you can propagate transactions, traceability data, and so "
"on in your reactive pipeline."
msgstr ""
"最後に、MutinyはMicroProfile Context Propagationと組み込み統合を行っていますので、リアクティブパイプラインにトランザクションやトレースデータを伝播するこ"
"とができます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:169
msgid "But enough talking, let's get our hands dirty!"
msgstr "しかし、十分な話をして、手を汚しましょう!"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:170
#, no-wrap
msgid "Bootstrapping the project"
msgstr "プロジェクトのブートストラップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:175
msgid ""
"There are several ways to implement reactive application with Quarkus.  In this guide we are going to use RESTEasy Reactive, an implementation of "
"RESTEasy benefiting from the Quarkus reactive engine.  By default, it invokes the HTTP endpoint on the I/O thread."
msgstr ""
"Quarkusでリアクティブアプリケーションを実装する方法は複数あります。このガイドでは、Quarkusリアクティブエンジンの恩恵を受ける RESTEasy Reactive の実装を使"
"用します。デフォルトでは、I/O スレッドで HTTP エンドポイントを呼び出します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:178
msgid ""
"While it's possible to use _traditional_ RESTEasy, you would need to add the `quarkus-resteasy-mutiny` extension, and the method will still be invoked "
"on a _worker_ thread.  So, while it would use reactive programming, it would still require worker threads, which defeats the purpose."
msgstr ""
"従来の _RESTEasy_ を使用することができますが、エクステンションを追加する必要があります。メソッドはワーカースレッドで呼び `quarkus-resteasy-mutiny` _出_ "
"されます。そのため、リアクティブプログラミングを使用する一方で、ワーカースレッドが必要で、目的を打ち負かします。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:180
msgid "The easiest way to create a new Quarkus project is to open a terminal and run the following command:"
msgstr "新しいQuarkusプロジェクトを作成する最も簡単な方法は、ターミナルを開いて以下のコマンドを実行します:"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:182
msgid "For Linux and macOS users"
msgstr "Linux および macOS ユーザーの場合"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:192
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive \\\n"
"    -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"resteasy-reactive\"\n"
"cd getting-started-reactive\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:195
msgid "For Windows users"
msgstr "Windows ユーザーの場合"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:197
msgid "If using cmd, (don't use forward slash `\\`)"
msgstr "cmdを使用している場合(スラッシュは使用しない `\\` )"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:201
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started-reactive -DclassName=\"org.acme.getting.started.ReactiveGreetingResource\" -Dpath=\"/hello\" -Dextensions=\"resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:204
msgid "If using Powershell, wrap `-D` parameters in double quotes"
msgstr "Powershell を使用する場合は、 `-D` パラメーターを二重引用符で囲みます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:208
#, no-wrap
msgid "mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \"-DprojectGroupId=org.acme\" \"-DprojectArtifactId=getting-started-reactive\" \"-DclassName=org.acme.getting.started.ReactiveGreetingResource\" \"-Dpath=/hello\" \"-Dextensions=resteasy-reactive\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:211
msgid "It generates the following in `./getting-started-reactive`:"
msgstr "以下が生成されます `./getting-started-reactive` :"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:213
msgid "the Maven structure"
msgstr "Mavenの構造"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:214
msgid "an `org.acme.quickstart.ReactiveGreetingResource` resource exposed on `/hello`"
msgstr "上 `org.acme.quickstart.ReactiveGreetingResource` で公開されたリソース。 `/hello`"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:215
msgid "an associated unit test"
msgstr "関連するユニットテスト"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:216
msgid "a landing page that is accessible on `http://localhost:8080` after starting the application"
msgstr "アプリケーションの起動後にアクセスできる `http://localhost:8080` ランディングページ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:217
msgid "example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`"
msgstr "両方 `Dockerfile` のモード用 `native` のサンプル `jvm` ファイル `src/main/docker`"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:218
msgid "the application configuration file"
msgstr "アプリケーション設定ファイル"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:219
#, no-wrap
msgid "Reactive JAX-RS resources"
msgstr "JAX-RS のリアクティブリソース"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:222
msgid ""
"During the project creation, the `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` file has been created with the following content:"
msgstr "プロジェクト作成時に、ファイル `src/main/java/org/acme/getting/started/ReactiveGreetingResource.java` は以下の内容で作成されます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:226 upstream/_guides/getting-started-reactive.adoc:269 upstream/_guides/getting-started-reactive.adoc:291
#, no-wrap
msgid "package org.acme.getting.started;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:231
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:234 upstream/_guides/getting-started-reactive.adoc:304
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:241
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"Hello RESTEasy Reactive\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:245
msgid ""
"It's a very simple REST endpoint, returning \"Hello RESTEasy Reactive\" to requests on \"/hello\".  As it uses RESTEAsy Reactive, this method is called "
"on the I/O thread."
msgstr ""
"これは非常にシンプルな REST エンドポイントで、\"/hello\" 上のリクエストに \"Hello RESTEasy Reactive\" を返します。RESTEAsy Reactive を使用すると、このメ"
"ソッドは I/O スレッドで呼び出されます。"

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:250
msgid ""
"To instruct Quarkus to invoke this method on a _worker_ thread, annotate it with the `io.smallrye.common.annotation.Blocking` annotation.  You can use "
"`@Blocking` on a method, class or enable it for the whole application by annotated an `Application` class:"
msgstr ""
"ワーカースレッドでこのメソッドを呼び出すようQuarkusに指示 _するには_ 、アノテーションでアノテーション `io.smallrye.common.annotation.Blocking` します。ク"
"ラスにアノテーションを付けすることで、メソッド、クラスで使用したり、アプリケーション全体 `@Blocking` で有効 `Application` にしたりすることができます:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:256
#, no-wrap
msgid ""
"import javax.ws.rs.ApplicationPath;\n"
"import javax.ws.rs.core.Application;\n"
"import io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:261
#, no-wrap
msgid ""
"@ApplicationPath(\"/\")\n"
"@Blocking\n"
"public class RestBlockingApplication extends Application {\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/getting-started-reactive.adoc:265
msgid "Let's now create a `ReactiveGreetingService` class with the following content:"
msgstr "では、以下の内容の `ReactiveGreetingService` クラスを作成します:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:272
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:275
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:278
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class ReactiveGreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:284
#, no-wrap
msgid ""
"    public Uni<String> greeting(String name) {\n"
"        return Uni.createFrom().item(name)\n"
"                .onItem().transform(n -> String.format(\"hello %s\", n));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:287
msgid "Then, edit the `ReactiveGreetingResource` class to match the following content:"
msgstr "次に、クラスを `ReactiveGreetingResource` 編集して以下の内容に一致します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:297
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:301
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:307
#, no-wrap
msgid ""
"    @Inject\n"
"    ReactiveGreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:314
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"/greeting/{name}\")\n"
"    public Uni<String> greeting(String name) {\n"
"        return service.greeting(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:321
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:326
msgid ""
"The `ReactiveGreetingService` class contains a straightforward method producing a `Uni`.  While, in this example, the resulting item is emitted "
"immediately, you can imagine any async API producing a `Uni`.  We cover this later in this guide."
msgstr "クラス `ReactiveGreetingService` には、 . `Uni` この例では、結果として得られるアイテムがすぐに放出されます。 `Uni` このガイドの後で説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:328
msgid "Now, start the application using:"
msgstr "さて、以下を使ってアプリケーションを起動します:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:332
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:335
msgid "Once running, check you get the expected greeting message by opening http://localhost:8080/hello/greeting/neo."
msgstr "実行したら、以下のコマンドを開いて期待するグリー http://localhost:8080/hello/greeting/neo"

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:336
#, no-wrap
msgid "Handling streams"
msgstr "ストリームの処理"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:340
msgid ""
"So far, we only return an asynchronous result.  In this section, we extend the application with streams conveying multiple items.  These streams could "
"come from Kafka or any other source of data, but to keep things simple, we just generate periodic greeting messages."
msgstr ""
"これまでは、非同期の結果のみを返しています。このセクションでは、複数のアイテムを伝えるストリームでアプリケーションを拡張します。これらのストリームは、"
"Kafkaや他のデータソースから来るかもしれませんが、シンプルに保つために、定期的にグリーティングメッセージを生成する必要があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:342
msgid "In the `ReactiveGreetingService`, add the following method:"
msgstr "で、 `ReactiveGreetingService` 以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:350
#, no-wrap
msgid ""
"public Multi<String> greetings(int count, String name) {\n"
"  return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .onItem().transform(n -> String.format(\"hello %s - %d\", name, n))\n"
"        .transform().byTakingFirstItems(count);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:353
msgid "you may need to add the `import io.smallrye.mutiny.Multi;` and `import java.time.Duration;` statements."
msgstr "and ステートメントを追加する `import io.smallrye.mutiny.Multi;` 必要 `import java.time.Duration;` がある場合があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:355
msgid "It generates a greeting message every second and stops after `count` messages."
msgstr "1 秒ごとにグリーティングメッセージを生成し、メッセージの後に停止 `count` します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:357
msgid "In the `ReactiveGreetingResource` add the following method:"
msgstr "以下の `ReactiveGreetingResource` 方法を追加します:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:366
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Path(\"/greeting/{count}/{name}\")\n"
"public Multi<String> greetings(int count, String name) {\n"
"  return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:370
msgid "This endpoint streams the items to the client as a JSON Array.  The name and number of messages are parameterized using path parameters."
msgstr ""
"このエンドポイントは、アイテムをクライアントにJSONアレイとしてストリームします。メッセージの名前と数は、パスパラメーターを使用してパラメーター化されま"
"す。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:372
msgid "So calling the endpoint produces something like:"
msgstr "そのため、エンドポイントを呼び出す場合、以下のようなものが生成されます:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:377
#, no-wrap
msgid ""
"$ curl http://localhost:8080/hello/greeting/3/neo\n"
"[\"hello neo - 0\", \"hello neo - 1\", \"hello neo - 2\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:380
msgid "We can also generate Server-Sent Event responses by returning a `Multi`:"
msgstr "また、以下を返してサーバー送信イベントの応答を生成することもできます `Multi` :"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:390
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@RestSseElementType(MediaType.TEXT_PLAIN)\n"
"@Path(\"/stream/{count}/{name}\")\n"
"public Multi<String> greetingsAsStream(int count, String name) {\n"
"    return service.greetings(count, name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:394
msgid ""
"The only difference with the previous snippet is the produced type and the `@RestSseElementType` annotation indicating the type of each event.  As the "
"`@Produces` annotation defines `SERVER_SENT_EVENTS`, JAX-RS needs it to knows the content type of each (nested) event."
msgstr ""
"前のスニペットとの唯一の違いは、生成された型と各イベントの `@RestSseElementType` 型を示すアノテーションです。アノテーションが `@Produces` 定義すると、"
"JAX-RSは各(ネストされた)イベントのコンテンツタイプを知 `SERVER_SENT_EVENTS` っている必要があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:396
msgid "You may need to add the `import org.jboss.resteasy.reactive.RestSseElementType;` statement."
msgstr "ステートメントを追加する必要 `import org.jboss.resteasy.reactive.RestSseElementType;` がある場合があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:398
msgid "You can see the result using:"
msgstr "次を使って結果を確認することができます:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:403
#, no-wrap
msgid ""
"$ curl -N http://localhost:8080/hello/stream/5/neo\n"
"data: hello neo - 0\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:405
#, no-wrap
msgid "data: hello neo - 1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:407
#, no-wrap
msgid "data: hello neo - 2\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:409
#, no-wrap
msgid "data: hello neo - 3\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:411
#, no-wrap
msgid "data: hello neo - 4\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:413
#, no-wrap
msgid "Using Reactive APIs"
msgstr "リアクティブ API の使用"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:415
#, no-wrap
msgid "Using Quarkus reactive APIs"
msgstr "QuarkusのリアクティブAPIの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:419
msgid ""
"Quarkus provides many reactive APIs using the Mutiny model.  In this section, we are going to see how you can use the Reactive PostgreSQL driver to "
"interact with your database in a non-blocking and reactive way."
msgstr ""
"Quarkusは、Mutinyモデルを使用して多くのリアクティブAPIを提供しています。このセクションでは、Reactive PostgreSQL ドライバーを使用してノンブロッキングとリ"
"アクティブの方法でデータベースと対話する方法について説明します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:421
msgid "Create a new project using:"
msgstr "以下を使って新しいプロジェクトを作成します:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:431
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=getting-started-reactive-crud \\\n"
"    -DclassName=\"org.acme.reactive.crud.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-reactive,resteasy-reactive-jackson,reactive-pg-client\"\n"
"cd getting-started-reactive-crud\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:434
msgid "This application is interacting with a PostgreSQL database, so you need one:"
msgstr "このアプリケーションはPostgreSQLデータベースと対話しています。そのため、以下が必要です:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:441
#, no-wrap
msgid ""
"docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 \\\n"
"           --name postgres-quarkus-reactive -e POSTGRES_USER=quarkus_test \\\n"
"           -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test \\\n"
"           -p 5432:5432 postgres:11.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:445
msgid "Then, let's configure our datasource.  Open the `src/main/resources/application.properties` and add the following content:"
msgstr "では、データソースを設定します。以下の内容 `src/main/resources/application.properties` を開き、追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:453
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.reactive.url=postgresql://localhost:5432/quarkus_test\n"
"myapp.schema.create=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:457
msgid ""
"The 3 first lines define the datasource.  The last line is going to be used in the application to indicate whether we insert a few items when the "
"application gets initialized."
msgstr ""
"3 行目がデータソースを定義します。アプリケーションが初期化されると、最後の行がアプリケーションで使用され、いくつかのアイテムを挿入するかどうかを示しま"
"す。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:460
msgid "Now, let's create our _entity_.  Create the `org.acme.reactive.crud.Fruit` class with the following content:"
msgstr "では、エンティティを作成 _しましょう_ 。以下の `org.acme.reactive.crud.Fruit` 内容でクラスを作成します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:464 upstream/_guides/getting-started-reactive.adoc:538 upstream/_guides/getting-started-reactive.adoc:581
#, no-wrap
msgid "package org.acme.reactive.crud;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:471
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import io.vertx.mutiny.sqlclient.Row;\n"
"import io.vertx.mutiny.sqlclient.RowSet;\n"
"import io.vertx.mutiny.sqlclient.Tuple;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:473
#, no-wrap
msgid "import java.util.stream.StreamSupport;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:475
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:477
#, no-wrap
msgid "    public Long id;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:479
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:483
#, no-wrap
msgid ""
"    public Fruit() {\n"
"        // default constructor.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:487
#, no-wrap
msgid ""
"    public Fruit(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:492
#, no-wrap
msgid ""
"    public Fruit(Long id, String name) {\n"
"        this.id = id;\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:500
#, no-wrap
msgid ""
"    public static Multi<Fruit> findAll(PgPool client) {\n"
"        return client.query(\"SELECT id, name FROM fruits ORDER BY name ASC\").execute()\n"
"                // Create a Multi from the set of rows:\n"
"                .onItem().transformToMulti(set -> Multi.createFrom().items(() -> StreamSupport.stream(set.spliterator(), false)))\n"
"                // For each row create a fruit instance\n"
"                .onItem().transform(Fruit::from);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:506
#, no-wrap
msgid ""
"    public static Uni<Fruit> findById(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"SELECT id, name FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(RowSet::iterator)\n"
"                .onItem().transform(iterator -> iterator.hasNext() ? from(iterator.next()) : null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:511
#, no-wrap
msgid ""
"    public Uni<Long> save(PgPool client) {\n"
"        return client.preparedQuery(\"INSERT INTO fruits (name) VALUES ($1) RETURNING (id)\").execute(Tuple.of(name))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.iterator().next().getLong(\"id\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:516
#, no-wrap
msgid ""
"    public Uni<Boolean> update(PgPool client) {\n"
"        return client.preparedQuery(\"UPDATE fruits SET name = $1 WHERE id = $2\").execute(Tuple.of(name, id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:521
#, no-wrap
msgid ""
"    public static Uni<Boolean> delete(PgPool client, Long id) {\n"
"        return client.preparedQuery(\"DELETE FROM fruits WHERE id = $1\").execute(Tuple.of(id))\n"
"                .onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:526
#, no-wrap
msgid ""
"    private static Fruit from(Row row) {\n"
"        return new Fruit(row.getLong(\"id\"), row.getString(\"name\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:532
msgid ""
"This _entity_ contains a few fields and methods to find, update, and delete rows from the database.  These methods return either `Unis` or `Multis` as "
"the produced items are emitted asynchronously when the results have been retrieved.  Notice that the reactive PostgreSQL client already provides `Uni` "
"and `Multi` instances.  So you only transform the results from the database into _business-friendly_ objects."
msgstr ""
"この _エンティティーには_ 、データベースから行を見つけ、更新、および削除するいくつかのフィールドとメソッドが含まれます。これらのメソッドは、結果が取得さ"
"れると、生成されたアイテムが非同期に放出される `Unis` `Multis` のいずれかを返します。リアクティブ PostgreSQL クライアントがすでに提供し、インスタンス "
"`Uni` に `Multi` 注意してください。そのため、データベースからの結果をビジネスフレンドリーな _オブジェクトに変換する必要_ があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:534
msgid "For the purposes of initializing the database when the application starts, we will create a class named `DBInit` with the following content:"
msgstr "アプリケーションの起動時にデータベースを初期化するために、以下の内容で名前の付いた `DBInit` クラスを作成します:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:542
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:545
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:548
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class DBInit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:551
#, no-wrap
msgid ""
"    private final PgPool client;\n"
"    private final boolean schemaCreate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:556
#, no-wrap
msgid ""
"    public DBInit(PgPool client, @ConfigProperty(name = \"myapp.schema.create\", defaultValue = \"true\") boolean schemaCreate) {\n"
"        this.client = client;\n"
"        this.schemaCreate = schemaCreate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:562
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent ev) {\n"
"        if (schemaCreate) {\n"
"            initdb();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:573
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:577
msgid "Then, let's use this `Fruit` class in the `FruitResource`.  Edit the `FruitResource` class to match the following content:"
msgstr "では、このクラス `Fruit` を. `FruitResource` 以下の `FruitResource` 内容に合わせてクラスを編集します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:583
#, no-wrap
msgid "import java.net.URI;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:595
#, no-wrap
msgid ""
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.PUT;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.ResponseBuilder;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:599
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.pgclient.PgPool;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:604
#, no-wrap
msgid ""
"@Path(\"fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:606
#, no-wrap
msgid "    private final PgPool client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:610
#, no-wrap
msgid ""
"    public FruitResource(PgPool client) {\n"
"        this.client = client;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:620
#, no-wrap
msgid ""
"    private void initdb() {\n"
"        client.query(\"DROP TABLE IF EXISTS fruits\").execute()\n"
"                .flatMap(r -> client.query(\"CREATE TABLE fruits (id SERIAL PRIMARY KEY, name TEXT NOT NULL)\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Kiwi')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Durian')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Pomelo')\").execute())\n"
"                .flatMap(r -> client.query(\"INSERT INTO fruits (name) VALUES ('Lychee')\").execute())\n"
"                .await().indefinitely();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:625
#, no-wrap
msgid ""
"    @GET\n"
"    public Multi<Fruit> get() {\n"
"        return Fruit.findAll(client);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:633
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> getSingle(Long id) {\n"
"        return Fruit.findById(client, id)\n"
"                .onItem().transform(fruit -> fruit != null ? Response.ok(fruit) : Response.status(Status.NOT_FOUND))\n"
"                .onItem().transform(ResponseBuilder::build);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:640
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<Response> create(Fruit fruit) {\n"
"        return fruit.save(client)\n"
"                .onItem().transform(id -> URI.create(\"/fruits/\" + id))\n"
"                .onItem().transform(uri -> Response.created(uri).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:648
#, no-wrap
msgid ""
"    @PUT\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> update(Long id, Fruit fruit) {\n"
"        return fruit.update(client)\n"
"                .onItem().transform(updated -> updated ? Status.OK : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:657
#, no-wrap
msgid ""
"    @DELETE\n"
"    @Path(\"{id}\")\n"
"    public Uni<Response> delete(Long id) {\n"
"        return Fruit.delete(client, id)\n"
"                .onItem().transform(deleted -> deleted ? Status.NO_CONTENT : Status.NOT_FOUND)\n"
"                .onItem().transform(status -> Response.status(status).build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:660
msgid "This resource returns `Uni` and `Multi` instances based on the result produced by the `Fruit` class."
msgstr "このリソースは、 `Uni` クラス `Multi` によって生成された結果に基づいてインスタンスを返 `Fruit` します。"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:661
#, no-wrap
msgid "Using Vert.x clients"
msgstr "Vert.x クライアントの使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:665
msgid "The previous example uses a _service_ provided by Quarkus.  Also, you can use Vert.x clients directly."
msgstr "前の例 _では_ 、Quarkusによって提供されたサービスを使用しています。また、Vert.xクライアントを直接使用することもできます。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:667
msgid "First of all, make sure the `quarkus-vertx` extension is present. If not, activate the extension by executing the following command:"
msgstr ""
"まず第一に、エクステンションが存在 `quarkus-vertx` するようにしてください。有効ではない場合は、以下のコマンドを実行してエクステンションを有効にしてくださ"
"い。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:672
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:add-extensions \\\n"
"    -Dextensions=vertx\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:675
msgid "Or add `quarkus-vertx` into your dependencies manually."
msgstr "または、 `quarkus-vertx` 手動で依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:682
#, no-wrap
msgid ""
"<dependency>\n"
"\t<groupId>io.quarkus</groupId>\n"
"\t<artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:686
msgid "There is a Mutiny version of the Vert.x APIs.  This API is divided into several artifacts you can import independently:"
msgstr "Vert.x API には Mutiny バージョンがあります。この API は、個別にインポートできるいくつかのアーティファクトに分割されます。"

#. type: Table
#: upstream/_guides/getting-started-reactive.adoc:719
#, no-wrap
msgid ""
"|groupId:artifactId | Description\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-core`\n"
"|Mutiny API for Vert.x Core\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-mail-client`\n"
"|Mutiny API for the Vert.x Mail Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-web-client`\n"
"|Mutiny API for the Vert.x Web Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-mongo-client`\n"
"|Mutiny API for the Vert.x Mongo Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-redis-client`\n"
"|Mutiny API for the Vert.x Redis Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-cassandra-client`\n"
"|Mutiny API for the Vert.x Cassandra Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-consul-client`\n"
"|Mutiny API for the Vert.x Consul Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-kafka-client`\n"
"|Mutiny API for the Vert.x Kafka Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-amqp-client`\n"
"|Mutiny API for the Vert.x AMQP Client\n"
"\n"
"|`io.smallrye.reactive:smallrye-mutiny-vertx-rabbitmq-client`\n"
"|Mutiny API for the Vert.x RabbitMQ Client\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:722
msgid "You can also check the available APIs on http://smallrye.io/smallrye-reactive-utils/apidocs/."
msgstr "また、インストール時に利用可能な http://smallrye.io/smallrye-reactive-utils/apidocs/ http://smallrye.io/smallrye-reactive-utils/apidocs/。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:725
msgid "Let's take an example.  Add the following dependency to your application:"
msgstr "例を挙ご説明します。以下の依存関係をアプリケーションに追加します。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:732
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:736
msgid "It provides the Mutiny API of the Vert.x Web Client.  Then, you can use the web client as follows:"
msgstr "Vert.x Webクライアントの Mutiny API を提供します。次に、以下のように Web クライアントを使用できます。"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:740
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:747
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:754
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:757
#, no-wrap
msgid ""
"@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:760
#, no-wrap
msgid ""
"    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:762
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:769
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void initialize() {\n"
"        this.client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\").setDefaultPort(443).setSsl(true)\n"
"                        .setTrustAll(true));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:786
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.get(\"/api/fruit/\" + name)\n"
"                .send()\n"
"                .map(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:788
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:791
msgid "There are 2 important points:"
msgstr "2つの重要なポイントがあります:"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:793
msgid "The injected Vert.x instance has the `io.vertx.mutiny.core.Vertx` type which is the Mutiny variant of Vert.x;"
msgstr "注入された Vert.x インスタンスには `io.vertx.mutiny.core.Vertx` 、Vert.x の Mutiny 変形である型があります。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:794
msgid "The Web Client is created from `io.vertx.mutiny.ext.web.client.WebClient`."
msgstr "Web クライアントが作成されます `io.vertx.mutiny.ext.web.client.WebClient` 。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:796
msgid "The Mutiny version of the Vert.x APIs also offers:"
msgstr "Vert.x APIの Mutiny バージョンでは、以下の機能も提供しています:"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:799
msgid ""
"`andAwait` methods such as `sendAndAwait`. `andAwait` indicates that the caller thread is blocked until the result is available.  Be aware not to block "
"the event loop / IO thread that way."
msgstr ""
"`andAwait` などのメソッドは `sendAndAwait` `andAwait` 、結果が得されるまで呼び出し元のスレッドがブロックされます。イベントループ/IOスレッドをブロックして"
"はいけなさそうに注意してください。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:803
msgid ""
"`andForget` methods such as `writeAndForget`. `andForget` is available for method returning a `Uni`.  `andForget` indicates that you don't need the "
"resulting `Uni` indicating the success or failure of the operation.  However, remember that if you don't subscribe, the operation would not be "
"triggered.  `andForget` manages this for you and manage the subscription."
msgstr ""
"`andForget` のようなメソッドは、 . を返すメソッドに対して利用可能です。これは、操作の成功と失敗を示す結果 `writeAndForget` `andForget` を必要 `Uni` "
"`andForget` `Uni` としないことを示します。しかし、サブスクライブしていない場合、操作はトリガーされないことを覚えておいてください。 `andForget` これを管理"
"し、サブスクリプションを管理します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:804
msgid "`toMulti` methods allowing to transform a Vert.x `ReadStream` into a `Multi`"
msgstr "`toMulti` Vert.xを1つのメソッドに `ReadStream` 変換することを可能にするメソッド `Multi`"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:805
msgid ""
"`toBlockingIterable` / `toBlockingStream` methods allowing to transform a Vert.x `ReadStream` into a blocking iterable or blocking `java.util.Stream`"
msgstr ""
"`toBlockingIterable` / `toBlockingStream` Vert.xをブロッキングイ `ReadStream` iterableまたはブロッキングに変換することを可能にするメソッド `java.util."
"Stream`"

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:806
#, no-wrap
msgid "Using RxJava or Reactor APIs"
msgstr "RxJava またはリアクター API の使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:809
msgid "Mutiny provides utilities to convert RxJava 2 and Project Reactor types to `Uni` and `Multi`."
msgstr "Mutinyは、RxJava 2とプロジェクトリアクターの型を変換するためのユーティリティーを `Uni` 提供しています `Multi` 。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:811
msgid "RxJava 2 converters are available in the following dependency:"
msgstr "RxJava 2の変換ツールは以下の依存関係で利用可能です:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:818
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-rxjava</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:821
msgid ""
"So if you have an API returning RxJava 2 types (`Completable`, `Single`, `Maybe`, `Observable`, `Flowable`), you can create `Unis` and `Multis` as "
"follows:"
msgstr ""
"そのため、RxJava 2型( 、 , , , ) を返すAPIがある場合は、 `Completable` `Single` `Maybe` `Observable` `Flowable` 以下のように作成 `Unis` `Multis` して作成"
"することができます:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:833
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiRxConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniRxConverters;\n"
"// ...\n"
"Uni<Void> uniFromCompletable = Uni.createFrom().converter(UniRxConverters.fromCompletable(), completable);\n"
"Uni<String> uniFromSingle = Uni.createFrom().converter(UniRxConverters.fromSingle(), single);\n"
"Uni<String> uniFromMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), maybe);\n"
"Uni<String> uniFromEmptyMaybe = Uni.createFrom().converter(UniRxConverters.fromMaybe(), emptyMaybe);\n"
"Uni<String> uniFromObservable = Uni.createFrom().converter(UniRxConverters.fromObservable(), observable);\n"
"Uni<String> uniFromFlowable = Uni.createFrom().converter(UniRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:840
#, no-wrap
msgid ""
"Multi<Void> multiFromCompletable = Multi.createFrom().converter(MultiRxConverters.fromCompletable(), completable);\n"
"Multi<String> multiFromSingle = Multi.createFrom().converter(MultiRxConverters.fromSingle(), single);\n"
"Multi<String> multiFromMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), maybe);\n"
"Multi<String> multiFromEmptyMaybe = Multi.createFrom().converter(MultiRxConverters.fromMaybe(), emptyMaybe);\n"
"Multi<String> multiFromObservable = Multi.createFrom().converter(MultiRxConverters.fromObservable(), observable);\n"
"Multi<String> multiFromFlowable = Multi.createFrom().converter(MultiRxConverters.fromFlowable(), flowable);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:843
msgid "You can also transform `Unis` and `Multis` into RxJava types:"
msgstr "RxJavaの `Unis` 型に `Multis` 変換して変換することもできます:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:860
#, no-wrap
msgid ""
"Completable completable = uni.convert().with(UniRxConverters.toCompletable());\n"
"Single<Optional<String>> single = uni.convert().with(UniRxConverters.toSingle());\n"
"Single<String> single2 = uni.convert().with(UniRxConverters.toSingle().failOnNull());\n"
"Maybe<String> maybe = uni.convert().with(UniRxConverters.toMaybe());\n"
"Observable<String> observable = uni.convert().with(UniRxConverters.toObservable());\n"
"Flowable<String> flowable = uni.convert().with(UniRxConverters.toFlowable());\n"
"// ...\n"
"Completable completable = multi.convert().with(MultiRxConverters.toCompletable());\n"
"Single<Optional<String>> single = multi.convert().with(MultiRxConverters.toSingle());\n"
"Single<String> single2 = multi.convert().with(MultiRxConverters\n"
"        .toSingle().onEmptyThrow(() -> new Exception(\"D'oh!\")));\n"
"Maybe<String> maybe = multi.convert().with(MultiRxConverters.toMaybe());\n"
"Observable<String> observable = multi.convert().with(MultiRxConverters.toObservable());\n"
"Flowable<String> flowable = multi.convert().with(MultiRxConverters.toFlowable());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:863
msgid "Project Reactor converters are available in the following dependency:"
msgstr "プロジェクトのリアクターの変換は、以下の依存関係で利用可能です:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:870
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>mutiny-reactor</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:873
msgid "So if you have an API returning Reactor types (`Mono`, `Flux`), you can create `Unis` and `Multis` as follows:"
msgstr "そのため、リアクトルタイプ( , )を返すAPIがある場合 `Mono` `Flux` は、以下のように `Unis` 作成 `Multis` することができます:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:881
#, no-wrap
msgid ""
"import io.smallrye.mutiny.converters.multi.MultiReactorConverters;\n"
"import io.smallrye.mutiny.converters.uni.UniReactorConverters;\n"
"// ...\n"
"Uni<String> uniFromMono = Uni.createFrom().converter(UniReactorConverters.fromMono(), mono);\n"
"Uni<String> uniFromFlux = Uni.createFrom().converter(UniReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:884
#, no-wrap
msgid ""
"Multi<String> multiFromMono = Multi.createFrom().converter(MultiReactorConverters.fromMono(), mono);\n"
"Multi<String> multiFromFlux = Multi.createFrom().converter(MultiReactorConverters.fromFlux(), flux);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:887
msgid "You can also transform `Unis` and `Multis` into Reactor types:"
msgstr "また、リアクタータイプ `Unis` に `Multis` 変換して変換することもできます:"

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:892
#, no-wrap
msgid ""
"Mono<String> mono = uni.convert().with(UniReactorConverters.toMono());\n"
"Flux<String> flux = uni.convert().with(UniReactorConverters.toFlux());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:895
#, no-wrap
msgid ""
"Mono<String> mono2 = multi.convert().with(MultiReactorConverters.toMono());\n"
"Flux<String> flux2 = multi.convert().with(MultiReactorConverters.toFlux());\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/getting-started-reactive.adoc:897
#, no-wrap
msgid "Using CompletionStages or Publisher API"
msgstr "CompletionStages または発行者 API の使用"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:901
msgid ""
"If you are facing an API using `CompletionStage`, `CompletableFuture`, or `Publisher`, you can convert back and forth.  First, both `Uni` and `Multi` "
"can be created from a `CompletionStage` or from a `Supplier<CompletionStage>`. For example:"
msgstr ""
"APIに直面している場合は、 `CompletionStage` 前後 `CompletableFuture` `Publisher` に変換することができます。最初に、 `Uni` 両方 `Multi` とも、aから、また"
"はから `CompletionStage` 作成することができます `Supplier<CompletionStage>` .例えば："

#. type: delimited block -
#: upstream/_guides/getting-started-reactive.adoc:907
#, no-wrap
msgid ""
"CompletableFuture<String> future = Uni\n"
"        // Create from a Completion Stage\n"
"        .createFrom().completionStage(CompletableFuture.supplyAsync(() -> \"hello\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:910
msgid ""
"On `Uni`, you can also produce a `CompletionStage` using `subscribeAsCompletionStage()` that produces a `CompletionStage` that would get the item or "
"failure emitted by the `Uni`."
msgstr ""
"上では、アイテムや失敗によって放出されるアイテムを生成する `Uni` `CompletionStage` using `subscribeAsCompletionStage()` `CompletionStage` を生成すること"
"ができます `Uni` 。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:914
msgid ""
"You can also create `Unis` and `Multis` from instances of `Publisher` using `createFrom().publisher(Publisher)`.  You can transform a `Uni` into a "
"`Publisher` using `toMulti`.  Indeed, `Multi` implements `Publisher`."
msgstr ""
"また、使用 `Unis` する `Multis` インスタンスを作成してから `Publisher` 作成することができます `createFrom().publisher(Publisher)` 。aを使用して `Uni` 変"
"換 `Publisher` できます `toMulti` 。実際、 `Multi` 実装 `Publisher` ."

#. type: Title ==
#: upstream/_guides/getting-started-reactive.adoc:915
#, no-wrap
msgid "What's next?"
msgstr "次のステップ"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:920
msgid ""
"This guide is an introduction to reactive in Quarkus.  There are plenty of Quarkus features that are already reactive.  The following list gives you a "
"few examples:"
msgstr "このガイドは、Quarkusでのリアクティブについて説明します。すでにリアクティブであるQuarkusの機能は豊富です。次のリストに、いくつかの例を示します。"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:922
msgid "link:rest-json#reactive[Using Mutiny with RestEasy]"
msgstr "link:rest-json#reactive[RestEasyでの Mutiny の使用]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:923
msgid "link:mailer[Sending email]"
msgstr "link:mailer[メールの送信]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:924
msgid "link:mongodb#reactive[Using MongoDB] and link:mongodb-panache#reactive[MongoDB with Panache]"
msgstr "link:mongodb#reactive[MongoDBと] link:mongodb-panache#reactive[MongoDBを Panacheで使用する]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:925
msgid "link:reactive-sql-clients[Reactive Database Clients]"
msgstr "link:reactive-sql-clients[リアクティブデータベースクライアント]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:926
msgid "link:vertx[Using Vert.x]"
msgstr "link:vertx[Vert.xの使用]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:927
msgid "link:kafka[Interacting with Kafka] and link:amqp[Interacting with AMQP]"
msgstr "link:kafka[Kafkaとの対話と] link:amqp[AMQPとの対話]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:neo4j#reactive[Using Neo4J]"
msgstr "link:neo4j#reactive[Neo4Jの使用]"

#. type: Plain text
#: upstream/_guides/getting-started-reactive.adoc:928
msgid "link:reactive-routes[Using reactive routes]"
msgstr "link:reactive-routes[リアクティブルートの使用]"

#, fuzzy
#~ msgid "The generated `pom.xml` also declares the RESTEasy Mutiny support and RESTEasy Jackson to serialize payloads."
#~ msgstr "生成された `pom.xml` はまた、ペイロードをシリアライズするために RESTEasy Mutiny サポートと RESTEasy Jackson を宣言しています。"

#, fuzzy
#~ msgid ""
#~ "In order to get Mutiny working properly with JAX-RS resources, make sure the Mutiny support for RESTEasy extension (`io.quarkus:quarkus-resteasy-"
#~ "mutiny`) is present, otherwise add the extension by executing the following command:"
#~ msgstr ""
#~ "JAX-RSリソースでMutinyを正しく動作させるためには、RESTEasyエクステンションのMutinyサポート( `io.quarkus:quarkus-resteasy-mutiny`)が存在することを確認"
#~ "してください。"

#, fuzzy
#~ msgid "Or add `quarkus-resteasy-reactive` into your dependencies manually."
#~ msgstr "または、手動で `quarkus-resteasy-mutiny` を依存関係に追加してください。"
