# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2020-12-29 14:10+0900\n"
"PO-Revision-Date: 2021-01-08 00:02+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: \n"
"Language-Team: \n"
"X-Generator: Poedit 2.4.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi.adoc:6
#, no-wrap
msgid "Quarkus - Introduction to Contexts and Dependency Injection"
msgstr "Quarkus - コンテキストと依存性注入（CDI）の紹介"

#. type: Plain text
#: upstream/_guides/cdi.adoc:15
msgid ""
"In this guide we're going to describe the basic principles of the Quarkus programming model that is based on the http://docs.jboss.org/"
"cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification."
msgstr ""
"このガイドでは、 http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基"
"づいたQuarkusプログラミングモデルの基本原理について説明します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:16
#, no-wrap
msgid "_Q: OK. Let's start simple. What is a bean?_"
msgstr "_Q：OK、簡単なことから始めましょう。Beanとは何ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:19
msgid ""
"A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle "
"callbacks and interceptors."
msgstr ""
"A: そうですね、Beanは _コンテナ管理された_ オブジェクトで、依存性の注入、ライフサイクルコールバック、インターセプターなどの基本的なサービ"
"スをサポートしています。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:20
#, no-wrap
msgid "_Q: Wait a minute. What does \"container-managed\" mean?_"
msgstr "_Q: ちょっと待ってください。コンテナ管理されている」とはどういう意味ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:26
msgid ""
"A: Simply put, you don't control the lifecycle of the object instance directly.  Instead, you can affect the lifecycle through "
"declarative means, such as annotations, configuration, etc.  The container is the _environment_ where your application runs.  It creates "
"and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans."
msgstr ""
"A: 簡単に言えば、オブジェクトインスタンスのライフサイクルを直接制御することはできません。その代わりに、アノテーションや設定などの宣言的な"
"手段でライフサイクルに影響を与えることができます。コンテナはアプリケーションが動作する _環境_ です。コンテナは、Beanのインスタンスを作成"
"したり破棄したり、指定されたコンテキストにインスタンスを関連付けたり、他のBeanズに注入したりします。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:27
#, no-wrap
msgid "_Q: What is it good for?_"
msgstr "_Ｑ：何に効くのですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:30
msgid ""
"A: An application developer can focus on the business logic rather than finding out \"where and how\" to obtain a fully initialized "
"component with all of its dependencies."
msgstr ""
"A: アプリケーション開発者は、すべての依存関係を持つ完全に初期化されたコンポーネントを取得するため、「どこでどのように」よりも、ビジネスロ"
"ジックに集中することができます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:32
msgid ""
"You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation "
"techniques of IoC."
msgstr ""
"_制御の反転_ （Inversion of Control, IoC ）というプログラミングの原理を聞いたことがあると思います。依存性注入はIoCの実装技術の一つです。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:33
#, no-wrap
msgid "_Q: What does a bean look like?_"
msgstr "_Q: Beanはどんな形をしていますか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:37
msgid "A: There are several kinds of beans.  The most common ones are class-based beans:"
msgstr "A: Beanにはいくつかの種類があります。最も一般的なのは、クラスベースのBeanです。"

#. type: Block title
#: upstream/_guides/cdi.adoc:38
#, no-wrap
msgid "Simple Bean Example"
msgstr "シンプルなBeanの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:44
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.eclipse.microprofile.metrics.annotation.Counted;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:47
#, no-wrap
msgid ""
"@ApplicationScoped <1>\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:50
#, no-wrap
msgid ""
"    @Inject\n"
"    Dictionary dictionary; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:56
#, no-wrap
msgid ""
"    @Counted  <3>\n"
"    String translate(String sentence) { \n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:58
msgid ""
"This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single "
"bean instance* is created for the application and used by all other beans that inject `Translator`."
msgstr ""
"これはスコープアノテーションです。これはコンテナに、Beanのインスタンスをどのコンテキストに関連付けるかを伝えます。この特定のケースでは、 "
"*単一のBeanインスタンス* がアプリケーション用に作成され、 `Translator`の注入を行う他の全てのBeanによって使用されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:59
msgid ""
"This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean "
"the build fails."
msgstr ""
"これはフィールド注入ポイントです。 `Translator`  が `Dictionary`  Beanに依存していることをコンテナに伝えます。マッチするBeanがない場合、"
"ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:60
msgid ""
"This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor "
"intercepts the invocation and updates the relevant metrics. We will talk about <<interceptors,interceptors>> later."
msgstr ""
"これはインターセプター結合アノテーションです。この場合、アノテーションは MicroProfile Metrics から来ています。関連するインターセプターは"
"呼び出しをインターセプトし、関連するメトリクスを更新します。 <<interceptors,インターセプター>>については後述します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:61
#, no-wrap
msgid "_Q: Nice. How does the dependency resolution work? I see no names or identifiers._"
msgstr "_Q: いいですね。依存関係の解決方法を教えてください。名前や識別子が見当たらないのですが、どうすればいいですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:70
msgid ""
"A: That's a good question.  In CDI the process of matching a bean to an injection point is *type-safe*.  Each bean declares a set of "
"bean types.  In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.  Subsequently, a bean "
"is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.  "
"We'll talk about qualifiers later.  For now, it's enough to know that the bean above is assignable to an injection point of type "
"`Translator` and `java.lang.Object`."
msgstr ""
"A: いい質問ですね。CDIでは、Beanをインジェクションポイントにマッチングするプロセスは *タイプセーフ* です。各Beanは、Beanタイプのセットを"
"宣言します。上の例では、 `Translator`  Beanには、 `Translator`  と `java.lang.Object`  の 2 つのBeanタイプがあります。その後、Beanが _必"
"要な型_ にマッチするBean型を持ち、 _必要な_ すべての _修飾子を_ 持っている場合、Beanはインジェクションポイントに代入可能です。この後、修"
"飾子について説明します。今のところ、上記のBeanが `Translator`  と `java.lang.Object`  のタイプのインジェクションポイントに代入可能である"
"ことを知っていれば十分です。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:71
#, no-wrap
msgid "_Q: Hm, wait a minute. What happens if multiple beans declare the same type?_"
msgstr "_Q: ふむ、ちょっと待ってください。複数の豆が同じ型を宣言した場合はどうなりますか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:77
msgid ""
"A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.  If none is "
"assignable the build fails with `UnsatisfiedResolutionException`.  If multiple are assignable the build fails with "
"`AmbiguousResolutionException`.  This is very useful because your application fails fast whenever the container is not able to find an "
"unambiguous dependency for any injection point."
msgstr ""
"A: シンプルなルールがあります: *1つのインジェクションポイントに正確に1つのBeanが割り当て可能でなければならない、そうでなければビルドは失"
"敗します* 。割り当て可能なBeanが1つもない場合、 `UnsatisfiedResolutionException`  でビルドは失敗します。複数のBeanが割り当て可能な場合、"
"ビルドは `AmbiguousResolutionException`  で失敗します。これは、コンテナがどのインジェクションポイントに対しても明確な依存関係を見つけるこ"
"とができない場合に、アプリケーションが高速に失敗するので、非常に便利です。"

#. type: delimited block =
#: upstream/_guides/cdi.adoc:81
msgid ""
"Your can use programmatic lookup via `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all "
"beans implementing a given type:"
msgstr ""
"`javax.enterprise.inject.Instance`  を通じてプログラム的なルックアップを使用して、実行時に曖昧さを解決したり、指定された型を実装している"
"すべてのBeanを反復処理したりすることができます："

#. type: delimited block -
#: upstream/_guides/cdi.adoc:85
#, no-wrap
msgid "public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:88
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<Dictionary> dictionaries; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:95
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      for (Dictionary dict : dictionaries) { <2>\n"
"         // ...\n"
"      }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:97
msgid ""
"This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type."
msgstr "このインジェクションポイントは、 `Dictionary`  型を実装した複数のBeanがあっても、曖昧な依存関係にはなりません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:98
msgid "`javax.enterprise.inject.Instance` extends `Iterable`."
msgstr "`javax.enterprise.inject.Instance` は `Iterable` を継承します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:100
#, no-wrap
msgid "_Q: Can I use setter and constructor injection?_"
msgstr "_Q: セッターやコンストラクタのインジェクションは使えますか？_"

#. type: delimited block =
#: upstream/_guides/cdi.adoc:105
msgid ""
"A: Yes, you can.  In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#initializer_methods[initializer methods, window=\"_blank\"].  Initializers may accept multiple parameters and don't have to follow "
"the JavaBean naming conventions."
msgstr ""
"A: はい、できます。実際、CDIでは「セッター注入」は、より強力な link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#initializer_methods[イニシャライザメソッド, window=_blank]に取って代わられています。イニシャライザは複数のパラメータを受け入れること"
"ができ、JavaBeanの命名規則に従う必要はありません。"

#. type: Block title
#: upstream/_guides/cdi.adoc:106
#, no-wrap
msgid "Initialized and Constructor Injection Example"
msgstr "初期化とコンストラクタのインジェクション例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:111 upstream/_guides/cdi.adoc:306
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:113
#, no-wrap
msgid "    private final TranslatorHelper helper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:117
#, no-wrap
msgid ""
"    Translator(TranslatorHelper helper) { <1>\n"
"       this.helper = helper;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:123
#, no-wrap
msgid ""
"    @Inject <2>\n"
"    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n"
"      / ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:128
msgid ""
"This is a constructor injection.  In fact, this code would not work in regular CDI implementations where a bean with a normal scope must "
"always declare a no-args constructor and the bean constructor must be annotated with `@Inject`.  However, in Quarkus we detect the "
"absence of no-args constructor and \"add\" it directly in the bytecode.  It's also not necessary to add `@Inject` if there is only one "
"constructor present."
msgstr ""
"これはコンストラクタのインジェクションです。実際には、このコードは通常のCDI実装では動作しません。通常のスコープを持つBeanは常にno-argsコ"
"ンストラクタを宣言しなければならず、Beanのコンストラクタは `@Inject`  でアノテーションされなければなりません。しかし、Quarkusでは、no-"
"argsコンストラクタが存在しないことを検出し、バイトコードに直接「追加」します。また、コンストラクタが1つしかない場合は、 `@Inject`  を追加"
"する必要はありません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:129
msgid "An initializer method must be annotated with `@Inject`."
msgstr "イニシャライザメソッドには `@Inject`  をアノテーションしなければなりません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:130
msgid "An initializer may accept multiple parameters - each one is an injection point."
msgstr "イニシャライザは複数のパラメータを受け付けることができ、それぞれがインジェクションポイントとなります。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:131
#, no-wrap
msgid "_Q: You talked about some qualifiers?_"
msgstr "_Q：修飾子の話もありましたね。_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:136
msgid ""
"A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container "
"to distinguish beans that implement the same type.  As we already said a bean is assignable to an injection point if it has all the "
"required qualifiers.  If you declare no qualifier at an injection point the `@Default` qualifier is assumed."
msgstr ""
"A link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[: 修飾子, window=_blank]は、コンテナが同じ型を実装したBeanを区別する"
"のに役立つアノテーションです。すでに述べたように、Beanは必要な修飾子をすべて持っていれば、インジェクションポイントに割り当てることができ"
"ます。インジェクションポイントで修飾子を宣言しない場合は、 `@Default`  の修飾子が想定されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:138
msgid ""
"A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and annotated with the `@javax.inject.Qualifier` meta-annotation:"
msgstr ""
"Qualifier型は、 `@Retention(RUNTIME)`  として定義された Java アノテーションで、 `@javax.inject.Qualifier`  メタアノテーションでアノテー"
"ションされています。"

#. type: Block title
#: upstream/_guides/cdi.adoc:139
#, no-wrap
msgid "Qualifier Example"
msgstr "修飾子の例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:146
#, no-wrap
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface Superior {}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:149
msgid "The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types:"
msgstr "Beanの修飾子は、Beanクラスやプロデューサのメソッドやフィールドに修飾子タイプをアノテーションすることで宣言されます。"

#. type: Block title
#: upstream/_guides/cdi.adoc:150
#, no-wrap
msgid "Bean With Custom Qualifier Example"
msgstr "カスタム修飾子を持つ Bean の例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:156
#, no-wrap
msgid ""
"@Superior <1>\n"
"@ApplicationScoped\n"
"public class SuperiorTranslator extends Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:161 upstream/_guides/cdi.adoc:210
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:163
msgid ""
"`@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"]."
msgstr ""
"`@Superior`  は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[修飾子アノテーション, window=_blank]で"
"す。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:167
msgid ""
"This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject "
"Translator`.  The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe "
"resolution.  And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable."
msgstr ""
"このBeanは `@Inject @Superior Translator`  と `@Inject @Superior SuperiorTranslator`  には割り当てられますが、 `@Inject Translator`  には"
"割り当てられません。その理由は、 `@Inject Translator`  はタイプセーフ解決の際に自動的に `@Inject @Default Translator`  に変換されるからで"
"す。また、私たちの `SuperiorTranslator`  は `@Default`  を宣言していないので、元の `Translator`  Beanだけが代入可能です。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:168
#, no-wrap
msgid "_Q: Looks good. What is the bean scope?_"
msgstr "_Ｑ：良さそうですね。Beanスコープとは何ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:171
msgid "The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed."
msgstr "Beanのスコープはインスタンスのライフサイクルを決定します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:173
msgid "Every bean has exactly one scope."
msgstr "すべての豆は、正確に1つのスコープを持っています。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:174
#, no-wrap
msgid "_Q: What scopes can I actually use in my Quarkus application?_"
msgstr "_Q: Quarkusアプリケーションで実際に使用できるスコープは何ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:177
msgid "A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`."
msgstr "A: `javax.enterprise.context.ConversationScoped`  を除いて、仕様書に記載されているすべての組み込みスコープを使用できます。"

#. ----------------------
#. type: Table
#: upstream/_guides/cdi.adoc:187
#, no-wrap
msgid ""
"|Annotation   |Description   \n"
"|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n"
"|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created when an injection point that resolves to a @Singleton bean is being injected.\n"
"|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n"
"|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. The instances are not shared and every injection point spawns a new instance of the dependent bean. The lifecycle of dependent bean is bound to the bean injecting it - it will be created and destroyed along with the bean injecting it.\n"
"|`@javax.enterprise.context.SessionScoped`   | This scope is backed by a `javax.servlet.http.HttpSession` object. It's only available if the `quarkus-undertow` extension is used.\n"
msgstr ""
"|Annotation   |Description   \n"
"|`@javax.enterprise.context.ApplicationScoped`   | 単一のBeanインスタンスがアプリケーションに使用され、すべてのインジェクションポイント間で共有されます。インスタンスは遅延して作成されます。つまり、<<client_proxies, client proxy>>でメソッドが呼び出されると作成されます。\n"
"|`@javax.inject.Singleton`   | `@ApplicationScoped` とクライアントプロキシが使用されないことを除いて、同じです。インスタンスは、@SingletonBeanに解決される注入ポイントが注入されているときに作成されます。\n"
"|`@javax.enterprise.context.RequestScoped`   | Beanインスタンスは現在の _リクエスト_ と関連付けられます（通常HTTPリクエスト）。 \n"
"|`@javax.enterprise.context.Dependent`   | これは疑似スコープです。インスタンスは共有されず、すべてのインジェクションポイントが依存Beanの新しいインスタンスを生成します。依存Beanのライフサイクルは、それを注入するBeanにバインドされています。これは、それを注入するBeanとともに作成および破棄されます。\n"
"|`@javax.enterprise.context.SessionScoped`   | このスコープは `javax.servlet.http.HttpSession` オブジェクトに支えられています。 `quarkus-undertow` エクステンションが使用されている場合のみ有効です。\n"

#. type: Plain text
#: upstream/_guides/cdi.adoc:190
msgid ""
"There can be other custom scopes provided by Quarkus extensions. For example, `quarkus-narayana-jta` provides `javax.transaction."
"TransactionScoped`."
msgstr ""
"Quarkusの拡張機能によって提供される他のカスタムスコープもあります。例えば、 `quarkus-narayana-jta` は `javax.transaction."
"TransactionScoped` を提供します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:192
#, no-wrap
msgid "_Q: I don't understand the concept of client proxies._"
msgstr "_Q: クライアントプロキシの概念がわかりません。_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:197
msgid ""
"Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp "
"but they provide some useful functionality.  A client proxy is basically an object that delegates all method invocations to a target "
"bean instance.  It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class."
msgstr ""
"実際、 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[クライアントプロキシ, window=_blank]は理解するのが難しいかも"
"しれませんが、いくつかの有用な機能を提供します。クライアントプロキシは基本的に、すべてのメソッド呼び出しをターゲットのBeanインスタンスに"
"委譲するオブジェクトです。これは `io.quarkus.arc.ClientProxy`  を実装し、Bean クラスを拡張したコンテナ構造体です。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:199
msgid ""
"Client proxies only delegate method invocations. So never read or write a field of a normal scoped bean, otherwise you will work with "
"non-contextual or stale data."
msgstr ""
"クライアントプロキシはメソッドの呼び出しをデリゲートするだけです。そのため、通常のスコープされたBeanのフィールドを読み書きしてはいけませ"
"ん。"

#. type: Block title
#: upstream/_guides/cdi.adoc:200
#, no-wrap
msgid "Generated Client Proxy Example"
msgstr "生成されたクライアントプロキシの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:205
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:213
#, no-wrap
msgid ""
"// The client proxy class is generated and looks like...\n"
"class Translator_ClientProxy extends Translator { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:221
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      // Find the correct translator instance...\n"
"      Translator translator = getTranslatorInstanceFromTheApplicationContext();\n"
"      // And delegate the method invocation...\n"
"      return translator.translate(sentence);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:223
msgid ""
"The `Translator_ClientProxy` instance is always injected instead of a direct reference to a https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#contextual_instance[contextual instance, window=\"_blank\"] of the `Translator` bean."
msgstr ""
"`Translator_ClientProxy`  インスタンスは、 `Translator`  Beanの link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#contextual_instance[コンテキストインスタンス, window=_blank]への直接参照の代わりに、常に注入されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:225
msgid "Client proxies allow for:"
msgstr "クライアントプロキシは、以下のことを可能にします。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:227
msgid "Lazy instantiation - the instance is created once a method is invoked upon the proxy."
msgstr "遅延インスタンス化 - メソッドがプロキシに呼び出されるとインスタンスが生成されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:228
msgid ""
"Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an "
"`@ApplicationScoped` bean."
msgstr ""
"「狭い」スコープのBeanを「広い」スコープのBeanに注入する機能、すなわち、 `@RequestScoped`  Beanを `@ApplicationScoped`  Beanに注入するこ"
"とができます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:229
msgid ""
"Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, "
"but sometimes it's inevitable."
msgstr ""
"依存関係グラフの円形の依存関係。循環的な依存関係を持つことは、しばしば再設計を検討すべきであることを示していますが、時には避けられないこ"
"ともあります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:230
msgid "In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance."
msgstr "まれなケースでは、手動でBeanを破棄するのが現実的です。直接参照を注入すると、古くなったBeanのインスタンスになってしまいます。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:232
#, no-wrap
msgid "_Q: OK. You said that there are several kinds of beans?_"
msgstr "_Q: なるほど、Beanは何種類かあるということですね。_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:235
msgid "A: Yes. In general, we distinguish:"
msgstr "A: はい。一般的には区別しています。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:237
msgid "Class beans"
msgstr "クラスBean"

#. type: Plain text
#: upstream/_guides/cdi.adoc:238
msgid "Producer methods"
msgstr "プロデューサーメソッド"

#. type: Plain text
#: upstream/_guides/cdi.adoc:239
msgid "Producer fields"
msgstr "プロデューサーフィールド"

#. type: Plain text
#: upstream/_guides/cdi.adoc:240
msgid "Synthetic beans"
msgstr "合成Bean"

#. type: Plain text
#: upstream/_guides/cdi.adoc:242
msgid "Synthetic beans are usually provided by extensions. Therefore, we are not going to cover them in this guide."
msgstr "合成Beanは通常、エクステンションによって提供されます。そのため、このガイドではそれらを取り上げません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:245
msgid ""
"Producer methods and fields are useful if you need additional control over instantiation of a bean.  They are also useful when "
"integrating third-party libraries where you don't control the class source and may not add additional annotations etc."
msgstr ""
"プロデューサ・メソッドとフィールドは、Beanのインスタンス化を追加で制御する必要がある場合に便利です。また、サードパーティのライブラリを統"
"合する際に、クラスソースを制御できず、追加のアノテーションなどを追加できない場合にも便利です。"

#. type: Block title
#: upstream/_guides/cdi.adoc:246
#, no-wrap
msgid "Producers Example"
msgstr "プロデューサーの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:251
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Producers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:254
#, no-wrap
msgid ""
"    @Produces <1>\n"
"    double pi = Math.PI; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:264
#, no-wrap
msgid ""
"    @Produces <3>\n"
"    List<String> names() {\n"
"       List<String> names = new ArrayList<>();\n"
"       names.add(\"Andy\");\n"
"       names.add(\"Adalbert\");\n"
"       names.add(\"Joachim\");\n"
"       return names; <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:267
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Consumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:270
#, no-wrap
msgid ""
"   @Inject\n"
"   double pi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:273
#, no-wrap
msgid ""
"   @Inject\n"
"   List<String> names;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:276
#, no-wrap
msgid ""
"   // ...   \n"
"} \n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:281
msgid ""
"The container analyses the field annotations to build a bean metadata.  The _type_ is used to build the set of bean types.  In this "
"case, it will be `double` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`."
msgstr ""
"コンテナは，フィールドアノテーションを分析して，Beanのメタデータを構築します。 _型_ は，Beanの型の集合を構築するために使用されます。この"
"場合、 `double`  と `java.lang.Object` .スコープアノテーションは宣言されていないので、デフォルトは `@Dependent` になります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:282
msgid "The container will read this field when creating the bean instance."
msgstr "コンテナは、Beanのインスタンスを作成するときにこのフィールドを読みます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:286
msgid ""
"The container analyses the method annotations to build a bean metadata.  The _return type_ is used to build the set of bean types.  In "
"this case, it will be `List<String>`, `Collection<String>`, `Iterable<String>` and `java.lang.Object`.  No scope annotation is declared "
"and so it's defaulted to `@Dependent`."
msgstr ""
"コンテナは，メソッドのアノテーションを解析して，Beanのメタデータを構築します。戻り値の _型_ は、Bean型のセットを構築するために使用されま"
"す。この場合、 `List<String>` と `Collection<String>`、 `Iterable<String>`、 `java.lang.Object` となります。スコープアノテーションは宣言"
"されていないので、デフォルトは `@Dependent`  となります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:287
msgid "The container will call this method when creating the bean instance."
msgstr "コンテナは、Beanのインスタンスを作成する際にこのメソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:291
msgid ""
"There's more about producers.  You can declare qualifiers, inject dependencies into the producer methods parameters, etc.  You can read "
"more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld docs, window="
"\"_blank\"]."
msgstr ""
"プロデューサーについては他にもあります。修飾子を宣言したり、プロデューサーメソッドのパラメータに依存性を注入したりすることができます。プ"
"ロデューサについては、例えば link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld, window=_blank] のド"
"キュメントを参照してください。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:292
#, no-wrap
msgid "_Q: OK, injection looks cool. What other services are provided?_"
msgstr "_Q: OK、インジェクションはかっこいいですね。他にはどんなサービスがありますか？_"

#. type: Title ===
#: upstream/_guides/cdi.adoc:294
#, no-wrap
msgid "Lifecycle Callbacks"
msgstr "ライフサイクルコールバック"

#. type: Plain text
#: upstream/_guides/cdi.adoc:297
msgid "A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:"
msgstr "Beanクラスは、ライフサイクル `@PostConstruct`  と `@PreDestroy`  コールバックを宣言することができます。"

#. type: Block title
#: upstream/_guides/cdi.adoc:298
#, no-wrap
msgid "Lifecycle Callbacks Example"
msgstr "ライフサイクルコールバックの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:303
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.annotation.PreDestroy;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:311
#, no-wrap
msgid ""
"    @PostConstruct <1>\n"
"    void init() {\n"
"       // ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:317
#, no-wrap
msgid ""
"    @PreDestroy <2>\n"
"    void destroy() {\n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:319
msgid "This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here."
msgstr "このコールバックは、Beanインスタンスがサービスに投入される前に呼び出されます。ここでいくつかの初期化を行うのが安全です。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:320
msgid "This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here."
msgstr "このコールバックは、Beanインスタンスが破棄される前に呼び出されます。ここでいくつかのクリーンアップタスクを実行しても安全です。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:322
msgid ""
"It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the "
"callbacks."
msgstr "コールバック内のロジックを「副作用なし」に保つこと、つまり、コールバック内で他のBeanを呼び出すことは避けるべきです。"

#. type: Title ===
#: upstream/_guides/cdi.adoc:324
#, no-wrap
msgid "Interceptors"
msgstr "インターセプター"

#. type: Plain text
#: upstream/_guides/cdi.adoc:328
msgid ""
"Interceptors are used to separate cross-cutting concerns from business logic.  There is a separate specification - Java Interceptors - "
"that defines the basic programming model and semantics."
msgstr ""
"インターセプターは、横断的な問題をビジネス・ロジックから分離するために使用されます。基本的なプログラミングモデルとセマンティクスを定義し"
"た Java Interceptors という別の仕様があります。"

#. type: Block title
#: upstream/_guides/cdi.adoc:329
#, no-wrap
msgid "Simple Interceptor Example"
msgstr "シンプルなインターセプターの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:334
#, no-wrap
msgid ""
"import javax.interceptor.Interceptor;\n"
"import javax.annotation.Priority;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:339
#, no-wrap
msgid ""
"@Logged <1>\n"
"@Priority(2020) <2>\n"
"@Interceptor <3>\n"
"public class LoggingInterceptor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:342
#, no-wrap
msgid ""
"   @Inject <4>\n"
"   Logger logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:350
#, no-wrap
msgid ""
"   @AroundInvoke <5>\n"
"   Object logInvocation(InvocationContext context) {\n"
"      // ...log before\n"
"      Object ret = context.proceed(); <6>\n"
"      // ...log after\n"
"      return ret;\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:352 upstream/_guides/cdi.adoc:388 upstream/_guides/cdi.adoc:397
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:354
msgid ""
"This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`."
msgstr ""
"これは、インターセプターをBeanにバインドするために使用されるインターセプターバインディングアノテーションです。Beanクラスに `@Logged`  を"
"アノテーションします。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:355
msgid ""
"`Priority` enables the interceptor and affects the interceptor ordering. Interceptors with smaller priority values are called first."
msgstr ""
"`Priority`  はインターセプターを有効にし、インターセプターの順序に影響を与えます。優先度の値が小さいインターセプターが最初に呼び出されま"
"す。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:356
msgid "Marks an interceptor component."
msgstr "インターセプターコンポーネントをマークします。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:357
msgid "An interceptor instance may be the target of dependency injection."
msgstr "インターセプターインスタンスは、依存性注入の対象となる場合があります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:358
msgid "`AroundInvoke` denotes a method that interposes on business methods."
msgstr "`AroundInvoke`  とは、ビジネスの方法に口出しする方法を指します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:359
msgid "Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method."
msgstr "インターセプターチェーンの次のインターセプターに進むか、インターセプターされたビジネスメソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:361
msgid ""
"Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each "
"intercepted bean."
msgstr "インターセプタのインスタンスは、インターセプトするBeanのインスタンスに依存するオブジェクトです。"

#. type: Title ===
#: upstream/_guides/cdi.adoc:362
#, no-wrap
msgid "Events and Observers"
msgstr "イベントとオブザーバー"

#. type: Plain text
#: upstream/_guides/cdi.adoc:367
msgid ""
"Beans may also produce and consume events to interact in a completely decoupled fashion.  Any Java object can serve as an event "
"payload.  The optional qualifiers act as topic selectors."
msgstr ""
"Beanは、完全に分離された方法で相互作用するために、イベントを生成したり消費したりすることもできます。任意の Java オブジェクトをイベントの"
"ペイロードとして使用できます。オプションの修飾子は、トピックセレクタとして機能します。"

#. type: Block title
#: upstream/_guides/cdi.adoc:368
#, no-wrap
msgid "Simple Event Example"
msgstr "シンプルなイベントの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:375
#, no-wrap
msgid ""
"class TaskCompleted {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:378
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class ComplicatedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:381
#, no-wrap
msgid ""
"   @Inject\n"
"   Event<TaskCompleted> event; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:386
#, no-wrap
msgid ""
"   void doSomething() {\n"
"      // ...\n"
"      event.fire(new TaskCompleted()); <2>\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:391
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class Logger {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:395
#, no-wrap
msgid ""
"   void onTaskCompleted(@Observes TaskCompleted task) { <3>\n"
"      // ...log the task\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:399
msgid "`javax.enterprise.event.Event` is used to fire events."
msgstr "`javax.enterprise.event.Event`  は、イベントの火付けに使われています。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:400
msgid "Fire the event synchronously."
msgstr "イベントを同期的に発生させます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:401
msgid "This method is notified when a `TaskCompleted` event is fired."
msgstr "このメソッドは、 `TaskCompleted`  イベントが発生したときに通知されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:403
msgid ""
"For more info about events/observers visit https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window=\"_blank"
"\"]."
msgstr ""
"イベント/オブザーバーの詳細については、 link:https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docsを, "
"window=_blank]をご覧ください。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:404
#, no-wrap
msgid "Conclusion"
msgstr "結論"

#. type: Plain text
#: upstream/_guides/cdi.adoc:411
msgid ""
"In this guide, we've covered some of the basic topics of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/"
"spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.  However, a full CDI "
"implementation is not used under the hood.  Quarkus only implements a subset of the CDI features - see also <<cdi-reference."
"adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.  On the other "
"hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,"
"Quarkus-specific APIs>>.  We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented "
"developer stacks in the future."
msgstr ""
"このガイドでは、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様"
"に基づいたQuarkusプログラミングモデルの基本的なトピックをいくつか取り上げました。ただし、CDIの完全な実装が使用されている訳ではありませ"
"ん。QuarkusはCDI link:cdi-reference.html#supported_features[機能]のサブセットのみを実装しています。一方で、 link:cdi-reference."
"html#nonstandard_features[非標準の機能]や link:cdi-reference.html#build_time_apis[Quarkus固有のAPI]もかなりの数があります。私たちの努力"
"は、将来的にビルドタイム指向の開発者スタックに向けてCDI仕様の革新を推進するものと信じています。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:413
msgid ""
"If you wish to learn more about Quarkus-specific features and limitations there is a Quarkus link:cdi-reference[CDI Reference Guide].  "
"We also recommend you to read the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDI specification] and the https://docs.jboss.org/"
"weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex "
"topics."
msgstr ""
"Quarkus固有の機能や制限について詳しく知りたい場合は、Quarkus link:cdi-reference[CDIリファレンスガイド]があります。また、 link:http://"
"docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDIの仕様]や link:https://docs.jboss.org/weld/reference/latest/en-US/html/[Weldのドキュメント]"
"（WeldはCDIリファレンスインプリメンテーションです）を読んで、より複雑なトピックに精通することをお勧めします。"
