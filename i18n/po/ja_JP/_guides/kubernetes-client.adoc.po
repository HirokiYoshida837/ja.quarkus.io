# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-12-29 14:10+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/building-my-first-extension.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Building my first extension"
msgstr "Quarkus - 私の最初の拡張機能を構築する"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:14
#, fuzzy
msgid ""
"Quarkus extensions enhance your application just as projects dependencies do."
"  The role of the extensions is to leverage Quarkus paradigms to integrate "
"seamlessly a library into Quarkus architecture - e.g. do more things at "
"build time.  This is how you can use your battle-tested ecosystem and take "
"advantage of Quarkus performance and native compilation.  Go to https://code."
"quarkus.io/[code.quarkus.io] to get the list of the supported extensions."
msgstr ""
"Quarkusの拡張機能は、プロジェクトの依存関係がそうであるように、アプリケーションを強化します。拡張機能の役割は、Quarkusのパラダイムを活用して、ライブラリをQuarkusアーキテクチャにシームレスに統合することです。このようにして、実績のあるエコシステムを利用して、Quarkusのパフォーマンスとネイティブコンパイルを活用することができます。 "
"link:https://code.quarkus.io/[code.quarkus."
"io]にアクセスして、サポートされている拡張機能のリストを入手してください。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:17
#, fuzzy
msgid ""
"In this guide we are going to develop the *Sample Greeting Extension*.  The "
"extension will expose a customizable HTTP endpoint which simply greets the "
"visitor."
msgstr ""
"このガイドでは、 *サンプルグリーティング拡張機能を*開発します。この拡張機能は、訪問者に挨拶をするだけのカスタマイズ可能な HTTP "
"エンドポイントを公開します。"

#. type: Block title
#: upstream/_guides/building-my-first-extension.adoc:19
#, no-wrap, fuzzy
msgid "Disclaimer"
msgstr "免責事項"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:23
#, fuzzy
msgid ""
"To be sure it's extra clear you don't need an extension to add a Servlet to "
"your application.  This guide is a simplified example to explain the "
"concepts of extensions development.  Keep in mind it's not representative of "
"the power of moving things to build time or simplifying the build of native "
"images."
msgstr ""
"アプリケーションにサーブレットを追加するのに拡張機能は必要ありません。このガイドは拡張機能開発の概念を説明するための簡略化された例です。ビルド時間に物を動かす力や、ネイティブイメージのビルドを単純化する力を代表するものではないことを覚えておいてください。"

#. type: Title ==
#: upstream/_guides/jms.adoc:16
#, no-wrap, fuzzy
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/jms.adoc:19
#, fuzzy
msgid "To complete this guide, you need:"
msgstr "このガイドを完成させるには、以下のものが必要です。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:17
#, fuzzy
msgid "less than 30 minutes"
msgstr "三十分以内"

#. type: Plain text
#: upstream/_guides/jms.adoc:22
#, fuzzy
msgid "an IDE"
msgstr "アイディーイーイー"

#. type: Plain text
#: upstream/_guides/jms.adoc:23
#, fuzzy
msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 1.8+ がインストールされ、 `JAVA_HOME` が適切に設定されています。"

#. type: Plain text
#: upstream/_guides/jms.adoc:24
#, fuzzy
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version} の場合"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:1350
#, no-wrap, fuzzy
msgid "Basic Concepts"
msgstr "基本概念"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:36
#, fuzzy
msgid "First things first, we will need to start with some basic concepts."
msgstr "まず最初に、いくつかの基本的な概念から始めましょう。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:38
#, fuzzy
msgid "JVM mode vs Native mode"
msgstr "JVMモードとネイティブモード"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:39
#, fuzzy
msgid ""
"Quarkus is first and foremost a Java framework, that means you can develop, "
"package and run classic JAR applications, that's what we call *JVM mode*."
msgstr "つまり、古典的な *JAR*アプリケーションを開発、パッケージ化、実行することができます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:40
#, fuzzy
msgid ""
"Thanks to https://graalvm.org/[GraalVM] you can compile your Java "
"application into machine specific code (like you do in Go or C++) and that's "
"what we call *Native mode*."
msgstr ""
"link:https://graalvm.org/[GraalVMの]おかげで、Javaアプリケーションをマシン "
"*固有*のコードにコンパイルすることができます（GoやC++のように）。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:42
#, fuzzy
msgid ""
"The operation of compiling Java bytecode into a native system-specific "
"machine code is named *Ahead of Time Compilation* (aka AoT)."
msgstr ""
"Javaバイトコードをネイティブシステム固有のマシンコードにコンパイルする操作は、 *Ahead of Time "
"Compilation*(AoT)と呼ばれています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:44
#, fuzzy
msgid "build time vs runtime in classic Java frameworks"
msgstr "古典的なJavaフレームワークにおけるビルド時間とランタイムの比較"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:45
#, fuzzy
msgid ""
"The build time corresponds to all the actions you apply to your Java source "
"files to convert them into something runnable (class files, jar/war, native "
"images)."
msgstr ""
"ビルド時間は、Javaソースファイルを実行可能なもの（クラスファイル、jar/"
"war、ネイティブイメージ）に変換するためにJavaソースファイルに適用するすべてのアクションに対応しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:46
#, fuzzy
msgid ""
"Usually this stage is composed by the compilation, annotation processing, "
"bytecode generation, etc. At this point, everything is under the developer's "
"scope and control."
msgstr ""
"通常、この段階はコンパイル、アノテーション処理、バイトコード生成などで構成されます。この時点では、すべてが開発者のスコープとコントロール下にあります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:47
#, fuzzy
msgid ""
"The runtime is all the actions that happen when you execute your application."
""
msgstr "ランタイムとは、アプリケーションを実行するときに発生するすべてのアクションのことです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:48
#, fuzzy
msgid ""
"It's obviously focused on starting your business-oriented actions but it "
"relies on a lot of technical actions like loading libraries and "
"configuration files, scanning the application's classpath, configuring the "
"dependency injection, setting up your Object-Relational Mapping, "
"instantiating your REST controllers, etc."
msgstr ""
"これは明らかにビジネス指向のアクションを開始することに焦点を当てていますが、ライブラリや設定ファイルのロード、アプリケーションのクラスパスのスキャン、依存性インジェクションの設定、オブジェクトリレーショナルマッピングの設定、RESTコントローラのインスタンス化など、多くの技術的なアクションに依存しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:50
#, fuzzy
msgid ""
"Usually, Java frameworks do their bootstrapping during the runtime before "
"actually starting the application \"Business oriented layer\". During "
"bootstrap, frameworks dynamically collect metadata by scanning the classpath "
"to find configurations, entity definitions, dependency injection binding, "
"etc. in order to instantiate proper objects through reflection. The main "
"consequences are:"
msgstr ""
"通常、Javaフレームワークは、アプリケーションの「ビジネス指向レイヤー」を実際に起動する前に、ランタイム中にブートストラップを行います。ブートストラップの間、フレームワークは、リフレクションによって適切なオブジェクトをインスタンス化するために、設定、エンティティ定義、依存性注入バインディングなどを見つけるためにクラスパスをスキャンすることによって動的にメタデータを収集します。主な結果は以下の通りです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:52
#, fuzzy
msgid ""
"Delaying the readiness of your application: you need to wait a couple of "
"seconds before actually serving a business request."
msgstr "アプリケーションの準備を遅らせる：実際にビジネスリクエストに対応する前に数秒待つ必要があります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:53
#, fuzzy
msgid ""
"Having a peak of resource consumption at bootstrap: in a constrained "
"environment, you will need to size the needed resources based on your "
"technical bootstrap needs rather than your actual business needs."
msgstr ""
"ブートストラップでリソース消費のピークを持つ：制約のある環境では、実際のビジネスニーズではなく、技術的なブートストラップのニーズに基づいて、必要なリソースのサイズを決定する必要があります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:56
#, fuzzy
msgid ""
"Quarkus' philosophy is to prevent as much as possible slow and memory "
"intensive dynamic code execution by shifting left these actions and "
"eventually do them during the build time.  A Quarkus extension is a Java "
"piece of code acting as an adapter layer for your favorite library or "
"technology."
msgstr ""
"Quarkusの哲学は、これらのアクションを左にシフトし、最終的にはビルド時に実行することで、可能な限り低速でメモリ集約的な動的コードの実行を防ぐことです。Quarkusの拡張機能は、お気に入りのライブラリやテクノロジーのアダプターレイヤーとして機能するJavaのコードです。"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:57
#, no-wrap, fuzzy
msgid "Description of a Quarkus extension"
msgstr "Quarkusの拡張機能の説明"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:60
#, fuzzy
msgid "A Quarkus extension consists of two parts:"
msgstr "Quarkusの拡張機能は、2つの部分から構成されています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:63
#, fuzzy
msgid ""
"The *runtime module* which represents the capabilities the extension "
"developer exposes to the application's developer (an authentication filter, "
"an enhanced data layer API, etc).  Runtime dependencies are the ones the "
"users will add as their application dependencies (in Maven POMs or Gradle "
"build scripts)."
msgstr ""
"拡張機能開発者がアプリケーションの開発者に公開する機能を表す "
"*ランタイムモジュール*(認証フィルタ、強化されたデータ層APIなど)。ランタイム依存関係は、ユーザーがアプリケーションの依存関係として追加するものです "
"(Maven POM または Gradle ビルドスクリプトで)。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:67
#, fuzzy
msgid ""
"The *deployment module* which is used during the augmentation phase of the "
"build, it describes how to \"deploy\" a library following the Quarkus "
"philosophy.  In other words, it applies all the Quarkus optimizations to "
"your application during the build.  The deployment module is also where we "
"prepare things for GraalVM's native compilation."
msgstr ""
"ビルドの拡張フェーズで使用される "
"*デプロイモジュール*で、Quarkusの哲学に従ったライブラリを「デプロイ」する方法を説明しています。言い換えれば、ビルド中にアプリケーションにQuarkusのすべての最適化を適用します。デプロイメントモジュールは、GraalVMのネイティブコンパイルのための準備をする場所でもあります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:70
#, fuzzy
msgid ""
"Users should not be adding the deployment modules of extension as "
"application dependencies. The deployment dependencies are resolved by "
"Quarkus during the augmentation phase from the runtime dependencies of the "
"application."
msgstr ""
"ユーザーは、拡張機能のデプロイメントモジュールをアプリケーションの依存関係として追加すべきではありません。デプロイメントの依存関係は、拡張フェーズの間にQuarkusによってアプリケーションのランタイム依存関係から解決されます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:72
#, fuzzy
msgid ""
"At this point, you should have understood that most of the magic will happen "
"at the Augmentation build time thanks to the deployment module."
msgstr "この時点で、デプロイメントモジュールのおかげで、ほとんどのマジックは拡張ビルド時に起こることを理解しているはずです。"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:73
#, no-wrap, fuzzy
msgid "Quarkus Application Bootstrap"
msgstr "Quarkusアプリケーションブートストラップ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:76
#, fuzzy
msgid "There are three distinct bootstrap phases of a Quarkus application."
msgstr "Quarkusアプリケーションには、3つの異なるブートストラップフェーズがあります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:81
#, no-wrap, fuzzy
msgid ""
"*Augmentation*. During the build time, the Quarkus extensions will load and "
"scan your application's bytecode (including the dependencies) and "
"configuration.\n"
"At this stage, the extension can read configuration files, scan classes for "
"specific annotations, etc.\n"
"Once all the metadata has been collected, the extensions can pre-process the "
"libraries bootstrap actions like your ORM, DI or REST controllers "
"configurations.\n"
"The result of the bootstrap is directly recorded into bytecode and will be "
"part of your final application package.\n"
msgstr ""
"*拡張*。ビルド時に、Quarkus拡張機能はアプリケーションのバイトコード（依存関係を含む）と設定をロードしてスキャンします。この段階で、拡張機能は設定ファイルを読み込んだり、特定のアノテーションのためにクラスをスキャンしたりすることができます。すべてのメタデータが収集されると、拡張機能は、ORM、DI、またはRESTコントローラの設定のようなライブラリのブートストラップアクションを前処理することができます。ブートストラップの結果はバイトコードに直接記録され、最終的なアプリケーションパッケージの一部となります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:84
#, no-wrap, fuzzy
msgid ""
"*Static Init*. During the run time, Quarkus will execute first a static init "
"method which contains some extensions actions/configurations.\n"
"When you will do your native packaging, this static method will be pre-"
"processed during the build time and the objects it has generated will be "
"serialized into the final native executable, so the initialization code will "
"not be executed in the native mode (imagine you execute a Fibonacci function "
"during this phase, the result of the computation will be directly recorded "
"in the native executable).\n"
"When running the application in JVM mode, this static init phase is executed "
"at the start of the application.\n"
msgstr ""
"スタティック *init*.ランタイムの間、Quarkusは最初に、いくつかの拡張アクション/"
"設定を含む静的initメソッドを実行します。ネイティブパッケージングを行う場合、このスタティックメソッドはビルド時に前処理され、生成されたオブジェクトは最終的なネイティブ実行ファイルにシリアライズされるため、初期化コードはネイティブモードでは実行されません（このフェーズでフィボナッチ関数を実行すると想像してください。JVMモードでアプリケーションを実行している場合、この静的initフェーズはアプリケーションの開始時に実行されます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:87
#, no-wrap, fuzzy
msgid ""
"*Runtime Init*. Well nothing fancy here, we do classic run time code "
"execution.\n"
"So, the more code you run during the two phases above, the faster your "
"application will start.\n"
msgstr ""
"ラン "
"*タイム*起動ここでは何も派手なことはしていませんが、古典的なランタイムコードの実行を行います。つまり、上記の2つのフェーズでより多くのコードを実行すればするほど、アプリケーションの起動が速くなります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:89
#, fuzzy
msgid "Now that everything is explained, we can start coding!"
msgstr "これで全てが説明されたので、さっそくコーディングに取り掛かりましょう"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:370
#, no-wrap, fuzzy
msgid "Maven setup"
msgstr "Mavenのセットアップ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:93
#, fuzzy
msgid ""
"Quarkus provides `create-extension` Maven Mojo to initialize your extension "
"project."
msgstr "Quarkusは、 `create-extension` Maven Mojoを提供し、拡張プロジェクトを初期化します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:114
#, no-wrap
msgid ""
"$ mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N "
"\\\n"
"    -DgroupId=org.acme \\ #<1>\n"
"    -DartifactId=quarkus-greeting \\  #<2>\n"
"    -Dversion=1.0-SNAPSHOT \\ #<3>\n"
"    -Dquarkus.nameBase=\"Greeting Extension\" #<4>\n"
"[INFO] Scanning for projects...\n"
"[INFO] \n"
"[INFO] ------------------< org.apache.maven:standalone-pom >-----------------"
"--\n"
"[INFO] Building Maven Stub Project (No POM) 1\n"
"[INFO] --------------------------------[ pom ]-------------------------------"
"--\n"
"[INFO] \n"
"[INFO] --- quarkus-maven-plugin:{quarkus-version}:create-extension (default-"
"cli) @ standalone-pom ---\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] BUILD SUCCESS\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Total time:  1.233 s\n"
"[INFO] Finished at: 2020-04-22T23:28:15+02:00\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:117
#, fuzzy
msgid "Project's groupId"
msgstr "プロジェクトのグループID"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:118
#, fuzzy
msgid ""
"artifactId for the runtime artifact of the extension (the deployment "
"artifactId will be derived from the runtime artifactId by appending `-"
"deployment`)"
msgstr ""
"拡張機能の実行時アーティファクトのartifactId (展開時アーティファクトIdは `-deployment` "
"を付加することで実行時アーティファクトIdから導出されます)"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:119
#, fuzzy
msgid "Project's version"
msgstr "プロジェクトのバージョン"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:120
#, fuzzy
msgid "Prefix for the `<name>` element values in the generated POMs"
msgstr "生成された POM の `&amp;lt;name&amp;gt;` 要素値の接頭辞"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:122
#, fuzzy
msgid ""
"Maven has generated a `quarkus-greeting` directory containing the extension "
"project which consists of the parent `pom.xml`, the `runtime` and the "
"`deployment` modules."
msgstr ""
"Maven は、親 `pom.xml` 、 `runtime` 、 `deployment` モジュールからなる拡張プロジェクトを含む `quarkus-"
"greeting` ディレクトリを生成しました。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:123
#, no-wrap, fuzzy
msgid "The parent pom.xml"
msgstr "親の pom.xml"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:126
#, fuzzy
msgid ""
"Your extension is a multi-module project. So let's start by checking out the "
"parent POM at `./quarkus-greeting/pom.xml`."
msgstr ""
"あなたの拡張モジュールはマルチモジュールプロジェクトです。ですから、まず親の POM を `./quarkus-greeting/pom.xml` "
"からチェックしてみましょう。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:134
#, no-wrap
msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://"
"maven.apache.org/xsd/maven-4.0.0.xsd\">\n"
"    <modelVersion>4.0.0</modelVersion>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:139
#, no-wrap
msgid ""
"    <groupId>org.acme</groupId>\n"
"    <artifactId>quarkus-greeting-parent</artifactId>\n"
"    <version>1.0-SNAPSHOT</version>\n"
"    <name>Greeting Extension - Parent</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:177
#, no-wrap
msgid ""
"    <packaging>pom</packaging>\n"
"    <properties>\n"
"        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n"
"        <project.reporting.outputEncoding>UTF-8</project.reporting."
"outputEncoding>\n"
"        <maven.compiler.source>1.8</maven.compiler.source>\n"
"        <maven.compiler.target>1.8</maven.compiler.target>\n"
"        <maven.compiler.parameters>true</maven.compiler.parameters>\n"
"        <quarkus.version>{quarkus-version}</quarkus.version>\n"
"        <compiler-plugin.version>3.8.1</compiler-plugin.version>\n"
"    </properties>\n"
"    <modules> #<1>\n"
"        <module>deployment</module>\n"
"        <module>runtime</module>\n"
"    </modules>\n"
"    <dependencyManagement>\n"
"        <dependencies>\n"
"            <dependency>\n"
"                <groupId>io.quarkus</groupId>\n"
"                <artifactId>quarkus-bom</artifactId> #<2>\n"
"                <version>${quarkus.version}</version>\n"
"                <type>pom</type>\n"
"                <scope>import</scope>\n"
"            </dependency>\n"
"        </dependencies>\n"
"    </dependencyManagement>\n"
"    <build>\n"
"        <pluginManagement>\n"
"            <plugins>\n"
"                <plugin>\n"
"                    <groupId>org.apache.maven.plugins</groupId>\n"
"                    <artifactId>maven-compiler-plugin</artifactId>\n"
"                    <version>${compiler-plugin.version}</version> #<3>\n"
"                </plugin>\n"
"            </plugins>\n"
"        </pluginManagement>\n"
"    </build>\n"
"</project>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:180
#, fuzzy
msgid "Your extension declares 2 sub-modules `deployment` and `runtime`."
msgstr "あなたの拡張機能は、2つのサブモジュール `deployment` と `runtime` を宣言しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:181
#, fuzzy
msgid ""
"The `quarkus-bom` aligns your dependencies with those used by Quarkus during "
"the augmentation phase."
msgstr "`quarkus-bom` は、オーグメンテーションの段階でQuarkusが使用している依存関係を調整します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:182
#, fuzzy
msgid ""
"Quarkus requires a recent version of the Maven compiler plugin supporting "
"the annotationProcessorPaths configuration."
msgstr ""
"Quarkusでは、annotationProcessorPaths設定をサポートするMavenコンパイラプラグインの最新バージョンが必要です。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:183
#, no-wrap, fuzzy
msgid "The Deployment module"
msgstr "デプロイメントモジュール"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:186
#, fuzzy
msgid ""
"Let's have a look at the deployment's `./quarkus-greeting/deployment/pom."
"xml`."
msgstr "デプロイメントの `./quarkus-greeting/deployment/pom.xml`."

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:199
#: upstream/_guides/building-my-first-extension.adoc:291
#, no-wrap
msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven."
"apache.org/xsd/maven-4.0.0.xsd\">\n"
"    <modelVersion>4.0.0</modelVersion>\n"
"    <parent>\n"
"        <groupId>org.acme</groupId>\n"
"        <artifactId>quarkus-greeting-parent</artifactId>\n"
"        <version>1.0-SNAPSHOT</version>\n"
"        <relativePath>../pom.xml</relativePath>\n"
"    </parent>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:202
#, no-wrap
msgid ""
"    <artifactId>quarkus-greeting-deployment</artifactId> <!--1-->\n"
"    <name>Greeting Extension - Deployment</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:215
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-core-deployment</artifactId> <!--2-->\n"
"            <version>${quarkus.version}</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId> <!--3-->\n"
"            <version>${project.version}</version>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:233
#, no-wrap
msgid ""
"    <build>\n"
"        <plugins>\n"
"            <plugin>\n"
"                <groupId>org.apache.maven.plugins</groupId>\n"
"                <artifactId>maven-compiler-plugin</artifactId>\n"
"                <configuration>\n"
"                    <annotationProcessorPaths>\n"
"                        <path>\n"
"                            <groupId>io.quarkus</groupId>\n"
"                            <artifactId>quarkus-extension-processor</"
"artifactId>  <!--4-->\n"
"                            <version>${quarkus.version}</version>\n"
"                        </path>\n"
"                    </annotationProcessorPaths>\n"
"                </configuration>\n"
"            </plugin>\n"
"        </plugins>\n"
"    </build>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:235
#: upstream/_guides/building-my-first-extension.adoc:575
#, no-wrap
msgid "</project>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:238
#: upstream/_guides/building-my-first-extension.adoc:336
#, fuzzy
msgid "The key points are:"
msgstr "肝心のポイントは"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:240
#, fuzzy
msgid ""
"By convention, the deployment module has the `-deployment` suffix (`greeting-"
"deployment`)."
msgstr "慣例では、配置モジュールのサフィックスは `-deployment` ( `greeting-deployment`) です。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:242
#, fuzzy
msgid ""
"The deployment module depends on the `quarkus-core-deployment` artifact.  We "
"will see later which dependencies are convenient to add."
msgstr ""
"デプロイメントモジュールは `quarkus-core-deployment` "
"アーティファクトに依存しています。どの依存関係を追加するのが便利かは後ほど見ていきます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:243
#, fuzzy
msgid "The deployment module also *must* depend on the runtime module."
msgstr "デプロイメントモジュールもランタイムモジュールに依存する *必要があります*。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:244
#: upstream/_guides/building-my-first-extension.adoc:340
#, fuzzy
msgid ""
"We add the `quarkus-extension-processor` to the compiler annotation "
"processors."
msgstr "コンパイラのアノテーションプロセッサに `quarkus-extension-processor` を追加します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:246
#, fuzzy
msgid ""
"In addition to the `pom.xml` `create-extension` also generated the `org.acme."
"quarkus.greeting.deployment.GreetingProcessor` class."
msgstr ""
"`pom.xml` `create-extension` に加えて `org.acme.quarkus.greeting.deployment."
"GreetingProcessor` クラスも生成されました。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:250
#: upstream/_guides/building-my-first-extension.adoc:403
#: upstream/_guides/building-my-first-extension.adoc:465
#: upstream/_guides/building-my-first-extension.adoc:594
#, no-wrap
msgid "package org.acme.quarkus.greeting.deployment;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:253
#: upstream/_guides/building-my-first-extension.adoc:406
#, no-wrap
msgid ""
"import io.quarkus.deployment.annotations.BuildStep;\n"
"import io.quarkus.deployment.builditem.FeatureBuildItem;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:255
#: upstream/_guides/building-my-first-extension.adoc:408
#: upstream/_guides/building-my-first-extension.adoc:472
#, no-wrap
msgid "class GreetingProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:257
#: upstream/_guides/building-my-first-extension.adoc:410
#: upstream/_guides/building-my-first-extension.adoc:474
#, no-wrap
msgid "    private static final String FEATURE = \"greeting\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:262
#: upstream/_guides/building-my-first-extension.adoc:479
#, no-wrap
msgid ""
"    @BuildStep\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(FEATURE);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:129
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:269
#, fuzzy
msgid ""
"`FeatureBuildItem` represents a functionality provided by an extension.  The "
"name of the feature gets displayed in the log during application bootstrap.  "
"An extension should provide at most one feature."
msgstr ""
"`FeatureBuildItem` "
"は拡張機能によって提供される機能を表します。機能の名前は、アプリケーションの起動時にログに表示されます。拡張機能は最大でも一つの機能を提供しなければなりません。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:273
#, fuzzy
msgid ""
"Be patient, we will explain the `Build Step Processor` concept and all the "
"extension deployment API later on.  At this point, you just need to "
"understand that this class explains to Quarkus how to deploy a feature named "
"`greeting` which is your extension.  In other words, you are augmenting your "
"application to use the `greeting` extension with all the Quarkus benefits "
"(build time optimization, native support, etc.)."
msgstr ""
"`Build Step Processor` の概念とすべての拡張機能のデプロイメント API については、後で説明します。この時点では、このクラスは、 "
"`greeting` "
"という拡張機能をデプロイする方法をQuarkusに説明していることを理解する必要があります。言い換えれば、アプリケーションを拡張して、 "
"`greeting` 拡張機能を使用して、Quarkusのすべての利点（ビルド時間の最適化、ネイティブサポートなど）を利用することになります。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:274
#, no-wrap, fuzzy
msgid "The Runtime module"
msgstr "ランタイムモジュール"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:277
#, fuzzy
msgid "Finally `./quarkus-greeting/runtime/pom.xml`."
msgstr "最後に `./quarkus-greeting/runtime/pom.xml`."

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:294
#, no-wrap
msgid ""
"    <artifactId>quarkus-greeting</artifactId>  <!--1-->\n"
"    <name>Greeting Extension - Runtime</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:297
#, no-wrap
msgid "    <dependencies>\n"
"    </dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:333
#, no-wrap
msgid ""
"    <build>\n"
"        <plugins>\n"
"            <plugin>\n"
"                <groupId>io.quarkus</groupId>\n"
"                <artifactId>quarkus-bootstrap-maven-plugin</artifactId>  <!--"
"2-->\n"
"                <version>${quarkus.version}</version>\n"
"                <executions>\n"
"                    <execution>\n"
"                        <goals>\n"
"                            <goal>extension-descriptor</goal>\n"
"                        </goals>\n"
"                        <phase>compile</phase>\n"
"                        <configuration>\n"
"                            <deployment>${project.groupId}:${project."
"artifactId}-deployment:${project.version}\n"
"                            </deployment>\n"
"                        </configuration>\n"
"                    </execution>\n"
"                </executions>\n"
"            </plugin>\n"
"            <plugin>\n"
"                <groupId>org.apache.maven.plugins</groupId>\n"
"                <artifactId>maven-compiler-plugin</artifactId>\n"
"                <configuration>\n"
"                    <annotationProcessorPaths>\n"
"                        <path>\n"
"                            <groupId>io.quarkus</groupId>\n"
"                            <artifactId>quarkus-extension-processor</"
"artifactId> <!--3-->\n"
"                            <version>${quarkus.version}</version>\n"
"                        </path>\n"
"                    </annotationProcessorPaths>\n"
"                </configuration>\n"
"            </plugin>\n"
"        </plugins>\n"
"    </build>\n"
"</project>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:338
#, fuzzy
msgid ""
"By convention, the runtime module has no suffix (`greeting`) as it is the "
"artifact exposed to the end user."
msgstr "慣習的に、ランタイムモジュールはエンドユーザーに公開される成果物であるため、サフィックス ( `greeting`) を持たない。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:339
#, fuzzy
msgid ""
"We add the `quarkus-bootstrap-maven-plugin` to generate the Quarkus "
"extension descriptor included into the runtime artifact which links it with "
"the corresponding deployment artifact."
msgstr ""
"ランタイム成果物に含まれるQuarkus拡張記述子を生成するために `quarkus-bootstrap-maven-plugin` "
"を追加し、これを対応するデプロイメント成果物とリンクさせています。"

#. type: Title ==
#: upstream/_guides/building-my-first-extension.adoc:341
#, no-wrap, fuzzy
msgid "Basic version of the Sample Greeting extension"
msgstr "サンプルグリーティング拡張機能の基本バージョン"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:343
#, no-wrap, fuzzy
msgid "Implementing the Greeting feature"
msgstr "グリーティング機能の実装"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:346
#, fuzzy
msgid ""
"The (killer) feature proposed by our extension is to greet the user.  To do "
"so, our extension will deploy, in the user application, a Servlet exposing "
"the HTTP endpoint `/greeting` which responds to the GET verb with a plain "
"text `Hello`."
msgstr ""
"私たちの拡張機能が提案する(キラー)機能は、ユーザに挨拶をすることです。 "
"`Hello`これを実現するために、我々の拡張機能はユーザアプリケーション内に、HTTP エンドポイント `/greeting` "
"を公開するサーブレットを配置します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:348
#, fuzzy
msgid ""
"The `runtime` module is where you develop the feature you want to propose to "
"your users, so it's time to create our Web Servlet."
msgstr "`runtime` モジュールは、ユーザーに提案したい機能を開発するところなので、そろそろ Web Servlet を作成しましょう。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:352
#, fuzzy
msgid ""
"To use Servlets in your applications you need to have a Servlet Container "
"such as http://undertow.io[Undertow].  Luckily, `quarkus-bom` imported by "
"our parent `pom.xml` already includes the Undertow Quarkus extension.  All "
"we need to do is add"
msgstr ""
"アプリケーションでサーブレットを使用するには、 link:http://undertow."
"io[Undertow]のようなサーブレットコンテナが必要です。 `pom.xml` 幸いにも、親である `quarkus-bom` がインポートした "
"には、すでに Undertow Quarkus 拡張機能が含まれています。必要なのは"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:360
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-undertow</artifactId>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:362
#, fuzzy
msgid "to our `./quarkus-greeting/runtime/pom.xml`."
msgstr "を `./quarkus-greeting/runtime/pom.xml` に移動します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:364
#, fuzzy
msgid ""
"Now we can create our Servlet `org.acme.quarkus.greeting.GreetingServlet` in "
"the `runtime` module."
msgstr ""
"これで、 `runtime` モジュールでサーブレット `org.acme.quarkus.greeting.GreetingServlet` "
"を作成することができるようになりました。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:367
#, no-wrap
msgid "package org.acme.quarkus.greeting;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:373
#, no-wrap
msgid ""
"import javax.servlet.annotation.WebServlet;\n"
"import javax.servlet.http.HttpServlet;\n"
"import javax.servlet.http.HttpServletRequest;\n"
"import javax.servlet.http.HttpServletResponse;\n"
"import java.io.IOException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:376
#, no-wrap
msgid "@WebServlet\n"
"public class GreetingServlet extends HttpServlet { // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:382
#, no-wrap
msgid ""
"    @Override\n"
"    protected void doGet(HttpServletRequest req, HttpServletResponse resp) "
"throws IOException { // <2>\n"
"        resp.getWriter().write(\"Hello\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:385
#, fuzzy
msgid ""
"As usual, defining a servlet requires to extend `javax.servlet.http."
"HttpServlet`."
msgstr "いつものように、サーブレットを定義するには `javax.servlet.http.HttpServlet`."

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:386
#, fuzzy
msgid ""
"Since we want to respond to the HTTP GET verb, we override the `doGet` "
"method and write `Hello` in the Servlet response's output stream."
msgstr ""
"HTTP GET動詞に応答したいので、 `doGet` メソッドをオーバーライドして、サーブレット応答の出力ストリームに `Hello` を記述します。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:387
#, no-wrap, fuzzy
msgid "Deploying the Greeting feature"
msgstr "グリーティング機能の展開"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:392
#, fuzzy
msgid ""
"Quarkus magic relies on bytecode generation at build time rather than "
"waiting for the runtime code evaluation, that's the role of your extension's "
"`deployment` module.  Calm down, we know, bytecode is hard and you don't "
"want to do it manually, Quarkus proposes a high level API to make your life "
"easier.  Thanks to basic concepts, you will describe the items to produce/"
"consume and the corresponding steps in order to generate the bytecode to "
"produce during the deployment time."
msgstr ""
"`deployment` Quarkus "
"magicは、実行時のコード評価を待つのではなく、ビルド時のバイトコード生成に依存しています。落ち着いてください。バイトコードは難しいし、手動でやりたくないことはわかっています。基本的な概念のおかげで、デプロイ時に生成するバイトコードを生成するために、生成/"
"消費するアイテムとそれに対応するステップを記述します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:394
#, fuzzy
msgid ""
"The `io.quarkus.builder.item.BuildItem` concept represents object instances "
"you will produce or consume (and at some point convert into bytecode) thanks "
"to methods annotated with `@io.quarkus.deployment.annotations.BuildStep` "
"which describe your extension's deployment tasks."
msgstr ""
"`io.quarkus.builder.item.BuildItem` の概念は、 `@io.quarkus.deployment."
"annotations.BuildStep` でアノテーションされたメソッドのおかげで、あなたが生成したり消費したり "
"(そしてある時点でバイトコードに変換したり) するオブジェクトインスタンスを表しており、拡張機能の展開タスクを記述します。"

#. type: Block title
#: upstream/_guides/building-substrate-howto.adoc:34
#, no-wrap, fuzzy
msgid "NOTE"
msgstr "ノート"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:396
#, fuzzy
msgid ""
"See link:all-builditems[the complete list of BuildItem implementations in "
"core] for more information"
msgstr "詳細は link:all-builditems[core の BuildItem 実装の完全なリストを]参照してください。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:399
#, fuzzy
msgid ""
"Go back to the generated `org.acme.quarkus.greeting.deployment."
"GreetingProcessor` class."
msgstr ""
"生成された `org.acme.quarkus.greeting.deployment.GreetingProcessor` クラスに戻ります。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:415
#, no-wrap
msgid ""
"    @BuildStep // <1>\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(FEATURE); // <2>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:422
#, fuzzy
msgid ""
"`feature()` method is annotated with `@BuildStep` which means it is "
"identified as a deployment task Quarkus will have to execute during the "
"deployment.  `BuildStep` methods are run concurrently at augmentation time "
"to augment the application.  They use a producer/consumer model, where a "
"step is guaranteed not to be run until all the items that it is consuming "
"have been produced."
msgstr ""
"`feature()` メソッドには `@BuildStep` "
"というアノテーションが付けられており、Quarkusがデプロイ時に実行しなければならないデプロイタスクとして識別されます。 `BuildStep` "
"メソッドは、アプリケーションを拡張するための拡張時に同時に実行されます。プロデューサ／消費者モデルを使用しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:425
#, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.FeatureBuildItem` is an implementation of "
"`BuildItem` which represents the description of an extension.  This "
"`BuildItem` will be used by Quarkus to display information to the users when "
"the application is starting."
msgstr ""
"`io.quarkus.deployment.builditem.FeatureBuildItem` は、拡張機能の記述を表す `BuildItem` "
"の実装です。この `BuildItem` は、アプリケーションの起動時にユーザーに情報を表示するためにQuarkusが使用します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:428
#, fuzzy
msgid ""
"There are many `BuildItem` implementations, each one represents an aspect of "
"the deployment process.  Here are some examples:"
msgstr "多くの `BuildItem` 実装があり、それぞれが展開プロセスの一面を表しています。ここではいくつかの例を紹介します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:430
#, fuzzy
msgid ""
"`ServletBuildItem`: describes a Servlet (name, path, etc.) we want to "
"generate during the deployment."
msgstr "`ServletBuildItem`: デプロイ時に生成したいサーブレット(名前、パスなど)を記述します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:431
#, fuzzy
msgid ""
"`BeanContainerBuildItem`: describes a container used to store and retrieve "
"object instances during the deployment."
msgstr ""
"`BeanContainerBuildItem`: デプロイ時にオブジェクトインスタンスを保存・取得するために使用するコンテナについて説明します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:434
#, fuzzy
msgid ""
"If you don't find a `BuildItem` for what you want to achieve, you can create "
"your own implementation. Keep in mind that a `BuildItem` should be as fine-"
"grained as possible, representing a specific part of the deployment.  To "
"create your `BuildItem` you can extend:"
msgstr ""
"実現したいことに対応する `BuildItem` が見つからない場合は、独自の実装を作成することができます。 `BuildItem` "
"は、デプロイメントの特定の部分を表すもので、できるだけ細かいものでなければならないということを覚えておいてください。 `BuildItem` "
"を作成するには"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:436
#, fuzzy
msgid ""
"`io.quarkus.builder.item.SimpleBuildItem` if you need only a single instance "
"of the item during the deployment (e.g. `BeanContainerBuildItem`, you only "
"want one container)."
msgstr ""
"`io.quarkus.builder.item.SimpleBuildItem` デプロイ時にアイテムのインスタンスを1つだけ必要とする場合(例: "
"`BeanContainerBuildItem`, コンテナを1つだけにしたい場合)。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:437
#, fuzzy
msgid ""
"`io.quarkus.builder.item.MultiBuildItem` if you want to have multiple "
"instances (e.g. `ServletBuildItem`, you can produce many Servlets during the "
"deployment)."
msgstr ""
"複数のインスタンスを持ちたい場合は `io.quarkus.builder.item.MultiBuildItem` (例: "
"`ServletBuildItem`, デプロイ時に多くのサーブレットを生成することができます)。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:440
#, fuzzy
msgid ""
"It's now time to declare our HTTP endpoint. To do so, we need to produce a "
"`ServletBuildItem`.  At this point, we are sure you understood that if the "
"`quarkus-undertow` dependency proposes Servlet support for our `runtime` "
"module, we will need the `quarkus-undertow-deployment` dependency in our "
"`deployment` module to have access to the `io.quarkus.undertow.deployment."
"ServletBuildItem`."
msgstr ""
"これで、HTTP エンドポイントを宣言する時が来ました。これを行うには、 `ServletBuildItem` を生成する必要があります。この時点で、 "
"`quarkus-undertow` 依存関係が `runtime` モジュールの Servlet サポートを提案している場合、 "
"`deployment` モジュールの `quarkus-undertow-deployment` 依存関係が `io.quarkus.undertow."
"deployment.ServletBuildItem` にアクセスできるようにする必要があることをご理解いただけたと思います。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:442
#, fuzzy
msgid "Update the `./quarkus-greeting/deployment/pom.xml` as follows:"
msgstr "`./quarkus-greeting/deployment/pom.xml` を以下のように更新します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:456
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId>\n"
"            <version>${project.version}</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-undertow-deployment</artifactId>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:459
#, fuzzy
msgid ""
"The dependency on `quarkus-core-deployment` generated by the `create-"
"extension` mojo can now be removed since `quarkus-undertow-deployment` "
"already depends on it."
msgstr ""
"`create-extension` mojo で生成された `quarkus-core-deployment` への依存は、 `quarkus-"
"undertow-deployment` が既に依存しているので、これで削除できます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:461
#, fuzzy
msgid ""
"We can now update `org.acme.quarkus.greeting.deployment.GreetingProcessor`:"
msgstr ""
"`org.acme.quarkus.greeting.deployment.GreetingProcessor` を更新できるようになりました。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:470
#, no-wrap
msgid ""
"import io.quarkus.deployment.annotations.BuildStep;\n"
"import io.quarkus.deployment.builditem.FeatureBuildItem;\n"
"import org.acme.quarkus.greeting.GreetingServlet;\n"
"import io.quarkus.undertow.deployment.ServletBuildItem;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:487
#, no-wrap
msgid ""
"    @BuildStep\n"
"    ServletBuildItem createServlet() { // <1>\n"
"      ServletBuildItem servletBuildItem = ServletBuildItem."
"builder(\"greeting\", GreetingServlet.class.getName())\n"
"        .addMapping(\"/greeting\")\n"
"        .build(); // <2>\n"
"      return servletBuildItem;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:493
#, fuzzy
msgid ""
"We add a `createServlet` method which returns a `ServletBuildItem` and "
"annotate it with `@BuildStep`.  Now, Quarkus will process this new task "
"which will result in the bytecode generation of the Servlet registration at "
"build time."
msgstr ""
"`ServletBuildItem` を返す `createServlet` メソッドを追加し、 `@BuildStep` "
"とアノテーションを付けます。これで、Quarkusはこの新しいタスクを処理して、ビルド時にサーブレット登録のバイトコードを生成します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:495
#, fuzzy
msgid ""
"`ServletBuildItem` proposes a fluent API to instantiate a Servlet named "
"`greeting` of type `GreetingServlet` (it's our class provided by our "
"extension `runtime` module), and map it the `/greeting` path."
msgstr ""
"`ServletBuildItem` は、 `GreetingServlet` 型の `greeting` というサーブレットをインスタンス化し、 `/"
"greeting` パスをマッピングするための流暢な API を提案しています (拡張モジュール `runtime` によって提供されるクラスです)。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:496
#, no-wrap, fuzzy
msgid "Testing the Greeting feature"
msgstr "グリーティング機能のテスト"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:500
#, fuzzy
msgid ""
"When developing a Quarkus extension, you mainly want to test your feature is "
"properly deployed in an application and works as expected.  That's why the "
"tests will be hosted in the `deployment` module."
msgstr ""
"Quarkus拡張機能を開発する際には、主に機能がアプリケーションに正しくデプロイされ、期待通りに動作するかどうかをテストしたいと考えています。そのため、テストは "
"`deployment` モジュールでホストされます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:502
#, fuzzy
msgid ""
"Let's add the testing dependencies into the `./quarkus-greeting/deployment/"
"pom.xml` and `maven-surefire` configuration"
msgstr ""
"`./quarkus-greeting/deployment/pom.xml` と `maven-surefire` "
"の設定にテスト用の依存関係を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:516
#, no-wrap
msgid ""
"    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven."
"apache.org/xsd/maven-4.0.0.xsd\">\n"
"    <modelVersion>4.0.0</modelVersion>\n"
"    <parent>\n"
"        <groupId>org.acme</groupId>\n"
"        <artifactId>quarkus-greeting-parent</artifactId>\n"
"        <version>1.0-SNAPSHOT</version>\n"
"        <relativePath>../pom.xml</relativePath>\n"
"    </parent>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:519
#, no-wrap
msgid ""
"    <artifactId>quarkus-greeting-deployment</artifactId>\n"
"    <name>Greeting Extension - Deployment</name>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:523
#, no-wrap
msgid ""
"    <properties>\n"
"        <maven.surefire.version>3.0.0-M4</maven.surefire.version>\n"
"    </properties>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:545
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId>\n"
"            <version>${project.version}</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-undertow-deployment</artifactId>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-junit5-internal</artifactId> <!--1-->\n"
"            <scope>test</scope>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.rest-assured</groupId>\n"
"            <artifactId>rest-assured</artifactId> <!--2-->\n"
"            <scope>test</scope>\n"
"        </dependency>\n"
"    </dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:573
#, no-wrap
msgid ""
"    <build>\n"
"        <plugins>\n"
"            <plugin>\n"
"                <groupId>org.apache.maven.plugins</groupId>\n"
"                <artifactId>maven-compiler-plugin</artifactId>\n"
"                <configuration>\n"
"                    <annotationProcessorPaths>\n"
"                        <path>\n"
"                            <groupId>io.quarkus</groupId>\n"
"                            <artifactId>quarkus-extension-processor</"
"artifactId>\n"
"                            <version>${quarkus.version}</version>\n"
"                        </path>\n"
"                    </annotationProcessorPaths>\n"
"                </configuration>\n"
"            </plugin>\n"
"            <plugin>\n"
"                <artifactId>maven-surefire-plugin</artifactId> <!--3-->\n"
"                <version>${maven.surefire.version}</version>\n"
"                <configuration>\n"
"                    <systemPropertyVariables>\n"
"                        <java.util.logging.manager>org.jboss.logmanager."
"LogManager</java.util.logging.manager>\n"
"                        <maven.home>${maven.home}</maven.home>\n"
"                    </systemPropertyVariables>\n"
"                </configuration>\n"
"            </plugin>\n"
"        </plugins>\n"
"    </build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:579
#, fuzzy
msgid ""
"Quarkus proposes facilities to test extensions via the `quarkus-junit5-"
"internal` artifact, in particular the `io.quarkus.test.QuarkusUnitTest` "
"runner which starts an application with your extension."
msgstr ""
"Quarkusは、 `quarkus-junit5-internal` "
"アーティファクトを介して拡張機能をテストするための機能、特に拡張機能を使ってアプリケーションを起動する `io.quarkus.test."
"QuarkusUnitTest` ランナーを提案しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:580
#, fuzzy
msgid ""
"We will use http://rest-assured.io[RestAssured] (massively used in Quarkus) "
"to test our HTTP endpoint."
msgstr ""
"link:http://rest-assured."
"io[RestAssured]（Quarkusで大量に使用されている）を使用してHTTPエンドポイントをテストします。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:581
#, fuzzy
msgid ""
"In order to not fallback to JUnit 4 legacy mode you need to define a recent "
"version of `maven-surefire` plugin."
msgstr ""
"JUnit 4 のレガシーモードにフォールバックしないようにするには、 `maven-surefire` "
"プラグインの最新バージョンを定義する必要があります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:583
#, fuzzy
msgid ""
"Currently, the `create-extension` Maven Mojo does not create the test "
"structure. We'll create it ourselves:"
msgstr "現在、 `create-extension` Maven Mojoはテスト構造を作成しません。自分たちで作成します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:587
#, no-wrap
msgid ""
"mkdir -p ./quarkus-greeting/deployment/src/test/java/org/acme/quarkus/"
"greeting/deployment\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:590
#, fuzzy
msgid ""
"To start testing your extension, create the following `org.acme.quarkus."
"greeting.deployment.GreetingTest` test class:"
msgstr ""
"拡張機能のテストを開始するには、次の `org.acme.quarkus.greeting.deployment.GreetingTest` "
"テストクラスを作成します。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:601
#, no-wrap
msgid ""
"import io.quarkus.test.QuarkusUnitTest;\n"
"import io.restassured.RestAssured;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:603
#, no-wrap
msgid "import static org.hamcrest.Matchers.containsString;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:605
#, no-wrap
msgid "public class GreetingTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:609
#, no-wrap
msgid ""
"  @RegisterExtension\n"
"  static final QuarkusUnitTest config = new QuarkusUnitTest()\n"
"    .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)); // "
"<1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:614
#, no-wrap
msgid ""
"  @Test\n"
"  public void testGreeting() {\n"
"    RestAssured.when().get(\"/greeting\").then().statusCode(200)."
"body(containsString(\"Hello\")); // <2>\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:619
#, fuzzy
msgid ""
"We register a Junit Extension which will start a Quarkus application with "
"the Greeting extension."
msgstr "グリーティング拡張機能でQuarkusアプリを起動するJunit拡張機能を登録しています。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:620
#, fuzzy
msgid ""
"We verify the application has a `greeting` endpoint responding to a HTTP GET "
"request with a OK status (200) and a plain text body containing `Hello`"
msgstr ""
"アプリケーションが `greeting` エンドポイントから OK ステータス (200) の HTTP GET "
"要求に応答していることと、以下の内容を含むプレーンテキストボディを持っていることを確認します。 `Hello`"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:622
#, fuzzy
msgid "Time to test!"
msgstr "テストの時間だ！"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:664
#, no-wrap
msgid ""
"$ mvn clean test\n"
"[INFO] Scanning for projects...\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Reactor Build Order:\n"
"[INFO]\n"
"[INFO] Greeting Extension - Parent                                        "
"[pom]\n"
"[INFO] Greeting Extension - Runtime                                       "
"[jar]\n"
"[INFO] Greeting Extension - Deployment                                    "
"[jar]\n"
"[INFO]\n"
"...\n"
"[INFO] --- maven-surefire-plugin:3.0.0-M4:test (default-test) @ quarkus-"
"greeting-deployment ---\n"
"[INFO] \n"
"[INFO] -------------------------------------------------------\n"
"[INFO]  T E S T S\n"
"[INFO] -------------------------------------------------------\n"
"[INFO] Running org.acme.quarkus.greeting.deployment.GreetingTest\n"
"2020-04-23 13:55:44,612 INFO  [io.quarkus] (main) Quarkus {quarkus-version} "
"started in 0.395s. Listening on: http://0.0.0.0:8081\n"
"2020-04-23 13:55:44,614 INFO  [io.quarkus] (main) Profile test activated. \n"
"2020-04-23 13:55:44,614 INFO  [io.quarkus] (main) Installed features: [cdi, "
"quarkus-greeting, servlet]\n"
"2020-04-23 13:55:45,876 INFO  [io.quarkus] (main) Quarkus stopped in 0.025s\n"
"[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.609 "
"s - in org.acme.quarkus.greeting.deployment.GreetingTest\n"
"[INFO] \n"
"[INFO] Results:\n"
"[INFO] \n"
"[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0\n"
"[INFO]\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Reactor Summary for getting-started-extension 1.0-SNAPSHOT:\n"
"[INFO]\n"
"[INFO] getting-started-extension .......................... SUCCESS [  0.076 "
"s]\n"
"[INFO] Greeting Extension - Parent ........................ SUCCESS [  0.002 "
"s]\n"
"[INFO] Greeting Extension - Runtime ....................... SUCCESS [  1.467 "
"s]\n"
"[INFO] Greeting Extension - Deployment .................... SUCCESS [  4.099 "
"s]\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] BUILD SUCCESS\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
"[INFO] Total time:  5.745 s\n"
"[INFO] Finished at: 2020-01-28T22:40:56+01:00\n"
"[INFO] ----------------------------------------------------------------------"
"--\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:667
#, fuzzy
msgid "Looks good! Congratulations you just finished your first extension."
msgstr "良さそうですね～。初めての増築を終えたばかりで、おめでとうございます。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:668
#, no-wrap, fuzzy
msgid "Debugging your extension"
msgstr "拡張機能のデバッグ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:672
#, fuzzy
msgid ""
"_If debugging is the process of removing bugs, then programming must be the "
"process of putting them in._ Edsger W. Dijkstra"
msgstr "_デバッグがバグを取り除く作業であるならば、プログラミングはバグを入れる作業でなければならない。_エドガー・W・ダイクストラ"

#. type: Title ====
#: upstream/_guides/building-my-first-extension.adoc:674
#, no-wrap, fuzzy
msgid "Debugging your application build"
msgstr "アプリケーションのビルドをデバッグする"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:678
#, fuzzy
msgid ""
"Since your extension deployment is made during the application build, this "
"process is triggered by your build tool.  That means if you want to debug "
"this phase you need to launch your build tool with the remote debug mode "
"switched one."
msgstr ""
"拡張機能のデプロイはアプリケーションのビルド中に行われるので、このプロセスはビルドツールによってトリガされます。つまり、このフェーズをデバッグしたい場合は、リモートデバッグモードを切り替えてビルドツールを起動する必要があります。"

#. type: Title =====
#: upstream/_guides/building-my-first-extension.adoc:679
#, no-wrap, fuzzy
msgid "Maven"
msgstr "メイヴン"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:683
#, fuzzy
msgid ""
"You can activate Maven remote debugging by using `mvnDebug`.  You can launch "
"your application with the following command line:"
msgstr ""
"`mvnDebug` を使用して、Maven リモートデバッグを有効にすることができます。以下のコマンドラインでアプリケーションを起動できます。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:687
#, no-wrap
msgid "mvnDebug clean compile quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:691
#, fuzzy
msgid ""
"By default, Maven will wait for a connection on `localhost:8000`.  Now, you "
"can run your IDE `Remote` configuration to attach it to `localhost:8000`."
msgstr ""
"デフォルトでは、Mavenは、 `localhost:8000` 上の接続を待ちます。今、あなたはそれをアタッチするために、IDE `Remote` "
"の設定を実行することができます `localhost:8000`."

#. type: Title =====
#: upstream/_guides/building-my-first-extension.adoc:692
#, no-wrap, fuzzy
msgid "Gradle"
msgstr "グラドル"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:696
#, fuzzy
msgid ""
"You can activate Gradle remote debugging by using the flags `org.gradle."
"debug=true` or `org.gradle.daemon.debug=true` in daemon mode.  You can "
"launch your application with the following command line:"
msgstr ""
"Gradle のリモートデバッグは、デーモンモードでフラグ `org.gradle.debug=true` または `org.gradle.daemon."
"debug=true` を使用して有効にすることができます。以下のコマンドラインでアプリケーションを起動することができます。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:700
#, no-wrap
msgid "./gradlew quarkusDev -Dorg.gradle.daemon.debug=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:704
#, fuzzy
msgid ""
"By default, Gradle will wait for a connection on `localhost:5005`.  Now, you "
"can run your IDE `Remote` configuration to attach it to `localhost:5005`."
msgstr ""
"デフォルトでは、Gradleは、 `localhost:5005` 上の接続を待ちます。今、あなたはそれを `localhost:5005` "
"にアタッチするために、あなたの IDE `Remote` の設定を実行することができます。"

#. type: Title ====
#: upstream/_guides/building-my-first-extension.adoc:706
#, no-wrap, fuzzy
msgid "Debugging your extension tests"
msgstr "拡張機能テストのデバッグ"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:710
#, fuzzy
msgid ""
"We have seen together how to test your extension and sometimes things don't "
"go so well and you want to debug your tests.  Same principle here, the trick "
"is to enable the Maven Surefire remote debugging in order to attach an IDE "
"`Remote` configuration."
msgstr ""
"拡張機能をテストする方法を一緒に見てきましたが、時にはうまくいかず、テストをデバッグしたい場合もあります。ここでも同じ原理で、IDE `Remote` "
"の設定をアタッチするために Maven Surefire リモートデバッグを有効にするのがコツです。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:715
#, no-wrap
msgid "$ cd ./greeting\n"
"$ mvn clean test -Dmaven.surefire.debug\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:718
#, fuzzy
msgid "By default, Maven will wait for a connection on `localhost:5005`."
msgstr "デフォルトでは、Maven は `localhost:5005` で接続を待ちます。"

#. type: Title ===
#: upstream/_guides/building-my-first-extension.adoc:719
#, no-wrap, fuzzy
msgid "Extension publication"
msgstr "拡張出版物"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:722
#, fuzzy
msgid ""
"Now that you just finished building your first extension you should be eager "
"to use it in a Quarkus application!"
msgstr "最初の拡張機能を構築し終えたばかりなので、Quarkusアプリケーションで使いたいと思うはずです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:724
#, no-wrap, fuzzy
msgid "*Classic Maven publication*\n"
msgstr "*古典的なメイヴンの出版*"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:727
#, fuzzy
msgid ""
"Because your extension produces traditional JARs, the easiest way to share "
"your extension is to publish it to a Maven repository.  Once published you "
"can simply declare it with your project dependencies. Let's demonstrate that "
"by creating a simple Quarkus application"
msgstr ""
"あなたの拡張機能は従来の JAR を生成するので、拡張機能を共有する最も簡単な方法は Maven "
"リポジトリに公開することです。公開したら、プロジェクトの依存関係とともに宣言するだけです。シンプルなQuarkusアプリケーションを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:735
#, no-wrap
msgid ""
"$mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"     -DprojectGroupId=org.acme \\\n"
"     -DprojectArtifactId=greeting-app \\\n"
"     -DprojectVersion=1.0-SNAPSHOT \\\n"
"     -DnoExamples\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:738
#, fuzzy
msgid ""
"`cd` into `greeting-app` and add the dependency on `quarkus-greeting` "
"extension we created above."
msgstr ""
"`cd` を `greeting-app` に入れて、上で作成した `quarkus-greeting` の拡張機能に依存関係を追加します。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:740
#, fuzzy
msgid ""
"`quarkus-greeting` extension has to be installed in the local Maven "
"repository to be usable in the application."
msgstr ""
"`quarkus-greeting` 拡張機能をアプリケーションで使用できるようにするには、ローカルの Maven "
"リポジトリにインストールする必要があります。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:754
#, no-wrap
msgid ""
"    <dependencies>\n"
"        <dependency>\n"
"            <groupId>org.acme</groupId>\n"
"            <artifactId>quarkus-greeting</artifactId>\n"
"            <version>1.0-SNAPSHOT</version>\n"
"        </dependency>\n"
"        <dependency>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-resteasy</artifactId>\n"
"        </dependency>\n"
"        <!-- the rest of the application dependencies -->\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:757
#, fuzzy
msgid ""
"Run the application and notice the `Install Features` list contains the "
"`quarkus-greeting` extension."
msgstr ""
"アプリケーションを実行して、 `Install Features` のリストに `quarkus-greeting` "
"の拡張子が含まれていることに気づきます。"

#. type: delimited block -
#: upstream/_guides/building-my-first-extension.adoc:787
#, no-wrap
msgid ""
"$ mvn clean compile quarkus:dev\n"
"[INFO] Scanning for projects...\n"
"[INFO]\n"
"[INFO] ---------------------< org.acme:code-with-quarkus >-------------------"
"--\n"
"[INFO] Building code-with-quarkus 1.0.0-SNAPSHOT\n"
"[INFO] --------------------------------[ jar ]-------------------------------"
"--\n"
"[INFO]\n"
"[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ code-with-quarkus -"
"--\n"
"[INFO] Deleting /tmp/code-with-quarkus/target\n"
"[INFO]\n"
"[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ code-"
"with-quarkus ---\n"
"[INFO] Using 'UTF-8' encoding to copy filtered resources.\n"
"[INFO] Copying 2 resources\n"
"[INFO]\n"
"[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ code-with-"
"quarkus ---\n"
"[INFO] Changes detected - recompiling the module!\n"
"[INFO] Compiling 1 source file to /tmp/code-with-quarkus/target/classes\n"
"[INFO]\n"
"[INFO] --- quarkus-maven-plugin:{quarkus-version}:dev (default-cli) @ code-"
"with-quarkus ---\n"
"Listening for transport dt_socket at address: 5005\n"
"__  ____  __  _____   ___  __ ____  ______ \n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/ \n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\   \n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/   \n"
"2020-04-23 14:17:36,137 INFO  [io.quarkus] (Quarkus Main Thread) greeting-"
"app 1.0-SNAPSHOT (powered by Quarkus {quarkus-version}) started in 0.985s. "
"Listening on: http://0.0.0.0:8080\n"
"2020-04-23 14:17:36,140 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev "
"activated. Live Coding activated.\n"
"2020-04-23 14:17:36,140 INFO  [io.quarkus] (Quarkus Main Thread) Installed "
"features: [cdi, quarkus-greeting, resteasy, servlet]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:792
#, fuzzy
msgid ""
"From an extension developer standpoint the Maven publication strategy is "
"very handy and fast but Quarkus wants to go one step further by also "
"ensuring a reliability of the ecosystem for the people who will use the "
"extensions.  Think about it, we all had a poor Developer Experience with an "
"unmaintained library, an incompatibility between dependencies (and we don't "
"even talk about legal issues).  That's why there is the Quarkus Platform."
msgstr ""
"拡張機能の開発者の立場からすると、Mavenの公開戦略は非常に便利で高速ですが、Quarkusは、拡張機能を使用する人々のためにエコシステムの信頼性も確保することで、さらに一歩進んでいきたいと考えています。考えてみてください。私たちは皆、メンテナンスされていないライブラリ、依存関係間の非互換性（法的な問題についても話しません）で、開発者の経験が乏しいことを経験しています。そのためにQuarkus "
"Platformがあるのです。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:794
#, no-wrap, fuzzy
msgid "*Quarkus Platform*\n"
msgstr "*Quarkusプラットフォーム*"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:796
#, fuzzy
msgid ""
"Quarkus proposes a `quarkus-universe-bom` which is a certified list of "
"extensions placed under the Quarkus Platform label. From an application "
"developer, the objectives of the platform are:"
msgstr ""
"Quarkusは、Quarkus Platformラベルの下に置かれた拡張機能の認定リストである `quarkus-universe-bom` "
"を提案しています。アプリケーション開発者からすると、このプラットフォームの目的は"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:798
#, fuzzy
msgid ""
"To guarantee a supportability of the extension (bugfix, security issues, "
"dependency upgrades)"
msgstr "拡張機能のサポート性を保証するために (バグフィックス、セキュリティ問題、依存関係のアップグレード)"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:799
#, fuzzy
msgid ""
"To ease the extension discovery through the Quarkus CLI or https://code."
"quarkus.io/"
msgstr "Quarkus CLIまたは https://code.quarkus.io/ を通じて拡張機能の発見を容易にするには"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:800
#, fuzzy
msgid "To ensure a global consistency of the extension ecosystem"
msgstr "拡張エコシステムのグローバルな整合性を確保するために"

#. type: Block title
#: upstream/_guides/building-my-first-extension.adoc:802
#, no-wrap, fuzzy
msgid "Should I publish my extension to the platform?"
msgstr "拡張機能をプラットフォームに公開すべきか？"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:807
#, fuzzy
msgid ""
"If you feel your extensions is for you or a limited group, simply publishing "
"to Maven is fine.  If the extension solves a general problem, it is very "
"handy for Quarkus users to see it on https://code.quarkus.io.  But this "
"comes with some responsibility for you, keeping it up to date with Quarkus "
"minor releases (every month or so at the moment).  When in doubt, have a "
"conversation with the community in the https://groups.google.com/forum/"
"#!forum/quarkus-dev[Quarkus Google Group]. We can make a collective decision."
""
msgstr ""
"拡張機能が自分や限定されたグループのためのものだと感じるのであれば、Mavenに公開するだけでも構いません。拡張機能が一般的な問題を解決する場合、Quarkusユーザーにとって、 "
"https://code.quarkus.io  "
"でそれを見ることができるのは非常に便利です。しかし、これには、Quarkusのマイナーリリース（現時点では1ヶ月に1回程度）に合わせて最新の状態に保つという、あなたの責任が伴います。疑問がある場合は、Quarkusの "
"link:https://groups.google.com/forum/#!forum/quarkus-"
"dev[Googleグループ]でコミュニティと会話をしてください。集団的な決定をすることができます。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:811
#, fuzzy
msgid ""
"As for now, the process to propose a new extension is not defined yet.  Your "
"best chance is to present your extension on the https://groups.google.com/"
"forum/#!forum/quarkus-dev[Quarkus Google Group] and wait for an official "
"invitation to join the Quarkus Platform."
msgstr ""
"今のところ、新しい拡張機能を提案するプロセスはまだ定義されていません。最良のチャンスは、 link:https://groups.google.com/"
"forum/#!forum/quarkus-dev[Quarkus Googleグループ]で拡張機能を提案し、Quarkus "
"Platformへの正式な招待状が届くのを待つことです。"

#. type: Title ==
#: upstream/_guides/vault-transit.adoc:254
#, no-wrap, fuzzy
msgid "Conclusion"
msgstr "結論"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:815
#, fuzzy
msgid ""
"Creating new extensions may appear to be an intricate task at first but once "
"you understood the Quarkus game-changer paradigm (build time vs runtime) the "
"structure of an extension makes perfectly sense."
msgstr ""
"新しい拡張機能の作成は、最初は複雑な作業に見えるかもしれませんが、Quarkusのゲームチェンジャーのパラダイム（ビルド時間とランタイム）を理解してしまえば、拡張機能の構造は完璧に理にかなったものになります。"

#. type: Plain text
#: upstream/_guides/building-my-first-extension.adoc:816
#, fuzzy
msgid ""
"As usual, along the path Quarkus simplifies things under the hood (Maven "
"Mojo, bytecode generation or testing) to make it pleasant to develop new "
"features."
msgstr ""
"いつものように、Quarkusはパスに沿って、新機能の開発を快適にするために、フードの下で物事を単純化します（Maven "
"Mojo、バイトコード生成またはテスト）。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/microprofile-graphql.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - GraphQL"
msgstr "Quarkus - GraphQL"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:12
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize the "
"**Eclipse MicroProfile GraphQL** specification through the SmallRye GraphQL "
"extension."
msgstr ""
"このガイドでは、QuarkusアプリケーションがSmallRye GraphQL拡張機能を使用して *Eclipse MicroProfile "
"GraphQL*仕様を利用する方法を説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:14
#, fuzzy
msgid "As the https://www.graphql.org/[GraphQL] specification website states:"
msgstr "link:https://www.graphql.org/[GraphQLの]仕様サイトにも記載されているように"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:20
#, fuzzy
msgid ""
"GraphQL is a query language for APIs and a runtime for fulfilling those "
"queries with your existing data.  GraphQL provides a complete and "
"understandable description of the data in your API, gives clients the power "
"to ask for exactly what they need and nothing more, makes it easier to "
"evolve APIs over time, and enables powerful developer tools."
msgstr ""
"GraphQLはAPI用のクエリ言語であり、既存のデータを使ってクエリを実行するためのランタイムです。GraphQLは、API内のデータを完全かつ理解しやすい形で記述し、クライアントが必要とするものを正確に求めることができるようにします。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:23
#, no-wrap, fuzzy
msgid ""
"**GraphQL** was originally developed by **Facebook** in 2012 and has been\n"
"an open standard since 2015.\n"
msgstr "*GraphQLは*もともと2012年に *Facebookが*開発したもので、2015年からはオープンスタンダードとなっています。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:26
#, fuzzy
msgid ""
"GraphQL is not a replacement for REST API specification but merely an "
"alternative. Unlike REST, GraphQL API's have the ability to benefit the "
"client by:"
msgstr ""
"GraphQLはREST APIの仕様を置き換えるものではなく、単なる代替品です。RESTとは異なり、GraphQL "
"APIは以下のようにクライアントに利益をもたらす機能を持っています。"

#. type: Labeled list
#: upstream/_guides/microprofile-graphql.adoc:27
#, no-wrap, fuzzy
msgid "Preventing Over-fetching and Under-fetching"
msgstr "オーバーフェッチとアンダーフェッチの防止"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:33
#, fuzzy
msgid ""
"REST API's are server-driven fixed data responses that cannot be determined "
"by the client. Although the client does not require all the fields the "
"client must retrieve all the data hence `Over-fetching`. A client may also "
"require multiple REST API calls according to the first call (HATEOAS) to "
"retrieve all the data that is required thereby `Under-fetching`."
msgstr ""
"REST API "
"は、クライアントが決定できないサーバー主導の固定データレスポンスです。クライアントはすべてのフィールドを必要としませんが、クライアントはすべてのデータを取得しなければならないため、 "
"`Over-fetching` 。クライアントはまた、必要とされるすべてのデータを取得するために、最初の呼び出し（HATEOAS）に応じて複数のREST "
"API呼び出しを必要とする場合があります。 `Under-fetching`."

#. type: Labeled list
#: upstream/_guides/microprofile-graphql.adoc:34
#, no-wrap, fuzzy
msgid "API Evolution"
msgstr "APIの進化"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:38
#, fuzzy
msgid ""
"Since GraphQL API's returns data that are requested by the client adding "
"additional fields and capabilities to existing API will not create breaking "
"changes to existing clients."
msgstr ""
"GraphQL "
"APIはクライアントから要求されたデータを返すので、既存のAPIにフィールドや機能を追加しても、既存のクライアントに大きな変更を加えることはありません。"

#. type: Plain text
#: upstream/_guides/jms.adoc:21
#, fuzzy
msgid "less than 15 minutes"
msgstr "15分以内"

#. type: Title ==
#: upstream/_guides/jms.adoc:27
#, no-wrap, fuzzy
msgid "Architecture"
msgstr "建築"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:52
#, fuzzy
msgid ""
"In this guide, we build a simple GraphQL application that exposes a GraphQL "
"API at `/graphql`."
msgstr "このガイドでは、 `/graphql` で GraphQL API を公開するシンプルな GraphQL アプリケーションを構築します。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:54
#, fuzzy
msgid "This example was inspired by a popular GraphQL API."
msgstr "この例は、人気のある GraphQL API にインスパイアされたものです。"

#. type: Title ===
#: upstream/_guides/jms.adoc:48 upstream/_guides/jms.adoc:353
#, no-wrap, fuzzy
msgid "Solution"
msgstr "解決策"

#. type: Plain text
#: upstream/_guides/jms.adoc:52
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step.  However, you can go right to the "
"completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/jms.adoc:358
#, fuzzy
msgid ""
"Clone the Git repository: `git clone {quickstarts-clone-url}`, or download "
"an {quickstarts-archive-url}[archive]."
msgstr ""
"Git リポジトリをクローンします: `git clone {quickstarts-clone-url}` 、または {quickstarts-"
"archive-url}[archive] をダウンロードしてください。"

#. type: quote
#: upstream/_guides/microprofile-graphql.adoc:63
#, fuzzy
msgid ""
"The solution is located in the `microprofile-graphql-quickstart` "
"{quickstarts-tree-url}/microprofile-graphql-quickstart[directory]."
msgstr ""
"ソリューションは `microprofile-graphql-quickstart` {quickstarts-tree-url}/"
"microprofile-graphql-quickstart[directory] にあります。"

#. type: Title ===
#: upstream/_guides/jms.adoc:60 upstream/_guides/jms.adoc:361
#, no-wrap, fuzzy
msgid "Creating the Maven Project"
msgstr "Mavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/jms.adoc:63
#, fuzzy
msgid ""
"First, we need a new project. Create a new project with the following "
"command:"
msgstr "まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:76
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=microprofile-graphql-quickstart \\\n"
"    -DclassName=\"org.acme.microprofile.graphql.FilmResource\" \\\n"
"    -Dextensions=\"graphql\"\n"
"cd microprofile-graphql-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:79
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `smallrye-graphql` "
"extension which is an implementation of the MicroProfile GraphQL "
"specification used in Quarkus."
msgstr ""
"このコマンドは、Quarkusで使用されているMicroProfile GraphQL仕様の実装である `smallrye-graphql` "
"拡張子をインポートして、Mavenプロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:82
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-graphql` extension to your project by running the following "
"command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-graphql` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:86
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"graphql\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:30
#, fuzzy
msgid "This will add the following to your `pom.xml`:"
msgstr "これにより、 `pom.xml`."

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:96
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-graphql</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:98
#, no-wrap, fuzzy
msgid "Preparing an Application: GraphQL API"
msgstr "アプリケーションの準備GraphQL API"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:101
#, fuzzy
msgid "In this section we will start creating the GraphQL API."
msgstr "このセクションでは、GraphQL APIの作成を開始します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:103
#, fuzzy
msgid ""
"First, create the following entities representing a film from a galaxy far "
"far away:"
msgstr "まず、遠く離れた銀河系の映画を表す次のような実体を作りなさい。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:107
#, no-wrap
msgid "package org.acme.microprofile.graphql;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:109
#, no-wrap
msgid "public class Film {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:114
#, no-wrap
msgid ""
"    private String title;\n"
"    private Integer episodeID;\n"
"    private String director;\n"
"    private LocalDate releaseDate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:118
#, no-wrap
msgid "    public String getTitle() {\n"
"        return title;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:122
#, no-wrap
msgid ""
"    public void setTitle(String title) {\n"
"        this.title = title;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:126
#, no-wrap
msgid "    public Integer getEpisodeID() {\n"
"        return episodeID;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:130
#, no-wrap
msgid ""
"    public void setEpisodeID(Integer episodeID) {\n"
"        this.episodeID = episodeID;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:134
#, no-wrap
msgid "    public String getDirector() {\n"
"        return director;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:138
#, no-wrap
msgid ""
"    public void setDirector(String director) {\n"
"        this.director = director;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:142
#, no-wrap
msgid ""
"    public LocalDate getReleaseDate() {\n"
"        return releaseDate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:146
#, no-wrap
msgid ""
"    public void setReleaseDate(LocalDate releaseDate) {\n"
"        this.releaseDate = releaseDate;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:150
#, no-wrap
msgid "public class Hero {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:158
#, no-wrap
msgid ""
"    private String name;\n"
"    private String surname;\n"
"    private Double height;\n"
"    private Integer mass;\n"
"    private Boolean darkSide;\n"
"    private LightSaber lightSaber;\n"
"    private List<Integer> episodeIds = new ArrayList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:152
#, no-wrap
msgid "    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:156
#, no-wrap
msgid ""
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:170
#, no-wrap
msgid "    public String getSurname() {\n"
"        return surname;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:174
#, no-wrap
msgid ""
"    public void setSurname(String surname) {\n"
"        this.surname = surname;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:178
#, no-wrap
msgid "    public Double getHeight() {\n"
"        return height;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:182
#, no-wrap
msgid ""
"    public void setHeight(Double height) {\n"
"        this.height = height;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:186
#, no-wrap
msgid "    public Integer getMass() {\n"
"        return mass;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:190
#, no-wrap
msgid ""
"    public void setMass(Integer mass) {\n"
"        this.mass = mass;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:194
#, no-wrap
msgid "    public Boolean getDarkSide() {\n"
"        return darkSide;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:198
#, no-wrap
msgid ""
"    public void setDarkSide(Boolean darkSide) {\n"
"        this.darkSide = darkSide;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:202
#, no-wrap
msgid ""
"    public LightSaber getLightSaber() {\n"
"        return lightSaber;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:206
#, no-wrap
msgid ""
"    public void setLightSaber(LightSaber lightSaber) {\n"
"        this.lightSaber = lightSaber;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:210
#, no-wrap
msgid ""
"    public List<Integer> getEpisodeIds() {\n"
"        return episodeIds;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:215
#, no-wrap
msgid ""
"    public void setEpisodeIds(List<Integer> episodeIds) {\n"
"        this.episodeIds = episodeIds;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:219
#, no-wrap
msgid "enum LightSaber {\n"
"    RED, BLUE, GREEN\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:223
#, fuzzy
msgid ""
"The classes we have just created describe the GraphQL schema which is a set "
"of possible data (objects, fields, relationships) that a client can access."
msgstr ""
"先ほど作成したクラスは、クライアントがアクセスできる可能性のあるデータ（オブジェクト、フィールド、リレーションシップ）のセットである GraphQL "
"スキーマを記述しています。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:225
#, fuzzy
msgid ""
"Let's continue with an example CDI bean, that would work as a repository:"
msgstr "リポジトリとして動作するCDIビーンの例を見てみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:230
#, no-wrap
msgid "@ApplicationScoped\n"
"public class GalaxyService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:232
#, no-wrap
msgid "    private List<Hero> heroes = new ArrayList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:234
#, no-wrap
msgid "    private List<Film> films = new ArrayList<>();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:236
#, no-wrap
msgid "    public GalaxyService() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:242
#, no-wrap
msgid ""
"        Film aNewHope = new Film();\n"
"        aNewHope.setTitle(\"A New Hope\");\n"
"        aNewHope.setReleaseDate(LocalDate.of(1977, Month.MAY, 25));\n"
"        aNewHope.setEpisodeID(4);\n"
"        aNewHope.setDirector(\"George Lucas\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:248
#, no-wrap
msgid ""
"        Film theEmpireStrikesBack = new Film();\n"
"        theEmpireStrikesBack.setTitle(\"The Empire Strikes Back\");\n"
"        theEmpireStrikesBack.setReleaseDate(LocalDate.of(1980, Month.MAY, "
"21));\n"
"        theEmpireStrikesBack.setEpisodeID(5);\n"
"        theEmpireStrikesBack.setDirector(\"George Lucas\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:254
#, no-wrap
msgid ""
"        Film returnOfTheJedi = new Film();\n"
"        returnOfTheJedi.setTitle(\"Return Of The Jedi\");\n"
"        returnOfTheJedi.setReleaseDate(LocalDate.of(1983, Month.MAY, 25));\n"
"        returnOfTheJedi.setEpisodeID(6);\n"
"        returnOfTheJedi.setDirector(\"George Lucas\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:258
#, no-wrap
msgid ""
"        films.add(aNewHope);\n"
"        films.add(theEmpireStrikesBack);\n"
"        films.add(returnOfTheJedi);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:267
#, no-wrap
msgid ""
"        Hero luke = new Hero();\n"
"        luke.setName(\"Luke\");\n"
"        luke.setSurname(\"Skywalker\");\n"
"        luke.setHeight(1.7);\n"
"        luke.setMass(73);\n"
"        luke.setLightSaber(LightSaber.GREEN);\n"
"        luke.setDarkSide(false);\n"
"        luke.getEpisodeIds().addAll(Arrays.asList(4, 5, 6));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:275
#, no-wrap
msgid ""
"        Hero leia = new Hero();\n"
"        leia.setName(\"Leia\");\n"
"        leia.setSurname(\"Organa\");\n"
"        leia.setHeight(1.5);\n"
"        leia.setMass(51);\n"
"        leia.setDarkSide(false);\n"
"        leia.getEpisodeIds().addAll(Arrays.asList(4, 5, 6));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:285
#, no-wrap
msgid ""
"        Hero vader = new Hero();\n"
"        vader.setName(\"Darth\");\n"
"        vader.setSurname(\"Vader\");\n"
"        vader.setHeight(1.9);\n"
"        vader.setMass(89);\n"
"        vader.setDarkSide(true);\n"
"        vader.setLightSaber(LightSaber.RED);\n"
"        vader.getEpisodeIds().addAll(Arrays.asList(4, 5, 6));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:289
#, no-wrap
msgid ""
"        heroes.add(luke);\n"
"        heroes.add(leia);\n"
"        heroes.add(vader);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:989
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:295
#, no-wrap
msgid "    public List<Film> getAllFilms() {\n"
"        return films;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:299
#, no-wrap
msgid "    public Film getFilm(int id) {\n"
"        return films.get(id);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:305
#, no-wrap
msgid ""
"    public List<Hero> getHeroesByFilm(Film film) {\n"
"        return heroes.stream()\n"
"                .filter(hero -> hero.getEpisodeIds().contains(film."
"getEpisodeID()))\n"
"                .collect(Collectors.toList());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:309
#, no-wrap
msgid "    public void addHero(Hero hero) {\n"
"        heroes.add(hero);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:313
#, no-wrap
msgid ""
"    public Hero deleteHero(int id) {\n"
"        return heroes.remove(id);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:320
#, no-wrap
msgid ""
"    public List<Hero> getHeroesBySurname(String surname) {\n"
"        return heroes.stream()\n"
"                .filter(hero -> hero.getSurname().equals(surname))\n"
"                .collect(Collectors.toList());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:323
#, fuzzy
msgid "Now, let's create our first GraphQL API."
msgstr "では、最初の GraphQL API を作成してみましょう。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:325
#, fuzzy
msgid ""
"Edit the `org.acme.microprofile.graphql.FilmResource` class as following:"
msgstr "`org.acme.microprofile.graphql.FilmResource` クラスを以下のように編集します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:330
#, no-wrap
msgid "@GraphQLApi // <1>\n"
"public class FilmResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:333
#, no-wrap
msgid "    @Inject\n"
"    GalaxyService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:340
#, no-wrap
msgid ""
"    @Query(\"allFilms\") // <2>\n"
"    @Description(\"Get all Films from a galaxy far far away\") // <3>\n"
"    public List<Film> getAllFilms() {\n"
"        return service.getAllFilms();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:343
#, fuzzy
msgid ""
"`@GraphQLApi` annotation indicates that the CDI bean will be a GraphQL "
"endpoint"
msgstr "`@GraphQLApi` アノテーションは、CDI BeanがGraphQLエンドポイントになることを示します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:344
#, fuzzy
msgid ""
"`@Query` annotation defines that this method will be queryable with the name "
"`allFilms`"
msgstr "`@Query` アノテーションは、このメソッドが名前を付けてクエリ可能であることを定義しています。 `allFilms`"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:345
#, fuzzy
msgid "Documentation of the queryable method"
msgstr "クエリー可能なメソッドのドキュメント"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:348
#, fuzzy
msgid ""
"The value of the `@Query` annotation is optional and would implicitly be "
"defaulted to the method name if absent."
msgstr "`@Query` アノテーションの値はオプションで、これがない場合は暗黙のうちにメソッド名がデフォルトになります。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:350
#, fuzzy
msgid ""
"This way we have created our first queryable API which we will later expand."
msgstr "このようにして、最初のクエリー可能なAPIを作成しました。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:351
#, no-wrap, fuzzy
msgid "Launch"
msgstr "打ち上げ"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:354
#, fuzzy
msgid "Launch the quarkus app:"
msgstr "quarkusアプリを起動します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:312
#, no-wrap
msgid "./mvnw compile quarkus:dev\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:359
#, no-wrap, fuzzy
msgid "Introspect"
msgstr "内観"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:362
#, fuzzy
msgid ""
"The full schema of the GraphQL API can be retrieved by calling the following:"
""
msgstr "GraphQL APIの完全なスキーマは、以下のように呼び出すことで取得できます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:366
#, no-wrap
msgid "curl http://localhost:8080/graphql/schema.graphql\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:369
#, fuzzy
msgid "The server will return the complete schema of the GraphQL API."
msgstr "サーバーはGraphQL APIの完全なスキーマを返します。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:370
#, no-wrap, fuzzy
msgid "GraphiQL UI"
msgstr "グラフィQL UI"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:336
#, fuzzy
msgid "Experimental - not included in the MicroProfile specification"
msgstr "実験 - MicroProfile仕様には含まれていません。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:375
#, fuzzy
msgid ""
"GraphiQL UI is a great tool permitting easy interaction with your GraphQL "
"APIs."
msgstr "GraphiQL UIは、GraphQL APIを簡単に操作できる素晴らしいツールです。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:378
#, fuzzy
msgid ""
"The Quarkus `smallrye-graphql` extension ships with `GraphiQL` and enables "
"it by default in `dev` and `test` modes, but it can also be explicitly "
"configured for `production` mode as well."
msgstr ""
"Quarkus `smallrye-graphql` 拡張機能は `GraphiQL` と同梱されており、デフォルトでは `dev` と `test` "
"モードで有効になっていますが、 `production` モードでも明示的に設定することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:380
#, fuzzy
msgid "GraphiQL can be accessed from http://localhost:8080/graphql-ui/ ."
msgstr "GraphiQL は http://localhost:8080/graphql-ui/ からアクセスできます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:382
#, fuzzy
msgid "image:graphql-ui-screenshot01.png[alt=GraphQL UI]"
msgstr "image:graphql-ui-screenshot01.png[alt=GraphQL UI]"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:383
#, no-wrap, fuzzy
msgid "Query the GraphQL API"
msgstr "GraphQL API に問い合わせる"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:386
#, fuzzy
msgid "Now visit the GraphiQL page that has been deployed in `dev` mode."
msgstr "ここで、 `dev` モードでデプロイされた GraphiQL のページにアクセスします。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:388
#, fuzzy
msgid "Enter the following query to GraphiQL and press the `play` button:"
msgstr "GraphiQLに以下のクエリを入力し、 `play` ボタンを押します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:399
#, no-wrap
msgid ""
"query allFilms {\n"
"  allFilms {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:405
#, fuzzy
msgid ""
"Since our query contains all the fields in the `Film` class we will retrieve "
"all the fields in our response. Since GraphQL API responses are client "
"determined, the client can choose which fields it will require."
msgstr ""
"クエリには `Film` クラスのすべてのフィールドが含まれているので、レスポンスに含まれるすべてのフィールドを取得します。GraphQL API "
"のレスポンスはクライアントが決定するので、クライアントはどのフィールドを必要とするかを選択することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:409
#, fuzzy
msgid ""
"Let's assume that our client only requires `title` and `releaseDate` making "
"the previous call to the API `Over-fetching` of unnecessary data."
msgstr ""
"私たちのクライアントは `title` と `releaseDate` のみを必要とし、API `Over-fetching` "
"への前回の呼び出しで不要なデータを作っていると仮定してみましょう。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:411
#, fuzzy
msgid "Enter the following query into GraphiQL and hit the `play` button:"
msgstr "GraphiQLに以下のクエリを入力し、 `play` ボタンを押します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:420
#, no-wrap
msgid "query allFilms {\n"
"  allFilms {\n"
"    title\n"
"    releaseDate\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:424
#, fuzzy
msgid ""
"Notice in the response we have only retrieved the required fields.  "
"Therefore, we have prevented `Over-fetching`."
msgstr "レスポンスでは、必須フィールドのみを取得していることに注意してください。そのため、 `Over-fetching`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:427
#, fuzzy
msgid ""
"Let's continue to expand our GraphQL API by adding the following to the "
"`FilmResource` class."
msgstr "引き続き、 `FilmResource` クラスに以下を追加して GraphQL API を拡張してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:435
#, no-wrap
msgid ""
"    @Query\n"
"    @Description(\"Get a Films from a galaxy far far away\")\n"
"    public Film getFilm(@Name(\"filmId\") int id) {\n"
"        return service.getFilm(id);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:440
#, fuzzy
msgid ""
"Notice how we have excluded the value in the `@Query` annotation.  "
"Therefore, the name of the query is implicitly set as the method name "
"excluding the `get`."
msgstr "`@Query` アノテーションの値を除外したことに注目してください。したがって、クエリの名前は暗黙のうちに `get`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:442
#, fuzzy
msgid "This query will allow the client to retrieve the film by id."
msgstr "このクエリは、クライアントがIDでフィルムを検索することを可能にします。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:444
#, fuzzy
msgid "Enter the following into `GraphiQL` and make a request."
msgstr "`GraphiQL` に以下を入力してリクエストしてください。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:455
#, no-wrap
msgid ""
"query getFilm {\n"
"  film(filmId: 1) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:460
#, fuzzy
msgid ""
"The `film` query method requested fields can be determined as such in our "
"previous example. This way we can retrieve individual film information."
msgstr ""
"`film` "
"クエリメソッドで要求されたフィールドは、先ほどの例のように決定することができます。このようにして、個々のフィルム情報を取得することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:464
#, fuzzy
msgid ""
"However, say our client requires both films with filmId `0` and `1`.  In a "
"REST API the client would have to make two calls to the API.  Therefore, the "
"client would be `Under-fetching`."
msgstr ""
"しかし、クライアントが filmId `0` と `1` の両方のフィルムを要求しているとします。REST "
"APIでは、クライアントはAPIへの呼び出しを2回行う必要があります。したがって、クライアントは `Under-fetching`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:466
#, fuzzy
msgid "In GraphQL it is possible to make multiple queries at once."
msgstr "GraphQLでは、一度に複数のクエリを作成することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:468
#, fuzzy
msgid "Enter the following into GraphiQL to retrieve two films:"
msgstr "GraphiQLに以下のように入力して、2つのフィルムを取得します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:485 upstream/_guides/microprofile-graphql.adoc:592
#, no-wrap
msgid ""
"query getFilms {\n"
"  film0: film(filmId: 0) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"  film1: film(filmId: 1) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:488
#, fuzzy
msgid ""
"This enabled the client to fetch the required data in a single request."
msgstr "これにより、クライアントは1回のリクエストで必要なデータを取得できるようになりました。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:489
#, no-wrap, fuzzy
msgid "Expanding the API"
msgstr "APIの拡張"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:493
#, fuzzy
msgid ""
"Until now, we have created a GraphQL API to retrieve film data.  We now want "
"to enable the clients to retrieve the `Hero` data of the `Film`."
msgstr ""
"今までは、映画のデータを取得するためのGraphQL APIを作成していました。今度はクライアントが `Hero` のデータを取得できるようにしたい "
"`Film`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:495 upstream/_guides/microprofile-graphql.adoc:601
#: upstream/_guides/microprofile-graphql.adoc:664
#, fuzzy
msgid "Add the following to our `FilmResource` class:"
msgstr "`FilmResource` クラスに以下を追加します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:501
#, no-wrap
msgid ""
"    public List<Hero> heroes(@Source Film film) { // <1>\n"
"        return service.getHeroesByFilm(film);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:504
#, fuzzy
msgid ""
"Enable `List<Hero>` data to be added to queries that respond with `Film`"
msgstr "で応答するクエリに `List&amp;lt;Hero&amp;gt;` データを追加できるようにします。 `Film`"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:508
#, fuzzy
msgid ""
"By adding this method we have effectively changed the schema of the GraphQL "
"API.  Although the schema has changed the previous queries will still work.  "
"Since we only expanded the API to be able to retrieve the `Hero` data of the "
"`Film`."
msgstr ""
"このメソッドを追加することで、実質的に GraphQL API "
"のスキーマを変更しました。スキーマが変更されても、以前のクエリはまだ動作します。私たちは、 `Hero` のデータを取得できるように API "
"を拡張しただけなので、 `Film`."

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:510
#, fuzzy
msgid "Enter the following into GraphiQL to retrieve the film and hero data."
msgstr "GraphiQLに以下のように入力して、映画やヒーローのデータを取得します。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:528
#, no-wrap
msgid ""
"query getFilmHeroes {\n"
"  film(filmId: 1) {\n"
"    title\n"
"    director\n"
"    releaseDate\n"
"    episodeID\n"
"    heroes {\n"
"      name\n"
"      height\n"
"      mass\n"
"      darkSide\n"
"      lightSaber\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:531
#, fuzzy
msgid "The response now includes the heroes of the film."
msgstr "今の反応は、この映画の主人公たちも含めて。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:532
#, no-wrap, fuzzy
msgid "Batching"
msgstr "バッチ処理"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:536
#, fuzzy
msgid ""
"When you are exposing a `Collection` return like our `getAllFilms`, you "
"might want to use the batch form of the above, to more efficiently fetch the "
"heroes:"
msgstr ""
"`getAllFilms` のように `Collection` "
"のリターンを公開している場合、より効率的にヒーローを取得するために、上記のバッチ形式を使用した方が良いかもしれません。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:542
#, no-wrap
msgid ""
"    public List<List<Hero>> heroes(@Source List<Film> films) { // <1>\n"
"        // Here fetch all hero lists\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:545
#, fuzzy
msgid ""
"Here receive the films as a batch, allowing you to fetch the corresponding "
"heroes."
msgstr "ここでは、対応するヒーローを取得することができ、バッチとしてフィルムを受信します。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:546
#, no-wrap, fuzzy
msgid "Reactive"
msgstr "反応性"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:549
#, fuzzy
msgid ""
"Queries can be made reactive by using `Uni`, or `CompletionStage` as a "
"return type, for example:"
msgstr ""
"クエリは、例えば `Uni` や `CompletionStage` をリターンタイプとして使用することで、リアクティブにすることができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:557
#, no-wrap
msgid ""
"    @Query\n"
"    @Description(\"Get a Films from a galaxy far far away\")\n"
"    public Uni<Film> getFilm(@Name(\"filmId\") int id) {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:560
#, fuzzy
msgid ""
"Due to the underlying library, graphql-java, `Uni` is creating a "
"`CompletionStage` under the hood."
msgstr ""
"基盤となるライブラリであるgraphql-javaのせいで、 `Uni` 、 `CompletionStage` 、アンダーフードを作成しています。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:562
#, fuzzy
msgid "Or you can use `CompletionStage`:"
msgstr "または、 `CompletionStage`."

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:570
#, no-wrap
msgid ""
"    @Query\n"
"    @Description(\"Get a Films from a galaxy far far away\")\n"
"    public CompletionStage<Film> getFilm(@Name(\"filmId\") int id) {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:573
#, fuzzy
msgid ""
"Using `Uni` or `CompletionStage` means that when a request contains more "
"than one query, they will be executed concurrently."
msgstr ""
"`Uni` や `CompletionStage` "
"を使うということは、リクエストに複数のクエリが含まれている場合、それらが同時に実行されることを意味します。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:575
#, fuzzy
msgid ""
"For instance, the query below will fetch `film0` and `film1` concurrently:"
msgstr "例えば、以下のクエリは `film0` と `film1` を同時に取得します。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:594
#, no-wrap, fuzzy
msgid "Mutations"
msgstr "変異"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:597
#, fuzzy
msgid "Mutations are used when data is created, updated or deleted."
msgstr "突然変異は、データの作成、更新、削除の際に使用されます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:599
#, fuzzy
msgid "Let's now add the ability to add and delete heroes to our GraphQL API."
msgstr "それでは、GraphQL APIにヒーローを追加・削除する機能を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:609
#, no-wrap
msgid ""
"    @Mutation\n"
"    public Hero createHero(Hero hero) {\n"
"        service.addHero(hero);\n"
"        return hero;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:614
#, no-wrap
msgid ""
"    @Mutation\n"
"    public Hero deleteHero(int id) {\n"
"        return service.deleteHero(id);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:617
#, fuzzy
msgid "Enter the following into `GraphiQL` to insert a `Hero`:"
msgstr "`GraphiQL` に以下のように入力すると、 `Hero`."

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:635
#, no-wrap
msgid ""
"mutation addHero {\n"
"  createHero(hero: {\n"
"      name: \"Han\",\n"
"      surname: \"Solo\"\n"
"      height: 1.85\n"
"      mass: 80\n"
"      darkSide: false\n"
"      episodeIds: [4, 5, 6]\n"
"  \t}\n"
"  )\n"
"  {\n"
"    name\n"
"    surname\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:638
#, fuzzy
msgid "By using this mutation we have created a `Hero` entity in our service."
msgstr "この突然変異を使用して、私たちのサービスに `Hero` エンティティを作成しました。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:643
#, fuzzy
msgid ""
"Notice how in the response we have retrieved the `name` and `surname` of the "
"created Hero. This is because we selected to retrieve these fields in the "
"response within the `{ }` in the mutation query.  This can easily be a "
"server side generated field that the client may require."
msgstr ""
"レスポンスでは、作成したヒーローの `name` と `surname` を取得していることに注目してください。これは、突然変異クエリの `{ }` "
"でこれらのフィールドを取得するように選択したためです。これは、クライアントが必要とするサーバー側のフィールドを簡単に生成することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:645
#, fuzzy
msgid "Let's now try deleting an entry:"
msgstr "それでは、エントリーを削除してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:653
#, no-wrap
msgid "mutation DeleteHero {\n"
"  deleteHero(id :3){\n"
"    name\n"
"    surname\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:657
#, fuzzy
msgid ""
"Similar to the `createHero` mutation method we also retrieve the `name` and "
"`surname` of the hero we have deleted which is defined in `{ }`."
msgstr "`createHero` `{ }` 突然変異法と同様に、削除したヒーローの と も取得します。 `name` `surname`"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:658
#, no-wrap, fuzzy
msgid "Creating Queries by fields"
msgstr "フィールドによるクエリの作成"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:662
#, fuzzy
msgid ""
"Queries can also be done on individual fields. For example, let's create a "
"method to query heroes by their last name."
msgstr "クエリは、個々のフィールドに対しても行うことができます。例えば、ヒーローの姓名判断でクエリを行うメソッドを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:671
#, no-wrap
msgid ""
"    @Query\n"
"    public List<Hero> getHeroesWithSurname(@DefaultValue(\"Skywalker\") "
"String surname) {\n"
"        return service.getHeroesBySurname(surname);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:675
#, fuzzy
msgid ""
"By using the `@DefaultValue` annotation we have determined that the surname "
"value will be `Skywalker` when the parameter is not provided."
msgstr ""
"`@DefaultValue` アノテーションを使用することで、パラメータが提供されていない場合、苗字の値は `Skywalker` "
"になると判断しています。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:677
#, fuzzy
msgid "Test the following queries with GraphiQL:"
msgstr "以下のクエリをGraphiQLでテストします。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:694
#, no-wrap
msgid ""
"query heroWithDefaultSurname {\n"
"  heroesWithSurname{\n"
"    name\n"
"    surname\n"
"    lightSaber\n"
"  }\n"
"}\n"
"query heroWithSurnames {\n"
"  heroesWithSurname(surname: \"Vader\") {\n"
"    name\n"
"    surname\n"
"    lightSaber\n"
"  }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:696
#, no-wrap, fuzzy
msgid "Context"
msgstr "文脈"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:699
#, fuzzy
msgid ""
"You can get information about the GraphQL request anywhere in your code, "
"using this experimental, SmallRye specific feature:"
msgstr "この実験的な SmallRye 特有の機能を使えば、コードのどこにいても GraphQL リクエストに関する情報を得ることができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:704
#, no-wrap
msgid "@Inject\n"
"Context context;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:707
#, fuzzy
msgid "The context object allows you to get:"
msgstr "コンテキストオブジェクトで取得できます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:709
#, fuzzy
msgid "the original request (Query/Mutation)"
msgstr "元のリクエスト (クエリ/ミューテーション)"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:710
#, fuzzy
msgid "the arguments"
msgstr "引数"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:711
#, fuzzy
msgid "the path"
msgstr "道筋"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:712
#, fuzzy
msgid "the selected fields"
msgstr "選択されたフィールド"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:713
#, fuzzy
msgid "any variables"
msgstr "任意の変数"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:715
#, fuzzy
msgid "This allows you to optimize the downstream queries to the datastore."
msgstr "これにより、データストアへのダウンストリームクエリを最適化することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:717
#, fuzzy
msgid ""
"See the https://javadoc.io/doc/io.smallrye/smallrye-graphql-api/latest/io/"
"smallrye/graphql/api/Context.html[JavaDoc] for more details."
msgstr ""
"詳細は link:https://javadoc.io/doc/io.smallrye/smallrye-graphql-api/latest/io/"
"smallrye/graphql/api/Context.html[JavaDoc]を参照してください。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:718
#, no-wrap, fuzzy
msgid "GraphQL-Java"
msgstr "グラフQL-Java"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:721
#, fuzzy
msgid ""
"This context object also allows you to fall down to the underlying https://"
"www.graphql-java.com/[graphql-java] features by using the leaky abstraction:"
msgstr ""
"このコンテキストオブジェクトはまた、リーキー抽象化を使用して、基礎となる link:https://www.graphql-java.com/"
"[graphql-javaの]機能にフォールダウンすることを可能にします。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:725
#, no-wrap
msgid ""
"DataFetchingEnvironment dfe = context.unwrap(DataFetchingEnvironment."
"class);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:728
#, fuzzy
msgid ""
"You can also get access to the underlying `graphql-java` during schema "
"generation, to add your own features directly:"
msgstr "また、スキーマの生成中に、スキーマの基礎となる `graphql-java` にアクセスして、独自の機能を直接追加することもできます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:732
#, no-wrap
msgid ""
"public GraphQLSchema.Builder addMyOwnEnum(@Observes GraphQLSchema.Builder "
"builder) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:739
#, no-wrap
msgid ""
"    // Here add your own features directly, example adding an Enum\n"
"    GraphQLEnumType myOwnEnum = GraphQLEnumType.newEnum()\n"
"            .name(\"SomeEnum\")\n"
"            .description(\"Adding some enum type\")\n"
"            .value(\"value1\")\n"
"            .value(\"value2\").build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:742
#, no-wrap
msgid "    return builder.additionalType(myOwnEnum);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:745
#, fuzzy
msgid "By using the `@Observer` you can add anything to the Schema builder."
msgstr "`@Observer` を使用することで、スキーマビルダーに何でも追加することができます。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:746
#, no-wrap, fuzzy
msgid "Map to Scalar"
msgstr "スカラーへの地図"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:750
#, fuzzy
msgid ""
"Another SmallRye specific experimental feature, allows you to map an "
"existing scalar (that is mapped by the implementation to a certain Java "
"type) to another type, or to map complex object, that would typically create "
"a `Type` or `Input` in GraphQL, to an existing scalar."
msgstr ""
"もう一つのSmallRye特有の実験的な機能として、既存のスカラ（実装によって特定のJava型にマップされている）を別の型にマップしたり、複雑なオブジェクトをマップしたりすることができます（通常はGraphQLで "
"`Type` や `Input` を作成します）。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:751
#, no-wrap, fuzzy
msgid "Mapping an existing Scalar to another type:"
msgstr "既存のスカラを別のタイプにマッピングします。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:756
#, no-wrap
msgid "public class Movie {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:759
#, no-wrap
msgid "    @ToScalar(Scalar.Int.class)\n"
"    Long idLongThatShouldChangeToInt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:762 upstream/_guides/microprofile-graphql.adoc:777
#, no-wrap
msgid "    // ....\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:765
#, fuzzy
msgid ""
"Above will map the `Long` java type to an `Int` Scalar type, rather than the "
"https://download.eclipse.org/microprofile/microprofile-graphql-1.0/"
"microprofile-graphql.html#scalars[default] `BigInteger`."
msgstr ""
"上記の例では、 `Long` java 型を link:https://download.eclipse.org/microprofile/"
"microprofile-graphql-1.0/microprofile-graphql.html#scalars[デフォルトの] "
"`BigInteger`.NET Framework 型ではなく `Int` Scalar 型にマップします。"

#. type: Title ===
#: upstream/_guides/microprofile-graphql.adoc:766
#, no-wrap, fuzzy
msgid "Mapping a complex object to a Scalar type:"
msgstr "複雑なオブジェクトをスカラー型にマッピングします。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:123
#, no-wrap
msgid "public class Person {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:774
#, no-wrap
msgid "    @ToScalar(Scalar.String.class)\n"
"    Phone phone;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:780
#, fuzzy
msgid ""
"This will, rather than creating a `Type` or `Input` in GraphQL, map to a "
"String scalar."
msgstr "これにより、GraphQLで `Type` や `Input` を作成するのではなく、Stringスカラーにマッピングされます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:784
#, fuzzy
msgid ""
"To be able to do the above, the `Phone` object needs to have a constructor "
"that takes a String (or `Int` / `Date` / etc.), or have a setter method for "
"the String (or `Int` / `Date` / etc.), or have a `fromString` (or `fromInt` /"
" `fromDate` - depending on the Scalar type) static method."
msgstr ""
"上記を行うためには、 `Phone` オブジェクトが String (または `Int` / `Date` / など) "
"を受け取るコンストラクタを持つか、String (または `Int` / `Date` / など) のセッターメソッドを持つか、 "
"`fromString` (または `fromInt` / `fromDate` - Scalar の型によって異なります) "
"のスタティックメソッドを持つ必要があります。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:786
#, fuzzy
msgid "For example:"
msgstr "例えば"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:790
#, no-wrap
msgid "public class Phone {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:792
#, no-wrap
msgid "    private String number;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:794
#, no-wrap
msgid "    // Getters and setters....\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:801
#, no-wrap
msgid ""
"    public static Phone fromString(String number) {\n"
"        Phone phone = new Phone();\n"
"        phone.setNumber(number);\n"
"        return phone;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:804
#, fuzzy
msgid ""
"See more about the `@ToScalar` feature in the https://javadoc.io/static/io."
"smallrye/smallrye-graphql-api/1.0.6/index.html?io/smallrye/graphql/api/"
"ToScalar.html[JavaDoc]."
msgstr ""
"link:https://javadoc.io/static/io.smallrye/smallrye-graphql-api/1.0.6/index."
"html?io/smallrye/graphql/api/ToScalar.html[JavaDoc]の「 `@ToScalar` "
"」機能については、こちらをご覧ください。"

#. type: Title ==
#: upstream/_guides/microprofile-graphql.adoc:805
#, no-wrap, fuzzy
msgid "Error code"
msgstr "エラーコード"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:808
#, fuzzy
msgid ""
"You can add an error code on the error output in the GraphQL response by "
"using the (SmallRye specific) `@ErrorCode`:"
msgstr "(SmallRye特有の) `@ErrorCode`.GraphQLレスポンスのエラー出力にエラーコードを追加することができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:815
#, no-wrap
msgid ""
"@ErrorCode(\"some-business-error-code\")\n"
"public class SomeBusinessException extends RuntimeException {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:818
#, fuzzy
msgid ""
"When `SomeBusinessException` occurs, the error output will contain the Error "
"code:"
msgstr "`SomeBusinessException` が発生した場合、エラー出力にはエラーコードが含まれます。"

#. type: delimited block -
#: upstream/_guides/microprofile-graphql.adoc:845
#, no-wrap
msgid ""
"{\n"
"    \"errors\": [\n"
"        {\n"
"            \"message\": \"Unexpected failure in the system. Jarvis is "
"working to fix it.\",\n"
"            \"locations\": [\n"
"                {\n"
"                    \"line\": 2,\n"
"                    \"column\": 3\n"
"                }\n"
"            ],\n"
"            \"path\": [\n"
"                \"annotatedCustomBusinessException\"\n"
"            ],\n"
"            \"extensions\": {\n"
"                \"exception\": \"io.smallrye.graphql.test.apps.error.api."
"ErrorApi$AnnotatedCustomBusinessException\",\n"
"                \"classification\": \"DataFetchingException\",\n"
"                \"code\": \"some-business-error-code\" <1>\n"
"            }\n"
"        }\n"
"    ],\n"
"    \"data\": {\n"
"        ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:848
#, fuzzy
msgid "The error code"
msgstr "エラーコード"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:853
#, fuzzy
msgid ""
"MicroProfile GraphQL enables clients to retrieve the exact data that is "
"required preventing `Over-fetching` and `Under-fetching`."
msgstr ""
"MicroProfile GraphQLを使用すると、クライアントは、 `Over-fetching` と `Under-fetching` "
"を防ぐために必要なデータを正確に取得することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-graphql.adoc:856
#, fuzzy
msgid ""
"The GraphQL API can be expanded without breaking previous queries enabling "
"easy API `evolution`."
msgstr ""
"GraphQL API は、以前のクエリを壊すことなく拡張することができ、簡単に API を利用することができます `evolution`."

#. type: Title ==
#: upstream/_guides/kubernetes-client.adoc:362
#, no-wrap, fuzzy
msgid "Configuration Reference"
msgstr "設定リファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/sending-emails.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Sending emails"
msgstr "Quarkus - メールの送信"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:11
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can send emails using "
"an SMTP server."
msgstr "このガイドでは、QuarkusアプリケーションがSMTPサーバーを使用して電子メールを送信する方法を説明します。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:18
#, fuzzy
msgid "The SMTP hostname, port and credentials, and an email address"
msgstr "SMTPホスト名、ポート、資格情報、および電子メール アドレス。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:22
#, fuzzy
msgid "GraalVM installed if you want to run in native mode."
msgstr "ネイティブモードで動作させたい場合は、GraalVMをインストールします。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:27
#, fuzzy
msgid ""
"In this guide, we are going to see how you can send emails from a Quarkus "
"application.  It covers simple emails, attachments, inlined attachments, the "
"reactive and imperative APIs..."
msgstr ""
"このガイドでは、Quarkusアプリケーションからメールを送信する方法を見ていきます。シンプルな電子メール、添付ファイル、インラインの添付ファイル、反応型と命令型のAPIをカバーしています。"

#. type: Plain text
#: upstream/_guides/jms.adoc:364
#, fuzzy
msgid "Create a new project with the following command:"
msgstr "以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:39
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=sending-email-quickstart \\\n"
"    -Dextensions=\"mailer\"\n"
"cd sending-email-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:41
#, fuzzy
msgid "If you already have an existing project, add the `mailer` extension:"
msgstr "既存のプロジェクトがある場合は、 `mailer` の拡張子を追加してください。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:45
#, no-wrap
msgid "./mvnw quarkus:add-extensions -Dextensions=\"mailer\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:56
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-mailer</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:47
#, no-wrap, fuzzy
msgid "Configuring the mailer"
msgstr "メーラーの設定"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:51
#, fuzzy
msgid ""
"The Quarkus mailer is using SMTP. In the `src/main/resources/application."
"properties` file, you need to configure the host, port, username, password "
"as well as the other configuration aspect.  Note that the password can also "
"be configured using system properties and environment variables."
msgstr ""
"QuarkusのメーラーはSMTPを使用しています。 `src/main/resources/application.properties` "
"ファイルでは、ホスト、ポート、ユーザー名、パスワードだけでなく、他の設定面も設定する必要があります。パスワードは、システムのプロパティや環境変数を使って設定することもできるので注意してください。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:53
#, fuzzy
msgid "Here is an example using _sendgrid_:"
msgstr "ここでは _sendgridを_使用した例を示します。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:74
#, no-wrap
msgid ""
"quarkus.mailer.from=test@quarkus.io\n"
"quarkus.mailer.host=smtp.sendgrid.net\n"
"quarkus.mailer.port=465\n"
"quarkus.mailer.ssl=true\n"
"quarkus.mailer.username=....\n"
"quarkus.mailer.password=....\n"
"quarkus.mailer.mock=false\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/mailer.adoc:82
#, fuzzy
msgid ""
"It is recommended to encrypt any sensitive data, such as the `quarkus.mailer."
"password`.  One approach is to save the value into a secure store like "
"HashiCorp Vault, and refer to it from the configuration.  Assuming for "
"instance that Vault contains key `mail-password` at path `myapps/myapp/"
"myconfig`, then the mailer extension can be simply configured as:"
msgstr ""
"`quarkus.mailer.password` "
"のようなセンシティブなデータは暗号化しておくことをお勧めします。一つの方法としては、HashiCorp Vault "
"のような安全なストアに値を保存し、設定から参照するという方法があります。例えば、Vault がパス `myapps/myapp/myconfig` "
"にキー `mail-password` を含んでいると仮定すると、メーラーの拡張子は単純に次のように設定することができます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:88
#, no-wrap
msgid ""
"...\n"
"# path within the kv secret engine where is located the application "
"sensitive configuration\n"
"quarkus.vault.secret-config-kv-path=myapps/myapp/myconfig\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:91
#, no-wrap
msgid "...\n"
"quarkus.mailer.password=${mail-password}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:94
#, fuzzy
msgid ""
"Please note that the password value is evaluated only once, at startup time. "
"If `mail-password` was changed in Vault, the only way to get the new value "
"would be to restart the application."
msgstr ""
"パスワードの値は、起動時に一度だけ評価されますのでご注意ください。Vault で `mail-password` "
"が変更された場合、新しい値を取得するにはアプリケーションを再起動するしかありません。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:66
#, fuzzy
msgid ""
"For more information about the Mailer extension configuration please refer "
"to the <<configuration-reference, Configuration Reference>>."
msgstr "メーラー拡張設定の詳細については、 link:#configuration-reference[設定リファレンスを]参照してください。"

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:67
#, no-wrap, fuzzy
msgid "Sending simple emails"
msgstr "簡単なメールの送信"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:70
#, fuzzy
msgid ""
"In a JAX-RS resource, or in a bean, you can inject the mailer as follows:"
msgstr "JAX-RSリソース内、またはビーン内では、以下のようにメーラーを注入することができます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:75
#, no-wrap
msgid "@Inject\n"
"Mailer mailer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:78
#, no-wrap
msgid "@Inject\n"
"ReactiveMailer reactiveMailer;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:81
#, fuzzy
msgid "There are 2 APIs:"
msgstr "APIは2つあります。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:83
#, fuzzy
msgid ""
"`io.quarkus.mailer.Mailer` provides the imperative (blocking and "
"synchronous) API;"
msgstr "`io.quarkus.mailer.Mailer` は、必須（ブロッキングと同期）APIを提供しています。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:116
#, fuzzy
msgid ""
"`io.quarkus.mailer.reactive.ReactiveMailer` provides the reactive (non-"
"blocking and asynchronous) API"
msgstr ""
"`io.quarkus.mailer.reactive.ReactiveMailer` は反応的な (ノンブロッキングで非同期の) API "
"を提供しています。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:86
#, fuzzy
msgid ""
"The two APIs are equivalent feature-wise. Actually the `Mailer` "
"implementation is built on top of the `ReactiveMailer` implementation."
msgstr "2つのAPIは機能的には同等です。実際には `Mailer` の実装は `ReactiveMailer` の実装の上に構築されています。"

#. type: Block title
#: upstream/_guides/amqp.adoc:345
#, no-wrap, fuzzy
msgid "Deprecation"
msgstr "非推奨"

#. type: delimited block =
#: upstream/_guides/mailer.adoc:123
#, fuzzy
msgid ""
"`io.quarkus.mailer.ReactiveMailer` is deprecated in favor of `io.quarkus."
"mailer.reactive.ReactiveMailer`."
msgstr ""
"`io.quarkus.mailer.ReactiveMailer` は `io.quarkus.mailer.reactive."
"ReactiveMailer` に代わって非推奨となりました。"

#. type: Block title
#: upstream/_guides/context-propagation.adoc:57
#, no-wrap, fuzzy
msgid "Mutiny"
msgstr "反乱"

#. type: delimited block =
#: upstream/_guides/mailer.adoc:129
#, fuzzy
msgid ""
"The reactive mailer uses Mutiny reactive types, if you're not familiar with "
"them, read the link:getting-started-reactive#mutiny[Getting Started with "
"Reactive guide] first."
msgstr ""
"リアクティブメーラーはMutiny link:getting-started-reactive#mutiny[リアクティブタイプ]を使用しています。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:88
#, fuzzy
msgid "To send a simple email, proceed as follows:"
msgstr "簡単なメールを送信するには、以下のように進めます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:139
#, no-wrap
msgid ""
"// Imperative API:\n"
"mailer.send(Mail.withText(\"to@acme.org\", \"A simple email from quarkus\", "
"\"This is my body.\"));\n"
"// Reactive API:\n"
"Uni<Void> stage = reactiveMailer.send(Mail.withText(\"to@acme.org\", \"A "
"reactive email from quarkus\", \"This is my body.\"));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:98
#, fuzzy
msgid "For example, you can use the `Mailer` in a JAX-RS endpoint as follows:"
msgstr "例えば、JAX-RS のエンドポイントで `Mailer` を使用すると、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:107
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/simple\")\n"
"public Response sendASimpleEmail() {\n"
"    mailer.send(Mail.withText(\"to@acme.org\", \"A simple email from "
"quarkus\", \"This is my body\"));\n"
"    return Response.accepted().build();\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:160
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/async\")\n"
"public CompletionStage<Response> sendASimpleEmailAsync() {\n"
"    return reactiveMailer.send(\n"
"            Mail.withText(\"to@acme.org\", \"A reactive email from "
"quarkus\", \"This is my body\"))\n"
"            .subscribeAsCompletionStage()\n"
"            .thenApply(x -> Response.accepted().build());\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/mailer.adoc:165
#, fuzzy
msgid ""
"With the `quarkus-resteasy-mutiny` extension, you can return an instance of "
"`Uni` directly."
msgstr "`quarkus-resteasy-mutiny` 拡張モジュールを使用すると、 `Uni` のインスタンスを直接返すことができます。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:118
#, fuzzy
msgid ""
"With such a JAX-RS resource, you can check that everything is working with:"
msgstr "このようなJAX-RSリソースがあれば、すべてが動作していることを確認することができます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:123
#, no-wrap
msgid "curl http://localhost:8080/simple\n"
"curl http://localhost:8080/async\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:128
#, fuzzy
msgid ""
"You can create new `io.quarkus.mailer.Mail` instances from the constructor "
"or from the `Mail.withText` and `Mail.withHtml` helper methods. The `Mail` "
"instance lets you add recipients (to, cc, or bcc), set the subject, headers, "
"sender (from) address..."
msgstr ""
"コンストラクタ、または `Mail.withText` と `Mail.withHtml` ヘルパーメソッドから、新しい `io.quarkus."
"mailer.Mail` インスタンスを作成できます。 `Mail` インスタンスでは、受信者 (to, cc, bcc) の追加、件名、ヘッダ、送信者 "
"(from) アドレスの設定などを行うことができます。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:130
#, fuzzy
msgid "You can also send several `Mail` objects in one call:"
msgstr "一度の呼び出しで複数の `Mail` オブジェクトを送信することもできます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:134
#, no-wrap
msgid "mailer.send(mail1, mail2, mail3);\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:136
#, no-wrap, fuzzy
msgid "Sending attachments"
msgstr "添付ファイルの送信"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:139
#, fuzzy
msgid ""
"To send attachment, just use the `addAttachment` methods on the `io.quarkus."
"mailer.Mail` instance:"
msgstr ""
"添付ファイルを送信するには、 `io.quarkus.mailer.Mail` インスタンスの `addAttachment` "
"メソッドを使用するだけです。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:151
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/attachment\")\n"
"public Response sendEmailWithAttachment() {\n"
"    mailer.send(Mail.withText(\"to@acme.org\", \"An email from quarkus with "
"attachment\",\n"
"            \"This is my body\")\n"
"            .addAttachment(\"my-file.txt\",\n"
"                \"content of my file\".getBytes(), \"text/plain\"));\n"
"    return Response.accepted().build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:154
#, fuzzy
msgid ""
"Attachments can be created from raw bytes (as shown in the snippet) or files."
""
msgstr "添付ファイルは、（スニペットに示すように）生のバイトから作成することも、ファイルから作成することもできます。"

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:155
#, no-wrap, fuzzy
msgid "Sending HTML emails with inlined attachments"
msgstr "インライン付きの添付ファイルでHTMLメールを送信する"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:159
#, fuzzy
msgid ""
"When sending HTML email, you can add inlined attachments.  For example, you "
"can send an image with your email, and this image will be displayed in the "
"mail content. If you put the image file into resources folder, you should "
"specify the full path to the file. \"e.g.\" \"META-INF/resources/quarkus-"
"logo.png\" otherwise quarkus will lookup in the root folder of the project"
msgstr ""
"HTMLメールを送信する際に、インラインの添付ファイルを追加することができます。例えば、メールに画像を添付して送信すると、この画像がメールの内容に表示されます。画像ファイルをリソースフォルダに入れる場合は、ファイルのフルパスを指定する必要があります。\"例\"\"META-"
"INF/resources/quarkus-logo.png\" でない場合、quarkusはプロジェクトのルートフォルダを検索します。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:174
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/html\")\n"
"public Response sendingHTML() {\n"
"    String body = \"<strong>Hello!</strong>\" + \"\\n\" +\n"
"        \"<p>Here is an image for you: <img src=\\\"cid:my-image@quarkus."
"io\\\"/></p>\" +\n"
"        \"<p>Regards</p>\";\n"
"    mailer.send(Mail.withHtml(\"to@acme.org\", \"An email in HTML\", body)\n"
"        .addInlineAttachment(\"quarkus-logo.png\",\n"
"            new File(\"quarkus-logo.png\"),\n"
"            \"image/png\", \"<my-image@quarkus.io>\"));\n"
"    return Response.accepted().build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:180
#, fuzzy
msgid ""
"Note the _content-id_ format and reference.  By spec, when you create the "
"inline attachment, the content-id must be structured as follows: "
"`<id@domain>`.  If you don't wrap your content-id between `<>`, it is "
"automatically wrapped for you.  When you want to reference your attachment, "
"for instance in the `src` attribute, use `cid:id@domain` (without the `<` "
"and `>`)."
msgstr ""
"content _-id の_形式と参照に注意してください。仕様上、インライン添付ファイルを作成する際には、content-"
"idは以下のように構成する必要があります。 `&amp;lt;id@domain&amp;gt;`. `&amp;lt;&amp;gt;` の間に "
"content-id を挟まない場合は、自動的にラップされます。添付ファイルを参照したい場合、例えば `src` 属性で参照したい場合は `cid:"
"id@domain` を使用してください（ `&amp;lt;` と `&amp;gt;` は使用しないでください）。"

#. type: Title ==
#: upstream/_guides/mailer.adoc:231
#, no-wrap, fuzzy
msgid "Message Body Based on Qute Templates"
msgstr "Quteテンプレートをベースにしたメッセージボディ"

#. type: Plain text
#: upstream/_guides/mailer.adoc:234
#, fuzzy
msgid ""
"It's also possible to inject a mail template, where the message body is "
"created automatically using link:qute[Qute templates]."
msgstr "また、 link:qute[Quteのテンプレートを]使ってメッセージ本文が自動的に作成されるメールテンプレートを注入することも可能です。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:239
#, no-wrap
msgid "@Path(\"\")\n"
"public class MailingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:244
#, no-wrap
msgid ""
"    @CheckedTemplate\n"
"    class Templates {\n"
"        public static native MailTemplateInstance hello(String name); <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:257
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/mail\")\n"
"    public CompletionStage<Response> send() {\n"
"        // the template looks like: Hello {name}! <2>\n"
"        return Templates.hello(\"John\")\n"
"           .to(\"to@acme.org\") <3>\n"
"           .subject(\"Hello from Qute template\")\n"
"           .send() <4>\n"
"           .subscribeAsCompletionStage()\n"
"           .thenApply(x -> Response.accepted().build());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:260
#, fuzzy
msgid ""
"By convention, the enclosing class name and method names are used to locate "
"the template. In this particular case, we will use the `MailingResource/"
"hello.html` and `MailingResource/hello.txt` templates to create the message "
"body."
msgstr ""
"慣例では、テンプレートの場所を特定するには、クラス名とメソッド名を囲んだ部分が使用されます。この例では、 `MailingResource/hello."
"html` および `MailingResource/hello.txt` テンプレートを使用してメッセージ本文を作成します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:261 upstream/_guides/mailer.adoc:288
#, fuzzy
msgid "Set the data used in the template."
msgstr "テンプレートで使用するデータを設定します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:262 upstream/_guides/mailer.adoc:287
#, fuzzy
msgid "Create a mail template instance and set the recipient."
msgstr "メールテンプレートのインスタンスを作成し、受信者を設定します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:263 upstream/_guides/mailer.adoc:289
#, fuzzy
msgid ""
"`MailTemplate.send()` triggers the rendering and, once finished, sends the e-"
"mail via a `Mailer` instance."
msgstr ""
"`MailTemplate.send()` はレンダリングをトリガーし、レンダリングが完了すると `Mailer` "
"インスタンスを経由して電子メールを送信します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:265 upstream/_guides/mailer.adoc:291
#, fuzzy
msgid ""
"Injected mail templates are validated during build. If there is no matching "
"template in `src/main/resources/templates` the build fails."
msgstr ""
"インジェクションされたメールテンプレートはビルド中に検証されます。 `src/main/resources/templates` "
"に一致するテンプレートがない場合、ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:267
#, fuzzy
msgid "You can also do this without type-safe templates:"
msgstr "タイプセーフのテンプレートがなくてもできます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:272
#, no-wrap
msgid "@Inject\n"
"MailTemplate hello; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:284
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/mail\")\n"
"public CompletionStage<Response> send() {\n"
"    return hello.to(\"to@acme.org\") <2>\n"
"       .subject(\"Hello from Qute template\")\n"
"       // the template looks like: Hello {name}!\n"
"       .data(\"name\", \"John\") <3>\n"
"       .send() <4>\n"
"       .subscribeAsCompletionStage()\n"
"       .thenApply(x -> Response.accepted().build());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:286
#, fuzzy
msgid ""
"If there is no `@ResourcePath` qualifier provided, the field name is used to "
"locate the template. In this particular case, we will use the `hello.html` "
"and `hello.txt` templates to create the message body."
msgstr ""
"`@ResourcePath` の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この場合、 `hello."
"html` および `hello.txt` テンプレートを使用してメッセージ本文を作成します。"

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:181
#, no-wrap, fuzzy
msgid "Testing email sending"
msgstr "メール送信のテスト"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:186
#, fuzzy
msgid ""
"Because it is very inconvenient to send emails during development and "
"testing, you can set the `quarkus.mailer.mock` boolean configuration to "
"`true` to not actually send emails but print them on stdout and collect them "
"in a `MockMailbox` bean instead.  This is the default if you are running "
"Quarkus in `DEV` or `TEST` mode."
msgstr ""
"開発中やテスト中にメールを送信するのは非常に不便なので、 `quarkus.mailer.mock` のブール設定を `true` "
"に設定して、実際にはメールを送信せずに標準出力に印刷して、代わりに `MockMailbox` ビーンに収集することができます。これは、 `DEV` "
"または `TEST` モードでQuarkusを実行している場合のデフォルトです。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:188
#, fuzzy
msgid ""
"You can then write tests to verify that your emails were sent, for example, "
"by a REST endpoint:"
msgstr "そして、テストを書いて、例えばRESTエンドポイントでメールが送信されたかどうかを確認することができます。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:193
#, no-wrap
msgid "@QuarkusTest\n"
"class MailTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:195
#, no-wrap
msgid "    private static final String TO = \"foo@quarkus.io\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:198
#, no-wrap
msgid "    @Inject\n"
"    MockMailbox mailbox;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:203
#, no-wrap
msgid "    @BeforeEach\n"
"    void init() {\n"
"        mailbox.clear();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:213
#, no-wrap
msgid ""
"    @Test\n"
"    void testTextMail() throws MessagingException, IOException {\n"
"        // call a REST endpoint that sends email\n"
"        given()\n"
"        .when()\n"
"        .get(\"/send-email\")\n"
"        .then()\n"
"           .statusCode(202)\n"
"           .body(is(\"OK\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:220
#, no-wrap
msgid ""
"        // verify that it was sent\n"
"        List<Mail> sent = mailbox.getMessagesSentTo(TO);\n"
"        assertThat(sent).hasSize(1);\n"
"        Mail actual = sent.get(0);\n"
"        assertThat(actual.getText()).contains(\"Wake up!\");\n"
"        assertThat(actual.getSubject()).isEqualTo(\"Alarm!\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:224
#, no-wrap
msgid ""
"        assertThat(mailbox.getTotalMessagesSent()).isEqualTo(6);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:226
#, no-wrap, fuzzy
msgid "Gmail specific configuration"
msgstr "Gmail特有の設定"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:229
#, fuzzy
msgid ""
"If you want to use the Gmail SMTP server, first create a dedicated password "
"in `Google Account > Security > App passwords` or go to https://myaccount."
"google.com/apppasswords."
msgstr ""
"GmailのSMTPサーバーを利用する場合は、まず、 `Google Account &amp;gt; Security &amp;gt; App "
"passwords` で専用のパスワードを作成するか、 https://myaccount.google.com/apppasswords 。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:231
#, fuzzy
msgid ""
"When done, you can configure your Quarkus application by adding the "
"following properties to your `application.properties`:"
msgstr ""
"完了したら、 `application.properties`."
"Quarkusアプリケーションに以下のプロパティを追加して、Quarkusアプリケーションを設定することができます。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:233
#, fuzzy
msgid "With TLS:"
msgstr "TLSで。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:354
#, no-wrap
msgid ""
"quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN "
"LOGIN\n"
"quarkus.mailer.from=YOUREMAIL@gmail.com\n"
"quarkus.mailer.host=smtp.gmail.com\n"
"quarkus.mailer.port=587\n"
"quarkus.mailer.start-tls=REQUIRED\n"
"quarkus.mailer.username=YOUREMAIL@gmail.com\n"
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:245
#, fuzzy
msgid "Or with SSL:"
msgstr "もしくはSSLで。"

#. type: Plain text
#: upstream/_guides/mailer.adoc:367
#, fuzzy
msgid ""
"  quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 "
"PLAIN LOGIN quarkus.mailer.from=YOUREMAIL@gmail.com quarkus.mailer.host=smtp."
"gmail.com quarkus.mailer.port=465 quarkus.mailer.ssl=true quarkus.mailer."
"username=YOUREMAIL@gmail.com quarkus.mailer.password="
"YOURGENERATEDAPPLICATIONPASSWORD"
msgstr ""
"<pre>quarkus.mailer.auth-methods=DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 "
"PLAIN LOGIN quarkus.mailer.from=YOUREMAIL@gmail.com quarkus.mailer.host=smtp."
"gmail.com quarkus.mailer.port=465 quarkus.mailer.ssl=true quarkus.mailer."
"username=YOUREMAIL@gmail.com quarkus.mailer.password="
"YOURGENERATEDAPPLICATIONPASSWORD quarkus.mailer.username=YOUREMAIL@gmail.com "
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD</pre>"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:374
#, no-wrap
msgid ""
"[NOTE]\n"
"====\n"
"The `quarkus.mailer.auth-methods` configuration option is needed for the "
"Quarkus mailer to support password authentication with Gmail.\n"
"By default both the mailer and Gmail default to `XOAUTH2` which requires "
"registering an application, getting tokens, etc.\n"
"====\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:256
#, no-wrap, fuzzy
msgid "Using SSL with native executables"
msgstr "ネイティブ実行ファイルでSSLを使用する"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:379
msgid ""
"Note that if you enable SSL for the mailer and you want to build a native "
"executable, you will need to enable the SSL support.  Please refer to the "
"link:native-and-ssl[Using SSL With Native Executables] guide for more "
"information."
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:261
#, no-wrap, fuzzy
msgid "Using the underlying Vert.x Mail Client"
msgstr "基盤となる Vert.x メールクライアントの使用"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:265
#, fuzzy
msgid ""
"The Quarkus Mailer is implemented on top of the https://vertx.io/docs/vertx-"
"mail-client/java/[Vert.x Mail Client], providing an asynchronous and non-"
"blocking way to send emails.  If you need fine control on how the mail is "
"sent, for instance if you need to retrieve the message ids, you can inject "
"the underlying client, and use it directly:"
msgstr ""
"Quarkus Mailerは、 link:https://vertx.io/docs/vertx-mail-client/java/[Vert."
"xメールクライアントの]上に実装されており、非同期でノンブロッキングな方法でメールを送信することができます。メールの送信方法を細かく制御する必要がある場合、例えばメッセージのIDを取得する必要がある場合など、基礎となるクライアントを注入して直接使用することができます。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:386
msgid "[source, java]"
msgstr ""

#. type: Plain text
#: upstream/_guides/mailer.adoc:388
#, fuzzy
msgid "@Inject MailClient client;"
msgstr "メールクライアントのクライアントをインジェクトします。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:391
#, no-wrap
msgid "Three API flavors are exposed:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:396
#, no-wrap
msgid ""
"* the Mutiny client (`io.vertx.mutiny.ext.mail.MailClient`)\n"
"* the Axle client (`io.vertx.axle.ext.mail.MailClient`), using "
"`CompletionStage` and Reactive Streams `Publisher` - deprecated, it is "
"recommended to switch to the Mutiny client\n"
"* the RX Java 2 client (`io.vertx.reactivex.ext.mail.MailClient`) - "
"deprecated, it is recommended to switch to the Mutiny client\n"
"* the bare client (`io.vertx.ext.mail.MailClient`)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:398
#, no-wrap
msgid ""
"Check the link:vertx[Using Vert.x guide] for further details about these "
"different APIs and how to select the most suitable for you.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/mailer.adoc:401
#, no-wrap
msgid ""
"The retrieved `MailClient` is configured using the configuration key "
"presented above.\n"
"You can also create your own instance, and pass your own configuration.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:286
#, fuzzy
msgid ""
"This guide has shown how you can send emails from a Quarkus application.  "
"The _mailer_ extension works in JVM and native mode."
msgstr ""
"このガイドでは、Quarkusアプリケーションからメールを送信する方法を紹介しました。 _メーラー_拡張機能は、JVMとネイティブモードで動作します。"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:409
msgid "[[configuration-reference]]"
msgstr ""

#. type: Title ==
#: upstream/_guides/sending-emails.adoc:289
#, no-wrap, fuzzy
msgid "Mailer Configuration Reference"
msgstr "メーラー設定リファレンス"

#. type: delimited block -
#: upstream/_guides/mailer.adoc:411
msgid ""
"include::{generated-dir}/config/quarkus-mailer.adoc[opts=optional, "
"leveloffset=+1]"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/infinispan-client.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Infinispan Client"
msgstr "Quarkus - Infinispanクライアント"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:12
#, fuzzy
msgid ""
"Infinispan is an in memory data grid that allows running in a server outside "
"of application processes. This extension provides functionality to allow the "
"client that can connect to said server when running in Quarkus."
msgstr ""
"Infinispanは、アプリケーションプロセス以外のサーバーでの実行を可能にするメモリ内データグリッドです。この拡張機能は、Quarkusで実行しているときに、クライアントがサーバーに接続できるようにする機能を提供します。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:15
#, fuzzy
msgid ""
"More information can be found about Infinispan at https://infinispan.org and "
"the client/server at https://infinispan.org/docs/dev/user_guide/user_guide."
"html#client_server"
msgstr ""
"Infinispan についての詳細は https://infinispan.org に、クライアント/サーバーについては https://"
"infinispan.org/docs/dev/user_guide/user_guide.html#client_server に記載されています。"

#. type: Title ==
#: upstream/_guides/kubernetes-client.adoc:19
#, no-wrap, fuzzy
msgid "Configuration"
msgstr "構成"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:20
#, fuzzy
msgid ""
"Once you have your Quarkus project configured you can add the `infinispan-"
"client` extension to your project by running the following from the command "
"line in your project base directory."
msgstr ""
"Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリのコマンドラインから以下を実行して、 `infinispan-client` "
"拡張機能をプロジェクトに追加することができます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:24
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"infinispan-client\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:27
#, fuzzy
msgid "This will add the following to your pom.xml"
msgstr "これにより、以下が pom.xml に追加されます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:34
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-infinispan-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:39
#, fuzzy
msgid ""
"The Infinispan client is configurable in the `application.properties` file "
"that can be provided in the `src/main/resources` directory. These are the "
"properties that can be configured in this file:"
msgstr ""
"Infinispan クライアントは、 `src/main/resources` ディレクトリで提供される `application."
"properties` ファイルで設定できます。このファイルで設定できるプロパティは以下の通りです。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:45
#, fuzzy
msgid ""
"It is also possible to configure a `hotrod-client.properties` as described "
"in the Infinispan user guide. Note that the `hotrod-client.properties` "
"values overwrite any matching property from the other configuration values "
"(eg. near cache).  This properties file is build time only and if it is "
"changed, requires a full rebuild."
msgstr ""
"Infinispan ユーザーガイドに記載されているように `hotrod-client.properties` を設定することも可能です。 "
"`hotrod-client.properties` "
"の値は、他の設定値（例：ニアキャッシュ）から一致するプロパティを上書きすることに注意してください。このプロパティファイルはビルド時のみのもので、変更された場合は完全に再構築する必要があります。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:46
#, no-wrap, fuzzy
msgid "Serialization (Key Value types support)"
msgstr "連載（キーバリュー型のサポート"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:51
#, fuzzy
msgid ""
"By default the client will support keys and values of the following types: "
"byte[], primitive wrappers (eg. Integer, Long, Double etc.), String, Date "
"and Instant. User types require some additional steps that are detailed here."
" Let's say we have the following user classes:"
msgstr ""
"デフォルトでは、クライアントは以下の型のキーと値をサポートします: byte[]、プリミティブラッパー(例: "
"Integer、Long、Doubleなど)、String、Date、Instant。ユーザー型については、ここで詳しく説明している追加のステップが必要です。以下のようなユーザクラスがあるとします。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:52
#: upstream/_guides/infinispan-client.adoc:96
#, no-wrap, fuzzy
msgid "Author.java"
msgstr "作成者.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:58
#, no-wrap
msgid ""
"public class Author {\n"
"   private final String name;\n"
"   private final String surname;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:65
#, no-wrap
msgid ""
"   public Author(String name, String surname) {\n"
"      this.name = Objects.requireNonNull(name);\n"
"      this.surname = Objects.requireNonNull(surname);\n"
"   }\n"
"   // Getter/Setter/equals/hashCode/toString omitted\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:67
#: upstream/_guides/infinispan-client.adoc:116
#, no-wrap, fuzzy
msgid "Book.java"
msgstr "Book.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:75
#, no-wrap
msgid ""
"public class Book {\n"
"   private final String title;\n"
"   private final String description;\n"
"   private final int publicationYear;\n"
"   private final Set<Author> authors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:84
#, no-wrap
msgid ""
"   public Book(String title, String description, int publicationYear, "
"Set<Author> authors) {\n"
"      this.title = Objects.requireNonNull(title);\n"
"      this.description = Objects.requireNonNull(description);\n"
"      this.publicationYear = publicationYear;\n"
"      this.authors = Objects.requireNonNull(authors);\n"
"   }\n"
"   // Getter/Setter/equals/hashCode/toString omitted\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:87
#, fuzzy
msgid ""
"Serialization of user types uses a library based on protobuf, called "
"Protostream."
msgstr "ユーザータイプのシリアライズは、Protostreamと呼ばれるprotobufをベースにしたライブラリを使用します。"

#. type: Title ===
#: upstream/_guides/infinispan-client.adoc:88
#, no-wrap, fuzzy
msgid "Annotation based Serialization"
msgstr "アノテーションに基づくシリアライゼーション"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:93
#, fuzzy
msgid ""
"This can be done automatically by adding protostream annotations to your "
"user classes.  In addition a single Initializer annotated interface is "
"required which controls how the supporting classes are generated."
msgstr ""
"これは、ユーザクラスに protostream "
"アノテーションを追加することで自動的に行うことができます。さらに、サポートするクラスがどのように生成されるかを制御するために、単一の "
"Initializer アノテーションされたインターフェイスが必要です。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:95
#, fuzzy
msgid "Here is an example of how the preceding classes should be changed:"
msgstr "ここでは、先行するクラスをどのように変更するかの例を示します。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:104
#, no-wrap
msgid ""
"    @ProtoFactory\n"
"    public Author(String name, String surname) {\n"
"        this.name = Objects.requireNonNull(name);\n"
"        this.surname = Objects.requireNonNull(surname);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:109
#, no-wrap
msgid ""
"    @ProtoField(number = 1)\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:114
#, no-wrap
msgid ""
"    @ProtoField(number = 2)\n"
"    public String getSurname() {\n"
"        return surname;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:126
#, no-wrap
msgid ""
"    @ProtoFactory\n"
"    public Book(String title, String description, int publicationYear, "
"Set<Author> authors) {\n"
"        this.title = Objects.requireNonNull(title);\n"
"        this.description = Objects.requireNonNull(description);\n"
"        this.publicationYear = publicationYear;\n"
"        this.authors = Objects.requireNonNull(authors);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:131
#, no-wrap
msgid ""
"    @ProtoField(number = 1)\n"
"    public String getTitle() {\n"
"        return title;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:136
#, no-wrap
msgid ""
"    @ProtoField(number = 2)\n"
"    public String getDescription() {\n"
"        return description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:141
#, no-wrap
msgid ""
"    @ProtoField(number = 3, defaultValue = \"-1\")\n"
"    public int getPublicationYear() {\n"
"        return publicationYear;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:146
#, no-wrap
msgid ""
"    @ProtoField(number = 4)\n"
"    public Set<Author> getAuthors() {\n"
"        return authors;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:149
#, fuzzy
msgid ""
"If your classes have only mutable fields, then the `ProtoFactory` annotation "
"is not required, assuming your class has a no arg constructor."
msgstr "クラスが mutable フィールドしかない場合は、 `ProtoFactory` アノテーションは必要ありません。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:152
#, fuzzy
msgid ""
"Then all that is required is a very simple `SerializationContextInitializer` "
"interface with an annotation on it to specify configuration settings"
msgstr ""
"必要なのは、非常にシンプルな `SerializationContextInitializer` "
"インターフェイスにアノテーションを付けて設定を指定するだけです。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:153
#, no-wrap, fuzzy
msgid "BookContextInitializer.java"
msgstr "BookContextInitializer.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:159
#, no-wrap
msgid ""
"@AutoProtoSchemaBuilder(includeClasses = { Book.class, Author.class }, "
"schemaPackageName = \"book_sample\")\n"
"interface BookContextInitializer extends SerializationContextInitializer {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:164
#, fuzzy
msgid ""
"So in this case we will automatically generate the marshaller and schemas "
"for the included classes and place them in the schema package automatically. "
"The package does not have to be provided, but if you utilize querying, you "
"must know the generated package."
msgstr ""
"そこで今回は、含まれるクラスのマーシャラーとスキーマを自動生成して、スキーマパッケージに自動で配置します。パッケージは用意する必要はありませんが、クエリを利用する場合は生成されたパッケージを知っておく必要があります。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:166
#, fuzzy
msgid ""
"In Quarkus the `schemaFileName` and `schemaFilePath` attributes should NOT "
"be set on the `AutoProtoSchemaBuilder` annotation, setting either will cause "
"native runtime to error."
msgstr ""
"Quarkusでは、 `schemaFileName` と `schemaFilePath` 属性は、 `AutoProtoSchemaBuilder` "
"アノテーションに設定すべきではありません。"

#. type: Title ===
#: upstream/_guides/infinispan-client.adoc:167
#, no-wrap, fuzzy
msgid "User written serialization"
msgstr "ユーザーが書いたシリアル化"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:173
#, fuzzy
msgid ""
"The previous method is suggested for any case when the user can annotate "
"their classes.  Unfortunately the user may not be able to annotate all "
"classes they will put in the cache. In this case you must define your schema "
"and create your own Marshaller(s)  yourself."
msgstr ""
"前の方法は、ユーザが自分のクラスにアノテーションを付けることができる場合のために提案されています。残念ながら、ユーザーはキャッシュに入れるすべてのクラスにアノテーションを付けることができないかもしれません。このような場合はスキーマを定義し、自分で独自のマーシャルを作成しなければなりません。"

#. type: Labeled list
#: upstream/_guides/infinispan-client.adoc:174
#, no-wrap, fuzzy
msgid "Protobuf schema"
msgstr "プロトバフスキーマ"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:175
#, fuzzy
msgid "You can supply a protobuf schema through either one of two ways."
msgstr "2つの方法のいずれかでprotobufスキーマを提供することができます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:176
#, fuzzy
msgid "Proto File"
msgstr "プロトファイル"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:179
#, fuzzy
msgid ""
"+ You can put the `.proto` file in the `META-INF` directory of the project. "
"These files will automatically be picked up at initialization time."
msgstr ""
"+ プロジェクトの `META-INF` ディレクトリに `.proto` "
"ファイルを置くことができます。これらのファイルは、初期化時に自動的にピックアップされます。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:180
#, no-wrap, fuzzy
msgid "library.proto"
msgstr "ライブラリープロト"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:183
#, no-wrap
msgid "package book_sample;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:188
#, no-wrap
msgid ""
"message Book {\n"
"  required string title = 1;\n"
"  required string description = 2;\n"
"  required int32 publicationYear = 3; // no native Date type available in "
"Protobuf\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:191
#, no-wrap
msgid "  repeated Author authors = 4;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:196
#, no-wrap
msgid ""
"message Author {\n"
"  required string name = 1;\n"
"  required string surname = 2;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:198
#, fuzzy
msgid "In Code"
msgstr "コードでは"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:201
#, fuzzy
msgid ""
"+ Or you can define the proto schema directly in user code by defining a "
"produced bean of type `org.infinispan.protostream.FileDescriptorSource`."
msgstr ""
"`org.infinispan.protostream.FileDescriptorSource`+ "
"または、ユーザコードで直接protoスキーマを定義することができます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:221
#, no-wrap
msgid ""
"   @Produces\n"
"   FileDescriptorSource bookProtoDefinition() {\n"
"      return FileDescriptorSource.fromString(\"library.proto\", \"package "
"book_sample;\\n\" +\n"
"            \"\\n\" +\n"
"            \"message Book {\\n\" +\n"
"            \"  required string title = 1;\\n\" +\n"
"            \"  required string description = 2;\\n\" +\n"
"            \"  required int32 publicationYear = 3; // no native Date type "
"available in Protobuf\\n\" +\n"
"            \"\\n\" +\n"
"            \"  repeated Author authors = 4;\\n\" +\n"
"            \"}\\n\" +\n"
"            \"\\n\" +\n"
"            \"message Author {\\n\" +\n"
"            \"  required string name = 1;\\n\" +\n"
"            \"  required string surname = 2;\\n\" +\n"
"            \"}\");\n"
"   }\n"
msgstr ""

#. type: Labeled list
#: upstream/_guides/infinispan-client.adoc:222
#, no-wrap, fuzzy
msgid "User Marshaller"
msgstr "ユーザーマーシャラー"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:226
#, fuzzy
msgid ""
"The last thing to do is to provide a `org.infinispan.protostream."
"MessageMarshaller` implementation for each user class defined in the proto "
"schema. This class is then provided via `@Produces` in a similar fashion to "
"the code based proto schema definition above."
msgstr ""
"最後にすべきことは、proto スキーマで定義された各ユーザークラスの `org.infinispan.protostream."
"MessageMarshaller` 実装を提供することです。このクラスは、上記のコードベースの proto スキーマの定義と同様の方法で "
"`@Produces` を介して提供されます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:228
#, fuzzy
msgid "Here is the Marshaller class for our Author & Book classes."
msgstr "こちらは、著者＆本のクラスのマーシャラークラスです。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:230
#, fuzzy
msgid ""
"The type name must match the `<protobuf package>.<protobuf message>` "
"exactly!"
msgstr ""
"タイプ名は `&amp;lt;protobuf package&amp;gt;.&amp;lt;protobuf message&amp;gt;` "
"と正確に一致している必要があります!"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:231
#, no-wrap, fuzzy
msgid "AuthorMarshaller.java"
msgstr "AuthorMarshaller.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:235
#, no-wrap
msgid "public class AuthorMarshaller implements MessageMarshaller<Author> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:240
#, no-wrap
msgid ""
"   @Override\n"
"   public String getTypeName() {\n"
"      return \"book_sample.Author\";\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:245
#, no-wrap
msgid ""
"   @Override\n"
"   public Class<? extends Author> getJavaClass() {\n"
"      return Author.class;\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:251
#, no-wrap
msgid ""
"   @Override\n"
"   public void writeTo(ProtoStreamWriter writer, Author author) throws "
"IOException {\n"
"      writer.writeString(\"name\", author.getName());\n"
"      writer.writeString(\"surname\", author.getSurname());\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:259
#, no-wrap
msgid ""
"   @Override\n"
"   public Author readFrom(ProtoStreamReader reader) throws IOException {\n"
"      String name = reader.readString(\"name\");\n"
"      String surname = reader.readString(\"surname\");\n"
"      return new Author(name, surname);\n"
"   }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:261
#, no-wrap, fuzzy
msgid "BookMarshaller.java"
msgstr "BookMarshaller.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:265
#, no-wrap
msgid "public class BookMarshaller implements MessageMarshaller<Book> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:270
#, no-wrap
msgid ""
"   @Override\n"
"   public String getTypeName() {\n"
"      return \"book_sample.Book\";\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:275
#, no-wrap
msgid ""
"   @Override\n"
"   public Class<? extends Book> getJavaClass() {\n"
"      return Book.class;\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:283
#, no-wrap
msgid ""
"   @Override\n"
"   public void writeTo(ProtoStreamWriter writer, Book book) throws "
"IOException {\n"
"      writer.writeString(\"title\", book.getTitle());\n"
"      writer.writeString(\"description\", book.getDescription());\n"
"      writer.writeInt(\"publicationYear\", book.getPublicationYear());\n"
"      writer.writeCollection(\"authors\", book.getAuthors(), Author.class);\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:293
#, no-wrap
msgid ""
"   @Override\n"
"   public Book readFrom(ProtoStreamReader reader) throws IOException {\n"
"      String title = reader.readString(\"title\");\n"
"      String description = reader.readString(\"description\");\n"
"      int publicationYear = reader.readInt(\"publicationYear\");\n"
"      Set<Author> authors = reader.readCollection(\"authors\", new "
"HashSet<>(), Author.class);\n"
"      return new Book(title, description, publicationYear, authors);\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:296
#, fuzzy
msgid "And you pass the marshaller by defining the following:"
msgstr "そして、以下のように定義してマーシャラーをパスします。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:303
#, no-wrap
msgid ""
"   @Produces\n"
"   MessageMarshaller authorMarshaller() {\n"
"      return new AuthorMarshaller();\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:308
#, no-wrap
msgid ""
"   @Produces\n"
"   MessageMarshaller bookMarshaller() {\n"
"      return new BookMarshaller();\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:310
#, fuzzy
msgid ""
"The above produced Marshaller method MUST return `MessageMarshaller` without "
"types or else it will not be found."
msgstr ""
"上記のように生成されたMarshallerメソッドは、型なしで `MessageMarshaller` を返さなければなりません(MUST)。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:311
#, no-wrap, fuzzy
msgid "Dependency Injection"
msgstr "依存性注入"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:317
#, fuzzy
msgid ""
"As you saw above we support the user injecting Marshaller configuration. You "
"can do the inverse with the Infinispan client extension providing injection "
"for `RemoteCacheManager` and `RemoteCache` objects.  There is one global "
"`RemoteCacheManager` that takes all of the configuration parameters setup in "
"the above sections."
msgstr ""
"上で見たように、Marshaller の設定をユーザーがインジェクションすることをサポートしています。Infinispan "
"クライアント拡張機能を使用すると、 `RemoteCacheManager` と `RemoteCache` "
"オブジェクトにインジェクションを行うことができます。上記のセクションで設定したすべての設定パラメータを受け取るグローバル "
"`RemoteCacheManager` があります。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:320
#, fuzzy
msgid ""
"It is very simple to inject these components. All you need to do is to add "
"the Inject annotation to the field, constructor or method. In the below code "
"we utilize field and constructor injection."
msgstr ""
"これらのコンポーネントを注入するのは非常に簡単です。必要なのは、フィールド、コンストラクタ、またはメソッドにインジェクションアノテーションを追加するだけです。以下のコードでは、フィールドとコンストラクタのインジェクションを利用しています。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:321
#, no-wrap, fuzzy
msgid "SomeClass.java"
msgstr "SomeClass.java"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:327
#, no-wrap
msgid ""
"    @Inject SomeClass(RemoteCacheManager remoteCacheManager) {\n"
"       this.remoteCacheManager = remoteCacheManager;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:330
#, no-wrap
msgid "    @Inject @Remote(\"myCache\")\n"
"    RemoteCache<String, Book> cache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:332
#, no-wrap
msgid "    RemoteCacheManager remoteCacheManager;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:337
#, fuzzy
msgid ""
"If you notice the `RemoteCache` declaration has an additional optional "
"annotation named `Remote`.  This is a qualifier annotation allowing you to "
"specify which named cache that will be injected. This annotation is not "
"required and if it is not supplied, the default cache will be injected."
msgstr ""
"`RemoteCache` 宣言に `Remote` "
"というオプションのアノテーションが追加されていることにお気づきでしょうか。これは、注入される名前付きキャッシュを指定するための修飾子アノテーションです。このアノテーションは必須ではなく、指定しなかった場合はデフォルトのキャッシュが注入されます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:339
#, fuzzy
msgid ""
"Other types may be supported for injection, please see other sections for "
"more information"
msgstr "その他のタイプは注入のためにサポートされている場合がありますが、詳細については他のセクションを参照してください。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:340
#, no-wrap, fuzzy
msgid "Querying"
msgstr "問い合わせ"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:345
#, fuzzy
msgid ""
"The Infinispan client supports both indexed and non indexed querying as long "
"as the `ProtoStreamMarshaller` is configured above. This allows the user to "
"query based on the properties of the proto schema."
msgstr ""
"Infinispan クライアントは、上記の `ProtoStreamMarshaller` "
"が設定されている限り、インデックス付きと非インデックス付きの両方のクエリをサポートしています。これにより、ユーザはプロトスキーマのプロパティに基づいてクエリを行うことができます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:350
#, fuzzy
msgid ""
"Query builds upon the proto definitions you can configure when setting up "
"the `ProtoStreamMarshaller`.  Either method of Serialization above will "
"automatically register the schema with the server at startup, meaning that "
"you will automatically gain the ability to query objects stored in the "
"remote Infinispan Server."
msgstr ""
"Query は、 `ProtoStreamMarshaller` "
"の設定時に設定できるプロト定義に基づいて構築されます。上記のいずれのシリアライズ方法でも、起動時に自動的にスキーマをサーバーに登録し、リモートの "
"Infinispan サーバーに保存されているオブジェクトをクエリする機能を自動的に得ることができます。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:352
#, fuzzy
msgid ""
"You can read more about this at https://infinispan.org/docs/stable/titles/"
"developing/developing.html#query_dsl."
msgstr ""
"これについては、 https://infinispan.org/docs/stable/titles/developing/developing."
"html#query_dsl 。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:355
#, fuzzy
msgid ""
"You can use either the Query DSL or the Ickle Query language with the "
"Quarkus Infinispan client extension."
msgstr "Quarkus Infinispanクライアントエクステンションでは、クエリDSLまたはIckleクエリ言語のいずれかを使用できます。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:356
#, no-wrap, fuzzy
msgid "Counters"
msgstr "カウンター"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:360
#, fuzzy
msgid ""
"Infinispan also has a notion of counters and the Quarkus Infinispan client "
"supports them out of the box."
msgstr ""
"Infinispanにはカウンターという概念もあり、Quarkus Infinispanのクライアントはそれらを箱から出してサポートしています。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:364
#, fuzzy
msgid ""
"The Quarkus Infinispan client extension allows for Dependency Injection of "
"the `CounterManager` directly. All you need to do is annotate your field, "
"constructor or method and you get it with no fuss. You can then use counters "
"as you would normally."
msgstr ""
"Quarkus Infinispanクライアント拡張機能を使用すると、 `CounterManager` "
"の依存性インジェクションを直接行うことができます。必要なのは、フィールド、コンストラクタ、メソッドにアノテーションを付けるだけで、手間をかけずにインジェクションが可能になります。そして、通常のようにカウンターを使用することができます。"

#. type: delimited block -
#: upstream/_guides/infinispan-client.adoc:369
#, no-wrap
msgid "@Inject\n"
"CounterManager counterManager;\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:371
#, no-wrap, fuzzy
msgid "Near Caching"
msgstr "ニアキャッシング"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:377
#, fuzzy
msgid ""
"Near caching is disabled by default, but you can enable it by setting the "
"profile config property `quarkus.infinispan-client.near-cache-max-entries` "
"to a value greater than 0. You can also configure a regular expression so "
"that only a subset of caches have near caching applied through the `quarkus."
"infinispan-client.near-cache-name-pattern` attribute."
msgstr ""
"ニア・キャッシングは既定では無効になっていますが、プロファイル構成プロパティ `quarkus.infinispan-client.near-cache-"
"max-entries` を 0 より大きい値に設定することで有効にすることができます。 また、正規表現を構成して、キャッシュのサブセットのみが "
"`quarkus.infinispan-client.near-cache-name-pattern` "
"属性を通じてニア・キャッシングを適用するようにすることもできます。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:378
#, no-wrap, fuzzy
msgid "Encryption"
msgstr "暗号化"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:381
#, fuzzy
msgid "Encryption at this point requires additional steps to get working."
msgstr "この時点での暗号化には、作業を開始するための追加のステップが必要です。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:385
#, fuzzy
msgid ""
"The first step is to configure the `hotrod-client.properties` file to point "
"to your truststore and/or keystore. This is further detailed at https://"
"infinispan.org/docs/dev/user_guide/user_guide.html#hr_encryption."
msgstr ""
"最初のステップは、 `hotrod-client.properties` ファイルが truststore および/または keystore "
"を指すように設定することです。これは https://infinispan.org/docs/dev/user_guide/user_guide."
"html#hr_encryption  でさらに詳しく説明されています。"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:388
#, fuzzy
msgid ""
"The Infinispan Client extension enables SSL by default. You can read more "
"about this at link:native-and-ssl[Using SSL With Native Executables]."
msgstr ""
"Infinispanクライアント拡張機能は、デフォルトでSSLを有効にします。これについての詳細は link:native-and-ssl[Using "
"SSL With Native Executables] を参照してください。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:389
#, no-wrap, fuzzy
msgid "Authentication"
msgstr "認証"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:393
#, fuzzy
msgid ""
"This chart illustrates what mechanisms have been verified to be working "
"properly with the Quarkus Infinispan Client extension."
msgstr "この図は、Quarkus Infinispanクライアント拡張機能で正常に動作することが確認されているメカニズムを示しています。"

#. type: Block title
#: upstream/_guides/infinispan-client.adoc:394
#, no-wrap, fuzzy
msgid "Mechanisms"
msgstr "メカニズム"

#. type: Table
#: upstream/_guides/infinispan-client.adoc:413
#, no-wrap, fuzzy
msgid ""
"| Name | Verified\n"
"\n"
"| DIGEST-MD5\n"
"| [green]*Y*\n"
"\n"
"| PLAIN\n"
"| [green]*Y*\n"
"\n"
"| EXTERNAL\n"
"| [green]*Y*\n"
"\n"
"| GSSAPI\n"
"| [red]*N*\n"
"\n"
"| Custom\n"
"| [red]*N*\n"
"\n"
msgstr "| 名前｜名前｜検証済み"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:417
#, fuzzy
msgid ""
"The guide for configuring these can be found at https://infinispan.org/docs/"
"dev/user_guide/user_guide.html#authentication.  However you need to "
"configure these through the `hotrod-client.properties` file if using "
"Dependency Injection."
msgstr ""
"これらを設定するためのガイドは https://infinispan.org/docs/dev/user_guide/user_guide."
"html#authentication  にあります。ただし、依存性インジェクションを使用する場合は `hotrod-client."
"properties` ファイルから設定する必要があります。"

#. type: Title ==
#: upstream/_guides/infinispan-client.adoc:418
#, no-wrap, fuzzy
msgid "Additional Features"
msgstr "追加機能"

#. type: Plain text
#: upstream/_guides/infinispan-client.adoc:422
#, fuzzy
msgid ""
"The Infinispan Client has additional features that were not mentioned here. "
"This means this feature was not tested in a Quarkus environment and they may "
"or may not work. Please let us know if you need these added!"
msgstr ""
"Infinispanクライアントには、ここでは触れられていない追加機能があります。これは、この機能がQuarkus環境でテストされていないことを意味します。これらの機能を追加する必要がある場合は、ご連絡ください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/reactive-event-bus.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using the event bus"
msgstr "Quarkus - イベントバスの使用"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:13
#, fuzzy
msgid ""
"Quarkus allows different beans to interact using asynchronous events, thus "
"promoting loose-coupling.  The messages are sent to _virtual addresses_.  It "
"offers 3 types of delivery mechanism:"
msgstr ""
"Quarkusでは、異なるビーンが非同期イベントを使用して相互作用することができるため、ゆるやかなカップリングが促進されます。メッセージは "
"_仮想アドレス_に送信されます。3種類の配信メカニズムを提供しています。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:15
#, fuzzy
msgid ""
"point-to-point - send the message, one consumer receives it. If several "
"consumers listen to the address, a round robin is applied;"
msgstr ""
"point-to-point - メッセージを送信し、1 "
"つのコンシューマがそれを受信します。複数の消費者がアドレスを聞いている場合、ラウンドロビンが適用されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:16
#, fuzzy
msgid ""
"publish/subscribe - publish a message, all the consumers listening to the "
"address are receiving the message;"
msgstr "publish/subscribe - メッセージを公開し、アドレスを聞いているすべての消費者がメッセージを受信します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:17
#, fuzzy
msgid ""
"request/reply - send the message and expect a response. The receiver can "
"respond to the message in an asynchronous-fashion"
msgstr "request/reply - メッセージを送信し、応答を期待します。受信者は非同期的にメッセージに応答することができます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:19
#, fuzzy
msgid ""
"All these delivery mechanism are non-blocking, and are providing one of the "
"fundamental brick to build reactive applications."
msgstr "これらの配信メカニズムはすべてノンブロッキングであり、反応型アプリケーションを構築するための基本的なレンガの1つを提供しています。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:22
#, fuzzy
msgid ""
"The asynchronous message passing feature allows replying to messages which "
"is not supported by Reactive Messaging.  However, it is limited to single-"
"event behavior (no stream) and to local messages."
msgstr ""
"非同期メッセージパッシング機能は、Reactive "
"Messagingではサポートされていないメッセージへの返信を可能にします。ただし、シングルイベント動作(ストリームなし)とローカルメッセージに限定されます。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:20
#, no-wrap, fuzzy
msgid "Installing"
msgstr "インストール"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:27
#, fuzzy
msgid ""
"This mechanism uses the Vert.x EventBus, so you need to enable the `vertx` "
"extension to use this feature.  If you are creating a new project, set the "
"`extensions` parameter are follows:"
msgstr ""
"この仕組みはVert.x EventBusを利用しているので、この機能を利用するには `vertx` "
"拡張機能を有効にする必要があります。新規プロジェクトを作成する場合は、 `extensions` パラメータを以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:36
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vertx-quickstart \\\n"
"    -Dextensions=\"vertx,resteasy-mutiny\" \\\n"
"    -DnoExamples\n"
"cd vertx-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:36
#, fuzzy
msgid ""
"If you have an already created project, the `vertx` extension can be added "
"to an existing Quarkus project with the `add-extension` command:"
msgstr ""
"すでに作成済みのプロジェクトがある場合は、 `vertx` 拡張機能を既存のQuarkusプロジェクトに追加するには、 `add-extension` "
"コマンドを使用します。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:44
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"vertx,resteasy-mutiny\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:43
#, fuzzy
msgid ""
"Otherwise, you can manually add this to the dependencies section of your "
"`pom.xml` file:"
msgstr "そうでなければ、 `pom.xml` ファイルの依存関係セクションに手動で追加することができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:50
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-vertx</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:56
#, no-wrap, fuzzy
msgid "Consuming events"
msgstr "消費イベント"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:59
#, fuzzy
msgid "To consume events, use the `io.quarkus.vertx.ConsumeEvent` annotation:"
msgstr "イベントを消費するには、 `io.quarkus.vertx.ConsumeEvent` アノテーションを使用します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:251 upstream/_guides/vertx.adoc:316
#: upstream/_guides/vertx.adoc:500
#, no-wrap
msgid "package org.acme.vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:65
#: upstream/_guides/reactive-event-bus.adoc:113
#: upstream/_guides/reactive-event-bus.adoc:335
#, no-wrap
msgid "import io.quarkus.vertx.ConsumeEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:116
#: upstream/_guides/microprofile-health.adoc:170
#: upstream/_guides/microprofile-health.adoc:218
#: upstream/_guides/microprofile-health.adoc:287
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:70
#: upstream/_guides/reactive-event-bus.adoc:121
#: upstream/_guides/reactive-event-bus.adoc:340
#, no-wrap
msgid "@ApplicationScoped\n"
"public class GreetingService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:76
#, no-wrap
msgid ""
"    @ConsumeEvent                           // <1>\n"
"    public String consume(String name) {    // <2>\n"
"        return name.toUpperCase();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:78
#, fuzzy
msgid ""
"If not set, the address is the fully qualified name of the bean, for "
"instance, in this snippet it's `org.acme.vertx.GreetingService`."
msgstr ""
"設定されていない場合、アドレスはビーンの完全修飾名となり、例えばこのスニペットでは `org.acme.vertx.GreetingService`."

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:79
#, fuzzy
msgid ""
"The method parameter is the message body. If the method returns _something_ "
"it's the message response."
msgstr "メソッドのパラメータはメッセージ本体です。メソッドが _何かを_返す場合は、それがメッセージのレスポンスになります。"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:84
#, fuzzy
msgid ""
"By default, the code consuming the event must be _non-blocking_, as it's "
"called on the Vert.x event loop.  If your processing is blocking, use the "
"`blocking` attribute:"
msgstr ""
"デフォルトでは、Vert.x イベントループで呼び出されるため、イベントを消費するコードは "
"_ノン_ブロッキングでなければなりません。処理がブロッキングされている場合は、 `blocking` 属性を使用してください。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:91
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\", blocking = true)\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:94
#, fuzzy
msgid ""
"Alternatively, you can annotate your method with `@io.smallrye.common."
"annotation.Blocking`:"
msgstr "あるいは、メソッドに `@io.smallrye.common.annotation.Blocking` と注釈を付けることもできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:101
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"blocking-consumer\")\n"
"@Blocking\n"
"void consumeBlocking(String message) {\n"
"    // Something blocking\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:104
#, fuzzy
msgid ""
"When using `@Blocking`, it ignores the value of the `blocking` attribute of "
"`@ConsumeEvent`."
msgstr "`@Blocking` を使用する場合、 `@ConsumeEvent` の `blocking` 属性の値は無視されます。"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:107
#, fuzzy
msgid ""
"Asynchronous processing is also possible by returning either an `io.smallrye."
"mutiny.Uni` or a `java.util.concurrent.CompletionStage`:"
msgstr ""
"`io.smallrye.mutiny.Uni` または `java.util.concurrent.CompletionStage`.NET "
"のどちらかを返すことで、非同期処理も可能です。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:118
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:127
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public CompletionStage<String> consume(String name) {\n"
"        // return a CompletionStage completed when the processing is "
"finished.\n"
"        // You can also fail the CompletionStage explicitly\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:134
#, no-wrap
msgid ""
"    @ConsumeEvent\n"
"    public Uni<String> process(String name) {\n"
"        // return an Uni completed when the processing is finished.\n"
"        // You can also fail the Uni explicitly\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:140
#, fuzzy
msgid ""
"The previous example uses Mutiny reactive types, if you're not familiar with "
"them, we recommend reading the link:getting-started-reactive#mutiny[Getting "
"Started with Reactive guide]."
msgstr ""
"前の例では Mutiny リアクティブタイプを使用していますが、もしよく知らないのであれば、 link:getting-started-"
"reactive#mutiny[Reactive の入門ガイド]を読むことをお勧めします。"

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:142
#, no-wrap, fuzzy
msgid "Configuring the address"
msgstr "アドレスの設定"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:145
#, fuzzy
msgid "The `@ConsumeEvent` annotation can be configured to set the address:"
msgstr "`@ConsumeEvent` アノテーションでアドレスを設定することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:152
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")               // <1>\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:154
#, fuzzy
msgid "Receive the messages sent to the `greeting` address"
msgstr "`greeting` アドレスに送信されたメッセージを受信する"

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:155
#, no-wrap, fuzzy
msgid "Replying"
msgstr "返事をする"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:159
#, fuzzy
msgid ""
"The _return_ value of a method annotated with `@ConsumeEvent` is used as "
"response to the incoming message.  For instance, in the following snippet, "
"the returned `String` is the response."
msgstr ""
"`@ConsumeEvent` でアノテーションされたメソッドの "
"_戻り_値が、着信メッセージに対するレスポンスとして使用されます。例えば、次のスニペットでは、 `String` がレスポンスとして返されます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:166
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public String consume(String name) {\n"
"    return name.toUpperCase();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:169
#, fuzzy
msgid ""
"You can also return a `Uni<T>` or a `CompletionStage<T>` to handle "
"asynchronous reply:"
msgstr ""
"また、 `Uni&amp;lt;T&amp;gt;` や `CompletionStage&amp;lt;T&amp;gt;` "
"を返すことで、非同期返信を処理することもできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:176
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public Uni<String> consume2(String name) {\n"
"    return Uni.createFrom().item(() -> name.toUpperCase()).emitOn(executor);\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:181
#, fuzzy
msgid ""
"You can inject an `executor` if you use the Context Propagation extension:"
msgstr "Context Propagation 拡張機能を使えば、 `executor` を注入することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:184
#, no-wrap
msgid "@Inject Executor executor;\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:187
#, no-wrap, fuzzy
msgid "Implementing fire and forget interactions"
msgstr "fire and forgetインタラクションの実装"

#. type: delimited block =
#: upstream/_guides/reactive-event-bus.adoc:192
#, fuzzy
msgid ""
"You don't have to reply to received messages.  Typically for a _fire and "
"forget_ interaction, the messages are consumed and the sender does not need "
"to know about it.  To implement this, your consumer method just returns "
"`void`"
msgstr ""
"受信したメッセージに返信する必要はありません。通常、 _fire and "
"forget_インタラクションでは、メッセージは消費され、送信者はそれについて知る必要はありません。これを実装するには、 consumer メソッドは "
"`void`"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:199
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(String event) {\n"
"    // Do something with the event\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/reactive-event-bus.adoc:201
#, no-wrap, fuzzy
msgid "Dealing with messages"
msgstr "メッセージへの対応"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:204
#, fuzzy
msgid ""
"As said above, this mechanism is based on the Vert.x event bus. So, you can "
"also use `Message` directly:"
msgstr "上でも述べたように、この仕組みはVert.xイベントバスをベースにしています。なので、直接 `Message` を使うこともできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:212
#, no-wrap
msgid ""
"@ConsumeEvent(\"greeting\")\n"
"public void consume(Message<String> msg) {\n"
"    System.out.println(msg.address());\n"
"    System.out.println(msg.body());\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:214
#, no-wrap, fuzzy
msgid "Sending messages"
msgstr "メッセージの送信"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:218
#, fuzzy
msgid ""
"Ok, we have seen how to receive messages, let's now switch to the _other "
"side_: the sender.  Sending and publishing messages use the Vert.x event bus:"
""
msgstr ""
"さて、メッセージを受信する方法を見てきましたが、次は送信者 _側_に切り替えましょう。メッセージの送信と公開は Vert.x イベントバスを使います。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:227
#: upstream/_guides/reactive-event-bus.adoc:301
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.core.eventbus.EventBus;\n"
"import io.vertx.mutiny.core.eventbus.Message;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:225
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:236
#: upstream/_guides/reactive-event-bus.adoc:310
#, no-wrap
msgid "@Path(\"/async\")\n"
"public class EventResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:239
#, no-wrap
msgid ""
"    @Inject\n"
"    EventBus bus;                                       // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:248
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(@PathParam String name) {\n"
"        return bus.<String>request(\"greeting\", name)        // <2>\n"
"                .onItem().transform(Message::body);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:250
#, fuzzy
msgid "Inject the Event bus"
msgstr "イベントバスのインジェクト"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:251
#, fuzzy
msgid "Send a message to the address `greeting`. Message payload is `name`"
msgstr "アドレス `greeting` にメッセージを送信してください。メッセージのペイロードは `name`"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:253
#, fuzzy
msgid "The `EventBus` object provides methods to:"
msgstr "`EventBus` オブジェクトは、以下のメソッドを提供します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:255
#, fuzzy
msgid ""
"`send` a message to a specific address - one single consumer receives the "
"message."
msgstr "`send` 特定のアドレスへのメッセージ - 一人の消費者がメッセージを受信する。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:256
#, fuzzy
msgid ""
"`publish` a message to a specific address - all consumers receive the "
"messages."
msgstr "`publish` 特定のアドレスにメッセージを送る - すべての消費者がメッセージを受け取る。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:257
#, fuzzy
msgid "`send` a message and expect reply"
msgstr "`send` メッセージを送って返信を期待する"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:267
#, no-wrap
msgid ""
"// Case 1\n"
"bus.sendAndForget(\"greeting\", name)\n"
"// Case 2\n"
"bus.publish(\"greeting\", name)\n"
"// Case 3\n"
"Uni<String> response = bus.<String>request(\"address\", \"hello, how are "
"you?\")\n"
"        .onItem().transform(Message::body);\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:269
#, no-wrap, fuzzy
msgid "Putting things together - bridging HTTP and messages"
msgstr "物事をまとめる - HTTPとメッセージのブリッジング"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:275
#, fuzzy
msgid ""
"Let's revisit a greeting HTTP endpoint and use asynchronous message passing "
"to delegate the call to a separated bean.  It uses the request/reply "
"dispatching mechanism.  Instead of implementing the business logic inside "
"the JAX-RS endpoint, we are sending a message.  This message is consumed by "
"another bean and the response is sent using the _reply_ mechanism."
msgstr ""
"挨拶HTTPエンドポイントを再訪し、非同期メッセージパッシングを使用して分離されたビーンに呼び出しを委譲してみましょう。リクエスト/"
"レスポンスディスパッチの仕組みを利用しています。JAX-"
"RSエンドポイント内にビジネスロジックを実装する代わりに、メッセージを送信しています。このメッセージは別のBeanによって消費され、応答は "
"_応答_機構を使用して送信されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:277
#, fuzzy
msgid "First create a new project using:"
msgstr "まず、新しいプロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:286
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vertx-http-quickstart \\\n"
"    -Dextensions=\"vertx\" \\\n"
"    -DnoExamples\n"
"cd vertx-http-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:289
#, fuzzy
msgid ""
"You can already start the application in _dev mode_ using `./mvnw compile "
"quarkus:dev`."
msgstr "`./mvnw compile quarkus:dev` を使用して、すでに _開発者モード_でアプリケーションを起動することができます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:291
#, fuzzy
msgid "Then, creates a new JAX-RS resource with the following content:"
msgstr "そして、以下の内容のJAX-RSリソースを新規に作成します。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:293
#, no-wrap, fuzzy
msgid "src/main/java/org/acme/vertx/EventResource.java"
msgstr "src/main/java/org/acme/vertx/ventResource.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:313
#, no-wrap
msgid "    @Inject\n"
"    EventBus bus;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:322
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Path(\"{name}\")\n"
"    public Uni<String> greeting(@PathParam String name) {\n"
"        return bus.<String>request(\"greeting\", name)            // <1>\n"
"                .onItem().transform(Message::body);            // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:324
#, fuzzy
msgid "send the `name` to the `greeting` address and request a response"
msgstr "`name` `greeting` を送信し、回答を求める。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:325
#, fuzzy
msgid "when we get the response, extract the body and send it to the user"
msgstr "レスポンスを取得したら、本文を抽出してユーザーに送信します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:328
#, fuzzy
msgid ""
"If you call this endpoint, you will wait and get a timeout. Indeed, no one "
"is listening.  So, we need a consumer listening on the `greeting` address. "
"Create a `GreetingService` bean with the following content:"
msgstr ""
"このエンドポイントを呼び出すと、待っていてタイムアウトになります。確かに、誰も聞いていません。そこで、 `greeting` "
"アドレスでリスニングしているコンシューマーが必要です。以下の内容の `GreetingService` ビーンを作成します。"

#. type: Block title
#: upstream/_guides/reactive-event-bus.adoc:330
#, no-wrap, fuzzy
msgid "src/main/java/org/acme/vertx/GreetingService.java"
msgstr "src/main/java/org/acme/vertx/GreetingService.java"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:345
#, no-wrap
msgid ""
"    @ConsumeEvent(\"greeting\")\n"
"    public String greeting(String name) {\n"
"        return \"Hello \" + name;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:350
#, fuzzy
msgid "This bean receives the name, and returns the greeting message."
msgstr "このBeanは名前を受け取り，挨拶メッセージを返します．"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:352
#, fuzzy
msgid ""
"Now, open your browser to http://localhost:8080/async/Quarkus, and you "
"should see:"
msgstr "さて、ブラウザを開いて http://localhost:8080/async/Quarkus 。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:356
#, no-wrap
msgid "Hello Quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:359
#, fuzzy
msgid ""
"To better understand, let's detail how the HTTP request/response has been "
"handled:"
msgstr "より理解しやすくするために、HTTPリクエスト/レスポンスがどのように処理されたかを詳しく見てみましょう。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:361
#, fuzzy
msgid "The request is received by the `hello` method"
msgstr "リクエストは `hello` メソッドで受信します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:362
#, fuzzy
msgid "a message containing the _name_ is sent to the event bus"
msgstr "_名前を_含むメッセージがイベントバスに送信されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:363
#, fuzzy
msgid "Another bean receives this message and computes the response"
msgstr "別のBeanはこのメッセージを受信して，応答を計算します．"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:364
#, fuzzy
msgid "This response is sent back using the reply mechanism"
msgstr "この応答は、リプライ機構を使用して返信されます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:365
#, fuzzy
msgid ""
"Once the reply is received by the sender, the content is written to the HTTP "
"response"
msgstr "送信者が返信を受信すると、HTTPレスポンスに内容が書き込まれます。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:367
#, fuzzy
msgid "This application can be packaged using:"
msgstr "このアプリケーションは、以下の方法でパッケージ化することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:371
#, no-wrap
msgid "./mvnw clean package\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:374
#, fuzzy
msgid "You can also compile it as a native executable with:"
msgstr "でネイティブ実行ファイルとしてコンパイルすることもできます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:378
#, no-wrap
msgid "./mvnw clean package -Pnative\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/reactive-event-bus.adoc:380
#, no-wrap, fuzzy
msgid "Using codecs"
msgstr "コーデックを使う"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:385
#, fuzzy
msgid ""
"The https://vertx.io/docs/vertx-core/java/#event_bus[Vert.x Event Bus] uses "
"codecs to _serialize_ and _deserialize_ objects.  Quarkus provides a default "
"codec for local delivery.  So you can exchange objects as follows:"
msgstr ""
"link:https://vertx.io/docs/vertx-core/java/#event_bus[Vert."
"xイベントバスで]は、コーデックを使用してオブジェクトの _シリアライズ_と "
"_デシリアライズ_を行います。Quarkusでは、ローカル配信用のデフォルトのコーデックを提供しています。そのため、以下のようにオブジェクトを交換することができます。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:395
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(@PathParam String name) {\n"
"    return bus.<String>request(\"greeting\", new MyName(name))\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:400
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\")\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \" + name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:403
#, fuzzy
msgid ""
"If you want to use a specific codec, you need to explicitly set it on both "
"ends:"
msgstr "特定のコーデックを使用したい場合は、両端で明示的に設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:414
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Path(\"{name}\")\n"
"public Uni<String> greeting(@PathParam String name) {\n"
"    return bus.<String>request(\"greeting\", name,\n"
"        new DeliveryOptions().setCodecName(MyNameCodec.class.getName())) // "
"<1>\n"
"        .onItem().transform(Message::body);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/reactive-event-bus.adoc:419
#, no-wrap
msgid ""
"@ConsumeEvent(value = \"greeting\", codec = MyNameCodec.class)            // "
"<2>\n"
"Uni<String> greeting(MyName name) {\n"
"    return Uni.createFrom().item(() -> \"Hello \"+name.getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:421
#, fuzzy
msgid "Set the name of the codec to use to send the message"
msgstr "メッセージの送信に使用するコーデックの名前を設定します。"

#. type: Plain text
#: upstream/_guides/reactive-event-bus.adoc:421
#, fuzzy
msgid "Set the codec to use to receive the message"
msgstr "メッセージの受信に使用するコーデックを設定します。"

#. type: Title =
#: upstream/_guides/quarkus-intro.adoc:1
#, no-wrap, fuzzy
msgid "What is Quarkus"
msgstr "クォークスとは"

#.  tag::intro[]
#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:19
#, fuzzy
msgid ""
"Quarkus is a Cloud Native, Container First framework for writing Java "
"applications."
msgstr "Quarkusは、Javaアプリケーションを書くためのクラウドネイティブ、コンテナファーストのフレームワークです。"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:21
#, no-wrap, fuzzy
msgid "Container First"
msgstr "コンテナファースト"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:23
#, fuzzy
msgid ""
"Minimal footprint Java applications optimized for running in containers"
msgstr "コンテナでの実行に最適化されたミニマムフットプリントのJavaアプリケーション"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:23
#: upstream/_guides/quarkus-intro.adoc:56
#, no-wrap, fuzzy
msgid "Cloud Native"
msgstr "クラウドネイティブ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:25
#, fuzzy
msgid "Embraces 12 factor architecture in environments like Kubernetes"
msgstr "Kubernetesのような環境で12因子アーキテクチャを採用"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:25
#, no-wrap, fuzzy
msgid "Unify imperative and reactive"
msgstr "命令的なものと反応的なものを統一する"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:27
#, fuzzy
msgid ""
"Brings under one programming model non blocking and imperative styles of "
"development"
msgstr "ノンブロッキングと命令型の開発スタイルを1つのプログラミングモデルにまとめました。"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:27
#, no-wrap, fuzzy
msgid "Standards-based"
msgstr "標準化された"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:29
#, fuzzy
msgid ""
"Based on the standards and the libraries you love and use (RESTEasy, "
"Hibernate, Netty, Eclipse Vert.x, Apache Camel...)"
msgstr ""
"標準や愛用しているライブラリ（RESTEasy、Hibernate、Netty、Eclipse Vert.x、Apache Camel..."
"）に基づいています。"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:29
#, no-wrap, fuzzy
msgid "Microservice First"
msgstr "マイクロサービスファースト"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:31
#, fuzzy
msgid "Brings lightning fast startup time to Java applications"
msgstr "Javaアプリケーションの起動時間を大幅に短縮"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:31
#, no-wrap, fuzzy
msgid "Extreme productivity"
msgstr "極限の生産性"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:33
#, fuzzy
msgid ""
"Instant hot code replacement: don't allow build, deploy, boot delays disrupt "
"your flow"
msgstr "インスタントホットコードの置き換え: ビルド、デプロイ、ブートの遅延がフローを混乱させないようにする"

#. type: Labeled list
#: upstream/_guides/quarkus-intro.adoc:33
#, no-wrap, fuzzy
msgid "Developer Joy"
msgstr "開発者の喜び"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:35
#, fuzzy
msgid ""
"Development-centric experience without compromises to bring your amazing "
"applications to life in no time"
msgstr "妥協のない開発中心の体験で、素晴らしいアプリケーションを短時間で実現"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:37
#, fuzzy
msgid "All under one framework."
msgstr "すべては一つの枠組みの下で。"

#.  end::intro[]
#. type: Title ==
#: upstream/_guides/quarkus-intro.adoc:40
#, no-wrap, fuzzy
msgid "Scratch pad"
msgstr "スクラッチパッド"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:44
#, fuzzy
msgid "Quarkus believes in developer Joy."
msgstr "クォークスは開発者のジョイを信じています。"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:48
#, fuzzy
msgid ""
"It unifies imperative and reactive.  It is a Microservice first toolkit."
msgstr "インプライベーティブとリアクティブを統一しています。マイクロサービスファーストのツールキットです。"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:51
#, fuzzy
msgid ""
"Standards based Quarkus brings all the standards and frameworks you love and "
"use: RESTEasy, Hibernate, Netty, vert.x, Camel...)"
msgstr ""
"標準ベースのQuarkusは、あなたが好きで使っているすべての標準やフレームワークを提供します。RESTEasy、Hibernate、Netty、vert."
"x、Camelなどです。)"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:53
#, fuzzy
msgid "Imperative and Reactive"
msgstr "強迫的と反応的"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:55
#, fuzzy
msgid "ahead-of-time native binary (executable binary)"
msgstr "先行ネイティブバイナリ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:57
#, fuzzy
msgid "Java"
msgstr "ジャワ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:58
#, fuzzy
msgid "modular"
msgstr "モジュラー"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:59
#, fuzzy
msgid "Substrate VM native"
msgstr "基板 VM ネイティブ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:61
#, fuzzy
msgid "Seamlessly build container optimal"
msgstr "シームレスに最適なコンテナを構築"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:63
#, fuzzy
msgid "Container affinity"
msgstr "コンテナとの親和性"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:65
#, fuzzy
msgid "Container optimal"
msgstr "コンテナの最適化"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:67
#, fuzzy
msgid "low memory"
msgstr "ローメモリ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:68
#, fuzzy
msgid "low startup time"
msgstr "低起動時間"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:69
#, fuzzy
msgid "ahead of time optimal"
msgstr "先行最適"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:71
#, fuzzy
msgid "Unifying Imperative and Reactive under one framework."
msgstr "ImperativeとReactiveを一つのフレームワークで統一する。"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:73
#, fuzzy
msgid "Usability"
msgstr "ユーザビリティ"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:74
#, fuzzy
msgid "easy to use"
msgstr "使いやすい"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:75
#, fuzzy
msgid "productive environment"
msgstr "せいさんかんきょう"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:76
#, fuzzy
msgid "hot reload"
msgstr "ホットリロード"

#. type: Plain text
#: upstream/_guides/quarkus-intro.adoc:78
#, fuzzy
msgid "Standards based"
msgstr "標準化された"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amazon-ses.adoc:6
#, no-wrap
msgid "Quarkus - Amazon SES Client"
msgstr "Quarkus - Amazon SES クライアント"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:13
msgid ""
"Amazon Simple Email Service (SES) is a flexible and highly-scalable email "
"sending and receiving service.  Using SES, you can send emails with any type "
"of correspondence. You can find more information about SES at https://aws."
"amazon.com/ses/[the Amazon SES website]."
msgstr ""
"Amazon Simple Email "
"Service（SES）は、柔軟で拡張性の高いメール送受信サービスです。SESを利用することで、あらゆる対応でメールを送信することができます。SESの詳細については、 "
"link:https://aws.amazon.com/ses/[Amazon SESのウェブサイト]で確認できます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:16
msgid ""
"The SES extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/"
"developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the "
"1.x code base that offers two programming models (Blocking & Async)."
msgstr ""
"SESのエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-"
"guide/welcome.html[AWS Java SDK 2.x]をベースにしており、2つのプログラミングモデル（Blocking &amp; "
"Async）を提供する1.xのコードベースを大幅に書き換えています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:23
#, fuzzy
msgid "The Quarkus extension supports two programming models:"
msgstr "Quarkus拡張機能は、2つのプログラミングモデルをサポートしています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:25
#, fuzzy
msgid ""
"Blocking access using URL Connection HTTP client (by default) or the Apache "
"HTTP Client"
msgstr ""
"URL Connection HTTP クライアント (デフォルト) または Apache HTTP クライアントを使ってアクセスをブロックする"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:26
#, fuzzy
msgid ""
"https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async."
"html[Asynchronous programming] based on JDK's `CompletableFuture` objects "
"and the Netty HTTP client."
msgstr ""
"JDK の `CompletableFuture` オブジェクトと Netty HTTP クライアントをベースにした link:https://docs."
"aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async."
"html[非同期プログラミング]。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:25
msgid ""
"In this guide, we see how you can get your REST services to use SES locally "
"and on AWS."
msgstr "このガイドでは、RESTサービスを利用してローカルでAWS上でSESを利用する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:34
msgid "An AWS Account to access the SES service"
msgstr "SESサービスにアクセスするためのAWSアカウント"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:35
msgid "Docker for your system to run SES locally for testing purposes"
msgstr "テスト目的でローカルでSESを実行するためのDocker"

#. type: Title ==
#: upstream/_guides/amazon-ses.adoc:36
#, no-wrap
msgid "Set up SES locally"
msgstr "ローカルでSESを設定する"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:40
msgid ""
"The easiest way to start working with SES is to run a local instance as a "
"container.  However, local instance of SES is only mocks the SES APIs "
"without the actual email sending capabilities. You can still use it for this "
"guide to verify an API communication or integration test purposes."
msgstr ""
"SESを使い始める最も簡単な方法は、コンテナとしてローカルインスタンスを実行することです。しかし、SESのローカルインスタンスは、実際のメール送信機能を持たずにSESのAPIをモックしているに過ぎません。それでも、このガイドではAPI通信の検証や統合テストの目的で使用することができます。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:44
#, no-wrap
msgid ""
"docker run --rm --name local-ses -p 8012:4579 -e SERVICES=ses -e START_WEB=0 "
"-d localstack/localstack:0.11.1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:46
msgid "This starts a SES instance that is accessible on port `8012`."
msgstr "これは、ポート `8012` でアクセス可能な SES インスタンスを起動します。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:48
msgid "Create an AWS profile for your local instance using AWS CLI:"
msgstr "AWS CLIを使ってローカルインスタンスのAWSプロファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:55
#, no-wrap
msgid ""
"$ aws configure --profile localstack\n"
"AWS Access Key ID [None]: test-key\n"
"AWS Secret Access Key [None]: test-secret\n"
"Default region name [None]: us-east-1\n"
"Default output format [None]:\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-ses.adoc:57
#, no-wrap
msgid "Using SES on your AWS account"
msgstr "AWSアカウントでSESを使う"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:61
msgid ""
"Amazon applies certain restrictions to new Amazon SES accounts, mainly to "
"prevent fraud and abuse. All new accounts are in the Amazon SES *sandbox*.  "
"All the features of the Amazon SES are still available while in sandbox, but "
"a following restrictions applies:"
msgstr ""
"Amazonは、主に詐欺や悪用を防ぐために、Amazon SESの新規アカウントに一定の制限を適用しています。新規アカウントはすべてAmazon "
"SESの *サンドボックス*に入っています。サンドボックスにいる間もAmazon SESの機能はすべて利用できますが、以下の制限が適用されます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:62
msgid ""
"You can send mail to verified email addresses and domains or to the https://"
"docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-simulator."
"html[Amazon SES mailbox simulator]"
msgstr ""
"検証済みのメールアドレスやドメインにメールを送信したり、 link:https://docs.aws.amazon.com/ses/latest/"
"DeveloperGuide/send-email-simulator.html[Amazon "
"SESのメールボックスシミュレータ]にメールを送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:63
msgid "You can only send mail from verified email addresses and domains"
msgstr "検証済みのメールアドレスとドメインからのみメールを送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:64
msgid "You can send a maximum of 1 message per second."
msgstr "1秒間に最大1メッセージまで送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:66
msgid ""
"Going production, you'd need to get your account of the sandbox following "
"the https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-"
"access.html[Amazon procedure]."
msgstr ""
"本番にするには、 link:https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-"
"production-access.html[Amazonの手順]に沿ってサンドボックスのアカウントを取得する必要があります。"

#. type: Title ===
#: upstream/_guides/amazon-ses.adoc:67
#, no-wrap
msgid "Set up AWS SES"
msgstr "AWS SESの設定"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:71
msgid ""
"We assume you are going to use AWS SES sandbox for the sake of this guide. "
"But before sending any email, you must verify sender and recipient email "
"addresses using AWS CLI.  You can use your personal email or any temporary "
"email service available if you wish."
msgstr ""
"このガイドでは、AWS SESサンドボックスを使用することを想定しています。しかし、メールを送信する前に、AWS "
"CLIを使って送信者と受信者のメールアドレスを確認する必要があります。必要に応じて、個人のメールや利用可能な一時的なメールサービスを利用することができます。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:76
#, no-wrap
msgid ""
"aws ses verify-email-identity --email-address <sender@email.address>\n"
"aws ses verify-email-identity --email-address <recipient@email.address>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:78
msgid ""
"Now, you need to open a mailboxes of those email addresses in order to "
"follow confirmation procedure. Once email is approved you can use it in your "
"application."
msgstr "ここで、確認のためにメールアドレスのメールボックスを開く必要があります。メールが承認されれば、申請に使用することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:81
msgid ""
"If you are using local SES you still need to verify email addresses, "
"otherwise your send email in order to let local SES accepting your request.  "
"However, no emails to be send as it only mocks the service APIs."
msgstr ""
"ローカルSESを使用している場合は、メールアドレスを確認する必要がありますが、そうでない場合は、ローカルSESにリクエストを受け付けるためにメールを送信します。ただし、サービスのAPIをモックするだけなので、メールは送信されません。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:86
#, no-wrap
msgid ""
"aws ses verify-email-identity --email-address <sender@email.address> --"
"profile localstack --endpoint-url=http://localhost:8012\n"
"aws ses verify-email-identity --email-address <recipient@email.address> --"
"profile localstack --endpoint-url=http://localhost:8012\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:90
msgid ""
"The application built here allows sending text emails to the recipients that "
"are verified on AWS SES."
msgstr "ここで構築したアプリケーションでは、AWS SES上で確認された受信者にテキストメールを送信することができます。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:97
msgid ""
"The solution is located in the `amazon-ses-quickstart` {quickstarts-tree-"
"url}/amazon-ses-quickstart[directory]."
msgstr ""
"ソリューションは `amazon-ses-quickstart` {quickstarts-tree-url}/amazon-ses-"
"quickstart[directory] にあります。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:41
#, no-wrap, fuzzy
msgid "Creating the Maven project"
msgstr "Mavenプロジェクトの作成"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:111
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=amazon-ses-quickstart \\\n"
"    -DclassName=\"org.acme.ses.QuarkusSesSyncResource\" \\\n"
"    -Dpath=\"/sync\" \\\n"
"    -Dextensions=\"resteasy-jackson,amazon-ses,resteasy-mutiny\"\n"
"cd amazon-ses-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:115
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS, "
"Mutiny and Amazon SES Client extensions.  After this, the `amazon-ses` "
"extension has been added to your `pom.xml` as well as the Mutiny support for "
"RESTEasy."
msgstr ""
"このコマンドは、RESTEasy/JAX-RS、Mutiny、Amazon SES "
"ClientエクステンションをインポートしたMavenディレクトリ構造を生成します。 `pom.xml` "
"この後、RESTEasyのMutinyサポートと同様に、 `amazon-ses` エクステンションが追加されています。"

#. type: Title ==
#: upstream/_guides/amazon-dynamodb.adoc:115
#, no-wrap, fuzzy
msgid "Creating JSON REST service"
msgstr "JSON RESTサービスの作成"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:119
msgid ""
"Lets create a `org.acme.ses.QuarkusSesSyncResource` that will provide an API "
"to send emails using the synchronous client."
msgstr ""
"同期クライアントを使用して電子メールを送信するためのAPIを提供する `org.acme.ses.QuarkusSesSyncResource` "
"を作成しましょう。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:123 upstream/_guides/amazon-ses.adoc:225
#, no-wrap
msgid "package org.acme.ses;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:132
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.acme.ses.model.Email;\n"
"import software.amazon.awssdk.services.ses.SesClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:137
#, no-wrap
msgid ""
"@Path(\"/sync\")\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class QuarkusSesSyncResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:140
#, no-wrap
msgid "    @Inject\n"
"    SesClient ses;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:152
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/email\")\n"
"    public String encrypt(Email data) {\n"
"        return ses.sendEmail(req -> req\n"
"            .source(data.getFrom())\n"
"            .destination(d -> d.toAddresses(data.getTo()))\n"
"            .message(msg -> msg\n"
"                .subject(sub -> sub.data(data.getSubject()))\n"
"                .body(b -> b.text(txt -> txt.data(data.getBody())))))."
"messageId();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amazon-ses.adoc:154
#, no-wrap
msgid "Configuring SES clients"
msgstr "SESクライアントの設定"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:159
msgid ""
"Both SES clients (sync and async) are configurable via the `application."
"properties` file that can be provided in the `src/main/resources` directory. "
" Additionally, you need to add to the classpath a proper implementation of "
"the sync client. By default the extension uses the URL connection HTTP "
"client, so you need to add a URL connection client dependency to the `pom."
"xml` file:"
msgstr ""
"SES クライアント (sync と async) は、 `src/main/resources` ディレクトリにある `application."
"properties` "
"ファイルを介して設定可能です。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、拡張機能は URL 接続 "
"HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` ファイルに追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:329
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>software.amazon.awssdk</groupId>\n"
"    <artifactId>url-connection-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:169
msgid ""
"If you want to use Apache HTTP client instead, configure it as follows:"
msgstr "代わりにApache HTTPクライアントを使用したい場合は、以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:172
#, no-wrap
msgid "quarkus.ses.sync-client.type=apache\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:175
msgid "And add the following dependency to the application `pom.xml`:"
msgstr "そして、以下の依存関係をアプリケーションの `pom.xml`に追加します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:344
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>software.amazon.awssdk</groupId>\n"
"    <artifactId>apache-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:184
msgid "If you're going to use a local SES instance, configure it as follows:"
msgstr "ローカルのSESインスタンスを使用する場合は、以下のように設定します："

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:188
#, no-wrap
msgid "quarkus.ses.endpoint-override=http://localhost:8012\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:193
#, no-wrap
msgid ""
"quarkus.ses.aws.region=us-east-1\n"
"quarkus.ses.aws.credentials.type=static\n"
"quarkus.ses.aws.credentials.static-provider.access-key-id=test-key\n"
"quarkus.ses.aws.credentials.static-provider.secret-access-key=test-secret\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:196
msgid ""
"`quarkus.ses.aws.region` - It's required by the client, but since you're "
"using a local SES instance use `us-east-1` as it's a default region of "
"localstack's SES."
msgstr ""
"`quarkus.ses.aws.region` - "
"クライアントで必要ですが、ローカルのSESインスタンスを使用しているので、ローカルスタックのSESのデフォルトリージョンである `us-east-1` "
"を使用してください。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:197
msgid ""
"`quarkus.ses.aws.credentials.type` - Set `static` credentials provider with "
"any values for `access-key-id` and `secret-access-key`"
msgstr ""
"`quarkus.ses.aws.credentials.type` - `static` 資格情報プロバイダを設定し、 `access-key-id` "
"と `secret-access-key`を任意の値で設定します"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:198
msgid ""
"`quarkus.ses.endpoint-override` - Override the SES client to use a local "
"instance instead of an AWS service"
msgstr ""
"`quarkus.ses.endpoint-override` - SES クライアントをオーバーライドして AWS "
"サービスの代わりにローカルインスタンスを使うようにする"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:201
msgid ""
"If you want to work with an AWS account, you can simply remove or comment "
"out all Amazon SES related properties. By default, the SES client extension "
"will use the `default` credentials provider chain that looks for credentials "
"in this order:"
msgstr ""
"AWSアカウントで作業したい場合は、Amazon "
"SES関連のプロパティをすべて削除するかコメントアウトするだけです。デフォルトでは、SESクライアントエクステンションは、`default` "
"クレデンシャルプロバイダチェーンは使用し、以下の順番でクレデンシャルを検索します："

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:205
msgid "And the region from your AWS CLI profile will be used."
msgstr "そして、AWS CLIプロファイルからのリージョンが使用されます。"

#. type: Title ==
#: upstream/_guides/amazon-dynamodb.adoc:374
#, no-wrap, fuzzy
msgid "Next steps"
msgstr "次のステップ"

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:376
#, no-wrap, fuzzy
msgid "Packaging"
msgstr "パッケージング"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:212
msgid ""
"Packaging your application is as simple as `./mvnw clean package`.  It can "
"be run with `java -jar target/amazon-ses-quickstart-1.0-SNAPSHOT-runner.jar`."
""
msgstr ""
"アプリケーションのパッケージ化は `./mvnw clean package` のように簡単です。 `java -jar target/amazon-"
"ses-quickstart-1.0-SNAPSHOT-runner.jar` で実行できます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:383
#, fuzzy
msgid ""
"With GraalVM installed, you can also create a native executable binary: `./"
"mvnw clean package -Dnative`.  Depending on your system, that will take some "
"time."
msgstr ""
"GraalVMをインストールした状態で、ネイティブの実行バイナリを作成することもできます: `./mvnw clean package -"
"Dnative`.お使いのシステムにもよりますが、時間がかかります。"

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:384
#, no-wrap, fuzzy
msgid "Going asynchronous"
msgstr "非同期に行く"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:387
#, fuzzy
msgid ""
"Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the "
"asynchronous programming model out of the box."
msgstr "Quarkusの拡張機能で使われているAWS SDK v2.xのおかげで、非同期プログラミングモデルをすぐに使えるようになりました。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:221
msgid ""
"Create a `org.acme.ses.QuarkusSesAsyncResource` REST resource that will be "
"similar to our `QuarkusSesSyncResource` but using an asynchronous "
"programming model."
msgstr ""
"`org.acme.ses.QuarkusSesAsyncResource` RESTリソースを作成します。 "
"`QuarkusSesSyncResource` と似ていますが、非同期プログラミングモデルを使用しています。"

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:236
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.acme.ses.model.Email;\n"
"import software.amazon.awssdk.services.ses.SesAsyncClient;\n"
"import software.amazon.awssdk.services.ses.model.SendEmailResponse;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:241
#, no-wrap
msgid ""
"@Path(\"/async\")\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class QuarkusSesAsyncResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:244
#, no-wrap
msgid "    @Inject\n"
"    SesAsyncClient ses;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-ses.adoc:259
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/email\")\n"
"    public Uni<String> encrypt(Email data) {\n"
"        return Uni.createFrom()\n"
"            .completionStage(\n"
"                ses.sendEmail(req -> req\n"
"                    .source(data.getFrom())\n"
"                    .destination(d -> d.toAddresses(data.getTo()))\n"
"                    .message(msg -> msg\n"
"                        .subject(sub -> sub.data(data.getSubject()))\n"
"                        .body(b -> b.text(txt -> txt.data(data."
"getBody()))))))\n"
"            .onItem().apply(SendEmailResponse::messageId);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:261
msgid ""
"We create `Uni` instances from the `CompletionStage` objects returned by the "
"asynchronous SES client, and then transform the emitted item."
msgstr ""
"非同期SESクライアントから返された `CompletionStage` オブジェクトから `Uni` "
"インスタンスを作成し、生成されたアイテムを変換します。"

#. type: Plain text
#: upstream/_guides/amazon-ses.adoc:263
msgid "And we need to add the Netty HTTP client dependency to the `pom.xml`:"
msgstr "そして、NETTY HTTPクライアント依存関係を `pom.xml`に追加する必要があります："

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:477
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>software.amazon.awssdk</groupId>\n"
"    <artifactId>netty-nio-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/performance-measure.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Measuring Performance"
msgstr "Quarkus - パフォーマンスの測定"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:11
#, fuzzy
msgid "This guide covers:"
msgstr "このガイドではカバーしています。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:13
#, fuzzy
msgid "how we measure memory usage"
msgstr "メモリ使用量の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:14
#, fuzzy
msgid "how we measure startup time"
msgstr "起動時間の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:15
#, fuzzy
msgid "which additional flags will Quarkus apply to native-image by default"
msgstr "Quarkusがデフォルトでネイティブイメージに適用する追加フラグ"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:18
#, fuzzy
msgid ""
"All of our tests are run on the same hardware for a given batch.  It goes "
"without saying but it's better when you say it."
msgstr "私たちのテストはすべて、与えられたバッチに対して同じハードウェアで実行されます。言うまでもないことですが、言ってくれた方がいいですよね。"

#. type: Title ==
#: upstream/_guides/performance-measure.adoc:19
#, no-wrap, fuzzy
msgid "How do we measure memory usage"
msgstr "メモリ使用量の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:24
#, fuzzy
msgid ""
"When measuring the footprint of a Quarkus application, we measure https://en."
"wikipedia.org/wiki/Resident_set_size[Resident Set Size (RSS)] and not the "
"JVM heap size which is only a small part of the overall problem.  The JVM "
"not only allocates native memory for heap (`-Xms`, `-Xmx`) but also "
"structures required by the jvm to run your application. Depending on the JVM "
"implementation, the total memory allocated for an application will include, "
"but not limited to:"
msgstr ""
"Quarkusアプリケーションのフットプリントを測定する際には、 link:https://en.wikipedia.org/wiki/"
"Resident_set_size[常駐セットサイズ（RSS）を]測定し、JVMのヒープサイズではなく、全体的な問題のほんの一部です。JVMは、ヒープ用のネイティブメモリ( "
"`-Xms`, `-"
"Xmx`)を割り当てるだけでなく、アプリケーションを実行するためにjvmが必要とする構造体も割り当てます。JVMの実装に応じて、アプリケーションに割り当てられる総メモリは、以下のものを含みますが、これに限定されません。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:26
#, fuzzy
msgid "Heap space"
msgstr "ヒープ空間"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:27
#, fuzzy
msgid "Class metadata"
msgstr "クラスのメタデータ"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:28
#, fuzzy
msgid "Thread stacks"
msgstr "スレッドスタック"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:29
#, fuzzy
msgid "Compiled code"
msgstr "コンパイルされたコード"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:30
#, fuzzy
msgid "Garbage collection"
msgstr "ゴミの収集"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:31
#, no-wrap, fuzzy
msgid "Native Memory Tracking"
msgstr "ネイティブメモリのトラッキング"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:34
#, fuzzy
msgid ""
"In order to view the native memory used by the JVM, you can enable the https:"
"//docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html[Native Memory "
"Tracking] (NMT) feature in hotspot;"
msgstr ""
"JVMで使用されているネイティブメモリを表示するには、hotspotでNMT( link:https://docs.oracle.com/javase/"
"8/docs/technotes/guides/vm/nmt-8.html[Native Memory Tracking])機能を有効にします。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:36
#, fuzzy
msgid "Enable NMT on the command line;"
msgstr "コマンドラインでNMTを有効にします。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:38
#, no-wrap, fuzzy
msgid " -XX:NativeMemoryTracking=[off | summary | detail] <1>\n"
msgstr ""
"<pre>-XX:NativeMemoryTracking=[off | summary | detail]<b class="
"\"conum\">(1)</b></pre>"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:40
#, fuzzy
msgid ""
"NOTE: this feature will add cause an approximately 5-10% performance "
"overhead"
msgstr ""
"<div class=\"title\">\n"
"  留意事項 \n"
"</div>  この機能は、約 5-10% のパフォーマンスオーバーヘッドを発生させます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:42
#, fuzzy
msgid ""
"It is then possible to use jcmd to dump a report of the native memory usage "
"of the Hotspot JVM running your application;"
msgstr "そして、jcmdを使ってアプリケーションを実行しているHotspot JVMのネイティブメモリ使用量のレポートをダンプすることができます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:44
#, no-wrap, fuzzy
msgid ""
" jcmd <pid> VM.native_memory [summary | detail | baseline | summary.diff | "
"detail.diff | shutdown] [scale= KB | MB | GB]\n"
msgstr ""
"<pre>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | "
"summary.diff | detail.diff | shutdown] [scale= KB | MB | GB] [scale= KB | MB "
"| GB</pre>"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:45
#, no-wrap, fuzzy
msgid "Cloud Native Memory Limits"
msgstr "クラウドネイティブのメモリ制限"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:49
#, fuzzy
msgid ""
"It is important to measure the whole memory to see the impact of a Cloud "
"Native application.  It is particularly true of container environments which "
"will kill a process based on its full RSS memory usage."
msgstr ""
"Cloud "
"Nativeアプリケーションの影響を見るためには、メモリ全体を測定することが重要です。特にコンテナ環境では、RSSメモリのフル使用量に基づいてプロセスを強制終了させてしまうことがあります。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:53
#, fuzzy
msgid ""
"Likewise, don't fall into the trap of only measuring private memory which is "
"what the process uses that is not shareable with other processes.  While "
"private memory might be useful in a environment deploying many different "
"applications (and thus sharing memory a lot), it is very misleading in "
"environments like Kubernetes/OpenShift."
msgstr ""
"同様に、他のプロセスと共有できないプロセスが使用しているプライベートメモリだけを測定するという罠にはまらないようにしましょう。プライベートメモリは、多くの異なるアプリケーションをデプロイする環境（したがってメモリを多く共有する）では有用かもしれませんが、Kubernetes/"
"OpenShiftのような環境では非常に誤解を招く可能性があります。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:54
#, no-wrap, fuzzy
msgid "Platform Specific Memory Reporting"
msgstr "プラットフォーム固有のメモリレポート"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:57
#, fuzzy
msgid ""
"In order to not incur the performance overhead of running with NVM enabled, "
"we measure the total RSS of an JVM application using tools specific to each "
"platform."
msgstr ""
"NVMを有効にして実行することによるパフォーマンスオーバーヘッドを発生させないために、各プラットフォームに特化したツールを使用して、JVMアプリケーションの総RSSを測定します。"

#. type: Labeled list
#: upstream/_guides/performance-measure.adoc:58
#, no-wrap, fuzzy
msgid "Linux"
msgstr "リナックス"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:61
#, fuzzy
msgid ""
"The linux https://linux.die.net/man/1/pmap[pmap] and https://linux.die.net/"
"man/1/ps[ps] tools provide a report on the native memory map for a process"
msgstr ""
"Linux の link:https://linux.die.net/man/1/pmap[pmap]と link:https://linux.die."
"net/man/1/ps[ps]ツールはプロセスのネイティブメモリマップのレポートを提供します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:65
#, no-wrap
msgid " $ ps -o pid,rss,command -p <pid>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:68
#, no-wrap
msgid ""
"   PID   RSS COMMAND\n"
" 11229 12628 ./target/getting-started-1.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:73
#, no-wrap
msgid " $ pmap -x <pid>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:87
#, no-wrap
msgid ""
" 13150:   /data/quarkus-application -Xmx100m -Xmn70m\n"
" Address           Kbytes     RSS   Dirty Mode  Mapping\n"
" 0000000000400000   55652   30592       0 r-x-- quarkus-application\n"
" 0000000003c58000       4       4       4 r-x-- quarkus-application\n"
" 0000000003c59000    5192    4628     748 rwx-- quarkus-application\n"
" 00000000054c0000     912     156     156 rwx--   [ anon ]\n"
" ...\n"
" 00007fcd13400000    1024    1024    1024 rwx--   [ anon ]\n"
" ...\n"
" 00007fcd13952000       8       4       0 r-x-- libfreebl3.so\n"
" ...\n"
" ---------------- ------- ------- -------\n"
" total kB         9726508  256092  220900\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:90
#, fuzzy
msgid "Each Memory region that has been allocated for the process is listed;"
msgstr "プロセスに割り当てられた各メモリ領域が一覧表示されます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:92
#, fuzzy
msgid "Address: Start address of virtual address space"
msgstr "アドレス。仮想アドレス空間の開始アドレス"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:93
#, fuzzy
msgid "Kbytes: Size (kilobytes) of virtual address space reserved for region"
msgstr "Kbytes（キロバイト）。リージョン用に予約された仮想アドレス空間のサイズ (キロバイト)"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:94
#, no-wrap, fuzzy
msgid ""
"RSS:     Resident set size (kilobytes).  This is the measure of how much "
"memory space is actually being used\n"
msgstr "RSSです。常駐セットサイズ（キロバイト）。これは、実際に使用されているメモリ領域の量を示す指標です。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:95
#, no-wrap, fuzzy
msgid "Dirty:   dirty pages (both shared and private) in kilobytes\n"
msgstr "ダーティ: ダーティなページ (共有およびプライベートの両方) をキロバイト単位で表示します。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:96
#, no-wrap, fuzzy
msgid "Mode:    Access mode for memory region\n"
msgstr "モード。メモリ領域のアクセスモード"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:97
#, no-wrap, fuzzy
msgid ""
"Mapping: Includes application regions and Shared Object (.so) mappings for "
"process\n"
msgstr "マッピング。プロセス用のアプリケーション領域と共有オブジェクト(.so)のマッピングを含む"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:99
#, fuzzy
msgid ""
"The Total RSS (kB) line reports the total native memory the process is using."
""
msgstr "Total RSS (kB)行は、プロセスが使用しているネイティブメモリの合計を報告します。"

#. type: Labeled list
#: upstream/_guides/performance-measure.adoc:100
#, no-wrap, fuzzy
msgid "macOS"
msgstr "マックオーエス"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:102
#, fuzzy
msgid ""
"On macOS, you can use `ps x -o pid,rss,command -p <PID>` which list the RSS "
"for a given process in KB (1024 bytes)."
msgstr ""
"macOSでは、特定のプロセスのRSSをKB(1024バイト)単位で一覧表示する `ps x -o pid,rss,command -p "
"&amp;lt;PID&amp;gt;` を使用することができます。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:106
#, no-wrap
msgid "$ ps x -o pid,rss,command -p 57160\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:109
#, no-wrap
msgid ""
"  PID    RSS COMMAND\n"
"57160 288548 /Applications/IntelliJ IDEA CE.app/Contents/jdk/Contents/Home/"
"jre/bin/java\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:112
#, fuzzy
msgid "Which means IntelliJ IDEA consumes 281,8 MB of resident memory."
msgstr "つまり、IntelliJ IDEAは281,8MBの常駐メモリを消費していることになります。"

#. type: Title ==
#: upstream/_guides/performance-measure.adoc:113
#, no-wrap, fuzzy
msgid "How do we measure startup time"
msgstr "起動時間の測定方法"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:118
#, fuzzy
msgid ""
"Some frameworks use aggressive lazy initialization techniques.  It is "
"important to measure the startup time to first request to most accurately "
"reflect how long a framework needs to start.  Otherwise, you will miss the "
"time the framework _actually_ takes to initialize."
msgstr ""
"フレームワークの中には、アグレッシブな遅延初期化テクニックを使用しているものがあります。フレームワークを開始するために必要な時間を最も正確に反映させるために、最初のリクエストまでの起動時間を測定することが重要です。そうしないと、フレームワークが "
"_実際に_初期化にかかる時間を見逃してしまいます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:120
#, fuzzy
msgid "Here is how we measure startup time in our tests."
msgstr "ここでは、テストでの起動時間の測定方法を説明します。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:122
#, fuzzy
msgid ""
"We create a sample application that logs timestamps for certain points in "
"the application lifecycle."
msgstr "アプリケーションのライフサイクルの特定のポイントのタイムスタンプをログに記録するサンプルアプリケーションを作成します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:127
#, no-wrap
msgid "@Path(\"/\")\n"
"public class GreetingEndpoint {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:129
#, no-wrap
msgid "    private static final String template = \"Hello, %s!\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:138
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/greeting\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Greeting greeting(@QueryParam(\"name\") String name) {\n"
"        System.out.println(new SimpleDateFormat(\"HH:mm:ss.SSS\").format(new "
"java.util.Date(System.currentTimeMillis())));\n"
"        String suffix = name != null ? name : \"World\";\n"
"        return new Greeting(String.format(template, suffix));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:143
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent startup) {\n"
"        System.out.println(new SimpleDateFormat(\"HH:mm:ss.SSS\").format(new "
"Date()));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:146
#, fuzzy
msgid ""
"We start looping in a shell, sending requests to the rest endpoint of the "
"sample application we are testing."
msgstr "私たちはシェル内でループを開始し、テストしているサンプルアプリケーションの残りのエンドポイントにリクエストを送信します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:150
#, no-wrap
msgid ""
"$ while [[ \"$(curl -s -o /dev/null -w ''%{http_code}'' localhost:8080/api/"
"greeting)\" != \"200\" ]]; do sleep .00001; done\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:153
#, fuzzy
msgid ""
"In a separate terminal, we start the timing application that we are testing, "
"printing the time the application starts"
msgstr "別の端末で、テストしているタイミングアプリケーションを起動し、アプリケーションが起動した時刻を印刷します。"

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:157
#, no-wrap
msgid "$ date +\"%T.%3N\" &&  ./target/quarkus-timing-runner\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/performance-measure.adoc:163
#, no-wrap
msgid ""
"10:57:32.508\n"
"10:57:32.512\n"
"2019-04-05 10:57:32,512 INFO  [io.quarkus] (main) Quarkus 0.11.0 started in "
"0.002s. Listening on: http://127.0.0.1:8080\n"
"2019-04-05 10:57:32,512 INFO  [io.quarkus] (main) Installed features: [cdi, "
"resteasy, resteasy-jackson]\n"
"10:57:32.537\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:166
#, fuzzy
msgid ""
"The difference between the final timestamp and the first timestamp is the "
"total startup time for the application to serve the first request."
msgstr "最終タイムスタンプと最初のタイムスタンプの差は、アプリケーションが最初のリクエストにサービスを提供するための総起動時間です。"

#. type: Title ==
#: upstream/_guides/performance-measure.adoc:167
#, no-wrap, fuzzy
msgid "Additional flags applied by Quarkus"
msgstr "Quarkusで適用される追加フラグ"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:170
#, fuzzy
msgid ""
"When Quarkus invokes GraalVM `native-image` it will apply some additional "
"flags by default."
msgstr "QuarkusがGraalVMを起動すると、 `native-image` デフォルトでいくつかの追加フラグが適用されます。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:172
#, fuzzy
msgid ""
"You might want to know about the following ones in case you're comparing "
"performance properties with other builds."
msgstr "他のビルドと性能特性を比較する場合には、以下のようなものを知っておくと良いでしょう。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:173
#, no-wrap, fuzzy
msgid "Disable fallback images"
msgstr "フォールバック画像を無効にする"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:177
#, fuzzy
msgid ""
"Fallback native images are a feature of GraalVM to \"fall back\" to run your "
"application in the normal JVM, should the compilation to native code fail "
"for some reason."
msgstr ""
"フォールバックネイティブイメージは、何らかの理由でネイティブコードへのコンパイルに失敗した場合に、アプリケーションを通常のJVMで実行するために「フォールバック」するためのGraalVMの機能です。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:180
#, fuzzy
msgid ""
"Quarkus disables this feature by setting `-H:FallbackThreshold=0`: this will "
"ensure you get a compilation failure rather risking to not notice that the "
"application is unable to really run in native mode."
msgstr ""
"Quarkusは、 `-H:FallbackThreshold=0` "
"を設定することでこの機能を無効にします。これにより、アプリケーションが本当にネイティブモードで実行できないことに気づかないリスクを冒して、コンパイルに失敗することが確実になります。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:182
#, fuzzy
msgid ""
"If you instead want to just run in Java mode, that's totally possible: just "
"skip the native-image build and run it as a jar."
msgstr "代わりに Java モードで実行したい場合は、ネイティブイメージのビルドをスキップして jar として実行することも可能です。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:183
#, no-wrap, fuzzy
msgid "Disable Isolates"
msgstr "アイソレートを無効にする"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:186
#, fuzzy
msgid ""
"Isolates are a neat feature of GraalVM, but Quarkus isn't using them at this "
"stage."
msgstr "アイソレートはGraalVMの優れた機能ですが、Quarkusは現段階では使用していません。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:188
#, fuzzy
msgid "Disable via `-H:-SpawnIsolates`."
msgstr "`-H:-SpawnIsolates` で無効化する。"

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:189
#, no-wrap, fuzzy
msgid "Disable auto-registration of all Service Loader implementations"
msgstr "すべてのサービスローダ実装の自動登録を無効にする"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:193
#, fuzzy
msgid ""
"Quarkus extensions can automatically pick the right services they need, "
"while GraalVM's native-image defaults to include all services it's able to "
"find on the classpath."
msgstr ""
"Quarkusの拡張機能では、必要なサービスを自動的に選択することができますが、GraalVMのネイティブイメージのデフォルトでは、クラスパス上で見つけることができるすべてのサービスが含まれています。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:195
#, fuzzy
msgid ""
"We prefer listing services explicitly as it produces better optimised "
"binaries. Disable it as well by setting `-H:-UseServiceLoaderFeature`."
msgstr ""
"サービスを明示的にリストアップした方が最適化されたバイナリが生成されるので好ましいです。 `-H:-UseServiceLoaderFeature`."

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:196
#, no-wrap, fuzzy
msgid "Better default for Garbage Collection implementation"
msgstr "ガベージコレクションの実装のためのより良いデフォルト"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:199
#, fuzzy
msgid ""
"The default in GraalVM seems meant to optimise for short lived processes."
msgstr "GraalVMのデフォルトは、短命なプロセスに最適化することを意図しているようです。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:202
#, no-wrap, fuzzy
msgid ""
"Quarkus defaults to server applications, so we switch to a better default by "
"setting\n"
" `-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge."
"CollectionPolicy$BySpaceAndTime`.\n"
msgstr ""
"Quarkusのデフォルトはサーバーアプリケーションになっているので、 `-H:InitialCollectionPolicy=com.oracle."
"svm.core.genscavenge.CollectionPolicy$BySpaceAndTime`."

#. type: Title ===
#: upstream/_guides/performance-measure.adoc:203
#, no-wrap, fuzzy
msgid "Others ..."
msgstr "その他..."

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:208
#, no-wrap, fuzzy
msgid ""
"This section is provided as high level guidance, but can't presume to be "
"comprehensive as some flags are controlled\n"
" dynamically by the extensions, the platform you're building on, "
"configuration details, your code and possibly\n"
" a combination of any of these.\n"
msgstr ""
"このセクションは高レベルのガイダンスとして提供されていますが、フラグのいくつかは拡張機能や構築しているプラットフォーム、設定の詳細、あなたのコード、そしておそらくこれらの組み合わせによって動的に制御されるため、包括的なものとは考えられません。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:211
#, fuzzy
msgid ""
"Generally speaking the ones listed here are those most likely to affect "
"performance metrics, but in the right circumstances one could observe non "
"negligible impact from the other flags too."
msgstr ""
"一般的に言えば、ここに挙げたものはパフォーマンス・メトリクスに影響を与える可能性が高いものですが、適切な状況下では、他のフラグからも無視できないほどの影響を受ける可能性があります。"

#. type: Plain text
#: upstream/_guides/performance-measure.adoc:214
#, fuzzy
msgid ""
"If you're to investigate some differences in detail make sure to check what "
"Quarkus is invoking exactly: when the build plugin is producing a native "
"image, the full command lines are logged."
msgstr "ビルドプラグインがネイティブイメージを生成しているときには、コマンドライン全体がログに記録されます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cassandra.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using the Cassandra Client"
msgstr "Quarkus - Cassandraクライアントの使用"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:13
#, fuzzy
msgid ""
"Apache Cassandra® is a free and open-source, distributed, wide column store, "
"NoSQL database management system designed to handle large amounts of data "
"across many commodity servers, providing high availability with no single "
"point of failure."
msgstr ""
"Apache "
"Cassandra®は、フリーでオープンソースの分散型ワイドカラムストアのNoSQLデータベース管理システムで、多くのコモディティサーバーにまたがる大量のデータを処理するように設計されており、単一障害点のない高可用性を提供します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:15
#, fuzzy
msgid ""
"In this guide, we will see how you can get your REST services to use a "
"Cassandra database."
msgstr "このガイドでは、RESTサービスでCassandraデータベースを使用する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:25
#, fuzzy
msgid ""
"GraalVM installed with `GRAALVM_HOME` configured appropriately if you want "
"to use the native mode."
msgstr "ネイティブモードを使用したい場合は、 `GRAALVM_HOME` を適切に設定して GraalVM をインストールしてください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:27
#, fuzzy
msgid "Cassandra or Docker installed"
msgstr "CassandraまたはDockerのインストール"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:32
#, fuzzy
msgid ""
"The application built in this guide is quite simple: the user can add "
"elements in a list using a form, and the items list is updated."
msgstr ""
"このガイドで構築されたアプリケーションは非常にシンプルです：ユーザーはフォームを使用してリストに要素を追加することができ、アイテムリストが更新されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:34
#, fuzzy
msgid ""
"All the information between the browser and the server is formatted as JSON."
msgstr "ブラウザとサーバ間の情報はすべてJSON形式になっています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:36
#, fuzzy
msgid "The elements are stored in the Cassandra database."
msgstr "要素はカサンドラ・データベースに格納されています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:45
#, fuzzy
msgid ""
"The solution is located in the `quickstart` link:https://github.com/datastax/"
"cassandra-quarkus/tree/master/quickstart[directory]."
msgstr ""
"ソリューションは `quickstart`  link:https://github.com/datastax/cassandra-quarkus/"
"tree/master/quickstart[ディレクトリ]にあります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:50
#, fuzzy
msgid ""
"First, create a new Maven project and copy the `pom.xml` file that is "
"present in the `quickstart` directory."
msgstr ""
"まず、新しいMavenプロジェクトを作成し、 `quickstart` ディレクトリに存在する `pom.xml` ファイルをコピーします。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:53
#, fuzzy
msgid ""
"The `pom.xml` is importing the RESTEasy/JAX-RS, JSON-B, Context Propagation "
"and Cassandra Client extensions."
msgstr ""
"`pom.xml` は、RESTEasy/JAX-RS、JSON-B、Context "
"Propagation、Cassandraクライアント拡張機能をインポートしています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:57
#, fuzzy
msgid ""
"We will be building a REST application using the link:https://docs.datastax."
"com/en/developer/java-driver/latest/manual/mapper[DataStax Object Mapper] to "
"simplify the Data Access Layer code."
msgstr ""
"link:https://docs.datastax.com/en/developer/java-driver/latest/manual/"
"mapper[DataStax Object Mapper]を使ってRESTアプリケーションを構築し、Data Access "
"Layerのコードを簡略化していきます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:59
#, fuzzy
msgid ""
"The most important part of the `pom.xml` is adding the `cassandra-quarkus` "
"extension:"
msgstr "`pom.xml` で最も重要なのは、 `cassandra-quarkus` の拡張子を追加することです。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:67
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>com.datastax.oss.quarkus</groupId>\n"
"    <artifactId>cassandra-quarkus-client</artifactId>\n"
"    <version>${quarkus.version}</version>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:73
#, fuzzy
msgid ""
"Also make sure to follow the link:https://docs.datastax.com/en/developer/"
"java-driver/latest/manual/mapper/config/[instructions] on how to add an "
"annotation processor to the compiler configuration. When the project is "
"compiled, additional mapper classes are generated."
msgstr ""
"また、コンパイラの設定にアノテーションプロセッサを追加する方法の link:https://docs.datastax.com/en/developer/"
"java-driver/latest/manual/mapper/config/"
"[説明]にも必ず従ってください。プロジェクトがコンパイルされると、追加のマッパークラスが生成されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:98
#, fuzzy
msgid ""
"In this example, we will create an application to manage a list of fruits."
msgstr "この例では、果物のリストを管理するアプリケーションを作成します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:100
#, fuzzy
msgid "First, let's create the `Fruit` bean as follows:"
msgstr "まず、以下のように `Fruit` Bean を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:84
#, no-wrap
msgid "@Entity\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:88
#, no-wrap
msgid ""
"    @PartitionKey private String storeId;\n"
"    @ClusteringColumn private String name;\n"
"    private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:90
#, no-wrap
msgid "    public Fruit() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:96
#, no-wrap
msgid ""
"    public Fruit(String storeId, String name, String description) {\n"
"      this.storeId = storeId;\n"
"      this.name = name;\n"
"      this.description = description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:99
#, no-wrap
msgid "    // getters, setters, hashCode and equals omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:105
#, fuzzy
msgid ""
"We are using DataStax Java driver Object Mapper, which is why this class is "
"annotated with an `@Entity`. Also, the `storeId` field represents a "
"Cassandra partition key and `name` represents a clustering column, and so we "
"are using the corresponding annotations from the Object Mapper library.  It "
"will allow the Mapper to generate proper CQL queries underneath."
msgstr ""
"DataStax JavaドライバのObject Mapperを使用しているので、このクラスには `@Entity` "
"がアノテーションされています。また、 `storeId` フィールドは Cassandra パーティション・キーを表し、 `name` "
"はクラスタリング・カラムを表しているので、Object Mapper "
"ライブラリから対応するアノテーションを使用しています。これにより、Mapperはその下に適切なCQLクエリを生成することができるようになります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:107
#, fuzzy
msgid "Entity classes are required to have a default no-args constructor."
msgstr "エンティティクラスは、デフォルトの no-args コンストラクタを持つ必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:109
#, fuzzy
msgid "To leverage the Mapper logic in this app we need to create a DAO:"
msgstr "このアプリでMapperロジックを活用するには、DAOを作成する必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:116
#, no-wrap
msgid ""
"@Dao\n"
"public interface FruitDao {\n"
"  @Update\n"
"  void update(Fruit fruit);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:120
#, no-wrap
msgid "  @Select\n"
"  PagingIterable<Fruit> findById(String id);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:123
#, fuzzy
msgid "This class exposes operations that will be used in the REST service."
msgstr "このクラスは、RESTサービスで使用される操作を公開します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:125
#, fuzzy
msgid "Finally, the Mapper itself:"
msgstr "最後にMapperそのもの。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:133
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  @DaoFactory\n"
"  FruitDao fruitDao();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:138
#, fuzzy
msgid ""
"The mapper is responsible for constructing instances of `FruitDao`. In the "
"example above, the `FruitDao` instance will be connected to the same "
"keyspace as the underlying session. More on that below."
msgstr ""
"マッパーは `FruitDao` のインスタンスを構築する責任があります。上の例では、 `FruitDao` "
"のインスタンスは、基礎となるセッションと同じ鍵空間に接続されます。詳細は後述します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:142
#, fuzzy
msgid ""
"It is also possible to create DAO instances for different keyspaces. To "
"learn how, see link:https://docs.datastax.com/en/developer/java-driver/4.7/"
"manual/mapper/mapper/#dao-parameterization[DAO parameterization] in the "
"driver docs."
msgstr ""
"異なるキースペース用の DAO インスタンスを作成することも可能です。方法については、ドライバドキュメントの link:https://docs."
"datastax.com/en/developer/java-driver/4.7/manual/mapper/mapper/#dao-"
"parameterization[DAO パラメータ化]を参照してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:146
#, fuzzy
msgid ""
"Next, we need a component to create our DAO instances: `FruitDaoProducer`. "
"Indeed, Mapper and Dao instances are stateful objects, and should be created "
"only once, as application-scoped singletons.  This component will do exactly "
"that, leveraging Quarkus Dependency Injection container:"
msgstr ""
"次に、DAO インスタンスを作成するためのコンポーネントが必要です: `FruitDaoProducer`."
"実際、MapperとDaoインスタンスはステートフルオブジェクトであり、アプリケーションスコープ付きのシングルトンとして一度だけ作成する必要があります。このコンポーネントは、Quarkus "
"Dependency Injectionコンテナを利用して、まさにそれを行います。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:155
#, no-wrap
msgid ""
"import com.datastax.oss.driver.api.core.CqlIdentifier;\n"
"import com.datastax.oss.quarkus.runtime.api.config.CassandraClientConfig;\n"
"import com.datastax.oss.quarkus.runtime.api.session.QuarkusCqlSession;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.inject.Produces;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:157
#, no-wrap
msgid "public class FruitDaoProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:160
#, no-wrap
msgid ""
"  private final FruitDao fruitDao;\n"
"  private final FruitDaoReactive fruitDaoReactive;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:169
#, no-wrap
msgid ""
"  @Inject\n"
"  public FruitDaoProducer(QuarkusCqlSession session) {\n"
"    // create a mapper\n"
"    FruitMapper mapper = new FruitMapperBuilder(session).build();\n"
"    // instantiate our Daos\n"
"    fruitDao = mapper.fruitDao();\n"
"    fruitDaoReactive = mapper.fruitDaoReactive();\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:175
#, no-wrap
msgid ""
"  @Produces\n"
"  @ApplicationScoped\n"
"  FruitDao produceFruitDao() {\n"
"    return fruitDao;\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:182
#, no-wrap
msgid ""
"  @Produces\n"
"  @ApplicationScoped\n"
"  FruitDaoReactive produceFruitDaoReactive() {\n"
"    return fruitDaoReactive;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:186
#, fuzzy
msgid ""
"Note how the `QuarkusCqlSession` instance is injected automatically by the "
"cassandra-quarkus extension in the `FruitDaoProducer` constructor."
msgstr ""
"`QuarkusCqlSession` のインスタンスが `FruitDaoProducer` コンストラクタの cassandra-quarkus "
"拡張機能によって自動的に注入されていることに注意してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:189
#, fuzzy
msgid ""
"Also note that `FruitMapperBuilder` is one of the classes generated "
"automatically by the `java-driver-mapper-processor` annotation processor."
msgstr ""
"また、 `FruitMapperBuilder` は `java-driver-mapper-processor` "
"アノテーション・プロセッサによって自動的に生成されるクラスの一つであることにも注意してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:192
#, fuzzy
msgid ""
"Now create a `FruitService` that will be the business layer of our "
"application and store/load the fruits from the Cassandra database."
msgstr ""
"今、私たちのアプリケーションのビジネス層となる `FruitService` を作成し、Cassandraデータベースから果実を保存/ロードします。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:197
#, no-wrap
msgid "@ApplicationScoped\n"
"public class FruitService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:199
#, no-wrap
msgid "  private final FruitDao dao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:204
#, no-wrap
msgid ""
"  @Inject\n"
"  public FruitService(FruitDao dao) {\n"
"    this.dao = dao;\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:208
#, no-wrap
msgid "  public void save(Fruit fruit) {\n"
"    dao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:213
#, no-wrap
msgid ""
"  public List<Fruit> get(String id) {\n"
"    return dao.findById(id).all();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:217
#, fuzzy
msgid ""
"Note how the service receives a `FruitDao` instance in the constructor. This "
"DAO instance is provided by `FruitDaoProducer` and injected automatically."
msgstr ""
"サービスがコンストラクタで `FruitDao` インスタンスを受け取る様子に注目してください。この DAO インスタンスは "
"`FruitDaoProducer` によって提供され、自動的に注入されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:219
#, fuzzy
msgid ""
"The last missing piece is the REST API that will expose GET and POST methods:"
""
msgstr "最後の欠落した部分は、GETとPOSTメソッドを公開するREST APIです。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:139
#, no-wrap
msgid "@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:226
#, no-wrap
msgid "  private static final String STORE_NAME = \"acme\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:228
#, no-wrap
msgid "  @Inject FruitService fruitService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:235
#, no-wrap
msgid ""
"  @GET\n"
"  public List<FruitDto> list() {\n"
"    return fruitService.get(STORE_NAME).stream()\n"
"        .map(fruit -> new FruitDto(fruit.getName(), fruit.getDescription()))\n"
"        .collect(Collectors.toList());\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:240
#, no-wrap
msgid ""
"  @POST\n"
"  public void add(FruitDto fruit) {\n"
"    fruitService.save(covertFromDto(fruit));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:245 upstream/_guides/cassandra.adoc:527
#, no-wrap
msgid ""
"  private Fruit covertFromDto(FruitDto fruitDto) {\n"
"    return new Fruit(fruitDto.getName(), fruitDto.getDescription(), "
"STORE_NAME);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:251
#, fuzzy
msgid ""
"The `list` and `add` operations are executed for the `storeId` \"acme\". "
"This is the partition key of our data model. We can easily retrieve all rows "
"from cassandra using that partition key.  They will be sorted by the "
"clustering column. `FruitResource` is using `FruitService` which "
"encapsulates the data access logic."
msgstr ""
"`list` と `add` の操作は、 `storeId` \"acme\" "
"に対して実行されます。これは、私たちのデータ・モデルのパーティション・キーです。このパーティション・キーを使用して、cassandraからすべての行を簡単に取得することができます。 "
"`FruitResource` は、データ・アクセス・ロジックをカプセル化した `FruitService` を使用しています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:257
#, fuzzy
msgid ""
"When creating the REST API we should not share the same entity object "
"between REST API and data access layers. They should not be coupled to allow "
"the API to evolve independently of the storage layer. This is the reason why "
"the API is using a `FruitDto` class. This class will be used by Quarkus to "
"convert JSON to java objects for client requests and java objects to JSON "
"for the responses. The translation is done by quarkus-resteasy extension."
msgstr ""
"REST APIを作成する際には、REST "
"APIとデータアクセス層の間で同じエンティティオブジェクトを共有すべきではありません。それらは、APIがストレージ層から独立して進化できるように結合されるべきではありません。これが、APIが "
"`FruitDto` "
"クラスを使用している理由です。このクラスは、Quarkusがクライアントのリクエストに対してはJSONをjavaオブジェクトに、レスポンスに対してはjavaオブジェクトをJSONに変換するために使用します。変換はquarkus-"
"resteasy拡張機能によって行われます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:261
#, no-wrap
msgid "public class FruitDto {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:264
#, no-wrap
msgid "  private String name;\n"
"  private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:266
#, no-wrap
msgid "  public FruitDto() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:273
#, no-wrap
msgid ""
"  public FruitDto(String name, String description) {\n"
"    this.name = name;\n"
"    this.description = description;\n"
"  }\n"
"  // getters and setters omitted for brevity\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:277
#, fuzzy
msgid ""
"DTO classes used by the JSON serialization layer are required to have a "
"default no-arg constructor."
msgstr "JSON シリアライゼーションレイヤーで使用される DTO クラスは、デフォルトの no-arg コンストラクタを持つ必要があります。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:278
#, no-wrap, fuzzy
msgid "Configuring the Cassandra database"
msgstr "Cassandraデータベースの設定"

#. type: Title ===
#: upstream/_guides/cassandra.adoc:280
#, no-wrap, fuzzy
msgid "Connecting to Apache Cassandra or DataStax Enterprise (DSE)"
msgstr "Apache CassandraまたはDataStax Enterprise（DSE）への接続"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:284
#, fuzzy
msgid ""
"The main properties to configure are: `contact-points`, to access the "
"Cassandra database, `local-datacenter`, which is required by the driver, and "
"– optionally – the keyspace to bind to."
msgstr ""
"構成する主なプロパティは次のとおりです。 `contact-points` 、Cassandraデータベースにアクセスするための `local-"
"datacenter` 、ドライバによって必要とされる 、そしてオプションでバインド先のキースペースです。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:286
#, fuzzy
msgid "A sample configuration should look like this:"
msgstr "設定のサンプルは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:292
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points={cassandra_ip}:9042\n"
"quarkus.cassandra.local-datacenter={dc_name}\n"
"quarkus.cassandra.keyspace={keyspace}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:296
#, fuzzy
msgid ""
"In this example, we are using a single instance running on localhost, and "
"the keyspace containing our data is `k1`:"
msgstr "この例では、ローカルホスト上で実行されている単一のインスタンスを使用しており、データを含む鍵空間は `k1`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:302
#, no-wrap
msgid ""
"quarkus.cassandra.contact-points=127.0.0.1:9042\n"
"quarkus.cassandra.local-datacenter=datacenter1\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:306
#, fuzzy
msgid ""
"If your cluster requires plain text authentication, you can also provide two "
"more settings: `username` and `password`."
msgstr "クラスタでプレーンテキスト認証が必要な場合は、 `username` と `password`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:311
#, no-wrap
msgid ""
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:313
#, no-wrap, fuzzy
msgid "Connecting to a cloud DataStax Astra database"
msgstr "クラウドDataStax Astraデータベースへの接続"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:318
#, fuzzy
msgid ""
"When connecting to Astra, instead of providing a contact point and a "
"datacenter, you should provide `secure-connect-bundle`, which should point "
"to a valid path to an Astra secure connect bundle, as well as `username` "
"and`password`, since authentication is always required on Astra clusters."
msgstr ""
"`username` Astra に接続する際には、コンタクトポイントとデータセンターを提供する代わりに、 `secure-connect-"
"bundle` を提供する必要があります。 は Astra secure connect bundle への有効なパスを指している必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:320
#, fuzzy
msgid "A sample configuration for DataStax Astra should look like this:"
msgstr "DataStax Astraのサンプル構成は次のようになります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:327
#, no-wrap
msgid ""
"quarkus.cassandra.cloud.secure-connect-bundle=/path/to/secure-connect-bundle."
"zip\n"
"quarkus.cassandra.auth.username=john\n"
"quarkus.cassandra.auth.password=s3cr3t\n"
"quarkus.cassandra.keyspace=k1\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cassandra.adoc:329
#, no-wrap, fuzzy
msgid "Advanced driver configuration"
msgstr "高度なドライバ設定"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:336
#, fuzzy
msgid ""
"You can configure other Java driver settings using `application.conf` or "
"`application.json` files.  They need to be located in the classpath of your "
"application.  All settings will be passed automatically to the underlying "
"driver configuration mechanism.  Settings defined in `application."
"properties` with the `quarkus.cassandra` prefix will have priority over "
"settings defined in `application.conf` or `application.json`."
msgstr ""
"`application.conf` または `application.json` ファイルを使用して、他の Java "
"ドライバの設定を設定することができます。これらのファイルは、アプリケーションのクラスパスに配置する必要があります。すべての設定は、基礎となるドライバ設定メカニズムに自動的に渡されます。 "
"`application.properties` で `quarkus.cassandra` のプレフィックスを付けて定義された設定は、 "
"`application.conf` または `application.json` で定義された設定よりも優先されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:339
#, fuzzy
msgid ""
"To see the full list of settings, please refer to the link:https://docs."
"datastax.com/en/developer/java-driver/latest/manual/core/configuration/"
"reference/[driver settings reference]."
msgstr ""
"設定の全リストを見るには、 link:https://docs.datastax.com/en/developer/java-driver/latest/"
"manual/core/configuration/reference/[ドライバの設定リファレンスを]参照してください。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:340
#, no-wrap, fuzzy
msgid "Running a Cassandra Database"
msgstr "Cassandraデータベースの実行"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:344
#, fuzzy
msgid ""
"By default, `CassandraClient` is configured to access a local Cassandra "
"database on port 9042 (the default Cassandra port)."
msgstr ""
"デフォルトでは、 `CassandraClient` は、ポート 9042（デフォルトの Cassandra ポート）でローカル Cassandra "
"データベースにアクセスするように構成されています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:347
#, fuzzy
msgid ""
"Make sure that the setting `quarkus.cassandra.local-datacenter` matches the "
"datacenter of your Cassandra cluster."
msgstr ""
"設定 `quarkus.cassandra.local-datacenter` "
"が、Cassandraクラスタのデータセンターと一致していることを確認してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:350
#, fuzzy
msgid ""
"If you don't know the name of your local datacenter, this value can be found "
"by running the following CQL query: `SELECT data_center FROM system.local`."
msgstr ""
"ローカルのデータセンターの名前がわからない場合は、以下の CQL クエリを実行することでこの値を見つけることができます ： `SELECT "
"data_center FROM system.local`."

#. type: Plain text
#: upstream/_guides/cassandra.adoc:353
#, fuzzy
msgid ""
"If you want to use Docker to run a Cassandra database, you can use the "
"following command to launch one:"
msgstr "Dockerを使用してCassandraデータベースを起動したい場合は、以下のコマンドを使用して起動することができます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:366
#, no-wrap
msgid ""
"docker run \\\n"
"   --name local-cassandra-instance \\\n"
"   -p 7000:7000 \\\n"
"   -p 7001:7001 \\\n"
"   -p 7199:7199 \\\n"
"   -p 9042:9042 \\\n"
"   -p 9160:9160 \\\n"
"   -p 9404:9404 \\\n"
"   -d \\\n"
"   launcher.gcr.io/google/cassandra3\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:370
#, fuzzy
msgid ""
"Note that only the 9042 port is required. All others all optional but "
"provide enhanced features like JMX monitoring of the Cassandra instance."
msgstr ""
"9042ポートのみが必要であることに注意してください。他のすべてはオプションですが、CassandraインスタンスのJMX監視などの拡張機能を提供します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:373
#, fuzzy
msgid ""
"Next you need to create the keyspace and table that will be used by your "
"application. If you are using Docker, run the following commands:"
msgstr ""
"次に、アプリケーションで使用するキースペースとテーブルを作成する必要があります。Dockerを使用している場合は、以下のコマンドを実行します。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:378
#, no-wrap
msgid ""
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE KEYSPACE IF NOT "
"EXISTS k1 WITH replication = {'class':'SimpleStrategy', 'replication_factor':"
"1}\"\n"
"docker exec -it local-cassandra-instance cqlsh -e \"CREATE TABLE IF NOT "
"EXISTS k1.fruit(store_id text, name text, description text, PRIMARY "
"KEY((store_id), name))\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:381
#, fuzzy
msgid ""
"If you're running Cassandra locally you can execute the cqlsh commands "
"directly:"
msgstr "ローカルでCassandraを実行している場合は、cqlshコマンドを直接実行できます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:386
#, no-wrap
msgid ""
"cqlsh -e \"CREATE KEYSPACE IF NOT EXISTS k1 WITH replication = {'class':"
"'SimpleStrategy', 'replication_factor':1}\n"
"cqlsh -e \"CREATE TABLE IF NOT EXISTS k1.fruit(store_id text, name text, "
"description text, PRIMARY KEY((store_id), name))\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:241
#, no-wrap, fuzzy
msgid "Creating a frontend"
msgstr "フロントエンドの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:391
#, fuzzy
msgid "Now let's add a simple web page to interact with our `FruitResource`."
msgstr "それでは、 `FruitResource` と対話するためのシンプルなウェブページを追加してみましょう。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:395
#, fuzzy
msgid ""
"Quarkus automatically serves static resources located under the `META-INF/"
"resources` directory.  In the `src/main/resources/META-INF/resources` "
"directory, add a `fruits.html` file with the content from this link:https://"
"github.com/datastax/cassandra-quarkus/tree/master/quickstart/src/main/"
"resources/META-INF/resources/fruits.html[fruits.html] file in it."
msgstr ""
"Quarkusは、 `META-INF/resources` ディレクトリの下にある静的リソースを自動的に提供します。 `src/main/"
"resources/META-INF/resources` ディレクトリに、この link:https://github.com/datastax/"
"cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/"
"resources/fruits.html[fruits.html]ファイルの内容を含む `fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:248
#, fuzzy
msgid "You can now interact with your REST service:"
msgstr "これで、REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:399 upstream/_guides/cassandra.adoc:542
#, fuzzy
msgid "start Quarkus with `mvn clean quarkus:dev`"
msgstr "クォークスを起動する `mvn clean quarkus:dev`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:251
#, fuzzy
msgid "open a browser to `http://localhost:8080/fruits.html`"
msgstr ""
"ブラウザを開く `&lt;a href=\"http://localhost:8080/fruits.html\" class="
"\"bare\"&gt;http://localhost:8080/fruits.html&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:252
#, fuzzy
msgid "add new fruits to the list via the form"
msgstr "フォームを使って新しいフルーツをリストに追加します"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:403
#, no-wrap, fuzzy
msgid "Reactive Cassandra Client"
msgstr "リアクティブCassandraクライアント"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:407
#, fuzzy
msgid ""
"When using `QuarkusCqlSession` you have access to reactive variant of "
"methods that integrate with Quarkus and Mutiny."
msgstr ""
"`QuarkusCqlSession` を使用すると、Quarkus や Mutiny と統合された反応性のあるバリアントメソッドにアクセスできます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:410
#, fuzzy
msgid ""
"If you're not familiar with Mutiny, read the link:https://quarkus.io/guides/"
"getting-started-reactive[Getting Started with Reactive guide] first."
msgstr ""
"Mutinyに慣れていない場合は、まずGet link:https://quarkus.io/guides/getting-started-"
"reactive[ting Started with Reactiveガイド]を読んでください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:412
#, fuzzy
msgid ""
"Let's rewrite the previous example using reactive programming with Mutiny."
msgstr "先ほどの例をMutinyを使ったリアクティブプログラミングで書き換えてみましょう。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:414
#, fuzzy
msgid "Firstly, we need to implement the `@Dao` that works in a reactive way:"
msgstr "まずは、反応的に動作する `@Dao` を実装する必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:419
#, no-wrap
msgid "@Dao\n"
"public interface FruitDaoReactive {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:422
#, no-wrap
msgid "  @Update\n"
"  Uni<Void> updateAsync(Fruit fruitDao);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:426
#, no-wrap
msgid ""
"  @Select\n"
"  MutinyMappedReactiveResultSet<Fruit> findByIdAsync(String id);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:433
#, fuzzy
msgid ""
"Please note the usage of `MutinyMappedReactiveResultSet` - it is a "
"specialized `Mutiny` type converted from the original `Publisher` returned "
"by the driver, which also exposes a few extra methods, e.g. to obtain the "
"query execution info. If you don't need anything in that interface, you can "
"also simply declare your method to return `Multi`: `Multi<Fruit> "
"findByIdAsync(String id)`,"
msgstr ""
"`MutinyMappedReactiveResultSet` の使用法に注意してください - これは、ドライバが返すオリジナルの "
"`Publisher` から変換された `Mutiny` "
"型で、クエリの実行情報を取得するなど、いくつかの余分なメソッドを公開しています。このインターフェイスで何も必要としない場合は、単にメソッドを "
"`Multi` を返すように宣言することもできます : `Multi&amp;lt;Fruit&amp;gt; findByIdAsync(String "
"id)`."

#. type: Plain text
#: upstream/_guides/cassandra.adoc:436
#, fuzzy
msgid ""
"Similarly, the method `updateAsync` returns a `Uni` - it is automatically "
"converted from the original result set returned by the driver."
msgstr "同様に、メソッド `updateAsync` は `Uni` を返します。これは、ドライバが返す元の結果セットから自動的に変換されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:444
#, fuzzy
msgid ""
"The Cassandra driver uses the Reactive Streams `Publisher` API for reactive "
"calls. The Quarkus framework however uses Mutiny. Because of that, the "
"`CqlQuarkusSession` interface transparently converts the `Publisher` "
"instances returned by the driver into the reactive type `Multi`.  "
"`CqlQuarkusSession` is also capable of converting a `Publisher` into a `Uni` "
"– in this case, the publisher is expected to emit at most one row, then "
"complete. This is suitable for write queries (they return no rows), or for "
"read queries guaranteed to return one row at most (count queries, for "
"example)."
msgstr ""
"Cassandraドライバは、リアクティブな呼び出しにReactive Streams `Publisher` "
"APIを使用します。しかし、QuarkusフレームワークはMutinyを使用しています。そのため、 `CqlQuarkusSession` "
"インターフェイスは、ドライバが返す `Publisher` インスタンスを透過的にリアクティブ型 `Multi` に変換します。 "
"`CqlQuarkusSession` は、 `Publisher` を `Uni` に変換することもできます - この場合、パブリッシャーは最大でも "
"1 行を返し、その後完了すると予想されます。これは、書き込みクエリ（行を返さない）や、最大でも 1 "
"行を返すことが保証されている読み込みクエリ（カウントクエリなど）に適しています。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:446
#, fuzzy
msgid ""
"Next, we need to adapt the `FruitMapper` to construct a `FruitDaoReactive` "
"instance:"
msgstr "次に、 `FruitMapper` を適応させて `FruitDaoReactive` インスタンスを構築する必要があります。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:452
#, no-wrap
msgid ""
"@Mapper\n"
"public interface FruitMapper {\n"
"  // the existing method omitted\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:456
#, no-wrap
msgid "  @DaoFactory\n"
"  FruitDaoReactive fruitDaoReactive();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:460
#, fuzzy
msgid ""
"Now, we can create a `FruitReactiveService` that leverages the reactive "
"`@Dao`:"
msgstr "これで、反応性のある `@Dao` を活用した `FruitReactiveService` を作成することができます。"

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:465
#, no-wrap
msgid "@ApplicationScoped\n"
"public class FruitReactiveService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:467
#, no-wrap
msgid "  private final FruitDaoReactive fruitDao;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:472
#, no-wrap
msgid ""
"  @Inject\n"
"  public FruitReactiveService(FruitDaoReactive fruitDao) {\n"
"    this.fruitDao = fruitDao;\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:476
#, no-wrap
msgid ""
"  public Uni<Void> add(Fruit fruit) {\n"
"    return fruitDao.update(fruit);\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:481
#, no-wrap
msgid ""
"  public Multi<Fruit> get(String id) {\n"
"    return fruitDao.findById(id);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:485
#, fuzzy
msgid ""
"The `get()` method above returns `Multi`, and the `add()` method returns "
"`Uni`; these types are compatible with the Quarkus reactive REST API."
msgstr ""
"上記の `get()` メソッドは `Multi` を返し、 `add()` メソッドは `Uni` を返します。これらのタイプは、Quarkus "
"のリアクティブ REST API と互換性があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:488
#, fuzzy
msgid ""
"To integrate the reactive logic with REST API, you need to have a dependency "
"to `quarkus-resteasy-mutiny`:"
msgstr "リアクティブロジックをREST APIと統合するには、 `quarkus-resteasy-mutiny`."

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:424
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-resteasy-mutiny</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:498
#, fuzzy
msgid ""
"It provides an integration layer between `Multi`, `Uni` and the REST API."
msgstr "`Multi`, `Uni` と REST API との間の統合レイヤを提供します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:500
#, fuzzy
msgid "Finally, we can create a `FruitReactiveResource`:"
msgstr "最後に、 `FruitReactiveResource`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:509
#, no-wrap
msgid ""
"@Path(\"/reactive-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitReactiveResource {\n"
"  private static final String STORE_NAME = \"acme\";\n"
"  @Inject FruitReactiveService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:516
#, no-wrap
msgid ""
"  @GET\n"
"  public Multi<FruitDto> getAll() {\n"
"    return service\n"
"        .get(STORE_NAME)\n"
"        .map(fruit -> new FruitDto(fruit.getName(), fruit."
"getDescription()));\n"
"  }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:522
#, no-wrap
msgid ""
"  @POST\n"
"  public Multi<FruitDto> add(FruitDto fruitDto) {\n"
"    Fruit fruit = covertFromDto(fruitDto);\n"
"    return service.add(fruit).then(ignored -> getAll());\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:530
#, fuzzy
msgid ""
"All methods exposed via REST interface are returning reactive types from the "
"Mutiny API."
msgstr "RESTインターフェースを介して公開されているすべてのメソッドは、Mutiny APIから反応型を返しています。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:531
#, no-wrap, fuzzy
msgid "Creating a reactive frontend"
msgstr "リアクティブなフロントエンドの作成"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:538
#, fuzzy
msgid ""
"Now let's add a simple web page to interact with our `FruitReactiveResource`."
"  In the `src/main/resources/META-INF/resources` directory, add a `reactive-"
"fruits.html` file with the content from this link:https://github.com/"
"datastax/cassandra-quarkus/tree/master/quickstart/src/main/resources/META-"
"INF/resources/reactive-fruits.html[reactive-fruits.html] file in it."
msgstr ""
"ここで、 `FruitReactiveResource` と対話するための簡単なウェブページを追加してみましょう。 `src/main/"
"resources/META-INF/resources` ディレクトリに、この link:https://github.com/datastax/"
"cassandra-quarkus/tree/master/quickstart/src/main/resources/META-INF/"
"resources/reactive-fruits.html[reactive-fruits.html]ファイルの内容を含む `reactive-"
"fruits.html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:540
#, fuzzy
msgid "You can now interact with your reactive REST service:"
msgstr "これで、リアクティブな REST サービスと対話できるようになりました。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:543
#, fuzzy
msgid "open a browser to `http://localhost:8080/reactive-fruits.html`"
msgstr ""
"ブラウザを開く `&lt;a href=\"http://localhost:8080/reactive-fruits.html\" class="
"\"bare\"&gt;http://localhost:8080/reactive-fruits.html&lt;/a&gt;`"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:546
#, no-wrap, fuzzy
msgid "Connection Health Check"
msgstr "接続の健康チェック"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:550
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-health` extension, `cassandra-"
"quarkus` will automatically add a readiness health check to validate the "
"connection to the cluster."
msgstr ""
"`quarkus-smallrye-health` 拡張モジュールを使用している場合、 `cassandra-quarkus` "
"はクラスタへの接続を検証するための準備状態の健康チェックを自動的に追加します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:553
#, fuzzy
msgid ""
"So when you access the `/health/ready` endpoint of your application you will "
"have information about the connection validation status."
msgstr "そのため、アプリケーションの `/health/ready` エンドポイントにアクセスすると、接続の検証状況に関する情報が表示されます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:556
#, fuzzy
msgid ""
"This behavior can be disabled by setting the `quarkus.cassandra.health."
"enabled` property to `false` in your `application.properties`."
msgstr ""
"この動作は、 `application.properties` の `quarkus.cassandra.health.enabled` プロパティを "
"`false` に設定することで無効にできます。"

#. type: Title ==
#: upstream/_guides/cassandra.adoc:557
#, no-wrap, fuzzy
msgid "Metrics"
msgstr "メトリクス"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:561
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-metrics` extension, `cassandra-"
"quarkus` can provide metrics about QuarkusCqlSession and Cassandra nodes."
msgstr ""
"`quarkus-smallrye-metrics` 拡張機能を使用している場合、 `cassandra-quarkus` "
"は、QuarkusCqlSession と Cassandra ノードに関するメトリクスを提供できます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:564
#, fuzzy
msgid ""
"This behavior must first be enabled by setting the `quarkus.cassandra."
"metrics.enabled` property to `true` in your `application.properties`."
msgstr ""
"この動作を有効にするには、まず `application.properties`.NET Framework の `quarkus.cassandra."
"metrics.enabled` プロパティを `true` に設定する必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:566
#, fuzzy
msgid ""
"The next step that you need to do is set explicitly which metrics should be "
"enabled."
msgstr "次のステップでは、どのメトリクスを有効にするかを明示的に設定します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:571
#, fuzzy
msgid ""
"The `quarkus.cassandra.metrics.session-enabled` and `quarkus.cassandra."
"metrics.node-enabled` properties should be used for enabling metrics; the "
"former should contain a list of session-level metrics to enable, while the "
"latter should contain a list of node-level metrics to enable. Both "
"properties accept a comma-separated list of valid metric names."
msgstr ""
"`quarkus.cassandra.metrics.session-enabled` `quarkus.cassandra.metrics.node-"
"enabled` "
"前者は、有効にするセッションレベルのメトリクスのリストを含む必要があり、後者は有効にするノードレベルのメトリクスのリストを含む必要があります。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:574
#, fuzzy
msgid ""
"For example, to enable `session.connected-nodes`, `session.bytes-sent`, and "
"`node.pool.open-connections` you should add the following settings to your "
"`application.properties`:"
msgstr ""
"例えば、 `session.connected-nodes`, `session.bytes-sent`, `node.pool.open-"
"connections` を有効にするには、以下の設定を `application.properties`."

#. type: delimited block -
#: upstream/_guides/cassandra.adoc:580
#, no-wrap
msgid ""
"quarkus.cassandra.metrics.enabled=true\n"
"quarkus.cassandra.metrics.session-enabled=connected-nodes,bytes-sent\n"
"quarkus.cassandra.metrics.node-enabled=pool.open-connections\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cassandra.adoc:585
#, fuzzy
msgid ""
"For the full list of available metrics, please refer to the link:https://"
"docs.datastax.com/en/developer/java-driver/latest/manual/core/configuration/"
"reference/[driver settings reference] and the `advanced.metrics` section."
msgstr ""
"利用可能なメトリクスの完全なリストについては、 link:https://docs.datastax.com/en/developer/java-"
"driver/latest/manual/core/configuration/reference/[ドライバの設定リファレンス]と `advanced."
"metrics` を参照してください。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:588
#, fuzzy
msgid ""
"When metrics are properly enabled and when you access the `/metrics` "
"endpoint of your application, you will see metric reports for all enabled "
"metrics."
msgstr ""
"メトリクスが適切に有効化され、アプリケーションの `/metrics` エンドポイントにアクセスすると、有効化されたすべてのメトリクスのメトリクス "
"レポートが表示されます。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:253
#, no-wrap, fuzzy
msgid "Building a native executable"
msgstr "ネイティブ実行ファイルの構築"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:592
#, fuzzy
msgid "You can use the Cassandra client in a native executable."
msgstr "ネイティブ実行ファイルでCassandraクライアントを使用することができます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:594
#, fuzzy
msgid ""
"You can build a native executable with the `mvn clean package -Dnative` "
"command."
msgstr "`mvn clean package -Dnative` コマンドでネイティブ実行ファイルをビルドすることができます。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:596
#, fuzzy
msgid ""
"Running it is as simple as executing `./target/quickstart-1.0.0-SNAPSHOT-"
"runner`."
msgstr "実行は `./target/quickstart-1.0.0-SNAPSHOT-runner` を実行するだけで簡単です。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:260
#, fuzzy
msgid ""
"You can then point your browser to `http://localhost:8080/fruits.html` and "
"use your application."
msgstr ""
"その後、ブラウザを `&lt;a href=\"http://localhost:8080/fruits.html\" class="
"\"bare\"&gt;http://localhost:8080/fruits.html&lt;/a&gt;`とアプリケーションを使用します。"

#. type: Plain text
#: upstream/_guides/cassandra.adoc:603
#, fuzzy
msgid ""
"Accessing a Cassandra database from a client application is easy with "
"Quarkus and the Cassandra extension, which provides configuration and native "
"support for the DataStax Java driver for Apache Cassandra."
msgstr ""
"クライアント・アプリケーションからのCassandraデータベースへのアクセスは、QuarkusとCassandra拡張機能で簡単に行えます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/software-transactional-memory.adoc:6
#, no-wrap, fuzzy
msgid "Using Software Transactional Memory in Quarkus"
msgstr "Quarkusでのソフトウェアトランザクションメモリの使用"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:20
#, fuzzy
msgid ""
"Software Transactional Memory (STM) has been around in research environments "
"since the late 1990's and has relatively recently started to appear in "
"products and various programming languages. We won't go into all of the "
"details behind STM but the interested reader could look at https://groups."
"csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].  "
"However, suffice it to say that STM offers an approach to developing "
"transactional applications in a highly concurrent environment with some of "
"the same characteristics of ACID transactions, which you've probably already "
"used through JTA. Importantly though, the Durability property is relaxed "
"(removed) within STM implementations, or at least made optional. This is not "
"the situation with JTA, where state changes are made durable to a relational "
"database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc."
"pdf[the X/Open XA standard]."
msgstr ""
"ソフトウェア・トランザクション・メモリ(STM)は、1990 "
"年代後半から研究環境に存在し、比較的最近になって製品や様々なプログラミング言語に登場し始めました。STM "
"の背後にあるすべての詳細については触れませんが，興味のある方は link:https://groups.csail.mit.edu/tds/papers/"
"Shavit/ShavitTouitou-podc95.pdf[この論文を]参照してください．しかし、STM は、JTA を通じて既に使用されている "
"ACID トランザクションと同じ特性を持つ、高度な同時実行環境でトランザクショ "
"ン・アプリケーションを開発するためのアプローチを提供していることは言うまでもありません。しかし、重要なことは、STM の実装では Durability "
"プロパティが緩和（削除）されているか、少なくともオプションになっていることです。これは、 link:https://pubs.opengroup.org/"
"onlinepubs/009680699/toc.pdf[X/Open XA "
"標準]をサポートするリレーショナル・データベースに対して状態の変更を耐久性のあるものにするという JTA の状況とは異なります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:24
#, fuzzy
msgid ""
"Note, the STM implementation provided by Quarkus is based on the https://"
"narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. "
"This document isn't meant to be a replacement for that project's "
"documentation so you may want to look at that for more detail. However, we "
"will try to focus more on how you can combine some of the key capabilities "
"into Quarkus when developing Kubernetes native applications and "
"microservices."
msgstr ""
"Quarkusが提供するSTMの実装は、 link:https://narayana.io/docs/project/index."
"html#d0e16066[Narayana "
"STMの]実装に基づいています。このドキュメントは、そのプロジェクトのドキュメントに代わるものではありませんので、詳細についてはそちらを参照してください。しかし、Kubernetesネイティブアプリケーションやマイクロサービスを開発する際に、主要な機能のいくつかをQuarkusにどのように組み合わせることができるかについて、より焦点を当ててみたいと思います。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:25
#, no-wrap, fuzzy
msgid "Why use STM with Quarkus?"
msgstr "なぜQuarkusでSTMを使うのか？"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:31
#, fuzzy
msgid ""
"Now you may still be asking yourself \"Why STM instead of JTA?\" or \"What "
"are the benefits to STM that I don't get from JTA?\" Let's try to answer "
"those or similar questions, with a particular focus on why we think they're "
"great for Quarkus, microservices and Kubernetes native applications. So in "
"no specific order ..."
msgstr ""
"今、あなたはまだ\"なぜJTAではなくSTMなのか？\"や\"JTAでは得られないSTMのメリットは何か？\"と自問自答しているかもしれません。ここでは、Quarkus、マイクロサービス、Kubernetesネイティブアプリケーションに最適だと思う理由を中心に、これらの質問や似たような質問に答えてみましょう。ということで、順不同で "
"..."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:40
#, fuzzy
msgid ""
"The goal of STM is to simplify object reads and writes from multiple threads/"
"protect state from concurrent updates. The Quarkus STM implementation will "
"safely manage any conflicts between these threads using whatever isolation "
"model has been chosen to protect that specific state instance (object in the "
"case of Quarkus). In Quarkus STM, there are two isolation implementations, "
"pessimistic (the default), which would cause conflicting threads to be "
"blocked until the original has completed its updates (committed or aborted "
"the transaction); then there's the optimistic approach which allows all of "
"the threads to proceed and checks for conflicts at commit time, where one or "
"more of the threads may be forced to abort if there have been conflicting "
"updates."
msgstr ""
"STMの目的は、複数のスレッドからのオブジェクトの読み書きを簡素化し、同時更新からステートを保護することです。QuarkusのSTM実装では、特定のステートインスタンス（Quarkusの場合はオブジェクト）を保護するために選択された分離モデルを使用して、これらのスレッド間の競合を安全に管理します。Quarkus "
"STMでは、2つの分離実装があります。悲観的なアプローチ（デフォルト）では、元のスレッドが更新を完了する（コミットまたはトランザクションを中止する）まで競合するスレッドがブロックされます。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:54
#, fuzzy
msgid ""
"STM objects have state but it doesn't need to be persistent (durable). In "
"fact the default behaviour is for objects managed within transactional "
"memory to be volatile, such that if the service or microservice within which "
"they are being used crashes or is spawned elsewhere, e.g., by a scheduler, "
"all state in memory is lost and the objects start from scratch. But surely "
"you get this and more with JTA (and a suitable transactional datastore) and "
"don't need to worry about restarting your application? Not quite. There's a "
"trade-off here: we're doing away with persistent state and the overhead of "
"reading from and then writing (and sync-ing) to the datastore during each "
"transaction. This makes updates to (volatile) state very fast but you still "
"get the benefits of atomic updates across multiple STM objects (e.g., "
"objects your team wrote then calling objects you inherited from another team "
"and requiring them to make all-or-nothing updates), as well as consistency "
"and isolation in the presence of concurrent threads/users (common in "
"distributed microservices architectures).  Furthermore, not all stateful "
"applications need to be durable - even when JTA transactions are used, it "
"tends to be the exception and not the rule. And as you'll see later, because "
"applications can optionally start and control transactions, it's possible to "
"build microservices which can undo state changes and try alternative paths."
msgstr ""
"STM "
"オブジェクトは状態を持っていますが、永続的（耐久性のある）である必要はありません。実際、デフォルトでは、トランザクションメモリ内で管理されているオブジェクトは揮発性であるため、使用されているサービスやマイクロサービスがクラッシュしたり、スケジューラなどで他の場所で生成されたりすると、メモリ内のすべての状態が失われ、オブジェクトはゼロから開始されます。しかし、確かに "
"JTA (と適切なトランザクションデータストア) "
"を使えば、これ以上のことが可能で、アプリケーションの再起動を心配する必要はないのでしょうか？そうではありません。ここではトレードオフがあります: "
"我々は永続的な状態と、各トランザクション中にデータストアから読み込んで書き込み(および同期)するオーバーヘッドを排除しています。これにより、（揮発性の）ステートへの更新は非常に高速になりますが、複数の "
"STM オブジェクト（例えば、自分のチームが書いたオブジェクトが、他のチームから継承したオブジェクトを呼び出して、オールオア "
"ナッシング更新を行う必要がある場合など）にまたがるアトミックな更新の利点を得ることができます。さらに、すべてのステートフルアプリケーションが耐久性を必要とするわけではありません "
"- JTA "
"トランザクションが使用される場合でも、それは例外であってルールではない傾向があります。後述するように、アプリケーションは任意でトランザクションを開始したり制御したりできるので、状態変化を元に戻したり、代替パスを試すことができるマイクロサービスを構築することが可能です。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:61
#, fuzzy
msgid ""
"Another benefit of STM is composability and modularity. You can write "
"concurrent Quarkus objects/services that can be easily composed with any "
"other services built using STM, without exposing the details of how the "
"objects/services are implemented. As we discussed earlier, this ability to "
"compose objects you wrote with those other teams may have written weeks, "
"months or years earlier, and have A, C and I properties can be hugely "
"beneficial. Furthermore, some STM implementations, including the one Quarkus "
"uses, support nested transactions and these allow changes made within the "
"context of a nested (sub) transaction to later be rolled back by the parent "
"transaction."
msgstr ""
"STMのもう1つの利点は、構成可能性とモジュール性です。オブジェクト/"
"サービスがどのように実装されているかの詳細を公開することなく、STMを使用して構築された他の任意のサービスと簡単に構成することができるQuarkusオブジェクト/"
"サービスを並行して書くことができます。先に説明したように、他のチームと一緒に書いたオブジェクトを、数週間、数ヶ月、数年前に書いたかもしれない、A、C、Iのプロパティを持つオブジェクトをコンパイルできるこの機能は、非常に有益なものになります。さらに、Quarkusが使用しているものを含むいくつかのSTM実装では、入れ子になったトランザクションをサポートしており、入れ子になった（サブ）トランザクションのコンテキスト内で行われた変更を、後で親トランザクションによってロールバックすることができます。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:66
#, fuzzy
msgid ""
"Although the default for STM object state is volatile, it is possible to "
"configure the STM implementation such that an object's state is durable. "
"Although it's possible to configure Narayana such that different backend "
"datastores can be used, including relational databases, the default is the "
"local operating system file system, which means you don't need to configure "
"anything else with Quarkus such as a database."
msgstr ""
"STMオブジェクトの状態のデフォルトは揮発性ですが、オブジェクトの状態が耐久性を持つようにSTMの実装を構成することができます。リレーショナルデータベースなど、さまざまなバックエンドのデータストアを使用できるようにNarayanaを設定することは可能ですが、デフォルトはローカルのオペレーティングシステムのファイルシステムであり、データベースのようなQuarkusで他の何かを設定する必要はありません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:70
#, fuzzy
msgid ""
"Many STM implementations allow \"plain old language objects\" to be made STM-"
"aware with little or no changes to the application code. You can build, test "
"and deploy applications without wanting them to be STM-aware and then later "
"add those capabilities if they become necessary and without much development "
"overhead at all."
msgstr ""
"多くの STM 実装では、アプリケーションコードをほとんど変更することなく、「古い言語オブジェクト」を STM "
"対応にすることができます。アプリケーションを STM "
"対応にすることを望まずに、アプリケーションを構築、テスト、デプロイし、必要に応じてそれらの機能を後から追加することができ、開発のオーバーヘッドをほとんど必要としません。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:71
#, no-wrap, fuzzy
msgid "Building STM applications"
msgstr "STMアプリケーションの構築"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:78
#, fuzzy
msgid ""
"There is also a fully worked example in the quickstarts which you may access "
"by cloning the Git repository: `git clone {quickstarts-clone-url}`, or by "
"downloading an {quickstarts-archive-url}[archive].  Look for the `software-"
"transactional-memory-quickstart` example. This will help to understand how "
"you can build STM-aware applications with Quarkus. However, before we do so "
"there are a few basic concepts which we need to cover."
msgstr ""
"Quickstarts には完全に動作する例もあり、Git リポジトリを複製してアクセスすることができます: `git clone "
"{quickstarts-clone-url}` あるいは {quickstarts-archive-url}[archive] "
"をダウンロードしてください。 `software-transactional-memory-quickstart` "
"の例を見てください。これで、Quarkusを使ってSTM対応アプリケーションを構築する方法を理解することができます。しかし、その前に、いくつかの基本的な概念を知っておく必要があります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:84
#, fuzzy
msgid ""
"Note, as you will see, STM in Quarkus relies on a number of annotations to "
"define behaviours. The lack of these annotations causes sensible defaults to "
"be assumed but it is important for the developer to understand what these "
"may be. Please refer to the https://narayana.io/docs/project/index."
"html#d0e16066[Narayana STM manual] and the https://narayana.io//docs/project/"
"index.html#d0e16133[STM annotations guide] for more details on all of the "
"annotations Narayana STM provides."
msgstr ""
"ご覧のように、QuarkusのSTMは、動作を定義するために多くのアノテーションに依存しています。これらのアノテーションがないために、適切なデフォルトが仮定されてしまいますが、開発者はこれらのアノテーションが何であるかを理解することが重要です。Narayana "
"STMが提供するすべてのアノテーションの詳細については、Naray link:https://narayana.io/docs/project/"
"index.html#d0e16066[ana STMマニュアル]と link:https://narayana.io//docs/project/"
"index.html#d0e16133[STMアノテーションガイド]を参照してください。"

#. type: Title ==
#: upstream/_guides/context-propagation.adoc:25
#, no-wrap, fuzzy
msgid "Setting it up"
msgstr "設定する"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:90
#, fuzzy
msgid ""
"To use the extension include it as a dependency in your application pom:"
msgstr "この拡張機能を使用するには、アプリケーションの依存関係として pom にインクルードしてください。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:101
#, no-wrap
msgid ""
"<dependencies>\n"
"    <!-- STM extension -->\n"
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-narayana-stm</artifactId>\n"
"      <version>${quarkus.version}</version>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:103
#, no-wrap, fuzzy
msgid "Defining STM-aware classes"
msgstr "STM対応クラスの定義"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:111
#, fuzzy
msgid ""
"In order for the STM subsystem to have knowledge about which classes are to "
"be managed within the context of transactional memory it is necessary to "
"provide a minimal level of instrumentation. This occurs by categorising STM-"
"aware and STM-unaware classes through an interface boundary; specifically "
"all STM-aware objects must be instances of classes which inherit from "
"interfaces that themselves have been annotated to identify them as STM-aware."
" Any other objects (and their classes) which do not follow this rule will "
"not be managed by the STM subsystem and hence any of their state changes "
"will not be rolled back, for example."
msgstr ""
"STM "
"サブシステムが，トランザクションメモリのコンテキスト内でどのクラスが管理されるべきかを知るためには，最低限の手段を提供する必要があります．具体的には，すべての "
"STM 対応オブジェクトは，STM "
"対応であることを識別するために注釈が付けられたインタフェースを継承するクラスのインスタンスでなければなりません．このルールに従わない他のオブジェクト（およびそのクラス）は、STM "
"サブシステムによって管理されないため、例えば、それらの状態の変更はロールバックされません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:114
#, fuzzy
msgid ""
"The specific annotation that STM-aware application interfaces must use is "
"`org.jboss.stm.annotations.Transactional`.  For example:"
msgstr ""
"STM対応アプリケーションインタフェースが使用しなければならない特定のアノテーションは、 `org.jboss.stm.annotations."
"Transactional`.例えば、以下のようなものです。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:122
#, no-wrap
msgid ""
"@Transactional\n"
"public interface FlightService {\n"
"    int getNumberOfBookings();\n"
"    void makeBooking(String details);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:129
#, fuzzy
msgid ""
"Classes which implement this interface are able to use additional "
"annotations from Narayana to tell the STM subsystem about things such as "
"whether a method will modify the state of the object, or what state "
"variables within the class should be managed transactionally, e.g., some "
"instance variables may not need to be rolled back if a transaction aborts. "
"As mentioned earlier, if those annotations are not present then defaults are "
"chosen to guarantee safety, such as assuming all methods will modify state."
msgstr ""
"このインタフェースを実装したクラスは，Narayana "
"からの追加のアノテーションを使用して，メソッドがオブジェクトの状態を変更するかどうかや，クラス内のどの状態変数をトランザクション的に管理すべきか，例えば，トランザクションが中断した場合にロールバックする必要のないインスタンス変数があるなどのことを "
"STM "
"サブシステムに伝えることができます．前述のように、これらのアノテーションが存在しない場合は、すべてのメソッドが状態を変更すると仮定するなど、安全性を保証するためにデフォルトが選択されます。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:136
#, no-wrap
msgid ""
"public class FlightServiceImpl implements FlightService {\n"
"    @ReadLock\n"
"    public int getNumberOfBookings() { ... }\n"
"    public void makeBooking(String details) {...}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:140
#, no-wrap
msgid "    @NotState\n"
"    private int timesCalled;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:146
#, fuzzy
msgid ""
"For example, by using the `@ReadLock` annotation on the "
"`getNumberOfBookings` method, we are able to tell the STM subsystem that no "
"state modifications will occur in this object when it is used in the "
"transactional memory. Also, the `@NotState` annotation tells the system to "
"ignore `timesCalled` when transactions commit or abort, so this value only "
"changes due to application code."
msgstr ""
"例えば、 `getNumberOfBookings` メソッドに `@ReadLock` "
"アノテーションを使用することで、このオブジェクトがトランザクション・メモリで使用されているときに、状態の変更がこのオブジェクトでは発生しないことを "
"STM サブシステムに伝えることができます。また、 `@NotState` アノテーションは、トランザクションがコミットまたは中止されたときに "
"`timesCalled` を無視するようにシステムに指示するので、この値はアプリケーション・コードによってのみ変化します。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:149
#, fuzzy
msgid ""
"Please refer to the Narayana guide for details of how to exert finer grained "
"control over the transactional behaviour of objects that implement "
"interfaces marked with the `@Transactional` annotation."
msgstr ""
"`@Transactional` "
"アノテーションでマークされたインターフェイスを実装したオブジェクトのトランザクション動作をより細かく制御する方法の詳細については、ナラヤナガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:150
#, no-wrap, fuzzy
msgid "Creating STM objects"
msgstr "STMオブジェクトの作成"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:156
#, fuzzy
msgid ""
"The STM subsystem needs to be told about which objects it should be managing."
" The Quarkus (aka Narayana) STM implementation does this by providing "
"containers of transactional memory within which these object instances "
"reside. Until an object is placed within one of these STM containers it "
"cannot be managed within transactions and any state changes will not possess "
"the A, C, I (or even D) properties."
msgstr ""
"STMサブシステムは、どのオブジェクトを管理すべきかを伝える必要があります。Quarkus（別名ナラヤナ）のSTM実装は、これらのオブジェクトインスタンスが存在するトランザクションメモリのコンテナを提供することでこれを行います。オブジェクトがこれらのSTMコンテナ内に置かれるまでは、トランザクション内で管理することはできず、状態の変更はA、C、I（あるいはD）のプロパティを持たないことになります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:160
#, fuzzy
msgid ""
"Note, the term \"container\" was defined within the STM implementation years "
"before Linux containers came along. It may be confusing to use especially in "
"a Kubernetes native environment such as Quarkus, but hopefully the reader "
"can do the mental mapping."
msgstr ""
"注：\"コンテナ\"という用語は、Linuxコンテナが登場する何年も前にSTMの実装で定義されていました。特にQuarkusのようなKubernetesネイティブ環境で使用すると混乱するかもしれませんが、うまくいけば読者がメンタルマッピングをしてくれることを期待しています。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:166
#, fuzzy
msgid ""
"The default STM container (`org.jboss.stm.Container`) provides support for "
"volatile objects that can only be shared between threads in the same "
"microservice/JVM instance. When a STM-aware object is placed into the "
"container it returns a handle through which that object should then be used "
"in the future. It is important to use this handle as continuing to access "
"the object through the original reference will not allow the STM subsystem "
"to track access and manage state and concurrency control."
msgstr ""
"デフォルトの STM コンテナ ( `org.jboss.stm.Container`) は、同じマイクロサービス/JVM "
"インスタンス内のスレッド間でのみ共有可能な揮発性オブジェクトをサポートしています。STM "
"を意識したオブジェクトがコンテナに置かれると、そのオブジェクトが将来的に使用されるべきハンドルを返します。元の参照を介してオブジェクトにアクセスし続けると、STM "
"サブシステムがアクセスを追跡したり、状態や同時実行制御を管理したりすることができなくなるため、このハンドルを使用することが重要です。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:170
#, no-wrap
msgid "    import org.jboss.stm.Container;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:294
#, no-wrap
msgid "    ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:176
#, no-wrap
msgid ""
"    Container<FlightService> container = new Container<>(); <1>\n"
"    FlightServiceImpl instance = new FlightServiceImpl(); <2>\n"
"    FlightService flightServiceProxy = container.create(instance); <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:180
#, fuzzy
msgid ""
"You need to tell each Container about the type of objects for which it will "
"be responsible. In this example it will be instances that implement the "
"FlightService interface."
msgstr ""
"各コンテナに、それが担当するオブジェクトの種類を伝える必要があります。この例では、FlightService "
"インターフェースを実装したインスタンスになります。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:182
#, fuzzy
msgid ""
"Then you create an instance that implements `FlightService`. You should not "
"use it directly at this stage because access to it is not being managed by "
"the STM subsystem."
msgstr ""
"次に、 `FlightService` を実装したインスタンスを作成します。この段階では、STM "
"サブシステムによってアクセスが管理されていないため、直接使用してはいけません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:184
#, fuzzy
msgid ""
"To obtain a managed instance, pass the original object to the STM "
"`container` which then returns a reference through which you will be able to "
"perform transactional operations. This reference can be used safely from "
"multiple threads."
msgstr ""
"管理されたインスタンスを取得するには、元のオブジェクトを STM `container` "
"に渡します。この参照は、複数のスレッドから安全に使用することができます。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:185
#, no-wrap, fuzzy
msgid "Defining transaction boundaries"
msgstr "トランザクションの境界を定義する"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:190
#, fuzzy
msgid ""
"Once an object is placed within an STM container the application developer "
"can manage the scope of transactions within which it is used. There are some "
"annotations which can be applied to the STM-aware class to have the "
"container automatically create a transaction whenever a specific method is "
"invoked."
msgstr ""
"一度オブジェクトをSTMコンテナ内に配置すると、アプリケーション開発者はそれが使用されるトランザクションの範囲を管理することができます。特定のメソッドが呼び出されたときにコンテナが自動的にトランザクションを作成するように、STM-"
"aware クラスに適用できるアノテーションがいくつかあります。"

#. type: Title ===
#: upstream/_guides/software-transactional-memory.adoc:191
#, no-wrap, fuzzy
msgid "Declarative approach"
msgstr "宣言的アプローチ"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:200
#, fuzzy
msgid ""
"If the `@NestedTopLevel` or `@Nested` annotation is placed on a method "
"signature then the STM container will start a new transaction when that "
"method is invoked and attempt to commit it when the method returns. If there "
"is a transaction already associated with the calling thread then each of "
"these annotations behaves slightly differently: the former annotation will "
"always create a new top-level transaction within which the method will "
"execute, so the enclosing transaction does not behave as a parent, i.e., the "
"nested top-level transaction will commit or abort independently; the latter "
"annotation will create a transaction with is properly nested within the "
"calling transaction, i.e., that transaction acts as the parent of this newly "
"created transaction."
msgstr ""
"`@NestedTopLevel` または `@Nested` アノテーションがメソッドのシグネチャに配置されている場合、STM "
"コンテナは、そのメソッドが呼び出されたときに新しいトランザク "
"ションを開始し、そのメソッドが戻ってきたときにコミットを試みます。前者のアノテーションは常にメソッドが実行される新しいトップレベルのトランザクションを作成し、その中でメソッドが実行されるため、そのトランザクションは親として動作しません。"

#. type: Title ===
#: upstream/_guides/software-transactional-memory.adoc:201
#, no-wrap, fuzzy
msgid "Programmatic approach"
msgstr "プログラム的アプローチ"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:204
#, fuzzy
msgid ""
"The application can programmatically start a transaction before accessing "
"the methods of STM objects:"
msgstr "アプリケーションは、STMオブジェクトのメソッドにアクセスする前に、プログラム的にトランザクションを開始することができます。"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:208
#, no-wrap
msgid "AtomicAction aa = new AtomicAction(); <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:221
#, no-wrap
msgid ""
"aa.begin(); <2>\n"
"{\n"
"    try {\n"
"        flightService.makeBooking(\"BA123 ...\");\n"
"        taxiService.makeBooking(\"East Coast Taxis ...\"); <3>\n"
"        <4>\n"
"        aa.commit();\n"
"        <5>\n"
"    } catch (Exception e) {\n"
"        aa.abort(); <6>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:226
#, fuzzy
msgid ""
"An object for manually controlling transaction boundaries (AtomicAction and "
"many other useful classes are included in the extension).  Refer https://"
"narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction.html[to the "
"javadoc] for more detail."
msgstr ""
"トランザクションの境界を手動で制御するためのオブジェクト (AtomicAction と他の多くの便利なクラスが拡張機能に含まれています)。詳細は "
"link:https://narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction."
"html[javadoc]を参照してください。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:227
#, fuzzy
msgid "Programmatically begin a transaction."
msgstr "プログラムでトランザクションを開始します。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:230
#, fuzzy
msgid ""
"Notice that object updates can be composed which means that updates to "
"multiple objects can be committed together as a single action.  [Note that "
"it is also possible to begin nested transactions so that you can perform "
"speculative work which may then be abandoned without abandoning other work "
"performed by the outer transaction]."
msgstr ""
"オブジェクトの更新は、複数のオブジェクトへの更新を単一のアクションとしてまとめてコミットすることができるという意味で、構成することができることに注意してください。これは、複数のオブジェクトへの更新を一つのアクションにまとめてコミットすることができることを意味します。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:231
#, fuzzy
msgid ""
"Since the transaction has not yet been committed the changes made by the "
"flight and taxi services are not visible outside of the transaction."
msgstr "この取引はまだコミットされていないため、フライトやタクシーサービスによって行われた変更は、取引の外では見ることができません。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:234
#, fuzzy
msgid ""
"Since the commit was successful the changes made by the flight and taxi "
"services are now visible to other threads.  Note that other transactions "
"that relied on the old state may or may not now incur conflicts when they "
"commit (the STM library provides a number of features for managing "
"conflicting behaviour and these are covered in the Narayana STM manual)."
msgstr ""
"コミットが成功したので、フライトサービスとタクシーサービスで行われた変更が他のスレッドから見えるようになりました。古い状態に依存していた他のトランザクションがコミットする際に競合が発生する可能性があることに注意してください（STM "
"ライブラリは競合する動作を管理するための多くの機能を提供しており、これらについては Narayana STM マニュアルに記載されています）。"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:235
#, fuzzy
msgid ""
"Programmatically decide to abort the transaction which means that the "
"changes made by the flight and taxi services are discarded."
msgstr "プログラム的には、フライトやタクシーサービスによって行われた変更が破棄されることを意味するトランザクションを中止することを決定します。"

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:236
#, no-wrap, fuzzy
msgid "Distributed transactions"
msgstr "分散型トランザクション"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:241
#, fuzzy
msgid ""
"Sharing a transaction between multiple services is possible but is currently "
"an advanced use case only and the Narayana documentation should be consulted "
"if this behaviour is required. In particular, STM does not yet support the "
"features described in the link:context-propagation[Context Propagation "
"guide]."
msgstr ""
"複数のサービス間でトランザクションを共有することは可能ですが、現在のところ高度なユースケースのみであり、この動作が必要な場合はNarayanaのドキュメントを参照してください。特に、STMはコンテキスト伝搬 "
"link:context-propagation[ガイド]で説明されている機能をまだサポートしていません。"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:2
#, fuzzy
msgid "Java System Properties - `aws.accessKeyId` and `aws.secretAccessKey`"
msgstr "Javaシステムのプロパティ - `aws.accessKeyId` と `aws.secretAccessKey`"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:3
#, fuzzy
msgid ""
"Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`"
msgstr "環境変数 - `AWS_ACCESS_KEY_ID` と `AWS_SECRET_ACCESS_KEY`"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:4
#, fuzzy
msgid ""
"Credential profiles file at the default location (`~/.aws/credentials`) "
"shared by all AWS SDKs and the AWS CLI"
msgstr ""
"Credential profiles file at default location ( `~/.aws/credentials`) at all "
"AWS SDKs and AWS CLI shared by all AWS SDKs"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:5
#, fuzzy
msgid ""
"Credentials delivered through the Amazon ECS if the "
"`AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the "
"security manager has permission to access the variable,"
msgstr ""
"`AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` "
"環境変数が設定されていて、セキュリティマネージャーがその変数にアクセスする権限を持っている場合、Amazon ECS を通して配信されるクレデンシャル。"

#. type: Plain text
#: upstream/_guides/amazon-credentials.adoc:5
#, fuzzy
msgid ""
"Instance profile credentials delivered through the Amazon EC2 metadata "
"service"
msgstr "Amazon EC2メタデータサービスを通じて配信されるインスタンスプロファイルの資格情報"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/gradle-config.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Gradle Plugin Repositories"
msgstr "Quarkus - Gradleプラグインリポジトリ"

#.  tag::repositories[]
#. type: Plain text
#: upstream/_guides/gradle-config.adoc:12
#, fuzzy
msgid ""
"The Quarkus Gradle plugin is published to the https://plugins.gradle.org/"
"plugin/io.quarkus[Gradle Plugin Portal]."
msgstr ""
"Quarkus Gradleプラグインは、Gradle link:https://plugins.gradle.org/plugin/io."
"quarkus[プラグインポータル]に公開されています。"

#. type: Plain text
#: upstream/_guides/gradle-config.adoc:14
#, fuzzy
msgid "To use it, add the following to your `build.gradle` file:"
msgstr "使用するには、 `build.gradle` ファイルに以下を追加します。"

#. type: delimited block -
#: upstream/_guides/gradle-config.adoc:21
#, no-wrap
msgid "plugins {\n"
"    id 'java'\n"
"    id 'io.quarkus'\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/gradle-config.adoc:24
#, fuzzy
msgid ""
"You also need to add the following at the top of your `settings.gradle` file:"
""
msgstr "また、 `settings.gradle` ファイルの先頭に以下を追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/gradle-config.adoc:35
#, no-wrap
msgid ""
"pluginManagement {\n"
"    repositories {\n"
"        mavenCentral()\n"
"        gradlePluginPortal()\n"
"    }\n"
"    plugins {\n"
"      id 'io.quarkus' version \"${quarkusPluginVersion}\"\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/gradle-config.adoc:38
#, fuzzy
msgid ""
"the `plugins{}` method in `settings.gradle` is not supported in Gradle 5.x. "
"In this case make sure to explicitly declare the plugin version in the "
"`build.gradle` file like the example below:"
msgstr ""
"`settings.gradle` の `plugins{}` メソッドは Gradle 5.x ではサポートされていません。この場合、以下の例のように "
"`build.gradle` ファイルでプラグインのバージョンを明示的に宣言してください。"

#. type: delimited block -
#: upstream/_guides/gradle-config.adoc:45
#, no-wrap
msgid ""
"plugins {\n"
"    id 'java'\n"
"    id 'io.quarkus' version '{quarkus-version}'\n"
"}\n"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/spring-cloud-config-client.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Reading properties from Spring Cloud Config Server"
msgstr "Quarkus - Spring Cloud Config Serverからプロパティを読み込む"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:12
#, fuzzy
msgid ""
"This guide explains how your Quarkus application can read configuration "
"properties at runtime from the https://cloud.spring.io/spring-cloud-"
"config[Spring Cloud Config Server]."
msgstr ""
"このガイドでは、Quarkusアプリケーションが実行時に link:https://cloud.spring.io/spring-cloud-"
"config[Spring Cloud Config Server]から設定プロパティを読み込む方法について説明します。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:28
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step."
msgstr "次項の説明に従って、一歩一歩アプリを作成していくことをお勧めします。"

#. type: Title ==
#: upstream/_guides/spring-cloud-config-client.adoc:29
#, no-wrap, fuzzy
msgid "Stand up a Config Server"
msgstr "コンフィグサーバを立ち上げる"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:33
#, fuzzy
msgid ""
"To stand up the Config Server required for this guide, please follow the "
"instructions outlined https://github.com/spring-guides/gs-centralized-"
"configuration#stand-up-a-config-server[here].  The end result of that "
"process is a running Config Server that will provide the `Hello world` value "
"for a configuration property named `message` when the application querying "
"the server is named `a-bootiful-client`."
msgstr ""
"このガイドに必要な Config Server を立ち上げるには、 link:https://github.com/spring-guides/gs-"
"centralized-configuration#stand-up-a-config-"
"server[ここで]概説されている手順に従ってください。このプロセスの最終的な結果は、実行中のコンフィグサーバーで、サーバーを照会するアプリケーションの名前が "
"`a-bootiful-client` である場合、 `message` という名前のコンフィグプロパティに `Hello world` "
"の値を提供することになります。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:47
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=spring-cloud-config-quickstart \\\n"
"    -DclassName=\"org.acme.spring.cloud.config.client.GreetingResource\" \\\n"
"    -Dpath=\"/greeting\" \\\n"
"    -Dextensions=\"spring-cloud-config-client\"\n"
"cd spring-cloud-config-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:50
#, fuzzy
msgid ""
"This command generates a Maven project with a REST endpoint and imports the "
"`spring-cloud-config-client` extension."
msgstr ""
"このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、 `spring-cloud-config-client` "
"拡張子をインポートします。"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:53
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `spring-"
"cloud-config-client` extension to your project by running the following "
"command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `spring-"
"cloud-config-client` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:57
#, no-wrap
msgid ""
"./mvnw quarkus:add-extension -Dextensions=\"spring-cloud-config-client\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:67
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-spring-cloud-config-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/consul-config.adoc:80
#, no-wrap, fuzzy
msgid "GreetingController"
msgstr "グリーティングコントローラ"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:73
#, fuzzy
msgid ""
"The Quarkus Maven plugin automatically generated a `GreetingResource` JAX-RS "
"resource in the `src/main/java/org/acme/spring/cloud/config/client/"
"GreetingResource.java` file that looks like:"
msgstr ""
"Quarkus Mavenプラグインは、 `src/main/java/org/acme/spring/cloud/config/client/"
"GreetingResource.java` ファイル内の `GreetingResource` JAX-"
"RSリソースを自動的に生成して、次のように表示します。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:77
#: upstream/_guides/spring-cloud-config-client.adoc:99
#, no-wrap
msgid "package org.acme.spring.spring.cloud.config.client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:251
#, no-wrap
msgid ""
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:289
#, no-wrap
msgid "@Path(\"/hello\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:103
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:106
#, fuzzy
msgid ""
"As we want to use configuration properties obtained from the Config Server, "
"we will update the `GreetingResource` to inject the `message` property. The "
"updated code will look like this:"
msgstr ""
"Config Serverから取得した設定プロパティを使用したいので、 `GreetingResource` を更新して `message` "
"プロパティを注入します。更新したコードは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:117
#, no-wrap
msgid "import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:112
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"message\", defaultValue=\"hello default\")\n"
"    String message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:130
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return message;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/consul-config.adoc:132
#, no-wrap, fuzzy
msgid "Configuring the application"
msgstr "アプリケーションの設定"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:124
#, fuzzy
msgid ""
"Quarkus provides various configuration knobs under the `quarkus.spring-cloud-"
"config` root. For the purposes of this guide, our Quarkus application is "
"going to be configured in `application.properties` as follows:"
msgstr ""
"Quarkusは、 `quarkus.spring-cloud-config` "
"ルートの下に様々な設定ノブを提供しています。このガイドの目的のために、私たちのQuarkusアプリケーションは以下のように `application."
"properties` で設定されることになっています。"

#. type: delimited block -
#: upstream/_guides/spring-cloud-config-client.adoc:133
#, no-wrap
msgid ""
"# use the same name as the application name that was configured when "
"standing up the Config Server\n"
"quarkus.application.name=a-bootiful-client\n"
"# enable retrieval of configuration from the Config Server - this is off by "
"default\n"
"quarkus.spring-cloud-config.enabled=true\n"
"# configure the URL where the Config Server listens to HTTP requests - this "
"could have been left out since http://localhost:8888 is the default\n"
"quarkus.spring-cloud-config.url=http://localhost:8888\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/scheduler.adoc:204
#, no-wrap, fuzzy
msgid "Package and run the application"
msgstr "アプリケーションをパッケージ化して実行する"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:167
#, fuzzy
msgid ""
"Run the application with: `./mvnw compile quarkus:dev`.  Open your browser "
"to http://localhost:8080/greeting."
msgstr ""
"アプリケーションを実行するには、次の手順を実行します: `./mvnw compile quarkus:dev`.ブラウザを http://"
"localhost:8080/greeting  に開きます。"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:141
#, fuzzy
msgid ""
"The result should be: `Hello world` as it is the value obtained from the "
"Spring Cloud Config server."
msgstr "結果は、Spring Cloud Configサーバから取得した値なので、 `Hello world` となるはずです。"

#. type: Title ==
#: upstream/_guides/consul-config.adoc:170
#, no-wrap, fuzzy
msgid "Run the application as a native executable"
msgstr "アプリケーションをネイティブ実行ファイルとして実行する"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:173
#, fuzzy
msgid ""
"You can of course create a native image using the instructions of the link:"
"building-native-image[Building a native executable guide]."
msgstr ""
"もちろん、 link:building-native-"
"image[ネイティブ実行ファイルの構築ガイド]の指示を使ってネイティブイメージを作成することもできます。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:514
#, no-wrap, fuzzy
msgid "More Spring guides"
msgstr "その他のスプリングガイド"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:517
#, fuzzy
msgid ""
"Quarkus has more Spring compatibility features. See the following guides for "
"more details:"
msgstr "Quarkusには、より多くのSpring互換機能があります。詳細については、以下のガイドを参照してください。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:519
#, fuzzy
msgid "link:spring-di[Quarkus - Extension for Spring DI]"
msgstr "link:spring-di[Quarkus - 春のDIのための拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-cloud-config-client.adoc:152
#, fuzzy
msgid "link:spring-web[Quarkus - Extension for Spring Web]"
msgstr "link:spring-web[Quarkus - Spring Web用の拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:520
#, fuzzy
msgid "link:spring-data-jpa[Quarkus - Extension for Spring Data JPA]"
msgstr "link:spring-data-jpa[Quarkus - Spring Data JPAの拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:521
#, fuzzy
msgid "link:spring-security[Quarkus - Extension for Spring Security]"
msgstr "link:spring-security[Quarkus - Spring Securityのための拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:523
#, fuzzy
msgid ""
"link:spring-boot-properties[Quarkus - Extension for Spring Boot properties]"
msgstr "link:spring-boot-properties[Quarkus - Spring Bootプロパティの拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:524
#, fuzzy
msgid "link:spring-cache[Quarkus - Extension for Spring Cache]"
msgstr "link:spring-cache[Quarkus - Spring Cacheの拡張機能]"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:524
#, fuzzy
msgid "link:spring-scheduled[Quarkus - Extension for Spring Scheduled]"
msgstr "link:spring-scheduled[クオークス - 春の予定延長]"

#. type: Title ==
#: upstream/_guides/spring-cloud-config-client.adoc:159
#, no-wrap, fuzzy
msgid "Spring Cloud Config Client Reference"
msgstr "Spring Cloud Configクライアントリファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/microprofile-health.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - MicroProfile Health"
msgstr "Quarkus - MicroProfile Health"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:12
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize the "
"MicroProfile Health specification through the SmallRye Health extension."
msgstr ""
"このガイドでは、QuarkusアプリケーションがSmallRye Health拡張機能を使用してMicroProfile "
"Health仕様を利用する方法を説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:17
#, fuzzy
msgid ""
"MicroProfile Health allows applications to provide information about their "
"state to external viewers which is typically useful in cloud environments "
"where automated processes must be able to determine whether the application "
"should be discarded or restarted."
msgstr ""
"MicroProfile Health "
"は、アプリケーションの状態に関する情報を外部のビューアに提供することを可能にします。これは、自動プロセスがアプリケーションを破棄するか再起動するかを判断する必要があるクラウド環境において、一般的に有用です。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:32
#, fuzzy
msgid ""
"In this guide, we build a simple REST application that exposes MicroProfile "
"Health functionalities at the `/health/live` and `/health/ready` endpoints "
"according to the specification."
msgstr ""
"このガイドでは、仕様に従って `/health/live` および `/health/ready` エンドポイントで MicroProfile "
"Health 機能を公開するシンプルな REST アプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:37
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step. However, you can go right to the "
"completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:43
#, fuzzy
msgid ""
"The solution is located in the `microprofile-health-quickstart` {quickstarts-"
"tree-url}/microprofile-health-quickstart[directory]."
msgstr ""
"ソリューションは `microprofile-health-quickstart` {quickstarts-tree-url}/"
"microprofile-health-quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:55
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=microprofile-health-quickstart \\\n"
"    -Dextensions=\"health\"\n"
"cd microprofile-health-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:59
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `smallrye-health` "
"extension which is an implementation of the MicroProfile Health "
"specification used in Quarkus."
msgstr ""
"このコマンドは、Quarkusで使用されているMicroProfile Health仕様の実装である `smallrye-health` "
"拡張子をインポートして、Mavenプロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:62
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-health` extension to your project by running the following command "
"in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-health` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:66
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"smallrye-health\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:76
#: upstream/_guides/microprofile-health.adoc:368
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-health</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:78
#, no-wrap, fuzzy
msgid "Running the health check"
msgstr "健康チェックの実行"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:81
#, fuzzy
msgid ""
"Importing the `smallrye-health` extension directly exposes three REST "
"endpoints:"
msgstr "`smallrye-health` 拡張モジュールをインポートすると、3 つの REST エンドポイントが直接公開されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:83
#, fuzzy
msgid "`/health/live` - The application is up and running."
msgstr "`/health/live` - アプリケーションが起動しています。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:84
#, fuzzy
msgid "`/health/ready` - The application is ready to serve requests."
msgstr "`/health/ready` - アプリケーションはリクエストに応える準備ができています。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:85
#, fuzzy
msgid ""
"`/health` - Accumulating all health check procedures in the application."
msgstr "`/health` - アプリケーション内のすべての健康チェックの手順を蓄積します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:87
#, fuzzy
msgid "To check that the `smallrye-health` extension is working as expected:"
msgstr "`smallrye-health` の拡張子が正常に動作していることを確認するため。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:89
#, fuzzy
msgid "start your Quarkus application with `./mvnw compile quarkus:dev`"
msgstr "でQuarkusアプリケーションを起動します。 `./mvnw compile quarkus:dev`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:91
#, fuzzy
msgid ""
"access the `http://localhost:8080/health/live` endpoint using your browser "
"or `curl http://localhost:8080/health/live`"
msgstr ""
"アクセス `&lt;a href=\"http://localhost:8080/health/live\" class="
"\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;`エンドポイントを使用して、ブラウザまたは "
"`curl &lt;a href=\"http://localhost:8080/health/live\" class="
"\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:93
#, fuzzy
msgid ""
"All of the health REST endpoints return a simple JSON object with two fields:"
""
msgstr "すべてのヘルスRESTエンドポイントは、2つのフィールドを持つシンプルなJSONオブジェクトを返します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:95
#, fuzzy
msgid "`status` -- the overall result of all the health check procedures"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:96
#, fuzzy
msgid "`checks` -- an array of individual checks"
msgstr "`checks`减免Zs_2009-ASEMANSIBLEAN-减免Zs_2009-ASEMANSIANの個別チェックの配列。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:100
#, fuzzy
msgid ""
"The general `status` of the health check is computed as a logical AND of all "
"the declared health check procedures. The `checks` array is empty as we have "
"not specified any health check procedure yet so let's define some."
msgstr ""
"ヘルスチェックの一般的な `status` は、宣言されたすべてのヘルスチェックプロシージャの論理 AND として計算されます。 `checks` "
"の配列は、まだ何もヘルスチェックプロシージャを指定していないので空です。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:101
#, no-wrap, fuzzy
msgid "Creating your first health check"
msgstr "初めての健康チェックの作成"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:104
#, fuzzy
msgid "In this section, we create our first simple health check procedure."
msgstr "ここでは、最初に簡単な健康チェックの手順を作成します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:106
#, fuzzy
msgid "Create the `org.acme.microprofile.health.SimpleHealthCheck` class:"
msgstr "`org.acme.microprofile.health.SimpleHealthCheck` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:110
#: upstream/_guides/microprofile-health.adoc:164
#: upstream/_guides/microprofile-health.adoc:210
#: upstream/_guides/microprofile-health.adoc:281
#, no-wrap
msgid "package org.acme.microprofile.health;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:114
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import org.eclipse.microprofile.health.Liveness;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:120
#, no-wrap
msgid ""
"@Liveness\n"
"@ApplicationScoped <1> <2>\n"
"public class SimpleHealthCheck implements HealthCheck {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:126
#, no-wrap
msgid ""
"    @Override\n"
"    public HealthCheckResponse call() {\n"
"        return HealthCheckResponse.up(\"Simple health check\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:128
#, fuzzy
msgid ""
"It's recommended to annotate the health check class with "
"`@ApplicationScoped` or the `@Singleton` scope so that a single bean "
"instance is used for all health check requests."
msgstr ""
"ヘルスチェッククラスに `@ApplicationScoped` や `@Singleton` "
"スコープをアノテーションして、単一のビーンインスタンスがすべてのヘルスチェックリクエストに使用されるようにすることをお勧めします。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:129
#, fuzzy
msgid ""
"If a bean class annotated with one of the health check annotations declares "
"no scope then the `@Singleton` scope is used automatically."
msgstr ""
"ヘルスチェックアノテーションの一つでアノテーションされたビーンクラスがスコープを宣言しない場合、 `@Singleton` "
"スコープが自動的に使用されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:131
#, fuzzy
msgid ""
"As you can see, the health check procedures are defined as CDI beans that "
"implement the `HealthCheck` interface and are annotated with one of the "
"health check qualifiers, such as:"
msgstr ""
"ご覧のように、ヘルスチェックの手続きは `HealthCheck` インターフェイスを実装した CDI "
"ビーンズとして定義されており、ヘルスチェック修飾子のいずれかでアノテーションされています。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:133
#, fuzzy
msgid "`@Liveness` - the liveness check accessible at `/health/live`"
msgstr "`@Liveness` - ライブネスチェックにアクセスするには、以下のサイトを参照してください。 `/health/live`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:134
#, fuzzy
msgid "`@Readiness` - the readiness check accessible at `/health/ready`"
msgstr "`@Readiness` - 準備状況のチェックは以下のサイトからアクセスできます。 `/health/ready`"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:138
#, fuzzy
msgid ""
"`HealthCheck` is a functional interface whose single method `call` returns a "
"`HealthCheckResponse` object which can be easily constructed by the fluent "
"builder API shown in the example."
msgstr ""
"`HealthCheck` は、単一メソッド `call` が `HealthCheckResponse` "
"オブジェクトを返す機能的なインターフェイスで、例に示した fluent ビルダー API で簡単に構築できます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:144
#, fuzzy
msgid ""
"As we have started our Quarkus application in dev mode simply repeat the "
"request to `http://localhost:8080/health/live` by refreshing your browser "
"window or by using `curl http://localhost:8080/health/live`. Because we "
"defined our health check to be a liveness procedure (with `@Liveness` "
"qualifier) the new health check procedure is now present in the `checks` "
"array."
msgstr ""
"開発モードでQuarkusアプリケーションを起動しているので、次のようなリクエストを繰り返します。 `&lt;a href=\"http://"
"localhost:8080/health/live\" class=\"bare\"&gt;http://localhost:8080/health/"
"live&lt;/a&gt;`ブラウザのウィンドウをリフレッシュするか `curl &lt;a href=\"http://localhost:8080/"
"health/live\" class=\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;`."
"ヘルスチェックをlivenessプロシージャ( `@Liveness` 修飾子付き)と定義したので、新しいヘルスチェックプロシージャは `checks` "
"配列に存在するようになりました。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:147
#, fuzzy
msgid ""
"Congratulations! You've created your first Quarkus health check procedure. "
"Let's continue by exploring what else can be done with the MicroProfile "
"Health specification."
msgstr ""
"おめでとうございます。最初のQuarkusヘルスチェック手順を作成しました。続けて、MicroProfile "
"Health仕様を使用して、他に何ができるのかを調べてみましょう。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:148
#, no-wrap, fuzzy
msgid "Adding a readiness health check procedure"
msgstr "準備健康チェックの手順を追加する"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:154
#, fuzzy
msgid ""
"In the previous section, we created a simple liveness health check procedure "
"which states whether our application is running or not. In this section, we "
"will create a readiness health check which will be able to state whether our "
"application is able to process requests."
msgstr ""
"前のセクションでは、アプリケーションが動作しているかどうかを示す、簡単な動作確認の手順を作成しました。このセクションでは、アプリケーションがリクエストを処理できるかどうかを示すことができるようにするための準備度チェックを作成します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:158
#, fuzzy
msgid ""
"We will create another health check procedure that simulates a connection to "
"an external service provider such as a database. For starters, we will "
"always return the response indicating the application is ready."
msgstr ""
"データベースのような外部サービス・プロバイダへの接続をシミュレートする別のヘルス・チェック・プロシージャを作成します。手始めに、アプリケーションの準備ができていることを示すレスポンスを常に返します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:160
#, fuzzy
msgid ""
"Create `org.acme.microprofile.health.DatabaseConnectionHealthCheck` class:"
msgstr ""
"`org.acme.microprofile.health.DatabaseConnectionHealthCheck` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:168
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import org.eclipse.microprofile.health.Readiness;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:174
#: upstream/_guides/microprofile-health.adoc:222
#, no-wrap
msgid ""
"@Readiness\n"
"@ApplicationScoped\n"
"public class DatabaseConnectionHealthCheck implements HealthCheck {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:180
#, no-wrap
msgid ""
"    @Override\n"
"    public HealthCheckResponse call() {\n"
"        return HealthCheckResponse.up(\"Database connection health check\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:190
#, fuzzy
msgid ""
"If you now rerun the health check at `http://localhost:8080/health/live` the "
"`checks` array will contain only the previously defined `SimpleHealthCheck` "
"as it is the only check defined with the `@Liveness` qualifier. However, if "
"you access `http://localhost:8080/health/ready` (in the browser or with "
"`curl http://localhost:8080/health/ready`) you will see only the `Database "
"connection health check` as it is the only health check defined with the "
"`@Readiness` qualifier as the readiness health check procedure."
msgstr ""
"でヘルスチェックを再実行した場合は `&lt;a href=\"http://localhost:8080/health/live\" class="
"\"bare\"&gt;http://localhost:8080/health/live&lt;/a&gt;` `checks` の配列には、 "
"`@Liveness` の修飾子で定義された唯一のチェックなので、先に定義された `SimpleHealthCheck` だけが含まれます。しかし、もし "
"`&lt;a href=\"http://localhost:8080/health/ready\" class=\"bare\"&gt;http://"
"localhost:8080/health/ready&lt;/a&gt;`(ブラウザや `curl &lt;a href=\"http://"
"localhost:8080/health/ready\" class=\"bare\"&gt;http://localhost:8080/health/"
"ready&lt;/a&gt;`)では、 `Database connection health check` だけが表示されますが、これは "
"`@Readiness` の修飾子で定義された唯一のヘルスチェックであるため、レディネスヘルスチェックの手順として表示されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:192
#, fuzzy
msgid ""
"If you access `http://localhost:8080/health` you will get back both checks."
msgstr ""
"アクセスした場合 `&lt;a href=\"http://localhost:8080/health\" class=\"bare\"&gt;http:"
"//localhost:8080/health&lt;/a&gt;`あなたは両方の小切手を取り戻すでしょう。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:197
#, fuzzy
msgid ""
"More information about which health check procedures should be used in which "
"situation is detailed in the MicroProfile Health specification. Generally, "
"the liveness procedures determine whether the application should be "
"restarted while readiness procedures determine whether it makes sense to "
"contact the application with requests."
msgstr ""
"どのヘルスチェック手順をどのような状況で使用すべきかについての詳細は、MicroProfile "
"のヘルス仕様に詳述されています。一般的には、活性化の手順はアプリケーションを再起動すべきかどうかを決定し、準備の手順はアプリケーションにリクエストを連絡することが意味のあることかどうかを決定します。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:198
#, no-wrap, fuzzy
msgid "Negative health check procedures"
msgstr "ネガティブヘルスチェックの手順"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:204
#, fuzzy
msgid ""
"In this section, we extend our `Database connection health check` with the "
"option of stating that our application is not ready to process requests as "
"the underlying database connection cannot be established. For simplicity "
"reasons, we only determine whether the database is accessible or not by a "
"configuration property."
msgstr ""
"このセクションでは、 `Database connection health check` を拡張して、基礎となるデータベース接続が確立できないために、 "
"アプリケーションがリクエストを処理する準備ができていないことを示すオプションを追加しています。単純化のために、データベースにアクセスできるかどうかは設定プロパティでのみ判断します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:206
#, fuzzy
msgid ""
"Update the `org.acme.microprofile.health.DatabaseConnectionHealthCheck` "
"class:"
msgstr ""
"`org.acme.microprofile.health.DatabaseConnectionHealthCheck` クラスを更新します。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:216
#, no-wrap
msgid ""
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n"
"import org.eclipse.microprofile.health.Readiness;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:225
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"database.up\", defaultValue = \"false\")\n"
"    private boolean databaseUp;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:228
#, no-wrap
msgid "    @Override\n"
"    public HealthCheckResponse call() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:230
#, no-wrap
msgid ""
"        HealthCheckResponseBuilder responseBuilder = HealthCheckResponse."
"named(\"Database connection health check\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:238
#, no-wrap
msgid ""
"        try {\n"
"            simulateDatabaseConnectionVerification();\n"
"            responseBuilder.up();\n"
"        } catch (IllegalStateException e) {\n"
"            // cannot access the database\n"
"            responseBuilder.down();\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:241
#, no-wrap
msgid "        return responseBuilder.build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:248
#, no-wrap
msgid ""
"    private void simulateDatabaseConnectionVerification() {\n"
"        if (!databaseUp) {\n"
"            throw new IllegalStateException(\"Cannot contact database\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:255
#, fuzzy
msgid ""
"Until now we used a simplified method of building a `HealthCheckResponse` "
"through the `HealthCheckResponse#up(String)` (there is also "
"`HealthCheckResponse#down(String)`) which will directly build the response "
"object.  From now on, we utilize the full builder capabilities provided by "
"the `HealthCheckResponseBuilder` class."
msgstr ""
"これまでは、 `HealthCheckResponse#up(String)` ( `HealthCheckResponse#down(String)` "
"もあります) を通して `HealthCheckResponse` "
"を構築する単純な方法を使用していましたが、これはレスポンスオブジェクトを直接構築するものです。今後は、 "
"`HealthCheckResponseBuilder` クラスが提供する完全なビルダー機能を利用します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:260
#, fuzzy
msgid ""
"If you now rerun the readiness health check (at `http://localhost:8080/"
"health/ready`)  the overall `status` should be DOWN. You can also check the "
"liveness check at `http://localhost:8080/health/live` which will return the "
"overall `status` UP because it isn't influenced by the readiness checks."
msgstr ""
"今、準備状態の健康チェックを再実行した場合 ( `&lt;a href=\"http://localhost:8080/health/ready\" "
"class=\"bare\"&gt;http://localhost:8080/health/ready&lt;/a&gt;`) `status` "
"が全体的にダウンしているはずです。また、ライブネスチェックは `&lt;a href=\"http://localhost:8080/health/"
"live\" class=\"bare\"&gt;http://localhost:8080/health/live&lt;/"
"a&gt;`これは、準備チェックの影響を受けないので、全体の `status` UP を返します。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:264
#, fuzzy
msgid ""
"As we shouldn't leave this application with a readiness check in a DOWN "
"state and because we are running Quarkus in dev mode you can add `database."
"up=true` in `src/main/resources/application.properties` and rerun the "
"readiness health check again"
msgstr ""
"このアプリケーションをDOWN状態でレディネスチェックをしたままにしておくべきではないし、Quarkusをdevモードで実行しているので、 "
"`database.up=true` を `src/main/resources/application.properties` "
"に追加して、レディネスヘルスチェックを再実行することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:265
#, fuzzy
msgid "it should be up again."
msgstr "また上がるはずです。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:267
#, no-wrap, fuzzy
msgid "Adding user-specific data to the health check response"
msgstr "ヘルスチェック応答にユーザー固有のデータを追加する"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:275
#, fuzzy
msgid ""
"In previous sections, we saw how to create simple health checks with only "
"the minimal attributes, namely, the health check name and its status (UP or "
"DOWN). However, the MicroProfile specification also provides a way for the "
"applications to supply arbitrary data in the form of key-value pairs sent to "
"the consuming end. This can be done by using the `withData(key, value)` "
"method of the health check response builder API."
msgstr ""
"前のセクションでは、最低限の属性、すなわちヘルスチェック名とそのステータス(UPまたはDOWN)だけで単純なヘルスチェックを作成する方法を見た。しかし、MicroProfile "
"仕様では、アプリケーションが任意のデータをキーと値のペアの形で消費側に送信する方法も提供しています。これは、ヘルスチェック応答ビルダ API の "
"`withData(key, value)` メソッドを使用して行うことができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:277
#, fuzzy
msgid ""
"Let's create a new health check procedure `org.acme.microprofile.health."
"DataHealthCheck`:"
msgstr "新しい健康チェックの手順を作ってみよう `org.acme.microprofile.health.DataHealthCheck`."

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:285
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.Liveness;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:291
#, no-wrap
msgid ""
"@Liveness\n"
"@ApplicationScoped\n"
"public class DataHealthCheck implements HealthCheck {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:301
#, no-wrap
msgid ""
"    @Override\n"
"    public HealthCheckResponse call() {\n"
"        return HealthCheckResponse.named(\"Health check with data\")\n"
"                .up()\n"
"                .withData(\"foo\", \"fooValue\")\n"
"                .withData(\"bar\", \"barValue\")\n"
"                .build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:307
#, fuzzy
msgid ""
"If you rerun the liveness health check procedure by accessing the `/health/"
"live` endpoint you can see that the new health check `Health check with "
"data` is present in the `checks` array. This check contains a new attribute "
"called `data` which is a JSON object consisting of the properties we have "
"defined in our health check procedure."
msgstr ""
"`/health/live` エンドポイントにアクセスして liveness ヘルスチェックプロシージャを再実行すると、 `checks` "
"配列に新しいヘルスチェック `Health check with data` が存在することがわかります。このチェックには `data` "
"という新しい属性が含まれており、これは、ヘルス・チェック・プロシージャで定義したプロパティで構成される JSON オブジェクトです。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:310
#, fuzzy
msgid ""
"This functionality is specifically useful in failure scenarios where you can "
"pass the error along with the health check response."
msgstr "この機能は、エラーをヘルスチェック応答と一緒に渡すことができる障害シナリオで特に有用です。"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:322
#, no-wrap
msgid ""
"        try {\n"
"            simulateDatabaseConnectionVerification();\n"
"            responseBuilder.up();\n"
"        } catch (IllegalStateException e) {\n"
"            // cannot access the database\n"
"            responseBuilder.down()\n"
"                    .withData(\"error\", e.getMessage()); // pass the "
"exception message\n"
"        }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:324
#, no-wrap, fuzzy
msgid "Extension health checks"
msgstr "エクステンションの健康チェック"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:327
#, fuzzy
msgid ""
"Some extension may provide default health checks, including the extension "
"will automatically register its health checks."
msgstr "拡張機能によってはデフォルトのヘルスチェックを提供している場合があり、その場合は拡張機能が自動的にヘルスチェックを登録してくれます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:330
#, fuzzy
msgid ""
"For example, `quarkus-agroal` that is used to manage Quarkus datasource(s) "
"automatically register a readiness health check that will validate each "
"datasources: link:datasource#datasource-health-check[Datasource Health "
"Check]."
msgstr ""
"例えば、Quarkusのデータソースを管理するために使用されている `quarkus-agroal` "
"は、各データソースを検証するレディネスヘルスチェックを自動的に登録します。 link:datasource#datasource-health-"
"check[Datasource Health Check]."

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:332
#, fuzzy
msgid ""
"You can disable extension health check via the property `quarkus.health."
"extensions.enabled` so none will be automatically registered."
msgstr ""
"プロパティ `quarkus.health.extensions.enabled` "
"で拡張子の健康チェックを無効にすることができるので、何も自動的に登録されません。"

#. type: Title ==
#: upstream/_guides/microprofile-health.adoc:333
#, no-wrap, fuzzy
msgid "Health UI "
msgstr "健康UI"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:338
#, fuzzy
msgid "`health-ui` allows you to see your Health Checks in a Web GUI."
msgstr "`health-ui` では、Web GUI で健康診断を見ることができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:340
#, fuzzy
msgid ""
"The Quarkus `smallrye-health` extension ships with `health-ui` and enables "
"it by default in dev and test modes, but it can also be explicitly "
"configured for production mode as well."
msgstr ""
"Quarkus `smallrye-health` 拡張機能は `health-ui` "
"に同梱されており、開発モードとテストモードではデフォルトで有効になっていますが、本番モードでも明示的に設定することができます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:342
#, fuzzy
msgid "`health-ui` can be accessed from http://localhost:8080/health-ui/ ."
msgstr "`health-ui` は http://localhost:8080/health-ui/ からアクセスできます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:344
#, fuzzy
msgid "image:health-ui-screenshot01.png[alt=Health UI]"
msgstr "image:health-ui-screenshot01.png[alt=Health UI]"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:351
#, fuzzy
msgid ""
"MicroProfile Health provides a way for your application to distribute "
"information about its healthiness state to state whether or not it is able "
"to function properly.  Liveness checks are utilized to tell whether the "
"application should be restarted and readiness checks are used to tell "
"whether the application is able to process requests."
msgstr ""
"MicroProfile Health "
"は、アプリケーションが正常に機能するかどうかを示すために、アプリケーションの健康状態に関する情報を配布する方法を提供します。元気度チェックはアプリケーションを再起動すべきかどうかを伝えるために利用され、レディネスチェックはアプリケーションがリクエストを処理できるかどうかを伝えるために利用されます。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:353
#, fuzzy
msgid ""
"All that is needed to enable the MicroProfile Health features in Quarkus is:"
msgstr "QuarkusのMicroProfile Health機能を有効にするために必要なのは、これだけです。"

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:356
#, fuzzy
msgid ""
"adding the `smallrye-health` Quarkus extension to your project using the "
"`quarkus-maven-plugin`: +"
msgstr ""
"`smallrye-health` Quarkus拡張機能をプロジェクトに追加するには、 `quarkus-maven-plugin`.\n"
"<br>"

#. type: delimited block -
#: upstream/_guides/microprofile-health.adoc:359
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"health\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-health.adoc:362
#, fuzzy
msgid "or simply adding the following Maven dependency: +"
msgstr "または、単に以下のMaven依存関係を追加するだけです。\n"
"<br>"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security.adoc:6
#, no-wrap
msgid "Quarkus - Security Architecture and Guides"
msgstr "Quarkus - セキュリティアーキテクチャとガイド"

#. type: Plain text
#: upstream/_guides/security.adoc:11
msgid ""
"Quarkus Security provides the architecture, multiple authentication and "
"authorization mechanisms, and other tools for the developers to build a "
"production-quality security for their Quarkus applications."
msgstr ""
"Quarkus "
"Securityでは、開発者がQuarkusアプリケーションの商用品質のセキュリティを構築するためのアーキテクチャ、複数の認証および認可メカニズム、その他のツールを提供しています。"

#. type: Plain text
#: upstream/_guides/security.adoc:13
msgid ""
"This document provides a brief overview of Quarkus Security and links to the "
"individual guides."
msgstr "このドキュメントでは、Quarkus Securityの簡単な概要と、各ガイドへのリンクについて説明しています。"

#. type: Plain text
#: upstream/_guides/security.adoc:17
msgid ""
"`HttpAuthenticationMechanism` is the main entry into Quarkus HTTP Security."
msgstr "`HttpAuthenticationMechanism`  は、Quarkus HTTP Securityのメインエントリです。"

#. type: Plain text
#: upstream/_guides/security.adoc:20
msgid ""
"Quarkus Security Manager uses `HttpAuthenticationMechanism` to extract the "
"authentication credentials from the HTTP request and delegates to "
"`IdentityProvider` to complete the conversion of these credentials to "
"`SecurityIdentity`."
msgstr ""
"Quarkus Security Managerは、 `HttpAuthenticationMechanism`  "
"を使用してHTTPリクエストから認証資格情報を抽出し、 `IdentityProvider`  に委任して、これらの資格情報の "
"`SecurityIdentity`  への変換を完了させます。"

#. type: Plain text
#: upstream/_guides/security.adoc:22
msgid ""
"For example, the credentials may be coming with the HTTP `Authorization` "
"header, client HTTPS certificates or cookies."
msgstr ""
"例えば、資格情報は、HTTP `Authorization`  ヘッダー、クライアントの HTTPS "
"証明書、またはクッキーを使用している場合があります。"

#. type: Plain text
#: upstream/_guides/security.adoc:24
msgid ""
"`IdentityProvider` verifies the authentication credentials and maps them to "
"`SecurityIdentity` which contains the username, roles, the original "
"authentication credentials, and other attributes."
msgstr ""
"`IdentityProvider`  は認証資格情報を検証し、ユーザ名、ロール、元の認証資格情報、およびその他の属性を含む "
"`SecurityIdentity`  にマップします。"

#. type: Plain text
#: upstream/_guides/security.adoc:26
msgid ""
"For every authenticated resource, you can inject a `SecurityIdentity` "
"instance to get the authenticated identity information."
msgstr "認証済みリソースごとに、 `SecurityIdentity`  インスタンスを注入して、認証済みの ID 情報を取得することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:29
msgid ""
"In some other contexts you may have other parallel representations of the "
"same information (or parts of it) such as `SecurityContext` for JAX-RS or "
"`JsonWebToken` for JWT."
msgstr ""
"他の文脈では、JAX-RSであれば `SecurityContext`  、JWTであれば `JsonWebToken`  "
"のように、同じ情報（またはその一部）を他の別の表現で表現している場合があります。"

#. type: Title ==
#: upstream/_guides/security.adoc:30
#, no-wrap
msgid "Authentication mechanisms"
msgstr "認証メカニズム"

#. type: Plain text
#: upstream/_guides/security.adoc:33
msgid ""
"Quarkus supports several sources to load authentication information from."
msgstr "Quarkusは、認証情報をロードするためのいくつかのソースをサポートしています。"

#. type: Title ===
#: upstream/_guides/security.adoc:34
#, no-wrap
msgid "Basic and Form Authentication Mechanisms"
msgstr "基本認証とフォーム認証の仕組み"

#. type: Plain text
#: upstream/_guides/security.adoc:38
msgid ""
"Basic and Form HTTP-based authentication mechanisms are the core "
"authentication mechanisms supported in Quarkus.  Please see link:security-"
"built-in-authentication#basic-auth[Basic HTTP Authentication] and link:"
"security-built-in-authentication#form-auth[Form HTTP Authentication] for "
"more information."
msgstr ""
"Basic HTTPベースの認証メカニズムとForm "
"HTTPベースの認証メカニズムは、Quarkusでサポートされている主要な認証メカニズムです。詳細については、 link:security-built-"
"in-authentication#basic-auth[基本HTTP認証]と link:security-built-in-"
"authentication#form-auth[フォームHTTP認証]を参照してください。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:41
#, no-wrap, fuzzy
msgid "Mutual TLS Authentication"
msgstr "相互TLS認証"

#. type: Plain text
#: upstream/_guides/security.adoc:42
msgid ""
"Quarkus provides Mutual TLS authentication so that you can authenticate "
"users based on their X.509 certificates."
msgstr "Quarkusは相互TLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。"

#. type: Plain text
#: upstream/_guides/security.adoc:44
msgid ""
"Please see link:security-built-in-authentication#mutual-tls[Mutual TLS "
"Authentication] for more information."
msgstr ""
"詳しくは link:security-built-in-authentication#mutual-tls[相互TLS認証] をご覧ください。"

#. type: Title ===
#: upstream/_guides/security.adoc:45
#, no-wrap
msgid "OpenId Connect"
msgstr "OpenId Connect"

#. type: Plain text
#: upstream/_guides/security.adoc:48
msgid ""
"`quarkus-oidc` extension provides a reactive, interoperable, multi-tenant "
"enabled OpenId Connect adapter which supports `Bearer Token` and "
"`Authorization Code Flow` authentication mechanisms."
msgstr ""
"`quarkus-oidc`  エクステンションは、 `Bearer Token`  および `Authorization Code Flow`  "
"認証メカニズムをサポートする、リアクティブで相互運用可能なマルチテナント対応の OpenId Connect アダプタを提供します。"

#. type: Plain text
#: upstream/_guides/security.adoc:51
msgid ""
"`Bearer Token` mechanism extracts the token from HTTP `Authorization` header."
"  `Authorization Code Flow` mechanism uses OpenId Connect Authorization Code "
"flow. It redirects the user to IDP to authenticate and completes the "
"authentication process after the user has been redirected back to Quarkus by "
"exchanging the provided code grant for ID, access and refresh tokens."
msgstr ""
"`Bearer Token`  メカニズムは、HTTP `Authorization`  ヘッダーからトークンを抽出します。 "
"`Authorization Code Flow`  メカニズムは、OpenId Connect Authorization Code "
"Flowを使用します。ユーザーをIDPにリダイレクトして認証を行い、提供されたCode "
"GrantをID、アクセストークン、リフレッシュトークンと交換することで、ユーザーがQuarkusにリダイレクトされた後に認証プロセスを完了させます。"

#. type: Plain text
#: upstream/_guides/security.adoc:53
msgid ""
"ID and access `JWT` tokens are verified with the refreshable `JWK` key set "
"but both JWT and opaque (binary) tokens can be introspected remotely."
msgstr ""
"ID とアクセス `JWT` トークンは、リフレッシュ可能な `JWK` キーセットで検証されますが、JWT と不透明な (バイナリの) "
"トークンの両方をリモートで検証することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:55
msgid ""
"See the link:security-openid-connect[Using OpenID Connect to Protect Service "
"Applications] guide for more information about `Bearer Token` authentication "
"mechanism."
msgstr ""
"`Bearer Token` 認証メカニズムの詳細については、 link:security-openid-connect[Using OpenID "
"Connect to Protect Service Applications]ガイドを参照してください。"

#. type: Plain text
#: upstream/_guides/security.adoc:57
msgid ""
"See the link:security-openid-connect-web-authentication[Using OpenID Connect "
"to Protect Web Application] guide for more information about `Authorization "
"Code Flow` authentication mechanism."
msgstr ""
"`Authorization Code Flow`  認証メカニズムの詳細については、 link:security-openid-connect-web-"
"authentication[Using OpenID Connect to Protect Web Application]ガイドを参照してください。"

#. type: delimited block =
#: upstream/_guides/security.adoc:61
msgid ""
"Both `quarkus-oidc` `Bearer` and `Authorization Code Flow` Authentication "
"mechanisms use <<smallrye-jwt, SmallRye JWT>> to represent JWT tokens as "
"Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken`."
msgstr ""
"`quarkus-oidc` の`Bearer` と `Authorization Code Flow`  認証メカニズムはいずれも link:"
"#smallrye-jwt[SmallRye JWT ]を使用して、JWT トークンを Microprofile JWT `org.eclipse."
"microprofile.jwt.JsonWebToken` として表現しています。"

#. type: Plain text
#: upstream/_guides/security.adoc:64
msgid ""
"See link:security-openid-connect-multitenancy[Using OpenID Connect Multi-"
"Tenancy] for more information about multiple tenants which can support "
"`Bearer` or `Authorization Code Flow` authentication mechanism and "
"configured statically or dynamically."
msgstr ""
"`Bearer`  または `Authorization Code Flow`  "
"認証メカニズムをサポートし、静的または動的に設定できる複数のテナントの詳細については、 link:security-openid-connect-"
"multitenancy[OpenID Connect マルチテナントの使用]を参照してください。"

#. type: delimited block =
#: upstream/_guides/security.adoc:69
msgid ""
"If you would like to have Quarkus OIDC extension enabled at runtime then set "
"`quarkus.oidc.tenant-enabled=false` at build time and re-enable it at "
"runtime using a system property.  See also link:security-openid-connect-"
"multitenancy#disable-tenant[Disabling Tenant Configurations] for more "
"information about managing the individual tenant configurations in the multi-"
"tenant OIDC deployments."
msgstr ""
"実行時にQuarkus OIDCエクステンションを有効にしたい場合は、ビルド時に `quarkus.oidc.tenant-enabled=false` "
"を設定し、システムプロパティを使用して実行時に再度有効にします。マルチテナントOIDCデプロイメントでの個々のテナント設定の管理の詳細については、テナント "
"link:security-openid-connect-multitenancy#disable-tenant[設定の無効化]も参照してください。"

#. type: Plain text
#: upstream/_guides/security.adoc:72
msgid ""
"If you use Keycloak and Bearer tokens then also see the link:security-"
"keycloak-authorization[Using Keycloak to Centralize Authorization] guide."
msgstr ""
"Keycloak と Bearer トークンを使用する場合は、 link:security-keycloak-authorization[Using "
"Keycloak to Centralize Authorization]ガイドも参照してください。"

#. type: delimited block =
#: upstream/_guides/security.adoc:76
msgid ""
"If you need to configure Keycloak programmatically then consider using https:"
"//www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak "
"Admin REST API] with the help of the `quarkus-keycloak-admin-client` "
"extension."
msgstr ""
"Keycloakをプログラムで設定する必要がある場合は、 `quarkus-keycloak-admin-client` "
"エクステンションの助けを借りて、 link:https://www.keycloak.org/docs/latest/"
"server_development/#admin-rest-api[Keycloak Admin REST API]の使用を検討してください。"

#. type: Title ===
#: upstream/_guides/security.adoc:79
#, no-wrap
msgid "SmallRye JWT"
msgstr "SmallRye JWT"

#. type: Plain text
#: upstream/_guides/security.adoc:82
msgid ""
"`quarkus-smallrye-jwt` provides Microprofile JWT 1.1.1 implementation and "
"many more options to verify signed and encrypted `JWT` tokens and represent "
"them as `org.eclipse.microprofile.jwt.JsonWebToken`."
msgstr ""
"`quarkus-smallrye-jwt` はMicroprofile JWT 1.1.1.1 の実装と、署名・暗号化された `JWT` "
"トークンを検証し、 `org.eclipse.microprofile.jwt.JsonWebToken` "
"として表現するための多くのオプションを提供します。"

#. type: Plain text
#: upstream/_guides/security.adoc:84
msgid ""
"It provides an alternative to `quarkus-oidc` Bearer Token Authentication "
"Mechanism. It can currently verify only `JWT` tokens using the PEM keys or "
"refreshable `JWK` key set."
msgstr ""
"それは `quarkus-oidc` ベアラートークン認証メカニズムに代わるものを提供します。現在、PEM 鍵または更新可能な `JWK` "
"鍵セットを使用して `JWT` トークンのみを検証することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:86
msgid ""
"Additionally it provides `JWT Generation API` for creating `signed`, `inner-"
"signed` and/or `encrypted` `JWT` tokens with ease."
msgstr ""
"さらに、 `JWT Generation API` を提供して、 `signed` , `inner-signed` , および/または "
"`encrypted` `JWT`トークンを簡単に作成することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:88
msgid ""
"See the link:security-jwt[Using SmallRye JWT] guide for more information."
msgstr "詳細については、 link:security-jwt[Using SmallRye JWT]ガイドを参照してください。"

#. type: Title ===
#: upstream/_guides/security.adoc:89
#, no-wrap
msgid "OAuth2"
msgstr "OAuth2"

#. type: Plain text
#: upstream/_guides/security.adoc:92
msgid ""
"`quarkus-elytron-security-oauth2` provides an alternative to `quarkus-oidc` "
"Bearer Token Authentication Mechanism. It is based on `Elytron` and is "
"primarily meant for introspecting the opaque tokens remotely."
msgstr ""
"`quarkus-elytron-security-oauth2`  は `quarkus-oidc`  Bearer Token "
"認証メカニズムの代替手段を提供します。これは `Elytron` "
"をベースにしており、主に不透明なトークンをリモートでイントロスペクトするためのものです。"

#. type: Plain text
#: upstream/_guides/security.adoc:94
msgid "See the link:security-oauth2[Using OAuth2] guide for more information."
msgstr "詳細については、 link:security-oauth2[OAuth2 の使用]ガイドを参照してください。"

#. type: Title ===
#: upstream/_guides/security.adoc:95
#, no-wrap
msgid "LDAP"
msgstr "LDAP"

#. type: Plain text
#: upstream/_guides/security.adoc:98
msgid ""
"Please see the link:security-ldap[Authenticate with LDAP] guide for more "
"information about LDAP authentication mechanism."
msgstr ""
"LDAP認証メカニズムの詳細については、 link:security-ldap[Authenticate with LDAP]ガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:100
#, no-wrap
msgid "Identity Providers"
msgstr "アイデンティティ・プロバイダー"

#. type: Plain text
#: upstream/_guides/security.adoc:103
msgid ""
"`IdentityProvider` converts the authentication credentials provided by "
"`HttpAuthenticationMechanism` to `SecurityIdentity`."
msgstr ""
"`IdentityProvider`  は、 `HttpAuthenticationMechanism`  が提供する認証資格情報を "
"`SecurityIdentity`  に変換します。"

#. type: Plain text
#: upstream/_guides/security.adoc:106
msgid ""
"Some extensions such as `OIDC`, `OAuth2`, `SmallRye JWT`, `LDAP` have the "
"inlined `IdentityProvider` implementations which are specific to the "
"supported authentication flow.  For example, `quarkus-oidc` uses its own "
"`IdentityProvider` to convert a token to `SecurityIdentity`."
msgstr ""
"`OIDC` , `OAuth2` , `SmallRye JWT` , `LDAP`  "
"などのエクステンションには、サポートされている認証フローに固有の `IdentityProvider` のインライン実装があります。例えば、 "
"`quarkus-oidc` は独自の `IdentityProvider` を使用してトークンを `SecurityIdentity` に変換します。"

#. type: Plain text
#: upstream/_guides/security.adoc:108
msgid ""
"If you use `Basic` or `Form` HTTP-based authentication then you have to add "
"an `IdentityProvider` which can convert a user name and password to "
"`SecurityIdentity`."
msgstr ""
"`Basic` または `Form` HTTP ベースの認証を使用している場合は、ユーザー名とパスワードを `SecurityIdentity` "
"に変換できる `IdentityProvider` を追加する必要があります。"

#. type: Plain text
#: upstream/_guides/security.adoc:111
msgid ""
"See link:security-jpa[JPA IdentityProvider] and link:security-jdbc[JDBC "
"IdentityProvider] for more information.  You can also use link:security-"
"testing#configuring-user-information[User Properties IdentityProvider] for "
"testing."
msgstr ""
"詳細は、 link:security-jpa[JPA IdentityProvider]および link:security-jdbc[JDBC "
"IdentityProvider]を参照してください。また、テストに link:security-testing#configuring-user-"
"information[User Properties IdentityProvider を]使用することもできます。"

#. type: Title ==
#: upstream/_guides/security.adoc:112
#, no-wrap
msgid "Combining Authentication Mechanisms"
msgstr "認証メカニズムの組み合わせ"

#. type: Plain text
#: upstream/_guides/security.adoc:116
msgid ""
"One can combine multiple authentication mechanisms if they get the "
"authentication credentials from the different sources.  For example, "
"combining built-in `Basic` and `quarkus-oidc` `Bearer` authentication "
"mechanisms is allowed, but combining `quarkus-oidc` `Bearer` and `smallrye-"
"jwt` authentication mechanisms is not allowed because both will attempt to "
"verify the token extracted from the HTTP `Authorization Bearer` scheme."
msgstr ""
"異なるソースから認証証明書を取得する場合、複数の認証メカニズムを組み合わせることができます。例えば、組み込みの `Basic`  と `Bearer`  "
" `quarkus-oidc`  認証機構を組み合わせることはできますが、 `quarkus-oidc`   `Bearer`  と `smallrye-"
"jwt`  認証機構を組み合わせることはできません。なぜなら、両方とも HTTP `Authorization Bearer`  "
"スキームから抽出されたトークンを検証しようとするからです。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:105
#, no-wrap, fuzzy
msgid "Proactive Authentication"
msgstr "プロアクティブ認証"

#. type: Plain text
#: upstream/_guides/security.adoc:121
msgid ""
"By default, Quarkus does what we call proactive authentication. This means "
"that if an incoming request has a credential then that request will always "
"be authenticated (even if the target page does not require authentication)."
msgstr ""
"デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます（ターゲットページが認証を必要としない場合でも）。"

#. type: Plain text
#: upstream/_guides/security.adoc:123
msgid ""
"See link:security-built-in-authentication#proactive-authentication[Proactive "
"Authentication] for more information."
msgstr ""
"詳細については、 link:security-built-in-authentication#proactive-"
"authentication[プロアクティブ認証]を参照してください。"

#. type: Title ===
#: upstream/_guides/security-built-in-authentication.adoc:99
#, no-wrap, fuzzy
msgid "Authorization"
msgstr "認可"

#. type: Plain text
#: upstream/_guides/security.adoc:127
msgid ""
"See link:security-authorization[Security Authorization] for more information "
"about Role Based Access Control and other authorization options."
msgstr ""
"役割ベースのアクセス制御およびその他の認可オプションの詳細については、 link:security-"
"authorization[セキュリティ認可]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:128
#, no-wrap
msgid "Customization and other useful tips"
msgstr "カスタマイズやその他の便利なヒント"

#. type: Plain text
#: upstream/_guides/security.adoc:131
msgid ""
"Quarkus Security is highly customizable. One can register custom "
"``HttpAuthenticationMechanism``s, ``IdentityProvider``s and "
"``SecurityidentityAugmentor``s."
msgstr ""
"Quarkus Securityは、高度なカスタマイズが可能です。カスタム `HttpAuthenticationMechanism` 、 "
"`IdentityProvider` 、 `SecurityidentityAugmentor` を登録することができます。"

#. type: Plain text
#: upstream/_guides/security.adoc:133
msgid ""
"See link:security-customization[Security Customization] for more information "
"about customizing Quarkus Security and other useful tips about the reactive "
"security, registering the security providers, etc."
msgstr ""
"Quarkus "
"Securityのカスタマイズの詳細や、リアクティブセキュリティ、セキュリティプロバイダーの登録などの便利なヒントについては、セキュリティの link:"
"security-customization[カスタマイズ]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:134
#, no-wrap
msgid "Secure connections with SSL"
msgstr "SSLによる安全な接続"

#. type: Plain text
#: upstream/_guides/security.adoc:137
msgid ""
"See the link:http-reference#ssl[Supporting secure connections with SSL] "
"guide for more information."
msgstr "詳細については、 link:http-reference#ssl[SSL による安全な接続のサポート]ガイドを参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:138
#, no-wrap
msgid "Cross-Origin Resource Sharing"
msgstr "クロスオリジンリソース共有"

#. type: Plain text
#: upstream/_guides/security.adoc:141
msgid ""
"If you plan to make your Quarkus application accessible to another "
"application running on a different domain, you will need to configure CORS "
"(Cross-Origin Resource Sharing). Please read the link:http-reference#cors-"
"filter[HTTP CORS documentation] for more information."
msgstr ""
"Quarkusアプリケーションを別のドメインで実行している別のアプリケーションにアクセスできるようにする場合は、CORS（Cross-Origin "
"Resource Sharing）を設定する必要があります。詳細については、 link:http-reference#cors-filter[HTTP "
"CORSのドキュメント]を参照してください。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:750
#, no-wrap, fuzzy
msgid "SameSite cookies"
msgstr "同サイトのクッキー"

#. type: Plain text
#: upstream/_guides/security.adoc:145
msgid ""
"Please see link:vertx#same-site-cookie for information about adding a https:/"
"/developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/"
"SameSite[SameSite] cookie property to any of the cookies set by a Quarkus "
"endpoint."
msgstr ""
"Quarkusのエンドポイントによって設定されたCookieに link:https://developer.mozilla.org/en-US/"
"docs/Web/HTTP/Headers/Set-Cookie/SameSite[SameSite]Cookieプロパティを追加する方法については、 "
"link:vertx#sam-site-cookie を参照してください。"

#. type: Title ==
#: upstream/_guides/kubernetes-client.adoc:72
#, no-wrap, fuzzy
msgid "Testing"
msgstr "テスト"

#. type: Plain text
#: upstream/_guides/security.adoc:149
msgid ""
"See link:security-testing[Security Testing] for more information about "
"testing Quarkus Security."
msgstr ""
"Quarkus Securityのテストの詳細については、 link:security-testing[セキュリティのテスト]を参照してください。"

#. type: Title ==
#: upstream/_guides/security.adoc:150
#, no-wrap
msgid "Secret Engines"
msgstr "シークレットエンジン"

#. type: Title ===
#: upstream/_guides/vault-auth.adoc:282
#, no-wrap, fuzzy
msgid "Vault"
msgstr "金庫室"

#. type: Plain text
#: upstream/_guides/security.adoc:152
msgid ""
"Quarkus provides a very comprehensive HashiCorp Vault support, please see "
"the link:vault[Quarkus and HashiCorp Vault] documentation for more "
"information."
msgstr ""
"Quarkusは非常に包括的な HashiCorp Vault のサポートを提供しています。詳しくは link:vault[Quarkus and "
"HashiCorp Vault] のドキュメントを参照下さい。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:21
#, fuzzy
msgid "Apache Maven 3.6.2+"
msgstr "Apache Maven 3.6.2+"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:38
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=sending-email-quickstart \\\n"
"    -Dextensions=\"mailer\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:62
#, no-wrap
msgid ""
"quarkus.mailer.from=test@quarkus.io\n"
"quarkus.mailer.host=smtp.sendgrid.net\n"
"quarkus.mailer.port=465\n"
"quarkus.mailer.ssl=true\n"
"quarkus.mailer.username=....\n"
"quarkus.mailer.password=....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:84
#, fuzzy
msgid ""
"`io.quarkus.mailer.ReactiveMailer` provides the reactive (non-blocking and "
"asynchronous) API"
msgstr ""
"`io.quarkus.mailer.ReactiveMailer` は反応的な (ノンブロッキングで非同期の) API を提供しています。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:95
#, no-wrap
msgid ""
"// Imperative API:\n"
"mailer.send(Mail.withText(\"to@acme.org\", \"A simple email from quarkus\", "
"\"This is my body.\"));\n"
"// Reactive API:\n"
"CompletionStage<Void> stage = reactiveMailer.send(Mail.withText(\"to@acme."
"org\", \"A reactive email from quarkus\", \"This is my body.\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:115
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/async\")\n"
"public CompletionStage<Response> sendASimpleEmailAsync() {\n"
"    return reactiveMailer.send(\n"
"            Mail.withText(\"to@acme.org\", \"A reactive email from "
"quarkus\", \"This is my body\"))\n"
"            .thenApply(x -> Response.accepted().build());\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:242
#, no-wrap
msgid ""
"quarkus.mailer.from=YOUREMAIL@gmail.com\n"
"quarkus.mailer.host=smtp.gmail.com\n"
"quarkus.mailer.port=587\n"
"quarkus.mailer.start-tls=REQUIRED\n"
"quarkus.mailer.username=YOUREMAIL@gmail.com\n"
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:254
#, no-wrap
msgid ""
"quarkus.mailer.from=YOUREMAIL@gmail.com\n"
"quarkus.mailer.host=smtp.gmail.com\n"
"quarkus.mailer.port=465\n"
"quarkus.mailer.ssl=true\n"
"quarkus.mailer.username=YOUREMAIL@gmail.com\n"
"quarkus.mailer.password=YOURGENERATEDAPPLICATIONPASSWORD\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:260
#, fuzzy
msgid ""
"Note that if you enable SSL for the mailer and you want to build a native "
"executable, you will need to enable the SSL support.  Please refer to the "
"native-and-ssl-guide.html[Using SSL With Native Executables] guide for more "
"information."
msgstr ""
"メーラーのSSLを有効にして、ネイティブ実行ファイルを構築する場合は、SSL対応を有効にする必要がありますのでご注意ください。詳しくは、native-"
"and-ssl-guide.html[Using SSL With Native Executables]ガイドを参照してください。"

#. type: delimited block -
#: upstream/_guides/sending-emails.adoc:269
#, no-wrap
msgid "@Inject MailClient client;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:272
#, fuzzy
msgid "Three API flavors are exposed:"
msgstr "3つのAPIフレーバーが公開されています。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:274
#, fuzzy
msgid ""
"the Axle client (`io.vertx.axle.ext.mail.MailClient`), using "
"`CompletionStage` and Reactive Streams `Publisher`"
msgstr ""
"Axle クライアント ( `io.vertx.axle.ext.mail.MailClient`) を使用して、 `CompletionStage` "
"と Reactive Streams を使用します。 `Publisher`"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:275
#, fuzzy
msgid "the RX Java 2 client (`io.vertx.reactivex.ext.mail.MailClient`)"
msgstr "RX Java 2 クライアント ( `io.vertx.reactivex.ext.mail.MailClient`)"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:276
#, fuzzy
msgid "the bare client (`io.vertx.ext.mail.MailClient`)"
msgstr "ベアクライアント ( `io.vertx.ext.mail.MailClient`)"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:278
#, fuzzy
msgid ""
"Check the link:using-vertx.html[Using Vert.x guide] for further details "
"about these different APIs and how to select the most suitable for you."
msgstr ""
"これらの異なる API の詳細と、あなたに最も適した API を選択する方法については、 link:using-vertx.html[Using "
"Vert.x ガイドを]確認してください。"

#. type: Plain text
#: upstream/_guides/sending-emails.adoc:281
#, fuzzy
msgid ""
"The retrieved `MailClient` is configured using the configuration key "
"presented above.  You can also create your own instance, and pass your own "
"configuration."
msgstr ""
"取得した `MailClient` は、上記で提示した設定キーを使用して設定します。また、独自のインスタンスを作成し、独自の設定を渡すこともできます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/grpc.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus gRPC"
msgstr "クォークラスジーアールピーシー"

#. type: Plain text
#: upstream/_guides/grpc.adoc:13
#, fuzzy
msgid ""
"https://grpc.io/[gRPC] is a high-performance RPC framework.  It can "
"efficiently connect services implemented using various languages and "
"frameworks.  It is also applicable in the last mile of distributed computing "
"to connect devices, mobile applications, and browsers to backend services."
msgstr ""
"link:https://grpc.io/"
"[gRPCは]高性能なRPCフレームワークです。様々な言語やフレームワークを使って実装されたサービスを効率的に接続することができます。また、デバイスやモバイルアプリケーション、ブラウザとバックエンドサービスを接続するために、分散コンピューティングのラストワンマイルにも適用可能です。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:16
#, fuzzy
msgid ""
"In general, gRPC uses HTTP/2, TLS, and https://developers.google.com/"
"protocol-buffers[Protobuf (Protocol Buffers)].  In a microservice "
"architecture, gRPC is an efficient, type-safe alternative to HTTP."
msgstr ""
"一般的に、gRPCはHTTP/2、TLS、 link:https://developers.google.com/protocol-"
"buffers[Protobuf（プロトコルバッファ）を]使用します。マイクロサービスアーキテクチャでは、gRPCはHTTPに代わる効率的で型安全な代替手段です。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:19
#, fuzzy
msgid "The Quarkus gRPC extension integrate gRPC in Quarkus application.  It:"
msgstr "QuarkusのgRPC拡張機能は、QuarkusアプリケーションにgRPCを統合します。それは"

#. type: Plain text
#: upstream/_guides/grpc.adoc:21
#, fuzzy
msgid "supports implementing gRPC services"
msgstr "gRPCサービスの実装をサポートしています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:22
#, fuzzy
msgid "supports consuming gRPC services"
msgstr "gRPC サービスの消費をサポートしています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:23
#, fuzzy
msgid ""
"integrates with the reactive engine from Quarkus as well as the reactive "
"development model"
msgstr "は、Quarkusのリアクティブエンジンやリアクティブ開発モデルと統合されています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:24
#, fuzzy
msgid ""
"allows plain-text communication as well as TLS, and TLS with mutual "
"authentication"
msgstr "平文通信に加えてTLS、相互認証付きのTLSも可能です。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:26
#, fuzzy
msgid ""
"Quarkus gRPC is based on https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC]."
""
msgstr ""
"Quarkus gRPCは link:https://vertx.io/docs/vertx-grpc/java/[Vert.x "
"gRPCを]ベースにしています。"

#. type: Plain text
#: upstream/_guides/grpc.adoc:28
#, fuzzy
msgid "link:./grpc-getting-started.adoc[Getting Started]"
msgstr "link:./grpc-getting-started.adoc[はじめに]"

#. type: Plain text
#: upstream/_guides/grpc.adoc:29
#, fuzzy
msgid "link:./grpc-service-implementation.adoc[Implementing a gRPC Service]"
msgstr "link:./grpc-service-implementation.adoc[gRPCサービスの実装]"

#. type: Plain text
#: upstream/_guides/grpc.adoc:29
#, fuzzy
msgid "link:./grpc-service-consumption.adoc[Consuming a gRPC Service]"
msgstr "link:./grpc-service-consumption.adoc[gRPC サービスを消費する]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/tika.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using Apache Tika"
msgstr "Quarkus - Apache Tikaの使用"

#. type: Plain text
#: upstream/_guides/tika.adoc:11
#, fuzzy
msgid ""
"This guide explains how your Quarkus application can use https://tika.apache."
"org/[Apache Tika] to parse the documents."
msgstr ""
"このガイドでは、Quarkusアプリケーションが link:https://tika.apache.org/[Apache "
"Tika]を使用してドキュメントを解析する方法について説明します。"

#. type: Plain text
#: upstream/_guides/tika.adoc:13
#, fuzzy
msgid ""
"https://tika.apache.org/[Apache Tika] is a content analysis toolkit which is "
"used to parse the documents in PDF, Open Document, Excel and many other well "
"known binary and text formats using a simple uniform API. Both the document "
"text and properties (metadata) are available once the document has been "
"parsed."
msgstr ""
"link:https://tika.apache.org/[Apache Tika は]コンテンツ分析ツールキットで、シンプルな統一 API を使って "
"PDF, Open Document, Excel "
"やその他多くのよく知られたバイナリやテキスト形式の文書を解析するのに使われます。文書のテキストとプロパティ (メタデータ) "
"の両方が、文書が解析されると利用可能になります。"

#. type: delimited block =
#: upstream/_guides/tika.adoc:17
#, fuzzy
msgid ""
"If you are planning to run the application as a native executable and parse "
"documents that may have been created with charsets different than the "
"standard ones supported in Java such as `UTF-8` then you should configure "
"Quarkus Maven Plugin to get the native image generator include all the "
"charsets available to the JVM:"
msgstr ""
"アプリケーションをネイティブ実行ファイルとして実行し、 `UTF-8` "
"のようなJavaでサポートされている標準の文字セットとは異なる文字セットで作成された可能性のあるドキュメントを解析する場合は、Quarkus Maven "
"Pluginを設定して、ネイティブイメージジェネレータがJVMで利用可能なすべての文字セットを含むようにする必要があります。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:35
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-maven-plugin</artifactId>\n"
"    <executions>\n"
"        <execution>\n"
"            <id>native-image</id>\n"
"            <goals>\n"
"                <goal>native-image</goal>\n"
"            </goals>\n"
"            <configuration>\n"
"                <addAllCharsets>true</addAllCharsets>\n"
"                ...\n"
"            </configuration>\n"
"        </execution>\n"
"    </executions>\n"
"</plugin>\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/tika.adoc:44
#, fuzzy
msgid "less than 20 minutes"
msgstr "二十分弱"

#. type: Plain text
#: upstream/_guides/kogito.adoc:30
#, fuzzy
msgid "Docker"
msgstr "ドッカー"

#. type: delimited block =
#: upstream/_guides/tika.adoc:49
#, fuzzy
msgid ""
"link:building-native-image[GraalVM installed if you want to run in native "
"mode]"
msgstr "link:building-native-image[ネイティブモードで動作させたい場合は、GraalVMをインストールしてください。]"

#. type: delimited block =
#: upstream/_guides/tika.adoc:58
#, fuzzy
msgid ""
"The solution is located in the `tika-quickstart` {quickstarts-tree-url}/tika-"
"quickstart[directory]."
msgstr ""
"ソリューションは `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory] "
"にあります。"

#. type: Plain text
#: upstream/_guides/tika.adoc:62
#, fuzzy
msgid ""
"The provided solution contains a few additional elements such as tests and "
"testing infrastructure."
msgstr "提供されるソリューションには、テストやテストのインフラストラクチャなど、いくつかの追加要素が含まれています。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:78
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme.example \\\n"
"    -DprojectArtifactId=tika-quickstart \\\n"
"    -DclassName=\"org.acme.tika.TikaParserResource\" \\\n"
"    -Dpath=\"/parse\" \\\n"
"    -Dextensions=\"tika,resteasy\"\n"
"cd tika-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:81
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `tika` and `resteasy` "
"extensions."
msgstr "このコマンドは、 `tika` と `resteasy` の拡張子をインポートして、Maven プロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/tika.adoc:84
#, fuzzy
msgid ""
"If you already have your Quarkus project configured you can add the `tika` "
"and `resteasy` extensions to your project by running the following command "
"in your project base directory."
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで次のコマンドを実行することで、 `tika` と "
"`resteasy` の拡張子をプロジェクトに追加できます。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:88
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"tika,resteasy\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:102
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-tika</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/tika.adoc:104
#, no-wrap, fuzzy
msgid "Examine the generated JAX-RS resource"
msgstr "生成されたJAX-RSリソースを調べる"

#. type: Plain text
#: upstream/_guides/tika.adoc:107
#, fuzzy
msgid ""
"Open the `src/main/java/org/acme/tika/TikaParserResource.java` file and see "
"the following content:"
msgstr ""
"`src/main/java/org/acme/tika/TikaParserResource.java` "
"ファイルを開くと、以下のような内容が表示されます。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:111 upstream/_guides/tika.adoc:135
#, no-wrap
msgid "package org.acme.tika;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:119
#, no-wrap
msgid "@Path(\"/parse\")\n"
"public class TikaParserResource {\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/tika.adoc:128
#, no-wrap, fuzzy
msgid "Update the JAX-RS resource"
msgstr "JAX-RSリソースの更新"

#. type: Plain text
#: upstream/_guides/tika.adoc:131
#, fuzzy
msgid ""
"Next update `TikaParserResource` to accept and parse PDF and OpenDocument "
"format documents:"
msgstr ""
"次に `TikaParserResource` を更新して、PDF および OpenDocument 形式の文書を受け入れて解析するようにします。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:139
#, no-wrap
msgid ""
"import java.io.InputStream;\n"
"import java.time.Duration;\n"
"import java.time.Instant;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:146
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:149
#, no-wrap
msgid "import io.quarkus.tika.TikaParser;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:153
#, no-wrap
msgid ""
"@Path(\"/parse\")\n"
"public class TikaParserResource {\n"
"    private static final Logger log = Logger.getLogger(TikaParserResource."
"class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:156
#, no-wrap
msgid "    @Inject\n"
"    TikaParser parser;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:163
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/text\")\n"
"    @Consumes({\"application/pdf\", \"application/vnd.oasis.opendocument."
"text\"})\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String extractText(InputStream stream) {\n"
"        Instant start = Instant.now();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:165
#, no-wrap
msgid "        String text = parser.getText(stream);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:167
#, no-wrap
msgid "        Instant finish = Instant.now();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:169
#, no-wrap
msgid ""
"        log.info(Duration.between(start, finish).toMillis() + \" mls have "
"passed\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/tika.adoc:173
#, no-wrap
msgid "        return text;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:176
#, fuzzy
msgid ""
"As you can see the JAX-RS resource method was renamed to `extractText`, "
"`@GET` annotation was replaced with `POST` and `@Path(/text)` annotation was "
"added, and `@Consumes` annotation shows that PDF and OpenDocument media type "
"formats can now be accepted. An injected `TikaParser` is used to parse the "
"documents and report the extracted text. It also measures how long does it "
"take to parse a given document."
msgstr ""
"ご覧のように、JAX-RSのリソースメソッドの名前が `extractText` に変更され、 `@GET` アノテーションが `POST` "
"に置き換わり、 `@Path(/text)` アノテーションが追加され、 `@Consumes` アノテーションでは、PDF と "
"OpenDocument のメディアタイプのフォーマットが受け入れられるようになったことが示されています。注入された `TikaParser` "
"は、文書を解析し、抽出されたテキストを報告するために使用されます。また、与えられた文書を解析するのにどのくらいの時間がかかるかを測定します。"

#. type: Title ==
#: upstream/_guides/validation.adoc:256
#, no-wrap, fuzzy
msgid "Run the application"
msgstr "アプリケーションの実行"

#. type: Plain text
#: upstream/_guides/tika.adoc:180
#, fuzzy
msgid "Now we are ready to run our application. Use:"
msgstr "これで、アプリケーションを実行する準備が整いました。使用してください。"

#. type: Plain text
#: upstream/_guides/tika.adoc:187
#, fuzzy
msgid "and you should see output similar to:"
msgstr "のような出力が表示されるはずです。"

#. type: Block title
#: upstream/_guides/tika.adoc:188
#, no-wrap, fuzzy
msgid "quarkus:dev Output"
msgstr "quarkus:dev 出力"

#. type: delimited block -
#: upstream/_guides/tika.adoc:206
#, no-wrap
msgid ""
"$ ./mvnw clean compile quarkus:dev\n"
"[INFO] Scanning for projects...\n"
"[INFO]\n"
"INFO] --------------------< org.acme.example:apache-tika >-------------------"
"-\n"
"[INFO] Building apache-tika 1.0-SNAPSHOT\n"
"[INFO] --------------------------------[ jar ]-------------------------------"
"--\n"
"...\n"
"Listening for transport dt_socket at address: 5005\n"
"2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning "
"quarkus augmentation\n"
"2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running "
"without servlet container.\n"
"2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-"
"undertow to run Resteasy within a servlet container\n"
"2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus "
"augmentation completed in 549ms\n"
"2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT "
"started in 1.361s. Listening on: http://0.0.0.0:8080\n"
"2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. "
"Live Coding activated.\n"
"2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, "
"resteasy, tika]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:209
#, fuzzy
msgid ""
"Now that the REST endpoint is running, we can get it to parse PDF and "
"OpenDocument documents using a command line tool like curl:"
msgstr ""
"REST エンドポイントが実行されているので、curl のようなコマンドラインツールを使用して PDF や OpenDocument "
"ドキュメントを解析することができます。"

#. type: delimited block -
#: upstream/_guides/tika.adoc:214
#, no-wrap
msgid ""
"$ curl -X POST -H \"Content-type: application/pdf\" --data-binary @target/"
"classes/quarkus.pdf http://localhost:8080/parse/text\n"
"Hello Quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:217
#, fuzzy
msgid "and"
msgstr "そして"

#. type: delimited block -
#: upstream/_guides/tika.adoc:222
#, no-wrap
msgid ""
"$ curl -X POST -H \"Content-type: Content-type: application/vnd.oasis."
"opendocument.text\" --data-binary @target/classes/quarkus.odt http://"
"localhost:8080/parse/text\n"
"Hello Quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/tika.adoc:228
#, fuzzy
msgid ""
"You can build a native executable with the usual command `./mvnw package -"
"Pnative`.  Running it is as simple as executing `./target/tika-quickstart-1."
"0-SNAPSHOT-runner`."
msgstr ""
"通常のコマンド `./mvnw package -Pnative` でネイティブの実行ファイルをビルドできます。実行は `./target/tika-"
"quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/spring-web.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Quarkus Extension for Spring Web API"
msgstr "Quarkus - Spring Web API用のQuarkus拡張機能"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:12
#, fuzzy
msgid ""
"While users are encouraged to use JAX-RS annotation for defining REST "
"endpoints, Quarkus provides a compatibility layer for Spring Web in the form "
"of the `spring-web` extension."
msgstr ""
"ユーザーはRESTエンドポイントの定義にJAX-RSアノテーションを使用することが推奨されていますが、QuarkusはSpring "
"Web用の互換性レイヤーを `spring-web` 拡張の形で提供しています。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:14
#, fuzzy
msgid ""
"This guide explains how a Quarkus application can leverage the well known "
"Spring Web annotations to define RESTful services."
msgstr ""
"このガイドでは、Quarkusアプリケーションがよく知られているSpring "
"Webアノテーションを活用してRESTfulサービスを定義する方法について説明します。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:35
#, fuzzy
msgid ""
"The solution is located in the `spring-web-quickstart` {quickstarts-tree-"
"url}/spring-web-quickstart[directory]."
msgstr ""
"ソリューションは `spring-web-quickstart` {quickstarts-tree-url}/spring-web-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:49
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=spring-web-quickstart \\\n"
"    -DclassName=\"org.acme.spring.web.GreetingController\" \\\n"
"    -Dpath=\"/greeting\" \\\n"
"    -Dextensions=\"spring-web\"\n"
"cd spring-web-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:52
#, fuzzy
msgid ""
"This command generates a Maven project with a REST endpoint and imports the "
"`spring-web` extension."
msgstr "このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、 `spring-web` 拡張子をインポートします。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:55
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `spring-"
"web` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `spring-"
"web` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:59
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"spring-web\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:69
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-spring-web</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:75
#, fuzzy
msgid ""
"The Quarkus maven plugin automatically generated a controller with the "
"Spring Web annotations to define our REST endpoint (instead of the JAX-RS "
"ones used by default)  The `src/main/java/org/acme/spring/web/"
"GreetingController.java` file looks as follows:"
msgstr ""
"Quarkusのmavenプラグインは、RESTエンドポイントを定義するためのSpring "
"Webアノテーションを持つコントローラを自動的に生成しました（デフォルトで使用されているJAX-RSのものではなく） `src/main/java/"
"org/acme/spring/web/GreetingController.java` ファイルは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:79 upstream/_guides/spring-web.adoc:102
#: upstream/_guides/spring-web.adoc:175
#, no-wrap
msgid "package org.acme.spring.web;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:83
#, no-wrap
msgid ""
"import org.springframework.web.bind.annotation.GetMapping;\n"
"import org.springframework.web.bind.annotation.RequestMapping;\n"
"import org.springframework.web.bind.annotation.RestController;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:87 upstream/_guides/spring-web.adoc:150
#, no-wrap
msgid ""
"@RestController\n"
"@RequestMapping(\"/greeting\")\n"
"public class GreetingController {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:93
#, no-wrap
msgid ""
"    @GetMapping\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/spring-web.adoc:95
#, no-wrap, fuzzy
msgid "GreetingControllerTest"
msgstr "グリーティングコントローラテスト"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:98
#, fuzzy
msgid "Note that a test for the controller has been created as well:"
msgstr "コントローラのテストも作成されていることに注意してください。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:184
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:277
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:111 upstream/_guides/spring-web.adoc:184
#, no-wrap
msgid "@QuarkusTest\n"
"public class GreetingControllerTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:120
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/greeting\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"hello\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:130
#, fuzzy
msgid "The result should be: `{\"message\": \"hello\"}`."
msgstr "結果は `{\"message\": \"hello\"}`."

#. type: Title ==
#: upstream/_guides/spring-web.adoc:135
#, no-wrap, fuzzy
msgid "Going further with an endpoint returning JSON"
msgstr "JSONを返すエンドポイントでさらに進む"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:139
#, fuzzy
msgid ""
"The `GreetingController` above was an example of a very simple endpoint. In "
"many cases however it is required to return JSON content.  The following "
"example illustrates how that could be achieved using a Spring RestController:"
""
msgstr ""
"上の `GreetingController` "
"は非常にシンプルなエンドポイントの例です。しかし多くの場合、JSONコンテンツを返す必要があります。次の例は、Spring "
"RestControllerを使ってどのように実現できるかを示しています。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:146
#, no-wrap
msgid ""
"import org.springframework.web.bind.annotation.GetMapping;\n"
"import org.springframework.web.bind.annotation.PathVariable;\n"
"import org.springframework.web.bind.annotation.RequestMapping;\n"
"import org.springframework.web.bind.annotation.RestController;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:155
#, no-wrap
msgid ""
"    @GetMapping(\"/{name}\")\n"
"    public Greeting hello(@PathVariable(name = \"name\") String name) {\n"
"        return new Greeting(\"hello \" + name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:158
#, no-wrap
msgid ""
"    public static class Greeting {\n"
"        private final String message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:162
#, no-wrap
msgid ""
"        public Greeting(String message) {\n"
"            this.message = message;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:168
#, no-wrap
msgid ""
"        public String getMessage(){\n"
"            return message;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:171
#, fuzzy
msgid "The corresponding test could look like:"
msgstr "対応するテストは次のようになります。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:193
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/greeting/quarkus\")\n"
"          .then()\n"
"            .statusCode(200)\n"
"            .body(\"message\", is(\"hello quarkus\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:198
#, fuzzy
msgid ""
"It should be noted that when using the Spring Web support in Quarkus, link:"
"https://github.com/FasterXML/jackson[Jackson] is automatically added to the "
"classpath and properly setup."
msgstr ""
"注意すべきは、QuarkusでSpring Webサポートを使用する場合、 link:https://github.com/FasterXML/"
"jackson[Jacksonは]自動的にクラスパスに追加され、適切に設定されることです。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:199
#, no-wrap, fuzzy
msgid "Adding OpenAPI and Swagger-UI"
msgstr "OpenAPIとSwagger-UIの追加"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:202
#, fuzzy
msgid ""
"You can add support for link:https://www.openapis.org/[OpenAPI] and link:"
"https://swagger.io/tools/swagger-ui/[Swagger-UI] by using the `quarkus-"
"smallrye-openapi` extension."
msgstr ""
"`quarkus-smallrye-openapi` の拡張子を使用して、 link:https://www.openapis.org/"
"[OpenAPI]と link:https://swagger.io/tools/swagger-ui/[Swagger-"
"UI]のサポートを追加することができます。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:204
#, fuzzy
msgid "Add the extension by running this command:"
msgstr "このコマンドを実行して拡張子を追加します。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:208
#, no-wrap
msgid ""
"./mvnw quarkus:add-extension -Dextensions=\"io.quarkus:quarkus-smallrye-"
"openapi\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:218
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-openapi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:221
#, fuzzy
msgid ""
"This is enough to generate a basic OpenAPI schema document from your REST "
"Endpoints:"
msgstr "これは、REST エンドポイントから基本的な OpenAPI スキーマドキュメントを生成するのに十分です。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:225
#, no-wrap
msgid "curl http://localhost:8080/openapi\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:228
#, fuzzy
msgid "You will see the generated OpenAPI schema document:"
msgstr "生成された OpenAPI スキーマドキュメントが表示されます。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:262
#, no-wrap
msgid "---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:268
#, no-wrap
msgid ""
"openapi: 3.0.1\n"
"info:\n"
"  title: Generated API\n"
"  version: \"1.0\"\n"
"paths:\n"
"  /greeting:\n"
"    get:\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                type: string\n"
"  /greeting/{name}:\n"
"    get:\n"
"      parameters:\n"
"      - name: name\n"
"        in: path\n"
"        required: true\n"
"        schema:\n"
"          type: string\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                $ref: '#/components/schemas/Greeting'\n"
"components:\n"
"  schemas:\n"
"    Greeting:\n"
"      type: object\n"
"      properties:\n"
"        message:\n"
"          type: string\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:271
#, fuzzy
msgid ""
"Also see link:https://quarkus.io/guides/openapi-swaggerui[the OpenAPI Guide]"
msgstr ""
"link:https://quarkus.io/guides/openapi-swaggerui[OpenAPIガイド]も参照してください。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:272
#, no-wrap, fuzzy
msgid "Adding MicroProfile OpenAPI Annotations"
msgstr "MicroProfile OpenAPIアノテーションの追加"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:276
#, fuzzy
msgid ""
"You can use link:https://github.com/eclipse/microprofile-open-"
"api[MicroProfile OpenAPI] to better document your schema, example, adding "
"the following to the class level of the `GreetingController`:"
msgstr ""
"link:https://github.com/eclipse/microprofile-open-api[MicroProfile OpenAPI "
"を]使用してスキーマをより良く文書化することができます。例えば、 `GreetingController`.NET Framework "
"のクラスレベルに以下を追加します。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:291
#, no-wrap
msgid ""
"@OpenAPIDefinition(\n"
"    info = @Info(\n"
"        title=\"Greeting API\",\n"
"        version = \"1.0.1\",\n"
"        contact = @Contact(\n"
"            name = \"Greeting API Support\",\n"
"            url = \"http://exampleurl.com/contact\",\n"
"            email = \"techsupport@example.com\"),\n"
"        license = @License(\n"
"            name = \"Apache 2.0\",\n"
"            url = \"http://www.apache.org/licenses/LICENSE-2.0.html\"))\n"
")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:294
#, fuzzy
msgid "And describe your endpoints like this:"
msgstr "そして、エンドポイントをこのように記述してください。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:302
#, no-wrap
msgid ""
"@Tag(name = \"Hello\", description = \"Just say hello\")\n"
"@GetMapping(produces=MediaType.TEXT_PLAIN_VALUE)\n"
"public String hello() {\n"
"    return \"hello\";\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:308
#, no-wrap
msgid ""
"@GetMapping(value = \"/{name}\", produces=MediaType.APPLICATION_JSON_VALUE)\n"
"@Tag(name = \"Hello to someone\", description = \"Just say hello to "
"someone\")\n"
"public Greeting hello(@PathVariable(name = \"name\") String name) {\n"
"    return new Greeting(\"hello \" + name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/spring-web.adoc:311
#, fuzzy
msgid "will generate this OpenAPI schema:"
msgstr "はこのOpenAPIスキーマを生成します。"

#. type: delimited block -
#: upstream/_guides/spring-web.adoc:367
#, no-wrap
msgid ""
"openapi: 3.0.1\n"
"info:\n"
"  title: Greeting API\n"
"  contact:\n"
"    name: Greeting API Support\n"
"    url: http://exampleurl.com/contact\n"
"    email: techsupport@example.com\n"
"  license:\n"
"    name: Apache 2.0\n"
"    url: http://www.apache.org/licenses/LICENSE-2.0.html\n"
"  version: 1.0.1\n"
"tags:\n"
"- name: Hello\n"
"  description: Just say hello\n"
"- name: Hello to someone\n"
"  description: Just say hello to someone\n"
"paths:\n"
"  /greeting:\n"
"    get:\n"
"      tags:\n"
"      - Hello\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                type: string\n"
"  /greeting/{name}:\n"
"    get:\n"
"      tags:\n"
"      - Hello to someone\n"
"      parameters:\n"
"      - name: name\n"
"        in: path\n"
"        required: true\n"
"        schema:\n"
"          type: string\n"
"      responses:\n"
"        \"200\":\n"
"          description: OK\n"
"          content:\n"
"            '*/*':\n"
"              schema:\n"
"                $ref: '#/components/schemas/Greeting'\n"
"components:\n"
"  schemas:\n"
"    Greeting:\n"
"      type: object\n"
"      properties:\n"
"        message:\n"
"          type: string\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/spring-web.adoc:369
#, no-wrap, fuzzy
msgid "Using Swagger UI"
msgstr "SwaggerのUIを使う"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:373
#, fuzzy
msgid ""
"Swagger UI is included by default when running in `Dev` or `Test` mode, and "
"can optionally added to `Prod` mode.  See link:https://quarkus.io/guides/"
"openapi-swaggerui#use-swagger-ui-for-development[the Swagger UI] Guide for "
"more details."
msgstr ""
"Swagger UIは、 `Dev` または `Test` モードで実行しているときにデフォルトで含まれており、オプションで `Prod` "
"モードに追加することができます。詳細については、 link:https://quarkus.io/guides/openapi-"
"swaggerui#use-swagger-ui-for-development[Swagger]UIガイドを参照してください。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:375
#, fuzzy
msgid ""
"Navigate to link:http://localhost:8080/swagger-ui/[localhost:8080/swagger-ui/"
"] and you will see the Swagger UI screen:"
msgstr ""
"link:http://localhost:8080/swagger-ui/[localhost:8080/swagger-ui/"
"]に移動すると、Swagger UIの画面が表示されます。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:377
#, fuzzy
msgid "image:spring-web-guide-screenshot01.png[alt=Swagger UI]"
msgstr "image:spring-web-guide-screenshot01.png[alt=Swagger UI]"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:378
#, no-wrap, fuzzy
msgid "Supported Spring Web functionalities"
msgstr "サポートされているSpring Webの機能"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:382
#, fuzzy
msgid ""
"Quarkus currently supports a subset of the functionalities that Spring Web "
"provides. More specifically Quarkus supports the REST related features of "
"Spring Web (think of `@RestController` instead of `@Controller`)."
msgstr ""
"Quarkusは現在、Spring Webが提供する機能のサブセットをサポートしています。より具体的には、QuarkusはSpring "
"WebのREST関連機能をサポートしています（ `@Controller` ではなく、 `@RestController` と考えてください）。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:383
#, no-wrap, fuzzy
msgid "Annotations"
msgstr "アノテーション"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:386
#, fuzzy
msgid "The table below summarizes the supported annotations:"
msgstr "下の表は、サポートされているアノテーションをまとめたものです。"

#. type: Block title
#: upstream/_guides/spring-web.adoc:387
#, no-wrap, fuzzy
msgid "Supported Spring Web annotation"
msgstr "サポートされているSpring Webアノテーション"

#. type: Table
#: upstream/_guides/spring-web.adoc:424
#, no-wrap, fuzzy
msgid ""
"|Name|Comments\n"
"\n"
"|@RestController\n"
"|\n"
"\n"
"|@RequestMapping\n"
"|\n"
"|@GetMapping\n"
"|\n"
"|@PostMapping\n"
"|\n"
"|@PutMapping\n"
"|\n"
"|@DeleteMapping\n"
"|\n"
"|@PatchMapping\n"
"|\n"
"|@RequestParam\n"
"|\n"
"|@RequestHeader\n"
"|\n"
"|@MatrixVariable\n"
"|\n"
"|@PathVariable\n"
"|\n"
"|@CookieValue\n"
"|\n"
"|@RequestBody\n"
"|\n"
"|@ResponseStatus\n"
"|\n"
"|@ExceptionHandler\n"
"|Can only be used in a @RestControllerAdvice class, not on a per-controller "
"basis\n"
"|@RestControllerAdvice\n"
"|Only the @ExceptionHandler capability is supported\n"
msgstr "|名前|コメント"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:426
#, no-wrap, fuzzy
msgid "Controller method return types"
msgstr "コントローラメソッドの戻り値の型"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:429 upstream/_guides/spring-web.adoc:444
#, fuzzy
msgid "The following method return types are supported:"
msgstr "以下のメソッドの戻り値の型がサポートされています。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:431
#, fuzzy
msgid "Primitive types"
msgstr "原始型"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:432
#, fuzzy
msgid ""
"String (which will be used as a literal, no Spring MVC view support is "
"provided)"
msgstr "文字列 (リテラルとして使用されます。Spring MVC ビューのサポートはありません)"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:433
#, fuzzy
msgid "POJO classes which will be serialized via JSON"
msgstr "JSON 経由でシリアライズされる POJO クラス"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:434 upstream/_guides/spring-web.adoc:446
#, fuzzy
msgid "`org.springframework.http.ResponseEntity`"
msgstr "`org.springframework.http.ResponseEntity`"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:435
#, no-wrap, fuzzy
msgid "Controller method parameter types"
msgstr "コントローラメソッドのパラメータの種類"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:440
#, fuzzy
msgid ""
"In addition to the method parameters that can be annotated with the "
"appropriate Spring Web annotations from the previous table, `javax.servlet."
"http.HttpServletRequest` and `javax.servlet.http.HttpServletResponse` are "
"also supported.  For this to function however, users need to add the "
"`quarkus-undertow` dependency."
msgstr ""
"前の表の適切なSpring Webアノテーションでアノテーションできるメソッドパラメータに加えて、 `javax.servlet.http."
"HttpServletRequest` と `javax.servlet.http.HttpServletResponse` "
"もサポートされています。ただし、これを機能させるためには `quarkus-undertow` 依存関係を追加する必要があります。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:441
#, no-wrap, fuzzy
msgid "Exception handler method return types"
msgstr "例外ハンドラメソッドの戻り値の型"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:447
#, fuzzy
msgid "`java.util.Map`"
msgstr "`java.util.Map`"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:449
#, fuzzy
msgid ""
"Other return types mentioned in the Spring `https://docs.spring.io/spring-"
"framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html[ExceptionHandler javadoc]` are not supported."
msgstr ""
"Springで言及されている他の戻り値の型 `&lt;a href=\"https://docs.spring.io/spring-framework/"
"docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html\"&gt;ExceptionHandler javadoc&lt;/a&gt;`はサポートされていません。"

#. type: Title ===
#: upstream/_guides/spring-web.adoc:450
#, no-wrap, fuzzy
msgid "Exception handler method parameter types"
msgstr "例外ハンドラメソッドのパラメータタイプ"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:453
#, fuzzy
msgid "The following parameter types are supported, in arbitrary order:"
msgstr "以下のパラメータタイプがサポートされています。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:455
#, fuzzy
msgid ""
"An exception argument: declared as a general `Exception` or as a more "
"specific exception. This also serves as a mapping hint if the annotation "
"itself does not narrow the exception types through its `value()`."
msgstr ""
"例外引数：一般的な `Exception` として宣言された例外、またはより具体的な例外として宣言された例外。これは、アノテーション自体が "
"`value()`."

#. type: Plain text
#: upstream/_guides/spring-web.adoc:456
#, fuzzy
msgid ""
"Request and/or response objects (typically from the Servlet API). You may "
"choose any specific request/response type, e.g. `ServletRequest` / "
"`HttpServletRequest`. To use Servlet API, the `quarkus-undertow` dependency "
"needs to be added."
msgstr ""
"リクエストおよび/またはレスポンスオブジェクト (通常はサーブレット API から)。 `ServletRequest` "
"`HttpServletRequest`特定のリクエスト/レスポンスタイプを選択することができます。Servlet API を使用するには "
"`quarkus-undertow` 依存関係を追加する必要があります。"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:458
#, fuzzy
msgid ""
"Other parameter types mentioned in the Spring `https://docs.spring.io/spring-"
"framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html[ExceptionHandler javadoc]` are not supported."
msgstr ""
"Springで言及されている他のパラメータタイプ `&lt;a href=\"https://docs.spring.io/spring-"
"framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/"
"ExceptionHandler.html\"&gt;ExceptionHandler javadoc&lt;/a&gt;`はサポートされていません。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:459
#, no-wrap, fuzzy
msgid "Important Technical Note"
msgstr "重要な技術的注意事項"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:465
#, fuzzy
msgid ""
"Please note that the Spring support in Quarkus does not start a Spring "
"Application Context nor are any Spring infrastructure classes run.  Spring "
"classes and annotations are only used for reading metadata and / or are used "
"as user code method return types or parameter types.  What that means for "
"end users, is that adding arbitrary Spring libraries will not have any "
"effect. Moreover Spring infrastructure classes (like `org.springframework."
"beans.factory.config.BeanPostProcessor` for example) will not be executed."
msgstr ""
"QuarkusのSpringサポートは、Springアプリケーションコンテキストを起動したり、Springインフラストラクチャクラスを実行したりしないことに注意してください。Springクラスやアノテーションは、メタデータの読み込みや、ユーザーコードのメソッドの戻り値の型やパラメータの型として使用されるだけです。これはエンドユーザーにとって何を意味するかというと、任意のSpringライブラリを追加しても何の効果もないということです。さらに、Springのインフラストラクチャクラス(例えば "
"`org.springframework.beans.factory.config.BeanPostProcessor` のような)は実行されません。"

#. type: Title ==
#: upstream/_guides/spring-web.adoc:466
#, no-wrap, fuzzy
msgid "Conversion Table"
msgstr "変換テーブル"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:469
#, fuzzy
msgid ""
"The following table shows how Spring Web annotations can be converted to JAX-"
"RS annotations."
msgstr "次の表は、Spring WebアノテーションをJAX-RSアノテーションに変換する方法を示しています。"

#. type: Table
#: upstream/_guides/spring-web.adoc:512
#, no-wrap, fuzzy
msgid ""
"|Spring |JAX-RS |Comments\n"
"\n"
"|@RequestController\n"
"|\n"
"|There is no equivalent in JAX-RS. Annotating a class with @Path suffices\n"
"\n"
"|@RequestMapping(path=\"/api\")\n"
"|@Path(\"/api\")\n"
"|\n"
"\n"
"|@RequestMapping(consumes=\"application/json\")\n"
"|@Consumes(\"application/json\")\n"
"|\n"
"\n"
"|@RequestMapping(produces=\"application/json\")\n"
"|@Produces(\"application/json\")\n"
"|\n"
"\n"
"|@RequestParam\n"
"|@QueryParam\n"
"|\n"
"\n"
"|@PathVariable\n"
"|@PathParam\n"
"|\n"
"\n"
"|@RequestBody\n"
"|\n"
"|No equivalent in JAX-RS. Method parameters corresponding to the body of the "
"request are handled in JAX-RS without requiring any annotation\n"
"\n"
"|@RestControllerAdvice\n"
"|\n"
"|No equivalent in JAX-RS\n"
"\n"
"|@ResponseStatus\n"
"|\n"
"|No equivalent in JAX-RS\n"
"\n"
"|@ExceptionHandler\n"
"|\n"
"|No equivalent annotation in JAX-RS. Exceptions are handled by implementing "
"`javax.ws.rs.ext.ExceptionMapper`\n"
msgstr "|春｜JAX-RS｜コメント"

#. type: Plain text
#: upstream/_guides/spring-web.adoc:522
#, fuzzy
msgid ""
"link:spring-cloud-config-client[Quarkus - Reading properties from Spring "
"Cloud Config Server]"
msgstr ""
"link:spring-cloud-config-client[Quarkus - Spring Cloud Config "
"Serverからプロパティを読み込む]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/tooling.adoc:6
#, no-wrap
msgid "Quarkus - Using our Tooling"
msgstr "Quarkus - ツールを使用する"

#. type: Plain text
#: upstream/_guides/tooling.adoc:12
msgid ""
"Quarkus comes with a toolchain enabling developers from live reload all the "
"way down to deploying a Kubernetes application.  In this guide, we will "
"explore:"
msgstr ""
"Quarkusには、開発者がライブリロードからKubernetesアプリケーションのデプロイまでを可能にするツールチェーンが付属しています。このガイドでは、以下を探検していきます："

#. type: Plain text
#: upstream/_guides/tooling.adoc:14
msgid "how to use link:maven-tooling[Maven] as a build tool"
msgstr "ビルドツールとしての link:maven-tooling[Maven]の使い方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:15
msgid "how to use link:gradle-tooling[Gradle] as a build tool"
msgstr "ビルドツールとしての link:gradle-tooling[Gradle]の使い方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:16
msgid "how to use the native CLI for your toolchain (coming soon)"
msgstr "ネイティブCLIのツールチェーンとしての使い方 (近日公開予定)"

#. type: Plain text
#: upstream/_guides/tooling.adoc:17
msgid "how to create and scaffold a new project"
msgstr "新規プロジェクトの作り方とスキャフォールド（足場）の作り方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:18
msgid "how to deal with extensions"
msgstr "エクステンションの扱い方"

#. type: Plain text
#: upstream/_guides/tooling.adoc:19
msgid "how to enable live reload"
msgstr "ライブリロードを有効にする方法"

#. type: Plain text
#: upstream/_guides/tooling.adoc:20
msgid "how to develop your application in your IDE"
msgstr "IDEでアプリケーションを開発する方法"

#. type: Plain text
#: upstream/_guides/tooling.adoc:21
msgid "how to compile your application natively"
msgstr "アプリケーションをネイティブにコンパイルする方法"

#. type: Title ==
#: upstream/_guides/tooling.adoc:23
#, no-wrap
msgid "Choosing your build tool"
msgstr "ビルドツールの選択"

#. type: Plain text
#: upstream/_guides/tooling.adoc:28
msgid ""
"Quarkus comes with a toolchain to help you at all development stages.  You "
"can use Maven or Gradle as build tool.  And we offer a native CLI that is "
"convenient to use (coming soon)."
msgstr ""
"Quarkusには、すべての開発段階で役立つツールチェーンが付属しています。ビルドツールとしてMavenやGradleを使うことができます。また、使い勝手の良いネイティブCLIも提供しています（近日公開予定）。"

#. type: Plain text
#: upstream/_guides/tooling.adoc:30
msgid "link:maven-tooling[Maven]"
msgstr "link:maven-tooling[Maven]"

#. * link:cli-tooling[CLI]
#. type: Plain text
#: upstream/_guides/tooling.adoc:31
msgid "link:gradle-tooling[Gradle]"
msgstr "link:gradle-tooling[Gradle]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amqp.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using AMQP with Reactive Messaging"
msgstr "Quarkus - リアクティブメッセージングでAMQPを使用する"

#. type: Plain text
#: upstream/_guides/amqp.adoc:12
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize "
"MicroProfile Reactive Messaging to interact with AMQP."
msgstr ""
"このガイドでは、QuarkusアプリケーションがMicroProfile Reactive "
"Messagingを利用してAMQPと対話する方法を説明します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:24
#, fuzzy
msgid ""
"A running AMQP 1.0 broker, or Docker Compose to start a development cluster"
msgstr "実行中のAMQP 1.0ブローカー、またはDocker Composeで開発クラスタを起動する"

#. type: Plain text
#: upstream/_guides/amqp.adoc:33
#, fuzzy
msgid ""
"In this guide, we are going to generate (random) prices in one component.  "
"These prices are written in an AMQP queue (`prices`).  A second component "
"reads from the `prices` queue and apply some magic conversion to the price.  "
"The result is sent to an in-memory stream consumed by a JAX-RS resource.  "
"The data is sent to a browser using server-sent events."
msgstr ""
"このガイドでは、1つのコンポーネントで(ランダムな)価格を生成します。これらの価格はAMQPキュー( "
"`prices`)に書き込まれます。2番目のコンポーネントは `prices` "
"キューから読み込み、価格にいくつかの魔法の変換を適用します。その結果は、JAX-"
"RSリソースによって消費されるインメモリストリームに送られます。データは、サーバーから送られたイベントを使ってブラウザに送られます。"

#. type: Target for macro image
#: upstream/_guides/amqp.adoc:34
#, no-wrap
msgid "amqp-guide-architecture.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:44
#, fuzzy
msgid ""
"The solution is located in the `amqp-quickstart` {quickstarts-tree-url}/amqp-"
"quickstart[directory]."
msgstr ""
"ソリューションは `amqp-quickstart` {quickstarts-tree-url}/amqp-quickstart[directory] "
"にあります。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:56
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=amqp-quickstart \\\n"
"    -Dextensions=\"amqp\"\n"
"cd amqp-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:59
#, fuzzy
msgid ""
"This command generates a Maven project, importing the Reactive Messaging and "
"AMQP connector extensions."
msgstr "このコマンドは、Reactive MessagingとAMQPコネクタ拡張をインポートしてMavenプロジェクトを生成します。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:60
#, no-wrap, fuzzy
msgid "Starting an AMQP broker"
msgstr "AMQPブローカーの開始"

#. type: Plain text
#: upstream/_guides/amqp.adoc:64
#, fuzzy
msgid ""
"Then, we need an AMQP broker.  You can follow the instructions from the "
"https://activemq.apache.org/components/artemis/[Apache Artemis web site] or "
"create a `docker-compose.yaml` file with the following content:"
msgstr ""
"次に、AMQPブローカーが必要です。 link:https://activemq.apache.org/components/artemis/"
"[Apache ArtemisのWebサイト]の指示に従うか、以下の内容の `docker-compose.yaml` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:70
#, no-wrap
msgid ""
"# A docker compose file to start an Artemis AMQP broker\n"
"# more details on https://github.com/vromero/activemq-artemis-docker.\n"
"version: '2'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:72
#, no-wrap
msgid "services:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:82
#, no-wrap
msgid ""
"  artemis:\n"
"    image: vromero/activemq-artemis:2.8.0-alpine\n"
"    ports:\n"
"      - \"8161:8161\"\n"
"      - \"61616:61616\"\n"
"      - \"5672:5672\"\n"
"    environment:\n"
"      ARTEMIS_USERNAME: quarkus\n"
"      ARTEMIS_PASSWORD: quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:85
#, fuzzy
msgid "Once created, run `docker-compose up`."
msgstr "作成したら、 `docker-compose up` を実行します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:87
#, fuzzy
msgid "This is a development cluster, do not use in production."
msgstr "これは開発クラスタであり、生産では使用しないでください。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:88
#, no-wrap, fuzzy
msgid "The price generator"
msgstr "価格発生装置"

#. type: Plain text
#: upstream/_guides/amqp.adoc:91
#, fuzzy
msgid ""
"Create the `src/main/java/org/acme/amqp/PriceGenerator.java` file, with the "
"following content:"
msgstr "以下の内容の `src/main/java/org/acme/amqp/PriceGenerator.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:95 upstream/_guides/amqp.adoc:137
#: upstream/_guides/amqp.adoc:178
#, no-wrap
msgid "package org.acme.amqp;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:98
#, no-wrap
msgid "import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:103
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:110
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random prices every 5 seconds.\n"
" * The prices are written to a AMQP queue (prices). The AMQP configuration "
"is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:152
#, no-wrap
msgid "    private Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:119
#, no-wrap
msgid ""
"    @Outgoing(\"generated-price\")                        // <1>\n"
"    public Multi<Integer> generate() {                  // <2>\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
"                .onOverflow().drop()\n"
"                .map(tick -> random.nextInt(100));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:124
#, fuzzy
msgid ""
"Instruct Reactive Messaging to dispatch the items from returned stream to "
"`generated-price`."
msgstr ""
"返されたストリームから `generated-price` にアイテムをディスパッチするように Reactive Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:125
#, fuzzy
msgid ""
"The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ "
"every 5 seconds."
msgstr "このメソッドは、5秒ごとにランダムな _価格を_放出する Mutiny _ストリーム_( `Multi`) を返します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:128
#, fuzzy
msgid ""
"The method returns a _Reactive Stream_. The generated items are sent to the "
"stream named `generated-price`.  This stream is mapped to an AMQP queue "
"using the `application.properties` file that we will create soon."
msgstr ""
"このメソッドは、 _Reactive ストリーム_を返します。生成されたアイテムは `generated-price` "
"という名前のストリームに送られます。このストリームは、近日中に作成する `application.properties` ファイルを使用して AMQP "
"キューにマッピングされます。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:129
#, no-wrap, fuzzy
msgid "The price converter"
msgstr "価格コンバーター"

#. type: Plain text
#: upstream/_guides/amqp.adoc:133
#, fuzzy
msgid ""
"The price converter reads the prices from AMQP, and transforms them.  Create "
"the `src/main/java/org/acme/amqp/PriceConverter.java` file with the "
"following content:"
msgstr ""
"価格コンバータは、AMQPから価格を読み込んで変換します。以下の内容の `src/main/java/org/acme/amqp/"
"PriceConverter.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:141
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:150
#, no-wrap
msgid ""
"/**\n"
" * A bean consuming data from the \"prices\" AMQP queue and applying some "
"conversion.\n"
" * The result is pushed to the \"my-data-stream\" stream which is an in-"
"memory stream.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConverter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:152
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:159
#, no-wrap
msgid ""
"    @Incoming(\"prices\")                                  // <1>\n"
"    @Outgoing(\"my-data-stream\")                          // <2>\n"
"    @Broadcast                                           // <3>\n"
"    public double process(int priceInUsd) {\n"
"        return priceInUsd * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:164
#, fuzzy
msgid "Indicates that the method consumes the items from the `prices` channel"
msgstr "メソッドが `prices` チャンネルのアイテムを消費することを示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:165
#, fuzzy
msgid ""
"Indicates that the objects returned by the method are sent to the `my-data-"
"stream` channel"
msgstr "メソッドによって返されたオブジェクトが `my-data-stream` チャンネルに送られることを示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:166
#, fuzzy
msgid "Indicates that the item are dispatched to all _subscribers_"
msgstr "アイテムがすべての _加入者_に発送されていることを示します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:169
#, fuzzy
msgid ""
"The `process` method is called for every AMQP messages from the `prices` "
"queue (configured in the application configuration).  Every result is sent "
"to the `my-data-stream` in-memory stream."
msgstr ""
"`process` メソッドは、 `prices` キュー(アプリケーション設定で設定されている)からの AMQP "
"メッセージごとに呼び出されます。すべての結果は `my-data-stream` のインメモリストリームに送信されます。"

#. type: Title ===
#: upstream/_guides/jms.adoc:211
#, no-wrap, fuzzy
msgid "The price resource"
msgstr "価格資源"

#. type: Plain text
#: upstream/_guides/amqp.adoc:174
#, fuzzy
msgid ""
"Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/"
"java/org/acme/amqp/PriceResource.java` file with the following content:"
msgstr ""
"最後に、ストリームをJAX-RSリソースにバインドしてみましょう。以下の内容の `src/main/java/org/acme/amqp/"
"PriceResource.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:181
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:193
#, no-wrap
msgid ""
"/**\n"
" * A simple resource retrieving the \"in-memory\" \"my-data-stream\" and "
"sending the items as server-sent events.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:196
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"my-data-stream\") Publisher<Double> prices;         // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:259
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"hello\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:210
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)                     // <2>\n"
"    public Publisher<Double> stream() {                         // <3>\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:212
#, fuzzy
msgid "Injects the `my-data-stream` channel using the `@Channel` qualifier"
msgstr "`@Channel` の修飾子を使って `my-data-stream` チャンネルを注入します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:213
#, fuzzy
msgid "Indicates that the content is sent using `Server Sent Events`"
msgstr "を使用してコンテンツが送信されていることを示します。 `Server Sent Events`"

#. type: Plain text
#: upstream/_guides/amqp.adoc:214
#, fuzzy
msgid "Returns the stream (_Reactive Stream_)"
msgstr "ストリーム _（Reactive Stream_）を返します。"

#. type: Title ==
#: upstream/_guides/amqp.adoc:215
#, no-wrap, fuzzy
msgid "Configuring the AMQP connector"
msgstr "AMQP コネクタの設定"

#. type: Plain text
#: upstream/_guides/amqp.adoc:219
#, fuzzy
msgid ""
"We need to configure the AMQP connector. This is done in the `application."
"properties` file.  The keys are structured as follows:"
msgstr ""
"AMQP コネクタを設定する必要があります。これは `application.properties` "
"ファイルで行います。キーは以下のように構成されています。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:221
#, fuzzy
msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgstr "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"

#. type: Plain text
#: upstream/_guides/amqp.adoc:223
#, fuzzy
msgid ""
"The `channel-name` segment must match the value set in the `@Incoming` and "
"`@Outgoing` annotation:"
msgstr ""
"`channel-name` セグメントは、 `@Incoming` および `@Outgoing` "
"アノテーションで設定された値と一致する必要があります。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:224
#, fuzzy
msgid "`generated-price` -> sink in which we write the prices"
msgstr "`generated-price` → 価格を書いた流し"

#. type: Plain text
#: upstream/_guides/amqp.adoc:225
#, fuzzy
msgid "`prices` -> source in which we read the prices"
msgstr "`prices` → 価格を読み取ったソース"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:231
#, no-wrap
msgid ""
"# Configures the AMQP broker credentials.\n"
"amqp-username=quarkus\n"
"amqp-password=quarkus\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:235
#, no-wrap
msgid ""
"# Configure the AMQP connector to write to the `prices` address\n"
"mp.messaging.outgoing.generated-price.connector=smallrye-amqp\n"
"mp.messaging.outgoing.generated-price.address=prices\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:239
#, no-wrap
msgid ""
"# Configure the AMQP connector to read from the `prices` queue\n"
"mp.messaging.incoming.prices.connector=smallrye-amqp\n"
"mp.messaging.incoming.prices.durable=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:242
#, fuzzy
msgid ""
"More details about this configuration is available in the https://smallrye."
"io/smallrye-reactive-messaging/#_interacting_using_amqp[SmallRye Reactive "
"Messaging AMQP connector] documentation."
msgstr ""
"この設定の詳細については、 link:https://smallrye.io/smallrye-reactive-messaging/"
"#_interacting_using_amqp[SmallRye Reactive Messaging AMQP "
"コネクタの]ドキュメントを参照してください。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:244
#, fuzzy
msgid ""
"What about `my-data-stream`? This is an in-memory stream, not connected to a "
"message broker."
msgstr "`my-data-stream` はどうですか？これはインメモリストリームであり、メッセージブローカには接続されていません。"

#. type: Title ===
#: upstream/_guides/jms.adoc:244
#, no-wrap, fuzzy
msgid "The HTML page"
msgstr "HTMLページ"

#. type: Plain text
#: upstream/_guides/jms.adoc:247
#, fuzzy
msgid "Final touch, the HTML page reading the converted prices using SSE."
msgstr "最後に、SSEを使って変換された価格を読み込んだHTMLページ。"

#. type: Plain text
#: upstream/_guides/jms.adoc:249
#, fuzzy
msgid ""
"Create the `src/main/resources/META-INF/resources/prices.html` file, with "
"the following content:"
msgstr ""
"以下の内容の `src/main/resources/META-INF/resources/prices.html` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:257
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"<head>\n"
"    <meta charset=\"UTF-8\">\n"
"    <title>Prices</title>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:265
#, no-wrap
msgid ""
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/"
"css/patternfly.min.css\">\n"
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/"
"css/patternfly-additions.min.css\">\n"
"</head>\n"
"<body>\n"
"<div class=\"container\">\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:281
#, no-wrap
msgid ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/"
"A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
"<script>\n"
"    var source = new EventSource(\"/prices/stream\");\n"
"    source.onmessage = function (event) {\n"
"        document.getElementById(\"content\").innerHTML = event.data;\n"
"    };\n"
"</script>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:284
#, fuzzy
msgid "Nothing spectacular here. On each received price, it updates the page."
msgstr "目を見張るようなものは何もありません。受信した価格ごとに、ページを更新します。"

#. type: Title ===
#: upstream/_guides/jms.adoc:304
#, no-wrap, fuzzy
msgid "Get it running"
msgstr "稼動させる"

#. type: Plain text
#: upstream/_guides/amqp.adoc:289
#, fuzzy
msgid ""
"If you followed the instructions, you should have the AMQP broker running.  "
"Then, you just need to run the application using:"
msgstr "指示に従えば、AMQPブローカーを実行しているはずです。あとは、アプリケーションを使用して実行するだけです。"

#. type: delimited block -
#: upstream/_guides/amqp.adoc:293
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:315 upstream/_guides/jms.adoc:339
#, fuzzy
msgid "Open `http://localhost:8080/prices.html` in your browser."
msgstr ""
"開く `&lt;a href=\"http://localhost:8080/prices.html\" class=\"bare\"&gt;http:/"
"/localhost:8080/prices.html&lt;/a&gt;`をブラウザに表示してください。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:298
#, fuzzy
msgid ""
"If you started the AMQP broker with docker compose, stop it using `CTRL+C` "
"followed by `docker-compose down`."
msgstr ""
"docker composeでAMQPブローカーを起動した場合は、 `CTRL+C` に続いて `docker-compose down`."

#. type: Title ===
#: upstream/_guides/jms.adoc:316
#, no-wrap, fuzzy
msgid "Running Native"
msgstr "ネイティブの実行"

#. type: Plain text
#: upstream/_guides/jms.adoc:319
#, fuzzy
msgid "You can build the native executable with:"
msgstr "でネイティブ実行ファイルをビルドすることができます。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:323
#, no-wrap
msgid "./mvnw package -Pnative\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/amqp.adoc:308
#, no-wrap, fuzzy
msgid "Imperative usage"
msgstr "強制的な使用法"

#. type: Plain text
#: upstream/_guides/amqp.adoc:311
#, fuzzy
msgid "Sometimes you need to have an imperative way of sending messages."
msgstr "時には、メッセージを送るための必須の方法が必要になることもあります。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:314
#, fuzzy
msgid ""
"For example, if you need to send a message to a stream from inside a REST "
"endpoint when receiving a POST request.  In this case, you cannot use "
"`@Outgoing` because your method has parameters."
msgstr ""
"例えば、POST リクエストを受信した際に、REST "
"エンドポイントの内部からストリームにメッセージを送信する必要がある場合。この場合、メソッドにはパラメータがあるため、 `@Outgoing` "
"を使用することはできません。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:316
#, fuzzy
msgid "For this, you can use an `Emitter`."
msgstr "そのためには、 `Emitter`."

#. type: delimited block -
#: upstream/_guides/amqp.adoc:321
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:327
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:330
#, no-wrap
msgid "@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:332
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amqp.adoc:339
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amqp.adoc:343
#, fuzzy
msgid ""
"The `Emitter` configuration is done the same way as the other stream "
"configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use "
"`@OnOverflow` to configure a back-pressure strategy."
msgstr ""
"`Emitter` の設定は、 `@Incoming` と `@Outgoing` が使用する他のストリームの設定と同じ方法で行います。さらに、 "
"`@OnOverflow` を使用して、バックプレッシャー戦略を設定することができます。"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:348
#, fuzzy
msgid ""
"The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye."
"reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging."
"annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr ""
"`io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive."
"messaging.annotations.Channel`, `io.smallrye.reactive.messaging.annotations."
"OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:350
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:351
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:352
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_guides/amqp.adoc:354
#, fuzzy
msgid ""
"The new `Emitter.send` method returns a `CompletionStage` completed when the "
"produced message is acknowledged."
msgstr "新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると `CompletionStage` 完了を返します。"

#. type: Title ==
#: upstream/_guides/validation.adoc:275
#, no-wrap, fuzzy
msgid "Going further"
msgstr "さらに進む"

#. type: Plain text
#: upstream/_guides/amqp.adoc:360
#, fuzzy
msgid ""
"This guide has shown how you can interact with AMQP using Quarkus.  It "
"utilizes MicroProfile Reactive Messaging to build data streaming "
"applications."
msgstr ""
"このガイドでは、Quarkusを使用してAMQPと対話する方法を示しました。このガイドでは、MicroProfile Reactive "
"Messagingを利用してデータストリーミングアプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:363
#, fuzzy
msgid ""
"If you did the Kafka quickstart, you have realized that it's the same code.  "
"The only difference is the connector configuration."
msgstr "Kafka のクイックスタートをした人は、同じコードであることに気がついたはずです。違うのはコネクタの設定だけです。"

#. type: Plain text
#: upstream/_guides/amqp.adoc:364
#, fuzzy
msgid ""
"If you want to go further check the documentation of https://smallrye.io/"
"smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation "
"used in Quarkus."
msgstr ""
"さらに詳しく知りたい場合は、Quarkusで使用されている実装である link:https://smallrye.io/smallrye-"
"reactive-messaging[SmallRye Reactive Messaging]のドキュメントを確認してください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/amazon-dynamodb.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Amazon DynamoDB Client"
msgstr "Quarkus - Amazon DynamoDBクライアント"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:15
#, fuzzy
msgid ""
"DynamoDB is a scalable AWS managed *NoSQL* database.  It supports both key-"
"value and document data models, that enables to have a flexible schema for "
"your data.  This extension provides functionality that allows the client to "
"communicate with the service when running in Quarkus.  You can find more "
"information about DynamoDB at https://aws.amazon.com/dynamodb/[the Amazon "
"DynamoDB website]."
msgstr ""
"DynamoDBは、AWSで管理されているスケーラブルな "
"*NoSQL*データベースです。DynamoDBはキーバリューとドキュメントの両方のデータモデルをサポートしており、データに対して柔軟なスキーマを持つことができます。この拡張機能は、Quarkusで実行しているときにクライアントがサービスと通信できるようにする機能を提供します。DynamoDBの詳細については、 "
"link:https://aws.amazon.com/dynamodb/[Amazon DynamoDBのウェブサイト]で確認できます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:19
#, fuzzy
msgid ""
"The DynamoDB extension is based on https://docs.aws.amazon.com/sdk-for-java/"
"v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of "
"the 1.x code base that offers two programming models (Blocking & Async).  "
"Keep in mind it's actively developed and does not support yet all the "
"features available in SDK 1.x such as https://github.com/aws/aws-sdk-java-v2/"
"issues/36[Document APIs] or https://github.com/aws/aws-sdk-java-v2/issues/"
"35[Object Mappers]"
msgstr ""
"DynamoDBエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-"
"guide/welcome.html[AWS Java SDK 2.x]をベースにしています。1."
"xのコードベースを大幅に書き換えたもので、2つのプログラミングモデル（ブロッキングと非同期）を提供しています。この拡張機能は積極的に開発されており、 "
"link:https://github.com/aws/aws-sdk-java-v2/issues/36[ドキュメントAPI]や link:https:"
"//github.com/aws/aws-sdk-java-v2/issues/35[オブジェクトマッパー]のようなSDK 1."
"xで利用可能な機能はまだサポートしていないことを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:28
#, fuzzy
msgid ""
"In this guide, we see how you can get your REST services to use the DynamoDB "
"locally and on AWS."
msgstr "このガイドでは、RESTサービスでDynamoDBをローカルとAWS上で利用する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:37
#, fuzzy
msgid "An AWS Account to access the DynamoDB service"
msgstr "DynamoDBサービスにアクセスするためのAWSアカウント"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:38
#, fuzzy
msgid ""
"Optionally, Docker for your system to run DynamoDB locally for testing "
"purposes"
msgstr "オプションで、Dockerを使ってシステムをテスト用にローカルでDynamoDBを実行することができます。"

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:39
#, no-wrap, fuzzy
msgid "Setup DynamoDB locally"
msgstr "DynamoDBをローカルに設定する"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:42
#, fuzzy
msgid ""
"The easiest way to start working with DynamoDB is to run a local instance as "
"a container."
msgstr "DynamoDBで作業を始める最も簡単な方法は、ローカルインスタンスをコンテナとして実行することです。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:46
#, no-wrap
msgid ""
"docker run --publish 8000:8000 amazon/dynamodb-local:1.11.477 -jar "
"DynamoDBLocal.jar -inMemory -sharedDb\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:50
#, fuzzy
msgid ""
"This starts a DynamoDB instance that is accessible on port `8000`.  You can "
"check it's running by accessing the web shell on `http://localhost:8000/"
"shell`."
msgstr ""
"これは、ポート `8000` でアクセス可能な DynamoDB "
"インスタンスを起動します。のWebシェルにアクセスして、実行中であることを確認することができます。 `&lt;a href=\"http://"
"localhost:8000/shell\" class=\"bare\"&gt;http://localhost:8000/shell&lt;/"
"a&gt;`."

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:52
#, fuzzy
msgid ""
"Have a look at the https://docs.aws.amazon.com/amazondynamodb/latest/"
"developerguide/DynamoDBLocal.html[Setting Up DynamoDB Local guide] for other "
"options to run DynamoDB."
msgstr ""
"DynamoDBを実行するための他のオプションについては、 link:https://docs.aws.amazon.com/"
"amazondynamodb/latest/developerguide/DynamoDBLocal.html[Setting Up DynamoDB "
"Localガイドを]ご覧ください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:54
#, fuzzy
msgid "Open `http://localhost:8000/shell` in your browser."
msgstr ""
"開く `&lt;a href=\"http://localhost:8000/shell\" class=\"bare\"&gt;http://"
"localhost:8000/shell&lt;/a&gt;`をブラウザに表示してください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:56
#, fuzzy
msgid "Copy and paste the following code to the shell and run it:"
msgstr "以下のコードをシェルにコピー＆ペーストして実行してください。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:64
#, no-wrap
msgid ""
"var params = {\n"
"    TableName: 'QuarkusFruits',\n"
"    KeySchema: [{ AttributeName: 'fruitName', KeyType: 'HASH' }],\n"
"    AttributeDefinitions: [{  AttributeName: 'fruitName', AttributeType: "
"'S', }],\n"
"    ProvisionedThroughput: { ReadCapacityUnits: 1, WriteCapacityUnits: 1, }\n"
"};\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:68
#, no-wrap
msgid ""
"dynamodb.createTable(params, function(err, data) {\n"
"    if (err) ppJson(err);\n"
"    else ppJson(data);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:70
#, no-wrap
msgid "});\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/amazon-dynamodb.adoc:72
#, no-wrap, fuzzy
msgid "Set up Dynamodb on AWS"
msgstr "AWS上にDynamodbを設定する"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:76
#, fuzzy
msgid ""
"Before you can use the AWS SDKs with DynamoDB, you must get an AWS access "
"key ID and secret access key.  For more information, see https://docs.aws."
"amazon.com/amazondynamodb/latest/developerguide/SettingUp.DynamoWebService."
"html[Setting Up DynamoDB (Web Service)]."
msgstr ""
"DynamoDBでAWS SDKを利用する前に、AWSのアクセスキーIDとシークレットアクセスキーを取得する必要があります。詳しくは、 link:"
"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SettingUp."
"DynamoWebService.html[DynamoDB（Webサービス）]のセットアップを参照してください。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:78
#, fuzzy
msgid "We recommend to use the AWS CLI to provision the table:"
msgstr "テーブルのプロビジョニングにはAWS CLIを利用することをお勧めします。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:85
#, no-wrap
msgid ""
"aws dynamodb create-table --table-name QuarkusFruits \\\n"
"                          --attribute-definitions AttributeName="
"fruitName,AttributeType=S \\\n"
"                          --key-schema AttributeName=fruitName,KeyType=HASH "
"\\\n"
"                          --provisioned-throughput ReadCapacityUnits="
"1,WriteCapacityUnits=1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:89
#, fuzzy
msgid ""
"The application built here allows to manage elements (fruits) stored in "
"Amazon DynamoDB."
msgstr "ここで構築したアプリケーションでは、Amazon DynamoDBに格納されている要素（果物）を管理することができます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:96
#, fuzzy
msgid ""
"The solution is located in the `amazon-dynamodb-quickstart` {quickstarts-"
"tree-url}/amazon-dynamodb-quickstart[directory]."
msgstr ""
"ソリューションは `amazon-dynamodb-quickstart` {quickstarts-tree-url}/amazon-dynamodb-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:110
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=amazon-dynamodb-quickstart \\\n"
"    -DclassName=\"org.acme.dynamodb.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jackson,amazon-dynamodb,resteasy-mutiny\"\n"
"cd amazon-dynamodb-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:114
#, fuzzy
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS, "
"Mutiny and DynamoDB Client extensions.  After this, the `amazon-dynamodb` "
"extension has been added to your `pom.xml` as well as the Mutiny support for "
"RESTEasy."
msgstr ""
"このコマンドは、RESTEasy/JAX-RS、Mutiny、DynamoDBクライアント拡張機能をインポートするMaven構造体を生成します。 "
"`pom.xml` この後、RESTEasyのMutinyサポートと同様に、 `amazon-dynamodb` 拡張機能が追加されています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:118
#, fuzzy
msgid ""
"In this example, we will create an application to manage a list of fruits. "
"The example application will demonstrate the two programming models "
"supported by the extension."
msgstr ""
"この例では、果物のリストを管理するアプリケーションを作成します。この例のアプリケーションでは、拡張機能でサポートされている2つのプログラミングモデルを実演します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:124
#: upstream/_guides/amazon-dynamodb.adoc:191
#: upstream/_guides/amazon-dynamodb.adoc:243
#: upstream/_guides/amazon-dynamodb.adoc:280
#: upstream/_guides/amazon-dynamodb.adoc:393
#: upstream/_guides/amazon-dynamodb.adoc:434
#, no-wrap
msgid "package org.acme.dynamodb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:127
#, no-wrap
msgid "import java.util.Map;\n"
"import java.util.Objects;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:130
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.RegisterForReflection;\n"
"import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:133
#, no-wrap
msgid "@RegisterForReflection\n"
"public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:136
#, no-wrap
msgid "    private String name;\n"
"    private String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:112
#, no-wrap
msgid "    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:148
#, no-wrap
msgid ""
"    public static Fruit from(Map<String, AttributeValue> item) {\n"
"        Fruit fruit = new Fruit();\n"
"        if (item != null && !item.isEmpty()) {\n"
"            fruit.setName(item.get(AbstractService.FRUIT_NAME_COL).s());\n"
"            fruit.setDescription(item.get(AbstractService.FRUIT_DESC_COL)."
"s());\n"
"        }\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:160
#, no-wrap
msgid ""
"    public String getDescription() {\n"
"        return description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:164
#, no-wrap
msgid ""
"    public void setDescription(String description) {\n"
"        this.description = description;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:170
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean equals(Object obj) {\n"
"        if (!(obj instanceof Fruit)) {\n"
"            return false;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:172
#, no-wrap
msgid "        Fruit other = (Fruit) obj;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:175
#, no-wrap
msgid "        return Objects.equals(other.name, this.name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:181
#, no-wrap
msgid ""
"    @Override\n"
"    public int hashCode() {\n"
"        return Objects.hash(this.name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:185
#, fuzzy
msgid ""
"Nothing fancy. One important thing to note is that having a default "
"constructor is required by the JSON serialization layer. The static `from` "
"method creates a bean based on the `Map` object provided by the DynamoDB "
"client response."
msgstr ""
"派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことは、JSONシリアライゼーションレイヤーによって要求されるということです。static "
"`from` メソッドは、DynamoDB クライアントのレスポンスで提供される `Map` オブジェクトに基づいてビーンを作成します。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:187
#, fuzzy
msgid ""
"Now create a `org.acme.dynamodb.AbstractService` that will consist of helper "
"methods that prepare DynamoDB request objects for reading and adding items "
"to the table."
msgstr ""
"これで、テーブルにアイテムを読み込んで追加するためのDynamoDBリクエストオブジェクトを準備するヘルパーメソッドで構成される `org.acme."
"dynamodb.AbstractService` を作成します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:194
#, no-wrap
msgid "import java.util.HashMap;\n"
"import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:199
#, no-wrap
msgid ""
"import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n"
"import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;\n"
"import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;\n"
"import software.amazon.awssdk.services.dynamodb.model.ScanRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:201
#, no-wrap
msgid "public abstract class AbstractService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:204
#, no-wrap
msgid ""
"    public final static String FRUIT_NAME_COL = \"fruitName\";\n"
"    public final static String FRUIT_DESC_COL = \"fruitDescription\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:208
#, no-wrap
msgid ""
"    public String getTableName() {\n"
"        return \"QuarkusFruits\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:213
#, no-wrap
msgid ""
"    protected ScanRequest scanRequest() {\n"
"        return ScanRequest.builder().tableName(getTableName())\n"
"                .attributesToGet(FRUIT_NAME_COL, FRUIT_DESC_COL).build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:218
#, no-wrap
msgid ""
"    protected PutItemRequest putRequest(Fruit fruit) {\n"
"        Map<String, AttributeValue> item = new HashMap<>();\n"
"        item.put(FRUIT_NAME_COL, AttributeValue.builder().s(fruit.getName())."
"build());\n"
"        item.put(FRUIT_DESC_COL, AttributeValue.builder().s(fruit."
"getDescription()).build());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:224
#, no-wrap
msgid ""
"        return PutItemRequest.builder()\n"
"                .tableName(getTableName())\n"
"                .item(item)\n"
"                .build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:228
#, no-wrap
msgid ""
"    protected GetItemRequest getRequest(String name) {\n"
"        Map<String, AttributeValue> key = new HashMap<>();\n"
"        key.put(FRUIT_NAME_COL, AttributeValue.builder().s(name).build());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:236
#, no-wrap
msgid ""
"        return GetItemRequest.builder()\n"
"                .tableName(getTableName())\n"
"                .key(key)\n"
"                .attributesToGet(FRUIT_NAME_COL, FRUIT_DESC_COL)\n"
"                .build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:239
#, fuzzy
msgid ""
"Then, create a `org.acme.dynamodb.FruitSyncService` that will be the "
"business layer of our application and stores/loads the fruits from DynamoDB "
"using the synchronous client."
msgstr ""
"次に、アプリケーションのビジネスレイヤーとなる `org.acme.dynamodb.FruitSyncService` "
"を作成し、同期クライアントを使用して DynamoDB からフルーツを保存/ロードします。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:246
#, no-wrap
msgid "import java.util.List;\n"
"import java.util.stream.Collectors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:601
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:251
#, no-wrap
msgid "import software.amazon.awssdk.services.dynamodb.DynamoDbClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:254
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitSyncService extends AbstractService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:257
#, no-wrap
msgid "    @Inject\n"
"    DynamoDbClient dynamoDB;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:263
#, no-wrap
msgid ""
"    public List<Fruit> findAll() {\n"
"        return dynamoDB.scanPaginator(scanRequest()).items().stream()\n"
"                .map(Fruit::from)\n"
"                .collect(Collectors.toList());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:268
#, no-wrap
msgid ""
"    public List<Fruit> add(Fruit fruit) {\n"
"        dynamoDB.putItem(putRequest(fruit));\n"
"        return findAll();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:273
#, no-wrap
msgid ""
"    public Fruit get(String name) {\n"
"        return Fruit.from(dynamoDB.getItem(getRequest(name)).item());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:276
#, fuzzy
msgid "Now, edit the `org.acme.dynamodb.FruitResource` class as follows:"
msgstr "ここで、 `org.acme.dynamodb.FruitResource` クラスを以下のように編集します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:246
#, no-wrap
msgid "import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:289
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:295
#, no-wrap
msgid "    @Inject\n"
"    FruitSyncService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:300
#, no-wrap
msgid ""
"    @GET\n"
"    public List<Fruit> getAll() {\n"
"        return service.findAll();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:306
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}\")\n"
"    public Fruit getSingle(@PathParam(\"name\") String name) {\n"
"        return service.get(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:313
#, no-wrap
msgid ""
"    @POST\n"
"    public List<Fruit> add(Fruit fruit) {\n"
"        service.add(fruit);\n"
"        return getAll();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:316
#, fuzzy
msgid ""
"The implementation is pretty straightforward and you just need to define "
"your endpoints using the JAX-RS annotations and use the `FruitSyncService` "
"to list/add new fruits."
msgstr ""
"実装はとても簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義し、 `FruitSyncService` "
"を使って新しいフルーツをリストアップ/追加するだけです。"

#. type: Title ==
#: upstream/_guides/amazon-dynamodb.adoc:317
#, no-wrap, fuzzy
msgid "Configuring DynamoDB clients"
msgstr "DynamoDBクライアントの設定"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:322
#, fuzzy
msgid ""
"Both DynamoDB clients (sync and async) are configurable via the `application."
"properties` file that can be provided in the `src/main/resources` directory. "
" Additionally, you need to add to the classpath a proper implementation of "
"the sync client. By default the extension uses the `java.net.URLConnection` "
"HTTP client, so you need to add a URL connection client dependency to the "
"`pom.xml` file:"
msgstr ""
"DynamoDBクライアント(syncとasync)はどちらも、 `src/main/resources` ディレクトリで提供されている "
"`application.properties` "
"ファイルを介して設定可能です。さらに、同期クライアントの適切な実装をクラスパスに追加する必要があります。デフォルトでは、拡張機能は `java.net."
"URLConnection` HTTP クライアントを使用するので、URL 接続クライアントの依存関係を `pom.xml` "
"ファイルに追加する必要があります。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:332
#, fuzzy
msgid ""
"If you want to use the Apache HTTP client instead, configure it as follows:"
msgstr "代わりにApache HTTPクライアントを使いたい場合は、以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:335
#, no-wrap
msgid "quarkus.dynamodb.sync-client.type=apache\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:338
#, fuzzy
msgid "And add following dependency to the application `pom.xml`:"
msgstr "そして、以下の依存関係をアプリケーションに追加します `pom.xml`."

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:347
#, fuzzy
msgid ""
"If you're going to use a local DynamoDB instance, configure it as follows:"
msgstr "ローカルのDynamoDBインスタンスを使用する場合は、以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:351
#, no-wrap
msgid "quarkus.dynamodb.endpoint-override=http://localhost:8000\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:356
#, no-wrap
msgid ""
"quarkus.dynamodb.aws.region=eu-central-1\n"
"quarkus.dynamodb.aws.credentials.type=static\n"
"quarkus.dynamodb.aws.credentials.static-provider.access-key-id=test-key\n"
"quarkus.dynamodb.aws.credentials.static-provider.secret-access-key=test-"
"secret\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:359
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.region` - It's required by the client, but since "
"you're using a local DynamoDB instance you can pick any valid AWS region."
msgstr ""
"`quarkus.dynamodb.aws.region` - "
"クライアントが必要ですが、ローカルのDynamoDBインスタンスを使用しているので、有効なAWSリージョンを選ぶことができます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:360
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.credentials.type` - Set `static` credentials provider "
"with any values for `access-key-id` and `secret-access-key`"
msgstr ""
"`quarkus.dynamodb.aws.credentials.type` - `static` の資格情報プロバイダを `access-key-"
"id` と任意の値で設定します。 `secret-access-key`"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:361
#, fuzzy
msgid ""
"`quarkus.dynamodb.endpoint-override` - Override the DynamoDB client to use a "
"local instance instead of an AWS service"
msgstr ""
"`quarkus.dynamodb.endpoint-override` - "
"DynamoDBクライアントをAWSサービスの代わりにローカルインスタンスを使用するようにオーバーライドする"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:363
#, fuzzy
msgid "If you want to work with an AWS account, you'd need to set it with:"
msgstr "AWSアカウントで作業したい場合は、AWSアカウントで設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:367
#, no-wrap
msgid ""
"quarkus.dynamodb.aws.region=<YOUR_REGION>\n"
"quarkus.dynamodb.aws.credentials.type=default\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:370
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.region` you should set it to the region where you "
"provisioned the DynamoDB table,"
msgstr ""
"`quarkus.dynamodb.aws.region` 、DynamoDBテーブルをプロビジョニングしたリージョンに設定する必要があります。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:371
#, fuzzy
msgid ""
"`quarkus.dynamodb.aws.credentials.type` - use the `default` credentials "
"provider chain that looks for credentials in this order:"
msgstr ""
"`quarkus.dynamodb.aws.credentials.type` - `default` "
"クレデンシャル・プロバイダ・チェーンを使用して、この順番でクレデンシャルを検索します。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:380
#, fuzzy
msgid ""
"Packaging your application is as simple as `./mvnw clean package`.  It can "
"be run with `java -jar target/amazon-dynamodb-quickstart-1.0-SNAPSHOT-runner."
"jar`."
msgstr ""
"アプリケーションのパッケージ化は `./mvnw clean package` のように簡単です。 `java -jar target/amazon-"
"dynamodb-quickstart-1.0-SNAPSHOT-runner.jar` で実行できます。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:389
#, fuzzy
msgid ""
"Create a `org.acme.dynamodb.FruitAsyncService` that will be similar to our "
"`FruitSyncService` but using an asynchronous programming model."
msgstr ""
"`FruitSyncService` と同様の `org.acme.dynamodb.FruitAsyncService` "
"を作成しますが、非同期プログラミングモデルを使用します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:397
#, no-wrap
msgid ""
"import java.util.List;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.stream.Collectors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:403
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import software.amazon.awssdk.services.dynamodb.DynamoDbAsyncClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:406
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitAsyncService extends AbstractService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:409
#, no-wrap
msgid "    @Inject\n"
"    DynamoDbAsyncClient dynamoDB;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:414
#, no-wrap
msgid ""
"    public Uni<List<Fruit>> findAll() {\n"
"        return Uni.createFrom().completionStage(() -> dynamoDB."
"scan(scanRequest()))\n"
"                .onItem().transform(res -> res.items().stream().map(Fruit::"
"from).collect(Collectors.toList()));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:419
#, no-wrap
msgid ""
"    public Uni<List<Fruit>> add(Fruit fruit) {\n"
"        return Uni.createFrom().completionStage(() -> dynamoDB."
"putItem(putRequest(fruit)))\n"
"                .onItem().ignore().andSwitchTo(this::findAll);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:425
#, no-wrap
msgid ""
"    public Uni<Fruit> get(String name) {\n"
"        return Uni.createFrom().completionStage(() -> dynamoDB."
"getItem(getRequest(name)))\n"
"                .onItem().transform(resp -> Fruit.from(resp.item()));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:428
#, fuzzy
msgid ""
"In the previous code, we create `Uni` instances from the `CompletionStage` "
"objects returned by the asynchronous DynamoDB client, and then transform the "
"emitted item."
msgstr ""
"先ほどのコードでは、非同期のDynamoDBクライアントから返された `CompletionStage` オブジェクトから `Uni` "
"インスタンスを作成し、排出されたアイテムを変換しています。"

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:430
#, fuzzy
msgid ""
"Then, create an asynchronous REST resource that consumes this async service:"
msgstr "次に、この非同期サービスを消費する非同期RESTリソースを作成します。"

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:436
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:441
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.*;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:446
#, no-wrap
msgid ""
"@Path(\"/async-fruits\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class FruitAsyncResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:449
#, no-wrap
msgid "    @Inject\n"
"    FruitAsyncService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:454
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<List<Fruit>> getAll() {\n"
"        return service.findAll();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:460
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}\")\n"
"    public Uni<Fruit> getSingle(@PathParam(\"name\") String name) {\n"
"        return service.get(name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/amazon-dynamodb.adoc:467
#, no-wrap
msgid ""
"    @POST\n"
"    public Uni<List<Fruit>> add(Fruit fruit) {\n"
"        return service.add(fruit)\n"
"                .onItem().ignore().andSwitchTo(this::getAll);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/amazon-dynamodb.adoc:470
#, fuzzy
msgid "And add Netty HTTP client dependency to the `pom.xml`:"
msgstr "そして、 `pom.xml`.NETTY HTTPクライアントの依存関係を追加します。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/consul-config.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Reading properties from Consul"
msgstr "Quarkus - 領事からプロパティを読み取る"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:12
#, fuzzy
msgid ""
"This guide explains how your Quarkus application can read configuration "
"properties at runtime from https://www.consul.io[Consul]."
msgstr ""
"このガイドでは、Quarkusアプリケーションが実行時に link:https://www.consul."
"io[Consul]から設定プロパティを読み取る方法について説明します。"

#. type: Title ==
#: upstream/_guides/consul-config.adoc:29
#, no-wrap, fuzzy
msgid "Introduction"
msgstr "序章"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:33
#, fuzzy
msgid ""
"Consul is a versatile system which among other things, provides a "
"distributed Key-Value store that is used in many architectures as a source "
"of configuration for services.  This Key-Value store is what the `quarkus-"
"consul-config` extension interacts with in order to allow Quarkus "
"applications to read runtime configuration properties from Consul."
msgstr ""
"Consulは、サービスの設定のソースとして多くのアーキテクチャで使用されている分散型のキーバリューストアを提供する多目的システムです。このキーバリューストアは、Quarkus "
"アプリケーションが Consul から実行時の設定プロパティを読み込めるようにするために、 `quarkus-consul-config` "
"拡張機能が相互に作用するものです。"

#. type: Title ==
#: upstream/_guides/consul-config.adoc:34
#, no-wrap, fuzzy
msgid "Starting Consul"
msgstr "領事を開始する"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:37
#, fuzzy
msgid ""
"There are various ways to start Consul that vary in complexity, but for the "
"purposes of this guide, we elect to start a single Consul server with no "
"persistence via Docker, like so:"
msgstr ""
"Consul を起動する方法は複雑さによって様々ですが、このガイドの目的のために、Docker を介して永続性のない単一の Consul "
"サーバを起動することを選択します。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:41
#, no-wrap
msgid ""
"docker run --rm --name consul -p 8500:8500 -p 8501:8501 consul:1.7 agent -"
"dev -ui -client=0.0.0.0 -bind=0.0.0.0 --https-port=8501\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:44
#, fuzzy
msgid ""
"Please consult the https://www.consul.io/docs/install[documentation] to "
"learn more about the various Consul installation options."
msgstr ""
"様々なConsulのインストールオプションについては、 link:https://www.consul.io/docs/"
"install[ドキュメントを]参照してください。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:58
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=consul-config-quickstart \\\n"
"    -DclassName=\"org.acme.consul.config.GreetingResource\" \\\n"
"    -Dpath=\"/greeting\" \\\n"
"    -Dextensions=\"consul-config\"\n"
"cd consul-config-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:61
#, fuzzy
msgid ""
"This command generates a Maven project with a REST endpoint and imports the "
"`consul-config` extension."
msgstr "このコマンドは、RESTエンドポイントを持つMavenプロジェクトを生成し、 `consul-config` 拡張子をインポートします。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:64
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `consul-"
"config` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `consul-"
"config` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:68
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"consul-config\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:78
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-consul-config</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:84
#, fuzzy
msgid ""
"The Quarkus Maven plugin automatically generated a `GreetingResource` JAX-RS "
"resource in the `src/main/java/org/acme/consul/config/client/"
"GreetingResource.java` file that looks like:"
msgstr ""
"Quarkus Mavenプラグインは、 `src/main/java/org/acme/consul/config/client/"
"GreetingResource.java` ファイル内の `GreetingResource` JAX-"
"RSリソースを自動的に生成して、次のように表示します。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:88
#: upstream/_guides/consul-config.adoc:110
#, no-wrap
msgid "package org.acme.consul.config.client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:123
#, no-wrap
msgid ""
"    @ConfigProperty(name = \"message\", defaultValue=\"Hello from default\")\n"
"    String message;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:135
#, fuzzy
msgid ""
"Quarkus provides various configuration knobs under the `quarkus.consul-"
"config` root. For the purposes of this guide, our Quarkus application is "
"going to be configured in `application.properties` as follows:"
msgstr ""
"Quarkusは、 `quarkus.consul-config` "
"ルートの下に様々な設定ノブを提供しています。このガイドの目的のために、私たちのQuarkusアプリケーションは以下のように `application."
"properties` で設定されることになっています。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:144
#, no-wrap
msgid ""
"# use the same name as the application name that was configured when "
"standing up the Config Server\n"
"quarkus.application.name=consul-test\n"
"# enable retrieval of configuration from Consul - this is off by default\n"
"quarkus.consul-config.enabled=true\n"
"# this is a key in Consul's KV store that the Quarkus application will read "
"and try to extract properties from\n"
"quarkus.consul-config.properties-value-keys=config/${quarkus.application."
"name}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/consul-config.adoc:146
#, no-wrap, fuzzy
msgid "Add Configuration to Consul"
msgstr "コンスルに設定を追加"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:150
#, fuzzy
msgid ""
"For the previous application configuration to work, we need to add a `config/"
"consul-test` key under Consul's Key Value store. The value of this key will "
"essentially be a properties \"file\" containing the application "
"configuration.  In this case we want to add the following data to the "
"`config/consul-test` key:"
msgstr ""
"以前のアプリケーション設定を動作させるためには、Consulのキーバリューストアの下に `config/consul-test` "
"キーを追加する必要があります。このキーの値は、基本的にはアプリケーションの設定を含むプロパティ「ファイル」になります。この場合、 `config/"
"consul-test` キーに以下のデータを追加したいと思います。"

#. type: delimited block -
#: upstream/_guides/consul-config.adoc:154
#, no-wrap
msgid "greeting.message=Hello from Consul\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/consul-config.adoc:158
#, fuzzy
msgid ""
"When adding this configuration from the UI, Consul will automatically "
"convert the data into the necessary base64 encoding. If you instead add the "
"configuration via the Consul's https://www.consul.io/api/kv.html#create-"
"update-key[REST API], make sure to first encode the previous data into "
"base64."
msgstr ""
"UI からこの設定を追加すると、Consul は自動的に必要な base64 エンコーディングにデータを変換します。代わりに Consul の link:"
"https://www.consul.io/api/kv.html#create-update-key[REST API "
"を]介して設定を追加する場合は、まず前のデータを base64 にエンコードするようにしてください。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:162
#, fuzzy
msgid ""
"In this use case we made the value of the key as a properties \"file\", "
"because we used `quarkus.consul-config.properties-value-keys` in the "
"application. The extension also provides the ability to use the raw values "
"of keys when `quarkus.consul-config.raw-value-keys` is used. Furthermore, "
"these two properties can be used simultaneously, while each one also "
"supports setting multiple keys."
msgstr ""
"このユースケースでは、アプリケーションで `quarkus.consul-config.properties-value-keys` "
"を使用しているため、キーの値をプロパティ「ファイル」にしました。また、この拡張機能では、 `quarkus.consul-config.raw-"
"value-keys` "
"を使用した場合に、キーの生の値を使用する機能を提供しています。さらに、この2つのプロパティは同時に使用することができ、それぞれが複数のキーの設定にも対応しています。"

#. type: Plain text
#: upstream/_guides/consul-config.adoc:169
#, fuzzy
msgid ""
"The result should be: `Hello from Consul` as it is the value obtained from "
"the Consul Key Value store."
msgstr "結果は、Consulキーバリューストアから取得した値なので、 `Hello from Consul` となるはずです。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/rest-json.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Writing JSON REST Services"
msgstr "Quarkus - JSON RESTサービスの記述"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:11
#, fuzzy
msgid "JSON is now the _lingua franca_ between microservices."
msgstr "JSONは今やマイクロサービス間の共通 _言語と_なっています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:13
#, fuzzy
msgid ""
"In this guide, we see how you can get your REST services to consume and "
"produce JSON payloads."
msgstr "このガイドでは、REST サービスが JSON ペイロードを消費して生成する方法を見ていきます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:15
#, fuzzy
msgid ""
"there is another guide if you need a link:rest-client[REST client] "
"(including support for JSON)."
msgstr "link:rest-client[REST クライアントが]必要な場合は、別のガイドがあります (JSON のサポートを含む)。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:28
#, fuzzy
msgid ""
"The application built in this guide is quite simple: the user can add "
"elements in a list using a form and the list is updated."
msgstr ""
"このガイドで構築されたアプリケーションは非常にシンプルです：ユーザーはフォームを使用してリストに要素を追加することができ、リストは更新されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:30
#, fuzzy
msgid ""
"All the information between the browser and the server are formatted as JSON."
""
msgstr "ブラウザとサーバ間の情報はすべてJSON形式で提供されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:39
#, fuzzy
msgid ""
"The solution is located in the `rest-json-quickstart` {quickstarts-tree-url}/"
"rest-json-quickstart[directory]."
msgstr ""
"ソリューションは `rest-json-quickstart` {quickstarts-tree-url}/rest-json-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:53
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json-quickstart \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jackson\"\n"
"cd rest-json-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:57
#, fuzzy
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS and "
"https://github.com/FasterXML/jackson[Jackson] extensions, and in particular "
"adds the following dependency:"
msgstr ""
"このコマンドは、RESTEasy/JAX-RSと link:https://github.com/FasterXML/"
"jackson[Jackson]拡張をインポートするMaven構造体を生成し、特に以下の依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:64
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:69
#, fuzzy
msgid ""
"To improve user experience, Quarkus registers the three Jackson https://"
"github.com/FasterXML/jackson-modules-java8[Java 8 modules] so you don't need "
"to do it manually."
msgstr ""
"ユーザーエクスペリエンスを向上させるために、Quarkusは3つのJackson link:https://github.com/FasterXML/"
"jackson-modules-java8[Java 8モジュールを]登録しているので、手動で登録する必要はありません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:72
#, fuzzy
msgid ""
"Quarkus also supports http://json-b.net/[JSON-B] so, if you prefer JSON-B "
"over Jackson, you can create a project relying on the RESTEasy JSON-B "
"extension instead:"
msgstr ""
"Quarkusは link:http://json-b.net/[JSON-B]もサポートしているので、JacksonよりもJSON-"
"Bが好きな場合は、代わりにRESTEasy JSON-B拡張機能に依存したプロジェクトを作成することができます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:82
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json-quickstart \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jsonb\"\n"
"cd rest-json-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:86
#, fuzzy
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS and "
"http://json-b.net/[JSON-B] extensions, and in particular adds the following "
"dependency:"
msgstr ""
"このコマンドは、RESTEasy/JAX-RSと link:http://json-b.net/[JSON-"
"B]拡張をインポートするMaven構造体を生成し、特に以下の依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:93
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:95
#, no-wrap, fuzzy
msgid "Creating your first JSON REST service"
msgstr "初めてのJSON RESTサービスの作成"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:104 upstream/_guides/rest-json.adoc:127
#: upstream/_guides/rest-json.adoc:311 upstream/_guides/rest-json.adoc:334
#: upstream/_guides/rest-json.adoc:464
#, no-wrap
msgid "package org.acme.rest.json;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:106
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:109 upstream/_guides/rest-json.adoc:316
#, no-wrap
msgid "    public String name;\n"
"    public String description;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:118
#, no-wrap
msgid ""
"    public Fruit(String name, String description) {\n"
"        this.name = name;\n"
"        this.description = description;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:121
#, fuzzy
msgid ""
"Nothing fancy. One important thing to note is that having a default "
"constructor is required by the JSON serialization layer."
msgstr ""
"派手なことは何もありません。注意すべき重要なことは、デフォルトのコンストラクタを持つことはJSONシリアライズレイヤーで必須であるということです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:123
#, fuzzy
msgid "Now, edit the `org.acme.rest.json.FruitResource` class as follows:"
msgstr "ここで、 `org.acme.rest.json.FruitResource` クラスを以下のように編集します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:131
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.LinkedHashMap;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:136
#, no-wrap
msgid ""
"import javax.ws.rs.DELETE;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:141
#, no-wrap
msgid ""
"    private Set<Fruit> fruits = Collections.newSetFromMap(Collections."
"synchronizedMap(new LinkedHashMap<>()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:146
#, no-wrap
msgid ""
"    public FruitResource() {\n"
"        fruits.add(new Fruit(\"Apple\", \"Winter fruit\"));\n"
"        fruits.add(new Fruit(\"Pineapple\", \"Tropical fruit\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:151
#, no-wrap
msgid "    @GET\n"
"    public Set<Fruit> list() {\n"
"        return fruits;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:157
#, no-wrap
msgid ""
"    @POST\n"
"    public Set<Fruit> add(Fruit fruit) {\n"
"        fruits.add(fruit);\n"
"        return fruits;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:164
#, no-wrap
msgid ""
"    @DELETE\n"
"    public Set<Fruit> delete(Fruit fruit) {\n"
"        fruits.removeIf(existingFruit -> existingFruit.name."
"contentEquals(fruit.name));\n"
"        return fruits;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:167
#, fuzzy
msgid ""
"The implementation is pretty straightforward and you just need to define "
"your endpoints using the JAX-RS annotations."
msgstr "実装は非常に簡単で、JAX-RSのアノテーションを使ってエンドポイントを定義するだけです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:170
#, fuzzy
msgid ""
"The `Fruit` objects will be automatically serialized/deserialized by http://"
"json-b.net/[JSON-B] or https://github.com/FasterXML/jackson[Jackson], "
"depending on the extension you chose when initializing the project."
msgstr ""
"`Fruit` オブジェクトは、プロジェクトの初期化時に選択した拡張子に応じて、 link:http://json-b.net/[JSON-B]または "
"link:https://github.com/FasterXML/jackson[Jackson] によって自動的にシリアライズ/"
"デシリアライズされます。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:177
#, fuzzy
msgid ""
"When a JSON extension is installed such as `quarkus-resteasy-jackson` or "
"`quarkus-resteasy-jsonb`, Quarkus will use the `application/json` media type "
"by default for most return values, unless the media type is explicitly set "
"via `@Produces` or `@Consumes` annotations (there are some exceptions for "
"well known types, such as `String` and `File`, which default to `text/plain` "
"and `application/octet-stream` respectively)."
msgstr ""
"`quarkus-resteasy-jackson` や `quarkus-resteasy-jsonb` などの JSON "
"拡張機能がインストールされている場合、メディアタイプが `@Produces` や `@Consumes` "
"アノテーションで明示的に設定されていない限り、Quarkus はほとんどの戻り値に `application/json` "
"メディアタイプをデフォルトで使用します（ `String` や `File` などのよく知られたタイプには例外があり、それぞれ `text/plain` "
"と `application/octet-stream` がデフォルトとなっています）。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:180
#, fuzzy
msgid ""
"If you don't want JSON by default you can set `quarkus.resteasy-json.default-"
"json=false` and the default will change back to being auto-negotiated. If "
"you set this you will need to add `@Produces(MediaType.APPLICATION_JSON)` "
"and `@Consumes(MediaType.APPLICATION_JSON)` to your endpoints in order to "
"use JSON."
msgstr ""
"デフォルトでJSONを使用したくない場合は、 `quarkus.resteasy-json.default-json=false` "
"を設定すると、デフォルトは自動ネゴシエーションに戻ります。これを設定した場合、JSON を使用するためには `@Produces(MediaType."
"APPLICATION_JSON)` と `@Consumes(MediaType.APPLICATION_JSON)` "
"をエンドポイントに追加する必要があります。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:183
#, fuzzy
msgid ""
"If you don't rely on the JSON default, it is heavily recommended to annotate "
"your endpoints with the `@Produces` and `@Consumes` annotations to define "
"precisely the expected content-types.  It will allow to narrow down the "
"number of JAX-RS providers (which can be seen as converters) included in the "
"native executable."
msgstr ""
"JSON のデフォルトに頼らない場合は、エンドポイントに `@Produces` や `@Consumes` "
"のアノテーションを付けて、期待されるコンテンツタイプを正確に定義することを強くお勧めします。これにより、ネイティブ実行ファイルに含まれる JAX-RS "
"プロバイダ (コンバータとみなすことができます) の数を絞り込むことができます。"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:185
#, no-wrap, fuzzy
msgid "Configuring JSON support"
msgstr "JSONサポートの設定"

#. type: Title ====
#: upstream/_guides/rest-json.adoc:187
#, no-wrap, fuzzy
msgid "Jackson"
msgstr "ジャクソン"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:191
#, fuzzy
msgid ""
"Quarkus makes it very easy to configure various Jackson settings via CDI "
"beans. The simplest (and suggested) approach is to define a CDI bean of type "
"`io.quarkus.jackson.ObjectMapperCustomizer` inside of which any Jackson "
"configuration can be applied."
msgstr ""
"Quarkusは、CDIビーンを介して、様々なJacksonの設定を非常に簡単に設定することができます。最もシンプルな（そして推奨される）アプローチは、 "
"`io.quarkus.jackson.ObjectMapperCustomizer` 型の CDI ビーンを定義し、その中で、Jackson "
"の設定を適用することです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:193
#, fuzzy
msgid ""
"An example where a custom module needs to be registered would look like so:"
msgstr "カスタムモジュールを登録する必要がある場合の例は次のようになります。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:199
#, no-wrap
msgid ""
"import com.fasterxml.jackson.databind.ObjectMapper;\n"
"import io.quarkus.jackson.ObjectMapperCustomizer;\n"
"import javax.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:202
#, no-wrap
msgid ""
"@Singleton\n"
"public class RegisterCustomModuleCustomizer implements "
"ObjectMapperCustomizer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:207
#, no-wrap
msgid ""
"    public void customize(ObjectMapper mapper) {\n"
"        mapper.registerModule(new CustomModule());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:212
#, fuzzy
msgid ""
"Users can even provide their own `ObjectMapper` bean if they so choose.  If "
"this is done, it is very important to manually inject and apply all `io."
"quarkus.jackson.ObjectMapperCustomizer` beans in the CDI producer that "
"produces `ObjectMapper`.  Failure to do so will prevent Jackson specific "
"customizations provided by various extensions from being applied."
msgstr ""
"ユーザーは、選択すれば自分の `ObjectMapper` ビーンを提供することもできます。この場合、 `ObjectMapper` を生成する CDI "
"プロデューサの中で、すべての `io.quarkus.jackson.ObjectMapperCustomizer` "
"ビーンを手動で注入して適用することが非常に重要です。これを怠ると、様々な拡張機能によって提供される Jackson "
"固有のカスタマイズが適用されなくなります。"

#. type: Title ====
#: upstream/_guides/rest-json.adoc:213
#, no-wrap, fuzzy
msgid "JSON-B"
msgstr "ジェイソンビー"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:216
#, fuzzy
msgid ""
"As stated above, Quarkus provides the option of using JSON-B instead of "
"Jackson via the use of the `quarkus-resteasy-jsonb` extension."
msgstr ""
"上記のように、Quarkusでは、 `quarkus-resteasy-jsonb` 拡張機能を使用することで、Jacksonの代わりにJSON-"
"Bを使用するオプションを提供しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:218
#, fuzzy
msgid ""
"Following the same approach as described in the previous section, JSON-B can "
"be configured using a `io.quarkus.jsonb.JsonbConfigCustomizer` bean."
msgstr ""
"前項と同様のアプローチで、 `io.quarkus.jsonb.JsonbConfigCustomizer` beanを使用してJSON-"
"Bを設定することができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:220
#, fuzzy
msgid ""
"If for example a custom serializer named `FooSerializer` for type `com."
"example.Foo` needs to be registered with JSON-B, the addition of a bean like "
"the following would suffice:"
msgstr ""
"例えば、 `FooSerializer` という名前のカスタムシリアライザを `com.example.Foo` タイプで JSON-B "
"で登録する必要がある場合、以下のようなビーンを追加すれば十分です。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:227
#, no-wrap
msgid ""
"import io.quarkus.jsonb.JsonbConfigCustomizer;\n"
"import javax.inject.Singleton;\n"
"import javax.json.bind.JsonbConfig;\n"
"import javax.json.bind.serializer.JsonbSerializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:230
#, no-wrap
msgid ""
"@Singleton\n"
"public class FooSerializerRegistrationCustomizer implements "
"JsonbConfigCustomizer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:235
#, no-wrap
msgid ""
"    public void customize(JsonbConfig config) {\n"
"        config.withSerializers(new FooSerializer());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:240
#, fuzzy
msgid ""
"A more advanced option would be to directly provide a bean of `javax.json."
"bind.JsonbConfig` (with a `Dependent` scope) or in the extreme case to "
"provide a bean of type `javax.json.bind.Jsonb` (with a `Singleton` scope).  "
"If the latter approach is leveraged it is very important to manually inject "
"and apply all `io.quarkus.jsonb.JsonbConfigCustomizer` beans in the CDI "
"producer that produces `javax.json.bind.Jsonb`.  Failure to do so will "
"prevent JSON-B specific customizations provided by various extensions from "
"being applied."
msgstr ""
"より高度なオプションとしては、 `javax.json.bind.JsonbConfig` （ `Dependent` "
"スコープ付き）のビーンを直接提供するか、極端な場合には `javax.json.bind.Jsonb` （ `Singleton` "
"スコープ付き）のタイプのビーンを提供することが考えられます。後者のアプローチを利用する場合は、 `javax.json.bind.Jsonb` "
"を生成する CDI プロデューサに `io.quarkus.jsonb.JsonbConfigCustomizer` "
"ビーンをすべて手動で注入して適用することが非常に重要です。これを怠ると、様々な拡張機能によって提供される JSON-B "
"固有のカスタマイズが適用されなくなります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:246
#, fuzzy
msgid ""
"Now let's add a simple web page to interact with our `FruitResource`.  "
"Quarkus automatically serves static resources located under the `META-INF/"
"resources` directory.  In the `src/main/resources/META-INF/resources` "
"directory, add a `fruits.html` file with the content from this {quickstarts-"
"blob-url}/rest-json-quickstart/src/main/resources/META-INF/resources/fruits."
"html[fruits.html] file in it."
msgstr ""
"ここで、 `FruitResource`.Quarkusと対話するための簡単なウェブページを追加してみましょう。Quarkusは、 `META-INF/"
"resources` ディレクトリの下にある静的リソースを自動的に提供します。 `src/main/resources/META-INF/"
"resources` ディレクトリに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/"
"resources/META-INF/resources/fruits.html[fruits.html] ファイルの内容を含む `fruits."
"html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:250
#, fuzzy
msgid "start Quarkus with `./mvnw compile quarkus:dev`"
msgstr "クォークスを起動する `./mvnw compile quarkus:dev`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:256
#, fuzzy
msgid ""
"You can build a native executable with the usual command `./mvnw package -"
"Pnative`."
msgstr "通常のコマンド `./mvnw package -Pnative` でネイティブ実行ファイルをビルドすることができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:258
#, fuzzy
msgid ""
"Running it is as simple as executing `./target/rest-json-quickstart-1.0-"
"SNAPSHOT-runner`."
msgstr "実行は `./target/rest-json-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:261
#, no-wrap, fuzzy
msgid "About serialization"
msgstr "連載について"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:264
#, fuzzy
msgid ""
"JSON serialization libraries use Java reflection to get the properties of an "
"object and serialize them."
msgstr "JSONシリアライズライブラリは、Javaのリフレクションを使用してオブジェクトのプロパティを取得してシリアライズします。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:268
#, fuzzy
msgid ""
"When using native executables with GraalVM, all classes that will be used "
"with reflection need to be registered.  The good news is that Quarkus does "
"that work for you most of the time.  So far, we haven't registered any "
"class, not even `Fruit`, for reflection usage and everything is working fine."
""
msgstr ""
"GraalVMでネイティブ実行ファイルを使用する場合、リフレクションで使用されるすべてのクラスを登録する必要があります。良いニュースは、Quarkusがほとんどの場合、その作業を代行してくれるということです。これまでのところ、 "
"`Fruit` でさえ、リフレクトを使用するためのクラスを登録しておらず、すべてが正常に動作しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:271
#, fuzzy
msgid ""
"Quarkus performs some magic when it is capable of inferring the serialized "
"types from the REST methods.  When you have the following REST method, "
"Quarkus determines that `Fruit` will be serialized:"
msgstr ""
"Quarkusは、RESTメソッドからシリアライズされた型を推論することができる場合に、何らかのマジックを実行します。以下のようなRESTメソッドがある場合、Quarkusは、 "
"`Fruit` がシリアライズされると判断します。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:278
#, no-wrap
msgid "@GET\n"
"public List<Fruit> list() {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:282
#, fuzzy
msgid ""
"Quarkus does that for you automatically by analyzing the REST methods at "
"build time and that's why we didn't need any reflection registration in the "
"first part of this guide."
msgstr "Quarkusは、ビルド時にRESTメソッドを分析することで、自動的にそのような処理を行ってくれます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:285
#, fuzzy
msgid ""
"Another common pattern in the JAX-RS world is to use the `Response` object.  "
"`Response` comes with some nice perks:"
msgstr ""
"JAX-RSの世界では、 `Response` オブジェクトを使用するのがもう一つの一般的なパターンです。 `Response` "
"にはいくつかの素晴らしい特典があります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:287
#, fuzzy
msgid ""
"you can return different entity types depending on what happens in your "
"method (a `Legume` or an `Error` for instance);"
msgstr "メソッドで何が起こるかによって異なるエンティティタイプを返すことができます (例えば `Legume` や `Error` )。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:288
#, fuzzy
msgid ""
"you can set the attributes of the `Response` (the status comes to mind in "
"the case of an error)."
msgstr "の属性を設定すると、 `Response` （エラーが発生した時にステータスが浮かんでくる）。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:290
#, fuzzy
msgid "Your REST method then looks like this:"
msgstr "RESTメソッドは次のようになります。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:297
#, no-wrap
msgid "@GET\n"
"public Response list() {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:301
#, fuzzy
msgid ""
"It is not possible for Quarkus to determine at build time the type included "
"in the `Response` as the information is not available.  In this case, "
"Quarkus won't be able to automatically register for reflection the required "
"classes."
msgstr ""
"`Response` "
"に含まれるタイプは情報がないため、Quarkusがビルド時に判断することはできません。この場合、Quarkusは必要なクラスを自動的に反映登録することができません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:303
#, fuzzy
msgid "This leads us to our next section."
msgstr "これが次のセクションにつながります。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:304
#, no-wrap, fuzzy
msgid "Using Response"
msgstr "レスポンスの利用"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:307
#, fuzzy
msgid ""
"Let's create the `Legume` class which will be serialized as JSON, following "
"the same model as for our `Fruit` class:"
msgstr "`Fruit` クラスと同じモデルに従って、JSON としてシリアライズされる `Legume` クラスを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:313
#, no-wrap
msgid "public class Legume {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:319
#, no-wrap
msgid "    public Legume() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:325
#, no-wrap
msgid ""
"    public Legume(String name, String description) {\n"
"        this.name = name;\n"
"        this.description = description;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:328
#, fuzzy
msgid ""
"Now let's create a `LegumeResource` REST service with only one method which "
"returns the list of legumes."
msgstr "それでは、マメ科植物のリストを返すメソッドを一つだけ持つ `LegumeResource` REST サービスを作成してみましょう。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:330
#, fuzzy
msgid "This method returns a `Response` and not a list of `Legume`."
msgstr "このメソッドは `Response` を返し、 `Legume` のリストではありません。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:338
#, no-wrap
msgid ""
"import java.util.Collections;\n"
"import java.util.LinkedHashSet;\n"
"import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:345
#, no-wrap
msgid ""
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:350
#, no-wrap
msgid ""
"@Path(\"/legumes\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public class LegumeResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:352
#, no-wrap
msgid ""
"    private Set<Legume> legumes = Collections.synchronizedSet(new "
"LinkedHashSet<>());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:357
#, no-wrap
msgid ""
"    public LegumeResource() {\n"
"        legumes.add(new Legume(\"Carrot\", \"Root vegetable, usually "
"orange\"));\n"
"        legumes.add(new Legume(\"Zucchini\", \"Summer squash\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:363
#, no-wrap
msgid ""
"    @GET\n"
"    public Response list() {\n"
"        return Response.ok(legumes).build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:368
#, fuzzy
msgid ""
"Now let's add a simple web page to display our list of legumes.  In the `src/"
"main/resources/META-INF/resources` directory, add a `legumes.html` file with "
"the content from this {quickstarts-blob-url}/rest-json-quickstart/src/main/"
"resources/META-INF/resources/legumes.html[legumes.html] file in it."
msgstr ""
"ここで、マメ科植物のリストを表示するための簡単なウェブページを追加してみましょう。 `src/main/resources/META-INF/"
"resources` ディレクトリに、この {quickstarts-blob-url}/rest-json-quickstart/src/main/"
"resources/META-INF/resources/legumes.html[legumes.html] ファイルの内容を含む `legumes."
"html` ファイルを追加します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:370
#, fuzzy
msgid ""
"Open a browser to http://localhost:8080/legumes.html and you will see our "
"list of legumes."
msgstr ""
"ブラウザを開いて http://localhost:8080/legumes.html にアクセスすると、マメ科植物のリストが表示されます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:372
#, fuzzy
msgid ""
"The interesting part starts when running the application as a native "
"executable:"
msgstr "興味深いのは、アプリケーションをネイティブ実行ファイルとして実行するときに始まります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:374 upstream/_guides/rest-json.adoc:405
#, fuzzy
msgid "create the native executable with `./mvnw package -Pnative`."
msgstr "`./mvnw package -Pnative` でネイティブ実行ファイルを作成します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:375 upstream/_guides/rest-json.adoc:406
#, fuzzy
msgid "execute it with `./target/rest-json-quickstart-1.0-SNAPSHOT-runner`"
msgstr "と共に実行する `./target/rest-json-quickstart-1.0-SNAPSHOT-runner`"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:376 upstream/_guides/rest-json.adoc:407
#, fuzzy
msgid "open a browser and go to http://localhost:8080/legumes.html"
msgstr "ブラウザを開き、 http://localhost:8080/legumes.html"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:378
#, fuzzy
msgid "No legumes there."
msgstr "そこには豆類はありません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:381
#, fuzzy
msgid ""
"As mentioned above, the issue is that Quarkus was not able to determine the "
"`Legume` class will require some reflection by analyzing the REST endpoints. "
" The JSON serialization library tries to get the list of fields of `Legume` "
"and gets an empty list so it does not serialize the fields' data."
msgstr ""
"上記のように、Quarkusが `Legume` クラスを判断できなかったことが問題となっており、REST "
"エンドポイントを解析して何らかの反映が必要となります。JSONシリアライズライブラリは、 `Legume` "
"のフィールドのリストを取得しようとすると空のリストを取得するので、フィールドのデータをシリアライズしません。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:386
#, fuzzy
msgid ""
"At the moment, when JSON-B or Jackson tries to get the list of fields of a "
"class, if the class is not registered for reflection, no exception will be "
"thrown.  GraalVM will simply return an empty list of fields."
msgstr ""
"現時点では、JSON-"
"BやJacksonがクラスのフィールドのリストを取得しようとしたときに、そのクラスがReflectionに登録されていない場合、例外はスローされません。GraalVMは単に空のフィールドのリストを返します。"

#. type: delimited block =
#: upstream/_guides/rest-json.adoc:388
#, fuzzy
msgid ""
"Hopefully, this will change in the future and make the error more obvious."
msgstr "うまくいけば、将来的にはこれが変化して、エラーがより明白になるでしょう。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:391
#, fuzzy
msgid ""
"We can register `Legume` for reflection manually by adding the "
"`@RegisterForReflection` annotation on our `Legume` class:"
msgstr ""
"`Legume` クラスに `@RegisterForReflection` アノテーションを追加することで、手動で `Legume` "
"をリフレクト用に登録することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:282
#: upstream/_guides/kafka-streams.adoc:329
#: upstream/_guides/kafka-streams.adoc:684
#, no-wrap
msgid "import io.quarkus.runtime.annotations.RegisterForReflection;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:399
#, no-wrap
msgid "@RegisterForReflection\n"
"public class Legume {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:402
#, fuzzy
msgid "Let's do that and follow the same steps as before:"
msgstr "それを実行して、今までと同じ手順を踏んでみましょう。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:404
#, fuzzy
msgid "hit `Ctrl+C` to stop the application"
msgstr "`Ctrl+C` を叩いてアプリケーションを停止させる"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:409
#, fuzzy
msgid "This time, you can see our list of legumes."
msgstr "今回はマメ科の一覧です。"

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:129
#, no-wrap, fuzzy
msgid "Being reactive"
msgstr "反応すること"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:415
#, fuzzy
msgid ""
"You can return _reactive types_ to handle asynchronous processing.  Quarkus "
"recommends the usage of https://smallrye.io/smallrye-mutiny[Mutiny] to write "
"reactive and asynchronous code."
msgstr ""
"非同期処理を処理するためにリア _クティブ型を_返すことができます。Quarkusでは、リアクティブで非同期なコードを書くために link:https:/"
"/smallrye.io/smallrye-mutiny[Mutiny]の使用を推奨しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:417
#, fuzzy
msgid ""
"To integrate Mutiny and RESTEasy, you need to add the `quarkus-resteasy-"
"mutiny` dependency to your project:"
msgstr ""
"Mutiny と RESTEasy を統合するには、 `quarkus-resteasy-mutiny` "
"依存関係をプロジェクトに追加する必要があります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:427
#, fuzzy
msgid "Then, your endpoint can return `Uni` or `Multi` instances:"
msgstr "そして、エンドポイントは `Uni` や `Multi` のインスタンスを返すことができます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:436
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/{name}\")\n"
"public Uni<Fruit> getOne(@PathParam String name) {\n"
"    return findByName(name);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:441
#, no-wrap
msgid "@GET\n"
"public Multi<Fruit> getAll() {\n"
"    return findAll();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:445
#, fuzzy
msgid ""
"Use `Uni` when you have a single result.  Use `Multi` when you have multiple "
"items that may be emitted asynchronously."
msgstr "単一の結果がある場合は `Uni` を使用します。 `Multi` は、非同期的に放出される可能性のある複数の項目がある場合に使用します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:447
#, fuzzy
msgid ""
"You can use `Uni` and `Response` to return asynchronous HTTP responses: "
"`Uni<Response>`."
msgstr ""
"`Uni` と `Response` を使用して、非同期 HTTP レスポンスを返すことができます: "
"`Uni&amp;lt;Response&amp;gt;`."

#. type: Plain text
#: upstream/_guides/rest-json.adoc:449
#, fuzzy
msgid ""
"More details about Mutiny can be found in the link:getting-started-"
"reactive#mutiny[Getting Started with Reactive guide]."
msgstr ""
"Mutinyについての詳細は、 link:getting-started-"
"reactive#mutiny[Reactiveの入門ガイド]に記載されています。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:451
#, no-wrap, fuzzy
msgid "HTTP filters and interceptors"
msgstr "HTTP フィルタとインターセプタ"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:457
#, fuzzy
msgid ""
"Both HTTP request and response can be intercepted by providing "
"`ContainerRequestFilter` or `ContainerResponseFilter` implementations "
"respectively. These filters are suitable for processing the metadata "
"associated with a message: HTTP headers, query parameters, media type, and "
"other metadata. They also have the capability to abort the request "
"processing, for instance when the user does not have the permissions to "
"access the endpoint."
msgstr ""
"HTTP リクエストとレスポンスの両方とも、それぞれ `ContainerRequestFilter` または "
"`ContainerResponseFilter` の実装を提供することで、 "
"傍受することができます。これらのフィルタは、メッセージに関連付けられたメタデータを処理するのに適しています。HTTP "
"ヘッダ、クエリパラメータ、メディアタイプ、その他のメタデータです。また、ユーザがエンドポイントにアクセスする権限を持っていない場合など、リクエスト処理を中止する機能も持っています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:460
#, fuzzy
msgid ""
"Let's use `ContainerRequestFilter` to add logging capability to our service. "
"We can do that by implementing `ContainerRequestFilter` and annotating it "
"with the `@Provider` annotation:"
msgstr ""
"`ContainerRequestFilter` を使用して、サービスにロギング機能を追加してみましょう。 "
"`ContainerRequestFilter` を実装して、 `@Provider` アノテーションをつけることで実現できます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:467
#, no-wrap
msgid ""
"import io.vertx.core.http.HttpServerRequest;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:473
#, no-wrap
msgid ""
"import javax.ws.rs.container.ContainerRequestContext;\n"
"import javax.ws.rs.container.ContainerRequestFilter;\n"
"import javax.ws.rs.core.Context;\n"
"import javax.ws.rs.core.UriInfo;\n"
"import javax.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:476
#, no-wrap
msgid ""
"@Provider\n"
"public class LoggingFilter implements ContainerRequestFilter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:478
#, no-wrap
msgid ""
"    private static final Logger LOG = Logger.getLogger(LoggingFilter."
"class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:481
#, no-wrap
msgid "    @Context\n"
"    UriInfo info;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:484
#, no-wrap
msgid "    @Context\n"
"    HttpServerRequest request;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:487
#, no-wrap
msgid ""
"    @Override\n"
"    public void filter(ContainerRequestContext context) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:491
#, no-wrap
msgid ""
"        final String method = context.getMethod();\n"
"        final String path = info.getPath();\n"
"        final String address = request.remoteAddress().toString();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:495
#, no-wrap
msgid ""
"        LOG.infof(\"Request %s %s from IP %s\", method, path, address);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:498
#, fuzzy
msgid ""
"Now, whenever a REST method is invoked, the request will be logged into the "
"console:"
msgstr "これで、RESTメソッドが呼び出されるたびに、リクエストがコンソールにログとして記録されるようになりました。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:505
#, no-wrap
msgid ""
"2019-06-05 12:44:26,526 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request GET /legumes from IP 127.0.0.1\n"
"2019-06-05 12:49:19,623 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request GET /fruits from IP 0:0:0:0:0:0:0:1\n"
"2019-06-05 12:50:44,019 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request POST /fruits from IP 0:0:0:0:0:0:0:1\n"
"2019-06-05 12:51:04,485 INFO  [org.acm.res.jso.LoggingFilter] (executor-"
"thread-1) Request GET /fruits from IP 127.0.0.1\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/rest-json.adoc:507
#, no-wrap, fuzzy
msgid "CORS filter"
msgstr "CORSフィルタ"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:512
#, fuzzy
msgid ""
"link:https://en.wikipedia.org/wiki/Cross-origin_resource_sharing[Cross-"
"origin resource sharing] (CORS) is a mechanism that allows restricted "
"resources on a web page to be requested from another domain outside the "
"domain from which the first resource was served."
msgstr ""
"link:https://en.wikipedia.org/wiki/Cross-"
"origin_resource_sharing[クロスオリジンリソース共有]（CORS）は、ウェブページ上の制限されたリソースを、最初のリソースが提供されたドメイン以外の別のドメインから要求できるようにするメカニズムです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:515
#, fuzzy
msgid ""
"Quarkus comes with a CORS filter. Read the link:http-reference#cors-"
"filter[HTTP Reference Documentation] to learn how to use it."
msgstr ""
"QuarkusにはCORSフィルターが付属しています。使用方法については、 link:http-reference#cors-"
"filter[HTTPリファレンスドキュメント]を参照してください。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:516
#, no-wrap, fuzzy
msgid "GZip Support"
msgstr "GZipサポート"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:519
#, fuzzy
msgid ""
"Quarkus comes with GZip support (even though it is not enabled by default). "
"The following configuration knobs allow to configure GZip support."
msgstr ""
"QuarkusにはGZipサポートが搭載されています（デフォルトでは有効になっていませんが）。以下の設定ノブを使用して、GZipサポートを設定できます。"

#. type: delimited block -
#: upstream/_guides/rest-json.adoc:524
#, no-wrap
msgid ""
"quarkus.resteasy.gzip.enabled=true // <1>\n"
"quarkus.resteasy.gzip.max-input=10M // <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/rest-json.adoc:527
#, fuzzy
msgid "Enable Gzip support."
msgstr "Gzipサポートを有効にします。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:529
#, fuzzy
msgid ""
"Configure the upper limit on deflated request body. This is useful to "
"mitigate potential attacks by limiting their reach. The default value is "
"`10M`.  This configuration option would recognize strings in this format "
"(shown as a regular expression): `[0-9]+[KkMmGgTtPpEeZzYy]?`. If no suffix "
"is given, assume bytes."
msgstr ""
"デフレーションされたリクエストボディの上限を設定します。これは、リーチを制限することで潜在的な攻撃を緩和するのに便利です。既定値は `10M` "
"です。この設定オプションは、以下の形式の文字列を認識します(正規表現で表示されます)： `[0-9]+[KkMmGgTtPpEeZzYy]?`."
"サフィックスが指定されていない場合は、バイトとみなします。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:530
#, no-wrap, fuzzy
msgid "Multipart Support"
msgstr "マルチパートサポート"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:533
#, fuzzy
msgid ""
"RESTEasy supports multipart via the https://docs.jboss.org/resteasy/docs/4.5."
"6.Final/userguide/html/Multipart.html[RESTEasy Multipart Provider]."
msgstr ""
"RESTEasyは link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/userguide/"
"html/Multipart.html[RESTEasy Multipart Provider]を介してマルチパートをサポートしています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:535
#, fuzzy
msgid ""
"Quarkus provides an extension called `quarkus-resteasy-multipart` to make "
"things easier for you."
msgstr "Quarkusは、 `quarkus-resteasy-multipart` という拡張機能を提供しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:537
#, fuzzy
msgid ""
"This extension slightly differs from the RESTEasy default behavior as the "
"default charset (if none is specified in your request) is UTF-8 rather than "
"US-ASCII."
msgstr ""
"この拡張機能は、デフォルトの文字セットが US-ASCII ではなく UTF-8 であるため、RESTEasy のデフォルトの動作とは若干異なります。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:539
#, fuzzy
msgid ""
"You can configure this behavior with the following configuration properties:"
msgstr "この動作は、以下の構成プロパティで設定できます。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:542
#, no-wrap, fuzzy
msgid "Servlet compatibility"
msgstr "サーブレットの互換性"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:545
#, fuzzy
msgid ""
"In Quarkus, RESTEasy can either run directly on top of the Vert.x HTTP "
"server, or on top of Undertow if you have any servlet dependency."
msgstr ""
"Quarkusでは、RESTEasyはVert.x "
"HTTPサーバーの上で直接実行するか、サーブレットに依存している場合はUndertowの上で実行することができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:552
#, fuzzy
msgid ""
"As a result, certain classes, such as `HttpServletRequest` are not always "
"available for injection. Most use-cases for this particular class are "
"covered by JAX-RS equivalents, except for getting the remote client's IP. "
"RESTEasy comes with a replacement API which you can inject: https://docs."
"jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/"
"HttpRequest.html[`HttpRequest`], which has the methods https://docs.jboss."
"org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest."
"html#getRemoteAddress--[`getRemoteAddress()`] and https://docs.jboss.org/"
"resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/HttpRequest."
"html#getRemoteHost--[`getRemoteHost()`] to solve this problem."
msgstr ""
"その結果、 `HttpServletRequest` "
"のような特定のクラスが常にインジェクションに利用できるわけではありません。この特定のクラスのほとんどのユースケースは、リモートクライアントの IP "
"を取得することを除いて、JAX-RS と同等のものでカバーされています。RESTEasy には、インジェクション可能な代替 API が付属しています。  "
"link:https://docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/"
"resteasy/spi/HttpRequest.html[`HttpRequest`]これは以下のメソッドを持っています。  link:https://"
"docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/"
"HttpRequest.html#getRemoteAddress--[`getRemoteAddress()`]そして  link:https://"
"docs.jboss.org/resteasy/docs/4.5.6.Final/javadocs/org/jboss/resteasy/spi/"
"HttpRequest.html#getRemoteHost--[`getRemoteHost()`]を解決するために、この問題を解決します。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:553
#, no-wrap, fuzzy
msgid "RESTEasy and REST Client interactions"
msgstr "RESTEasy と REST クライアントのインタラクション"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:557
#, fuzzy
msgid ""
"In Quarkus, the RESTEasy extension and link:rest-client[the REST Client "
"extension] share the same infrastructure.  One important consequence of this "
"consideration is that they share the same list of providers (in the JAX-RS "
"meaning of the word)."
msgstr ""
"Quarkusでは、RESTEasyエクステンションと link:rest-"
"client[RESTクライアントエクステンションは]同じインフラストラクチャを共有しています。この考慮の重要な結果の一つは、（JAX-"
"RSの意味での）プロバイダーのリストを共有しているということです。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:560
#, fuzzy
msgid ""
"For instance, if you declare a `WriterInterceptor`, it will by default "
"intercept both the servers calls and the client calls, which might not be "
"the desired behavior."
msgstr ""
"例えば、 `WriterInterceptor` "
"を宣言した場合、デフォルトではサーバの呼び出しとクライアントの呼び出しの両方を傍受しますが、これは望ましい動作ではないかもしれません。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:562
#, fuzzy
msgid ""
"However, you can change this default behavior and constrain a provider to:"
msgstr "しかし、このデフォルトの動作を変更してプロバイダを制約することができます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:564
#, fuzzy
msgid ""
"only consider *server* calls by adding the `@ConstrainedTo(RuntimeType."
"SERVER)` annotation to your provider;"
msgstr ""
"プロバイダに `@ConstrainedTo(RuntimeType.SERVER)` アノテーションを追加することで、 "
"*サーバ*コールのみを考慮します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:565
#, fuzzy
msgid ""
"only consider *client* calls by adding the `@ConstrainedTo(RuntimeType."
"CLIENT)` annotation to your provider."
msgstr ""
"プロバイダに `@ConstrainedTo(RuntimeType.CLIENT)` アノテーションを追加することで、 "
"*クライアントコール*のみを考慮します。"

#. type: Title ==
#: upstream/_guides/rest-json.adoc:566
#, no-wrap, fuzzy
msgid "What's Different from Jakarta EE Development"
msgstr "ジャカルタEE開発との違い"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:568
#, no-wrap, fuzzy
msgid "No Need for `Application` Class"
msgstr "`Application` クラスは不要"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:571
#, fuzzy
msgid ""
"Configuration via an application-supplied subclass of `Application` is "
"supported, but not required."
msgstr "`Application` のアプリケーションが提供するサブクラスによる設定もサポートされていますが、必須ではありません。"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:572
#, no-wrap, fuzzy
msgid "Only a single JAX-RS application"
msgstr "単一のJAX-RSアプリケーションのみ"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:576
#, fuzzy
msgid ""
"In contrast to JAX-RS (and RESTeasy) running in a standard servlet-"
"container, Quarkus only supports the deployment of a single JAX-RS "
"application.  If multiple JAX-RS `Application` classes are defined, the "
"build will fail with the message `Multiple classes have been annotated with "
"@ApplicationPath which is currently not supported`."
msgstr ""
"JAX-RS（およびRESTeasy）が標準のサーブレットコンテナで実行されているのとは対照的に、Quarkusは単一のJAX-"
"RSアプリケーションのデプロイのみをサポートしています。複数のJAX-RS `Application` クラスが定義されている場合、ビルドは "
"`Multiple classes have been annotated with @ApplicationPath which is "
"currently not supported`."

#. type: Plain text
#: upstream/_guides/rest-json.adoc:578
#, fuzzy
msgid ""
"If multiple JAX-RS applications are defined, the property `quarkus.resteasy."
"ignoreApplicationClasses=true` can be used to ignore all explicit "
"`Application` classes. This makes all resource-classes available via the "
"application-path as defined by `quarkus.resteasy.path` (default: `/`)."
msgstr ""
"複数の JAX-RS アプリケーションが定義されている場合、プロパティ `quarkus.resteasy."
"ignoreApplicationClasses=true` を使用して、すべての明示的な `Application` "
"クラスを無視することができます。これにより、すべてのリソースクラスが `quarkus.resteasy.path` "
"で定義されたアプリケーションパスを介して利用できるようになります（デフォルトは `/` ）。"

#. type: Title ===
#: upstream/_guides/rest-json.adoc:579
#, no-wrap, fuzzy
msgid "Lifecycle of Resources"
msgstr "資源のライフサイクル"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:583
#, fuzzy
msgid ""
"In Quarkus all JAX-RS resources are treated as CDI beans.  It's possible to "
"inject other beans via `@Inject`, bind interceptors using bindings such as "
"`@Transactional`, define `@PostConstruct` callbacks, etc."
msgstr ""
"Quarkusでは、すべてのJAX-RSリソースはCDIビーンとして扱われます。 `@Inject` を介して他のビーンを注入したり、 "
"`@Transactional` のようなバインディングを使用してインターセプターをバインドしたり、 `@PostConstruct` "
"コールバックを定義したりすることが可能です。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:589
#, fuzzy
msgid ""
"If there is no scope annotation declared on the resource class then the "
"scope is defaulted.  The default scope can be controlled through the "
"`quarkus.resteasy.singleton-resources` property.  If set to `true` (default) "
"then a *single instance* of a resource class is created to service all "
"requests (as defined by `@javax.inject.Singleton`).  If set to `false` then "
"a *new instance* of the resource class is created per each request.  An "
"explicit CDI scope annotation (`@RequestScoped`, `@ApplicationScoped`, etc.) "
"always overrides the default behavior and specifies the lifecycle of "
"resource instances."
msgstr ""
"リソースクラスでスコープ注釈が宣言されていない場合は、スコープはデフォルトになります。デフォルトのスコープは `quarkus.resteasy."
"singleton-resources` プロパティで制御できます。 `true` (デフォルト) に設定すると、( `@javax.inject."
"Singleton` で定義されているように) すべてのリクエストにサービスを提供するためのリソースクラスの *単一のインスタンス*が作成されます。 "
"`false` に設定すると、各リクエストごとにリソースクラスの *新しい インスタンス*が作成されます。明示的な CDI スコープ注釈 ( "
"`@RequestScoped`, `@ApplicationScoped`, など) "
"は常にデフォルトの動作を上書きし、リソースインスタンスのライフサイクルを指定します。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:593
#, fuzzy
msgid ""
"Creating JSON REST services with Quarkus is easy as it relies on proven and "
"well known technologies."
msgstr "Quarkusを使用したJSON RESTサービスの作成は、実績のあるよく知られたテクノロジーに依存しているため、簡単に行えます。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:595
#, fuzzy
msgid ""
"As usual, Quarkus further simplifies things under the hood when running your "
"application as a native executable."
msgstr "いつものように、Quarkusは、アプリケーションをネイティブの実行ファイルとして実行する際に、その下での作業をさらに簡略化しています。"

#. type: Plain text
#: upstream/_guides/rest-json.adoc:596
#, fuzzy
msgid ""
"There is only one thing to remember: if you use `Response` and Quarkus can't "
"determine the beans that are serialized, you need to annotate them with "
"`@RegisterForReflection`."
msgstr ""
"覚えておくべきことは一つだけあります。 `Response` を使用していて、Quarkus がシリアライズされているビーンを特定できない場合は、 "
"`@RegisterForReflection`.NET を使って注釈を付ける必要があります。"

#. type: delimited block =
#: upstream/_guides/platform-include.adoc:4
#, fuzzy
msgid ""
"This extension is developed by a third party and is part of the Quarkus "
"Platform."
msgstr "この拡張機能はサードパーティによって開発されたもので、Quarkus Platformの一部です。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka-streams.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using Apache Kafka Streams"
msgstr "Quarkus - Apache Kafkaストリームの使用"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:11
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize the Apache "
"Kafka Streams API to implement stream processing applications based on "
"Apache Kafka."
msgstr ""
"このガイドでは、QuarkusアプリケーションがApache Kafka Streams APIを利用して、Apache "
"Kafkaベースのストリーム処理アプリケーションを実装する方法を説明します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:21
#, fuzzy
msgid "Docker Compose to start an Apache Kafka development cluster"
msgstr "Docker ComposeでApache Kafka開発クラスタを起動する"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:24
#, fuzzy
msgid ""
"It is recommended, that you have read the {quickstarts-tree-url}/kafka-"
"quickstart[Kafka quickstart] before."
msgstr ""
"事前に{quickstarts-tree-url}/kafka-quickstart[Kafka quickstart]を読んでおくことをお勧めします。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:29
#, fuzzy
msgid ""
"The Quarkus extension for Kafka Streams allows for very fast turnaround "
"times during development by supporting the Quarkus Dev Mode (e.g. via `./"
"mvnw compile quarkus:dev`).  After changing the code of your Kafka Streams "
"topology, the application will automatically be reloaded when the next input "
"message arrives."
msgstr ""
"Kafka Streams用のQuarkus拡張機能を使用すると、Quarkus Dev "
"Modeをサポートすることで、開発期間を非常に短縮することができます（例： `./mvnw compile quarkus:dev` "
"を参照）。Kafka Streamsトポロジーのコードを変更した後、次の入力メッセージが到着すると、アプリケーションが自動的にリロードされます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:32
#, fuzzy
msgid ""
"A recommended development set-up is to have some producer which creates test "
"messages on the processed topic(s) in fixed intervals, e.g. every second and "
"observe the streaming application's output topic(s) using a tool such as "
"`kafkacat`.  Using the dev mode, you'll instantly see messages on the output "
"topic(s) as produced by the latest version of your streaming application "
"when saving."
msgstr ""
"推奨される開発セットアップは、処理されたトピックに対して一定の間隔 (たとえば毎秒) でテストメッセージを作成するプロデューサを用意し、 "
"`kafkacat` のようなツールを使用してストリーミング "
"アプリケーションの出力トピックを観察することです。開発モードを使用すると、保存時にストリーミングアプリケーションの最新バージョンによって生成された出力トピッ "
"ク上のメッセージを即座に見ることができます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:34
#, fuzzy
msgid ""
"For the best development experience, we recommend applying the following "
"configuration settings to your Kafka broker:"
msgstr "最高の開発環境を実現するために、以下の設定を Kafka ブローカーに適用することをお勧めします。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:38
#, no-wrap
msgid "group.min.session.timeout.ms=250\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:41
#, fuzzy
msgid ""
"Also specify the following settings in your Quarkus `application.properties`:"
""
msgstr "また、以下の設定をQuarkusで指定します `application.properties`."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:46
#, no-wrap
msgid ""
"kafka-streams.consumer.session.timeout.ms=250\n"
"kafka-streams.consumer.heartbeat.interval.ms=200\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:49
#, fuzzy
msgid ""
"Together, these settings will ensure that the application can very quickly "
"reconnect to the broker after being restarted in dev mode."
msgstr "これらの設定を併用することで、アプリケーションを開発モードで再起動した後に、非常に迅速にブローカに再接続できるようになります。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:56
#, fuzzy
msgid ""
"In this guide, we are going to generate (random) temperature values in one "
"component (named `generator`).  These values are associated to given weather "
"stations and are written in a Kafka topic (`temperature-values`).  Another "
"topic (`weather-stations`) contains just the master data about the weather "
"stations themselves (id and name)."
msgstr ""
"このガイドでは、(ランダムな)温度値を 1 つのコンポーネント ( `generator`) "
"で生成します。これらの値は、与えられた気象観測所に関連付けられ、Kafka トピック ( `temperature-values`) "
"に書き込まれます。別のトピック ( `weather-stations`) には、気象観測所自体に関するマスターデータ (id と名前) "
"だけが格納されています。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:58
#, fuzzy
msgid ""
"A second component (`aggregator`) reads from the two Kafka topics and "
"processes them in a streaming pipeline:"
msgstr ""
"2 つ目のコンポーネント ( `aggregator`) は、2 つの Kafka トピックから読み込み、ストリーミングパイプラインで処理します。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:60
#, fuzzy
msgid "the two topics are joined on weather station id"
msgstr "ウェザーステーションIDでは、この2つのトピックが結合されています。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:61
#, fuzzy
msgid "per weather station the min, max and average temperature is determined"
msgstr "各気象台ごとに最低、最高、平均気温が決定されます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:62
#, fuzzy
msgid ""
"this aggregated data is written out to a third topic (`temperatures-"
"aggregated`)"
msgstr "この集約されたデータは、第三のトピック ( `temperatures-aggregated`) に書き出されます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:66
#, fuzzy
msgid ""
"The data can be examined by inspecting the output topic.  By exposing a "
"Kafka Streams https://kafka.apache.org/22/documentation/streams/developer-"
"guide/interactive-queries.html[interactive query], the latest result for "
"each weather station can alternatively be obtained via a simple REST query."
msgstr ""
"出力トピックを検査することで、データを調べることができます。Kafka Streams の link:https://kafka.apache.org/"
"22/documentation/streams/developer-guide/interactive-queries."
"html[対話型クエリを]公開することで、各気象観測所の最新の結果を単純な REST クエリで取得することができます。"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:68
#, fuzzy
msgid "The overall architecture looks like so:"
msgstr "全体的な建築はこんな感じです。"

#. type: Target for macro image
#: upstream/_guides/kafka-streams.adoc:69
#, no-wrap
msgid "kafka-streams-guide-architecture.png"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:79
#, fuzzy
msgid ""
"The solution is located in the `kafka-streams-quickstart` {quickstarts-tree-"
"url}/kafka-streams-quickstart[directory]."
msgstr ""
"ソリューションは `kafka-streams-quickstart` {quickstarts-tree-url}/kafka-streams-"
"quickstart[directory] にあります。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:80
#, no-wrap, fuzzy
msgid "Creating the Producer Maven Project"
msgstr "Producer Maven プロジェクトの作成"

#. type: delimited block =
#: upstream/_guides/kafka-streams.adoc:84
#, fuzzy
msgid ""
"First, we need a new project with the temperature value producer.  Create a "
"new project with the following command:"
msgstr "まず、温度値プロデューサを持つ新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:93
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-streams-quickstart-producer \\\n"
"    -Dextensions=\"kafka\" \\\n"
"    -DnoExamples \\\n"
"    && mv kafka-streams-quickstart-producer producer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:96
#, fuzzy
msgid ""
"This command generates a Maven project, importing the Reactive Messaging and "
"Kafka connector extensions."
msgstr "このコマンドは、Reactive Messaging と Kafka コネクタ拡張をインポートして Maven プロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:99
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-reactive-messaging-kafka` extension to your project by running the "
"following command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-reactive-messaging-kafka` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:103
#, no-wrap
msgid ""
"./mvnw quarkus:add-extension -Dextensions=\"quarkus-smallrye-reactive-"
"messaging-kafka\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:113
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:115
#, no-wrap, fuzzy
msgid "The Temperature Value Producer"
msgstr "温度値プロデューサー"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:119
#, fuzzy
msgid ""
"Create the `producer/src/main/java/org/acme/kafka/streams/producer/generator/"
"ValuesGenerator.java` file, with the following content:"
msgstr ""
"以下の内容の `producer/src/main/java/org/acme/kafka/streams/producer/generator/"
"ValuesGenerator.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:123
#, no-wrap
msgid "package org.acme.kafka.streams.producer.generator;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:132
#, no-wrap
msgid ""
"import java.math.BigDecimal;\n"
"import java.math.RoundingMode;\n"
"import java.time.Duration;\n"
"import java.time.Instant;\n"
"import java.util.Arrays;\n"
"import java.util.Collections;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:139
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.smallrye.reactive.messaging.kafka.Record;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
"import org.jboss.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:148
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random temperature data every second.\n"
" * The values are written to a Kafka topic (temperature-values).\n"
" * Another topic contains the name of weather stations (weather-stations).\n"
" * The Kafka configuration is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class ValuesGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:150
#, no-wrap
msgid ""
"    private static final Logger LOG = Logger.getLogger(ValuesGenerator."
"class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:165
#, no-wrap
msgid ""
"    private List<WeatherStation> stations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                    new WeatherStation(1, \"Hamburg\", 13),\n"
"                    new WeatherStation(2, \"Snowdonia\", 5),\n"
"                    new WeatherStation(3, \"Boston\", 11),\n"
"                    new WeatherStation(4, \"Tokio\", 16),\n"
"                    new WeatherStation(5, \"Cusco\", 12),\n"
"                    new WeatherStation(6, \"Svalbard\", -7),\n"
"                    new WeatherStation(7, \"Porthsmouth\", 11),\n"
"                    new WeatherStation(8, \"Oslo\", 7),\n"
"                    new WeatherStation(9, \"Marrakesh\", 20)\n"
"            ));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:175
#, no-wrap
msgid ""
"    @Outgoing(\"temperature-values\")                                        "
"// <1>\n"
"    public Multi<Record<Integer, String>> generate() {\n"
"        return Multi.createFrom().ticks().every(Duration.ofMillis(500))    //"
" <2>\n"
"                .onOverflow().drop()\n"
"                .map(tick -> {\n"
"                    WeatherStation station = stations.get(random."
"nextInt(stations.size()));\n"
"                    double temperature = BigDecimal.valueOf(random."
"nextGaussian() * 15 + station.averageTemperature)\n"
"                            .setScale(1, RoundingMode.HALF_UP)\n"
"                            .doubleValue();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:180
#, no-wrap
msgid ""
"                    LOG.infov(\"station: {0}, temperature: {1}\", station."
"name, temperature);\n"
"                    return Record.of(station.id, Instant.now() + \";\" + "
"temperature);\n"
"                });\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:190
#, no-wrap
msgid ""
"    @Outgoing(\"weather-stations\")                                          "
"// <3>\n"
"    public Multi<Record<Integer, String>> weatherStations() {\n"
"        return Multi.createFrom().items(stations.stream()\n"
"            .map(s -> Record.of(\n"
"                    s.id,\n"
"                    \"{ \\\"id\\\" : \" + s.id +\n"
"                    \", \\\"name\\\" : \\\"\" + s.name + \"\\\" }\"))\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:192
#, no-wrap
msgid "    private static class WeatherStation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:196
#, no-wrap
msgid "        int id;\n"
"        String name;\n"
"        int averageTemperature;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:204
#, no-wrap
msgid ""
"        public WeatherStation(int id, String name, int averageTemperature) {\n"
"            this.id = id;\n"
"            this.name = name;\n"
"            this.averageTemperature = averageTemperature;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:206
#, fuzzy
msgid ""
"Instruct Reactive Messaging to dispatch the items from the returned `Multi` "
"to `temperature-values`."
msgstr ""
"返却された `Multi` から `temperature-values` にアイテムを発送するように Reactive Messaging "
"に指示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:207
#, fuzzy
msgid ""
"The method returns a Mutiny _stream_ (`Multi`) emitting a random temperature "
"value every 0.5 seconds."
msgstr "このメソッドは、0.5 秒ごとにランダムな温度値を放出する Mutiny _ストリーム_( `Multi`) を返します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:208
#, fuzzy
msgid ""
"Instruct Reactive Messaging to dispatch the items from the returned `Multi` "
"(static list of weather stations) to `weather-stations`."
msgstr ""
"返された `Multi` (気象観測所の静的リスト) から `weather-stations` にアイテムをディスパッチするように Reactive "
"Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:210
#, fuzzy
msgid ""
"The two methods each return a _reactive stream_ whose items are sent to the "
"streams named `temperature-values` and `weather-stations`, respectively."
msgstr ""
"この 2 つのメソッドは、それぞれ `temperature-values` と `weather-stations` "
"という名前のストリームにアイテムが送信される _反応型ストリーム_を返します。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:211
#, no-wrap, fuzzy
msgid "Topic Configuration"
msgstr "トピック構成"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:215
#, fuzzy
msgid ""
"The two channels are mapped to Kafka topics using the Quarkus configuration "
"file `application.properties`.  For that, add the following to the file "
"`producer/src/main/resources/application.properties`:"
msgstr ""
"2つのチャンネルは、Quarkus設定ファイル `application.properties` "
"を使用してKafkaトピックにマッピングされます。そのためには、ファイル `producer/src/main/resources/"
"application.properties` に次のように追加します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:220
#, no-wrap
msgid ""
"# Configure the Kafka broker location\n"
"kafka.bootstrap.servers=localhost:9092\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:224
#, no-wrap
msgid ""
"mp.messaging.outgoing.temperature-values.connector=smallrye-kafka\n"
"mp.messaging.outgoing.temperature-values.key.serializer=org.apache.kafka."
"common.serialization.IntegerSerializer\n"
"mp.messaging.outgoing.temperature-values.value.serializer=org.apache.kafka."
"common.serialization.StringSerializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:228
#, no-wrap
msgid ""
"mp.messaging.outgoing.weather-stations.connector=smallrye-kafka\n"
"mp.messaging.outgoing.weather-stations.key.serializer=org.apache.kafka."
"common.serialization.IntegerSerializer\n"
"mp.messaging.outgoing.weather-stations.value.serializer=org.apache.kafka."
"common.serialization.StringSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:232
#, fuzzy
msgid ""
"This configures the Kafka bootstrap server, the two topics and the "
"corresponding (de-)serializers.  More details about the different "
"configuration options are available on the https://kafka.apache.org/"
"documentation/#producerconfigs[Producer configuration] and https://kafka."
"apache.org/documentation/#consumerconfigs[Consumer configuration] section "
"from the Kafka documentation."
msgstr ""
"これは、Kafka ブートストラップサーバ、2 つのトピック、および対応する "
"(脱)シリアライザを設定します。さまざまな設定オプションの詳細については、Kafka ドキュメントの link:https://kafka.apache."
"org/documentation/#producerconfigs[Producer 設定]と link:https://kafka.apache."
"org/documentation/#consumerconfigs[Consumer 設定]のセクションを参照してください。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:233
#, no-wrap, fuzzy
msgid "Creating the Aggregator Maven Project"
msgstr "アグリゲータMavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:238
#, fuzzy
msgid ""
"With the producer application in place, it's time to implement the actual "
"aggregator application, which will run the Kafka Streams pipeline.  Create "
"another project like so:"
msgstr ""
"プロデューサアプリケーションを用意したら、Kafka Streams "
"パイプラインを実行するアグリゲータアプリケーションを実装しましょう。このように別のプロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:247
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-streams-quickstart-aggregator \\\n"
"    -Dextensions=\"kafka-streams,resteasy-jackson\" \\\n"
"    -DnoExamples \\\n"
"    && mv kafka-streams-quickstart-aggregator aggregator\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:250
#, fuzzy
msgid ""
"This creates the `aggregator` project with the Quarkus extension for Kafka "
"Streams and with RESTEasy support for Jackson."
msgstr ""
"これにより、Kafka Streams用のQuarkus拡張機能とJackson用のRESTEasyサポートを備えた `aggregator` "
"プロジェクトが作成されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:253
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `kafka-"
"streams` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `kafka-"
"streams` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:257
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"kafka-streams\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:267
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-kafka-streams</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:269
#, no-wrap, fuzzy
msgid "The Pipeline Implementation"
msgstr "パイプラインの実装"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:273
#, fuzzy
msgid ""
"Let's begin the implementation of the stream processing application by "
"creating a few value objects for representing temperature measurements, "
"weather stations and for keeping track of aggregated values."
msgstr ""
"ストリーム処理アプリケーションの実装を開始しましょう。温度測定、気象観測所を表現し、集約された値を追跡するためのいくつかの値オブジェクトを作成することから始めましょう。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:276
#, fuzzy
msgid ""
"First, create the file `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/model/WeatherStation.java`, representing a weather station, with "
"the following content:"
msgstr ""
"まず、次の内容で、ファイル `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/WeatherStation.java` を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:280
#: upstream/_guides/kafka-streams.adoc:298
#: upstream/_guides/kafka-streams.adoc:324
#: upstream/_guides/kafka-streams.adoc:682
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.model;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:285
#, no-wrap
msgid "@RegisterForReflection // <1>\n"
"public class WeatherStation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:289
#, no-wrap
msgid "    public int id;\n"
"    public String name;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:291
#, fuzzy
msgid ""
"By adding the `@RegisterForReflection` annotation, it is ensured that this "
"type can be instantiated reflectively when running the application in native "
"mode."
msgstr ""
"`@RegisterForReflection` "
"アノテーションを追加することで、ネイティブモードでアプリケーションを実行しているときに、この型が反射的にインスタンス化されることが保証されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:294
#, fuzzy
msgid ""
"Then the file `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/TemperatureMeasurement.java`, representing temperature measurements "
"for a given station:"
msgstr ""
"次に、指定されたステーションの温度測定値を表すファイル `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/model/TemperatureMeasurement.java` 。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:300
#: upstream/_guides/kafka-streams.adoc:367
#, no-wrap
msgid "import java.time.Instant;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:302
#, no-wrap
msgid "public class TemperatureMeasurement {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:307
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public Instant timestamp;\n"
"    public double value;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:316
#, no-wrap
msgid ""
"    public TemperatureMeasurement(int stationId, String stationName, Instant "
"timestamp,\n"
"            double value) {\n"
"        this.stationId = stationId;\n"
"        this.stationName = stationName;\n"
"        this.timestamp = timestamp;\n"
"        this.value = value;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:320
#, fuzzy
msgid ""
"And finally `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/Aggregation.java`, which will be used to keep track of the aggregated "
"values while the events are processed in the streaming pipeline:"
msgstr ""
"そして最後に `aggregator/src/main/java/org/acme/kafka/streams/aggregator/model/"
"Aggregation.java` 、イベントがストリーミング・パイプラインで処理されている間、集約された値を追跡するために使用されます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:327
#, no-wrap
msgid "import java.math.BigDecimal;\n"
"import java.math.RoundingMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:332
#, no-wrap
msgid "@RegisterForReflection\n"
"public class Aggregation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:340
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public double min = Double.MAX_VALUE;\n"
"    public double max = Double.MIN_VALUE;\n"
"    public int count;\n"
"    public double sum;\n"
"    public double avg;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:344
#, no-wrap
msgid ""
"    public Aggregation updateFrom(TemperatureMeasurement measurement) {\n"
"        stationId = measurement.stationId;\n"
"        stationName = measurement.stationName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:349
#, no-wrap
msgid ""
"        count++;\n"
"        sum += measurement.value;\n"
"        avg = BigDecimal.valueOf(sum / count)\n"
"                .setScale(1, RoundingMode.HALF_UP).doubleValue();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:352
#, no-wrap
msgid ""
"        min = Math.min(min, measurement.value);\n"
"        max = Math.max(max, measurement.value);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:356
#, no-wrap
msgid "        return this;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:361
#, fuzzy
msgid ""
"Next, let's create the actual streaming query implementation itself in the "
"`aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/"
"TopologyProducer.java` file.  All we need to do for that is to declare a CDI "
"producer method which returns the Kafka Streams `Topology`; the Quarkus "
"extension will take care of configuring, starting and stopping the actual "
"Kafka Streams engine."
msgstr ""
"次に、実際のストリーミングクエリの実装自体を `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/streams/TopologyProducer.java` ファイルで作成してみましょう。そのために必要なのは、Kafka "
"Streams `Topology` を返す CDI プロデューサメソッドを宣言することだけです。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:365
#: upstream/_guides/kafka-streams.adoc:598
#: upstream/_guides/kafka-streams.adoc:645
#: upstream/_guides/kafka-streams.adoc:869
#: upstream/_guides/kafka-streams.adoc:923
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.streams;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:370
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.inject.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:383
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.model.Aggregation;\n"
"import org.acme.kafka.streams.aggregator.model.TemperatureMeasurement;\n"
"import org.acme.kafka.streams.aggregator.model.WeatherStation;\n"
"import org.apache.kafka.common.serialization.Serdes;\n"
"import org.apache.kafka.streams.StreamsBuilder;\n"
"import org.apache.kafka.streams.Topology;\n"
"import org.apache.kafka.streams.kstream.Consumed;\n"
"import org.apache.kafka.streams.kstream.GlobalKTable;\n"
"import org.apache.kafka.streams.kstream.Materialized;\n"
"import org.apache.kafka.streams.kstream.Produced;\n"
"import org.apache.kafka.streams.state.KeyValueBytesStoreSupplier;\n"
"import org.apache.kafka.streams.state.Stores;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:385
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperSerde;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:388
#, no-wrap
msgid "@ApplicationScoped\n"
"public class TopologyProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:390
#, no-wrap
msgid ""
"    static final String WEATHER_STATIONS_STORE = \"weather-stations-"
"store\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:394
#, no-wrap
msgid ""
"    private static final String WEATHER_STATIONS_TOPIC = \"weather-"
"stations\";\n"
"    private static final String TEMPERATURE_VALUES_TOPIC = \"temperature-"
"values\";\n"
"    private static final String TEMPERATURES_AGGREGATED_TOPIC = "
"\"temperatures-aggregated\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:398
#, no-wrap
msgid ""
"    @Produces\n"
"    public Topology buildTopology() {\n"
"        StreamsBuilder builder = new StreamsBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:402
#, no-wrap
msgid ""
"        ObjectMapperSerde<WeatherStation> weatherStationSerde = new "
"ObjectMapperSerde<>(\n"
"                WeatherStation.class);\n"
"        ObjectMapperSerde<Aggregation> aggregationSerde = new "
"ObjectMapperSerde<>(Aggregation.class);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:405
#, no-wrap
msgid ""
"        KeyValueBytesStoreSupplier storeSupplier = Stores."
"persistentKeyValueStore(\n"
"                WEATHER_STATIONS_STORE);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:409
#, no-wrap
msgid ""
"        GlobalKTable<Integer, WeatherStation> stations = builder."
"globalTable( // <1>\n"
"                WEATHER_STATIONS_TOPIC,\n"
"                Consumed.with(Serdes.Integer(), weatherStationSerde));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:436
#, no-wrap
msgid ""
"        builder.stream(                                                      "
" // <2>\n"
"                        TEMPERATURE_VALUES_TOPIC,\n"
"                        Consumed.with(Serdes.Integer(), Serdes.String())\n"
"                )\n"
"                .join(                                                       "
" // <3>\n"
"                        stations,\n"
"                        (stationId, timestampAndValue) -> stationId,\n"
"                        (timestampAndValue, station) -> {\n"
"                            String[] parts = timestampAndValue.split(\";\");\n"
"                            return new TemperatureMeasurement(station.id, "
"station.name,\n"
"                                    Instant.parse(parts[0]), Double."
"valueOf(parts[1]));\n"
"                        }\n"
"                )\n"
"                .groupByKey()                                                "
" // <4>\n"
"                .aggregate(                                                  "
" // <5>\n"
"                        Aggregation::new,\n"
"                        (stationId, value, aggregation) -> aggregation."
"updateFrom(value),\n"
"                        Materialized.<Integer, Aggregation> "
"as(storeSupplier)\n"
"                            .withKeySerde(Serdes.Integer())\n"
"                            .withValueSerde(aggregationSerde)\n"
"                )\n"
"                .toStream()\n"
"                .to(                                                         "
" // <6>\n"
"                        TEMPERATURES_AGGREGATED_TOPIC,\n"
"                        Produced.with(Serdes.Integer(), aggregationSerde)\n"
"                );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:440
#, no-wrap
msgid "        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:442
#, fuzzy
msgid ""
"The `weather-stations` table is read into a `GlobalKTable`, representing the "
"current state of each weather station"
msgstr "`weather-stations` テーブルは、各気象台の現在の状態を表す `GlobalKTable` に読み込まれます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:443
#, fuzzy
msgid ""
"The `temperature-values` topic is read into a `KStream`; whenever a new "
"message arrives to this topic, the pipeline will be processed for this "
"measurement"
msgstr ""
"`temperature-values` トピックは `KStream` "
"に読み込まれます。このトピックに新しいメッセージが到着するたびに、パイプラインはこの測定のために処理されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:444
#, fuzzy
msgid ""
"The message from the `temperature-values` topic is joined with the "
"corresponding weather station, using the topic's key (weather station id); "
"the join result contains the data from the measurement and associated "
"weather station message"
msgstr ""
"`temperature-values` トピックからのメッセージは、トピックのキー (ウェザーステーション ID) "
"を使用して、対応するウェザーステーションと結合されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:445
#, fuzzy
msgid "The values are grouped by message key (the weather station id)"
msgstr "値はメッセージキー（ウェザーステーションID）によってグループ化されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:446
#, fuzzy
msgid ""
"Within each group, all the measurements of that station are aggregated, by "
"keeping track of minimum and maximum values and calculating the average "
"value of all measurements of that station (see the `Aggregation` type)"
msgstr ""
"各グループ内では、最小値と最大値を追跡し、そのステーションのすべての測定値の平均値を計算することで、そのステーションのすべての測定値が集約されます（ "
"`Aggregation` タイプを参照）。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:447
#, fuzzy
msgid ""
"The results of the pipeline are written out to the `temperatures-aggregated` "
"topic"
msgstr "パイプラインの結果は `temperatures-aggregated` トピックに書き出しています。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:450
#, fuzzy
msgid ""
"The Kafka Streams extension is configured via the Quarkus configuration file "
"`application.properties`.  Create the file `aggregator/src/main/resources/"
"application.properties` with the following contents:"
msgstr ""
"Kafka Streamsの拡張子は、Quarkusの設定ファイル `application.properties` で設定します。ファイル "
"`aggregator/src/main/resources/application.properties` を以下の内容で作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:456
#, no-wrap
msgid ""
"quarkus.kafka-streams.bootstrap-servers=localhost:9092\n"
"quarkus.kafka-streams.application-server=${hostname}:8080\n"
"quarkus.kafka-streams.topics=weather-stations,temperature-values\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:463
#, no-wrap
msgid ""
"# pass-through options\n"
"kafka-streams.cache.max.bytes.buffering=10240\n"
"kafka-streams.commit.interval.ms=1000\n"
"kafka-streams.metadata.max.age.ms=500\n"
"kafka-streams.auto.offset.reset=earliest\n"
"kafka-streams.metrics.recording.level=DEBUG\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:470
#, fuzzy
msgid ""
"The options with the `quarkus.kafka-streams` prefix can be changed "
"dynamically at application startup, e.g. via environment variables or system "
"properties.  `bootstrap-servers` and `application-server` are mapped to the "
"Kafka Streams properties `bootstrap.servers` and `application.server`, "
"respectively.  `topics` is specific to Quarkus: the application will wait "
"for all the given topics to exist before launching the Kafka Streams engine. "
" This is to done to gracefully await the creation of topics that don't yet "
"exist at application startup time."
msgstr ""
"`quarkus.kafka-streams` `bootstrap-servers` と は、それぞれ Kafka Streams プロパティ と "
"にマップされます。 は Quarkus に固有のもので、アプリケーションは Kafka Streams "
"エンジンを起動する前に、指定したすべてのトピックが存在するのを待ちます。これは、アプリケーションの起動時にまだ存在しないトピックの作成を優雅に待つために行われます。 "
"`application-server` `bootstrap.servers` `application.server` `topics`"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:473
#, fuzzy
msgid ""
"All the properties within the `kafka-streams` namespace are passed through "
"as-is to the Kafka Streams engine.  Changing their values requires a rebuild "
"of the application."
msgstr ""
"`kafka-streams` ネームスペース内のすべてのプロパティは、そのまま Kafka Streams "
"エンジンに渡されます。プロパティの値を変更するには、アプリケーションの再構築が必要です。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:474
#, no-wrap, fuzzy
msgid "Building and Running the Applications"
msgstr "アプリケーションの構築と実行"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:477
#, fuzzy
msgid "We now can build the `producer` and `aggregator` applications:"
msgstr "`producer` と `aggregator` のアプリケーションを構築できるようになりました。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:482
#, no-wrap
msgid ""
"./mvnw clean package -f producer/pom.xml\n"
"./mvnw clean package -f aggregator/pom.xml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:487
#, fuzzy
msgid ""
"Instead of running them directly on the host machine using the Quarkus dev "
"mode, we're going to package them into container images and launch them via "
"Docker Compose.  This is done in order to demonstrate scaling the "
"`aggregator` aggregation to multiple nodes later on."
msgstr ""
"Quarkusのdevモードを使ってホストマシン上で直接実行するのではなく、コンテナイメージにパッケージ化してDocker "
"Compose経由で起動します。これは、後で `aggregator` のアグリゲーションを複数のノードにスケーリングすることを実証するために行います。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:490
#, fuzzy
msgid ""
"The `Dockerfile` created by Quarkus by default needs one adjustment for the "
"`aggregator` application in order to run the Kafka Streams pipeline.  To do "
"so, edit the file `aggregator/src/main/docker/Dockerfile.jvm` and replace "
"the line `FROM fabric8/java-alpine-openjdk8-jre` with `FROM fabric8/java-"
"centos-openjdk8-jdk`."
msgstr ""
"Quarkusがデフォルトで作成した `Dockerfile` は、Kafka Streamsパイプラインを実行するために、 `aggregator` "
"アプリケーションに1つの調整が必要です。そのためには、 `aggregator/src/main/docker/Dockerfile.jvm` "
"ファイルを編集して、 `FROM fabric8/java-alpine-openjdk8-jre` の行を `FROM fabric8/java-"
"centos-openjdk8-jdk` に置き換えます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:492
#, fuzzy
msgid ""
"Next create a Docker Compose file (`docker-compose.yaml`) for spinning up "
"the two applications as well as Apache Kafka and ZooKeeper like so:"
msgstr ""
"次に、2 つのアプリケーションを回転させるための Docker Compose ファイル ( `docker-compose.yaml`) "
"を作成し、Apache Kafka、ZooKeeper と同様に以下のようにします。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:496
#, no-wrap
msgid "version: '3.5'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:528
#, no-wrap
msgid ""
"services:\n"
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
"    networks:\n"
"      - kafkastreams-network\n"
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override "
"listeners=$${KAFKA_LISTENERS} --override advertised.listeners="
"$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect="
"$${KAFKA_ZOOKEEPER_CONNECT} --override num.partitions="
"$${KAFKA_NUM_PARTITIONS}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
"      KAFKA_NUM_PARTITIONS: 3\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:538
#, no-wrap
msgid ""
"  producer:\n"
"    image: quarkus-quickstarts/kafka-streams-producer:1.0\n"
"    build:\n"
"      context: producer\n"
"      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}\n"
"    environment:\n"
"      KAFKA_BOOTSTRAP_SERVERS: kafka:9092\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:548
#, no-wrap
msgid ""
"  aggregator:\n"
"    image: quarkus-quickstarts/kafka-streams-aggregator:1.0\n"
"    build:\n"
"      context: aggregator\n"
"      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}\n"
"    environment:\n"
"      QUARKUS_KAFKA_STREAMS_BOOTSTRAP_SERVERS: kafka:9092\n"
"    networks:\n"
"      - kafkastreams-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:552
#, no-wrap
msgid "networks:\n"
"  kafkastreams-network:\n"
"    name: ks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:556
#, fuzzy
msgid ""
"To launch all the containers, building the `producer` and `aggregator` "
"container images, run `docker-compose up --build`."
msgstr ""
"`producer` と `aggregator` のコンテナイメージを構築して、すべてのコンテナを起動するには、 `docker-compose up "
"--build` を実行します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:558
#, fuzzy
msgid ""
"You should see log statements from the `producer` application about messages "
"being sent to the \"temperature-values\" topic."
msgstr ""
"`producer` アプリケーションから、\"temperature-values\" "
"トピックに送信されたメッセージに関するログステートメントが表示されるはずです。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:561
#, fuzzy
msgid ""
"Now run an instance of the _debezium/tooling_ image, attaching to the same "
"network all the other containers run in.  This image provides several useful "
"tools such as _kafkacat_ and _httpie_:"
msgstr ""
"ここで _debezium/"
"tooling_イメージのインスタンスを実行し、他のすべてのコンテナが実行しているのと同じネットワークにアタッチします。このイメージは、 "
"_kafkacat_や _httpie_ などの便利なツールを提供しています。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:565
#, no-wrap
msgid "docker run --tty --rm -i --network ks debezium/tooling:1.1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:568
#, fuzzy
msgid ""
"Within the tooling container, run _kafkacat_ to examine the results of the "
"streaming pipeline:"
msgstr "ツールコンテナ内で、 _kafkacatを_実行して、ストリーミングパイプラインの結果を調べます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:572
#, no-wrap
msgid "kafkacat -b kafka:9092 -C -o beginning -q -t temperatures-aggregated\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:577
#, no-wrap
msgid ""
"{\"avg\":34.7,\"count\":4,\"max\":49.4,\"min\":16.8,\"stationId\":"
"9,\"stationName\":\"Marrakesh\",\"sum\":138.8}\n"
"{\"avg\":15.7,\"count\":1,\"max\":15.7,\"min\":15.7,\"stationId\":"
"2,\"stationName\":\"Snowdonia\",\"sum\":15.7}\n"
"{\"avg\":12.8,\"count\":7,\"max\":25.5,\"min\":-13.8,\"stationId\":"
"7,\"stationName\":\"Porthsmouth\",\"sum\":89.7}\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:581
#, fuzzy
msgid ""
"You should see new values arrive as the producer continues to emit "
"temperature measurements, each value on the outbound topic showing the "
"minimum, maximum and average temperature values of the represented weather "
"station."
msgstr ""
"プロデューサが温度測定値を出力し続けると、新しい値が表示され、送信トピックの各値は、表現された気象観測所の最小、最大、および平均温度値を表示します。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:582
#, no-wrap, fuzzy
msgid "Interactive Queries"
msgstr "インタラクティブクエリ"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:590
#, fuzzy
msgid ""
"Subscribing to the `temperatures-aggregated` topic is a great way to react "
"to any new temperature values.  It's a bit wasteful though if you're just "
"interested in the latest aggregated value for a given weather station.  This "
"is where Kafka Streams interactive queries shine: they let you directly "
"query the underlying state store of the pipeline for the value associated to "
"a given key.  By exposing a simple REST endpoint which queries the state "
"store, the latest aggregation result can be retrieved without having to "
"subscribe to any Kafka topic."
msgstr ""
"`temperatures-aggregated` "
"のトピックを購読することは、新しい気温の値に反応するための素晴らしい方法です。しかし、特定の気象観測所の最新の集計値だけに興味がある場合には、少しもったいないです。そこで、Kafka "
"Streams の対話型クエリが威力を発揮します。ステートストアをクエリするシンプルな REST エンドポイントを公開することで、Kafka "
"トピックを購読しなくても最新の集計結果を取得することができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:592
#, fuzzy
msgid ""
"Let's begin by creating a new class `InteractiveQueries` in the file "
"`aggregator/src/main/java/org/acme/kafka/streams/aggregator/streams/"
"InteractiveQueries.java`:"
msgstr ""
"`InteractiveQueries` まず、ファイル `aggregator/src/main/java/org/acme/kafka/"
"streams/aggregator/streams/InteractiveQueries.java`."

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:594
#, fuzzy
msgid ""
"one more method to the `KafkaStreamsPipeline` class which obtains the "
"current state for a given key:"
msgstr "`KafkaStreamsPipeline` クラスに、与えられたキーの現在の状態を取得するメソッドをもう一つ追加しました。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:608
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.model.Aggregation;\n"
"import org.acme.kafka.streams.aggregator.model.WeatherStationData;\n"
"import org.apache.kafka.streams.KafkaStreams;\n"
"import org.apache.kafka.streams.errors.InvalidStateStoreException;\n"
"import org.apache.kafka.streams.state.QueryableStoreTypes;\n"
"import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:611
#, no-wrap
msgid "@ApplicationScoped\n"
"public class InteractiveQueries {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:614
#, no-wrap
msgid "    @Inject\n"
"    KafkaStreams streams;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:617
#, no-wrap
msgid ""
"    public GetWeatherStationDataResult getWeatherStationData(int id) {\n"
"        Aggregation result = getWeatherStationStore().get(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:625
#, no-wrap
msgid ""
"        if (result != null) {\n"
"            return GetWeatherStationDataResult.found(WeatherStationData."
"from(result)); // <1>\n"
"        }\n"
"        else {\n"
"            return GetWeatherStationDataResult.notFound();                   "
"          // <2>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:636
#, no-wrap
msgid ""
"    private ReadOnlyKeyValueStore<Integer, Aggregation> "
"getWeatherStationStore() {\n"
"        while (true) {\n"
"            try {\n"
"                return streams.store(TopologyProducer."
"WEATHER_STATIONS_STORE, QueryableStoreTypes.keyValueStore());\n"
"            } catch (InvalidStateStoreException e) {\n"
"                // ignore, store not ready yet\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:638
#, fuzzy
msgid ""
"A value for the given station id was found, so that value will be returned"
msgstr "指定された駅IDの値が見つかったので、その値が返されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:639
#, fuzzy
msgid ""
"No value was found, either because a non-existing station was queried or no "
"measurement exists yet for the given station"
msgstr "存在しないステーションがクエリされたか、指定されたステーションに測定がまだ存在しないため、値が見つかりませんでした。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:641
#, fuzzy
msgid ""
"Also create the method's return type in the file `aggregator/src/main/java/"
"org/acme/kafka/streams/aggregator/streams/GetWeatherStationDataResult.java`:"
msgstr ""
"また、メソッドの戻り値の型もファイル `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/streams/GetWeatherStationDataResult.java`."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:648
#: upstream/_guides/kafka-streams.adoc:872
#, no-wrap
msgid "import java.util.Optional;\n"
"import java.util.OptionalInt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:650
#: upstream/_guides/kafka-streams.adoc:874
#, no-wrap
msgid "import org.acme.kafka.streams.aggregator.model.WeatherStationData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:652
#: upstream/_guides/kafka-streams.adoc:876
#, no-wrap
msgid "public class GetWeatherStationDataResult {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:655
#, no-wrap
msgid ""
"    private static GetWeatherStationDataResult NOT_FOUND =\n"
"            new GetWeatherStationDataResult(null);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:657
#, no-wrap
msgid "    private final WeatherStationData result;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:661
#, no-wrap
msgid ""
"    private GetWeatherStationDataResult(WeatherStationData result) {\n"
"        this.result = result;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:665
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult found(WeatherStationData data) "
"{\n"
"        return new GetWeatherStationDataResult(data);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:669
#: upstream/_guides/kafka-streams.adoc:902
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult notFound() {\n"
"        return NOT_FOUND;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:674
#, no-wrap
msgid ""
"    public Optional<WeatherStationData> getResult() {\n"
"        return Optional.ofNullable(result);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:678
#, fuzzy
msgid ""
"Also create `aggregator/src/main/java/org/acme/kafka/streams/aggregator/"
"model/WeatherStationData.java`, which represents the actual aggregation "
"result for a weather station:"
msgstr ""
"また、気象台の実際の集計結果を表す `aggregator/src/main/java/org/acme/kafka/streams/"
"aggregator/model/WeatherStationData.java` を作成します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:687
#, no-wrap
msgid "@RegisterForReflection\n"
"public class WeatherStationData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:694
#, no-wrap
msgid ""
"    public int stationId;\n"
"    public String stationName;\n"
"    public double min = Double.MAX_VALUE;\n"
"    public double max = Double.MIN_VALUE;\n"
"    public int count;\n"
"    public double avg;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:704
#, no-wrap
msgid ""
"    private WeatherStationData(int stationId, String stationName, double "
"min, double max,\n"
"            int count, double avg) {\n"
"        this.stationId = stationId;\n"
"        this.stationName = stationName;\n"
"        this.min = min;\n"
"        this.max = max;\n"
"        this.count = count;\n"
"        this.avg = avg;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:715
#, no-wrap
msgid ""
"    public static WeatherStationData from(Aggregation aggregation) {\n"
"        return new WeatherStationData(\n"
"                aggregation.stationId,\n"
"                aggregation.stationName,\n"
"                aggregation.min,\n"
"                aggregation.max,\n"
"                aggregation.count,\n"
"                aggregation.avg);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:719
#, fuzzy
msgid ""
"We now can add a simple REST endpoint (`aggregator/src/main/java/org/acme/"
"kafka/streams/aggregator/rest/WeatherStationEndpoint.java`), which invokes "
"`getWeatherStationData()` and returns the data to the client:"
msgstr ""
"これで、 `getWeatherStationData()` を呼び出してクライアントにデータを返すシンプルな REST エンドポイント ( "
"`aggregator/src/main/java/org/acme/kafka/streams/aggregator/rest/"
"WeatherStationEndpoint.java`) を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:723
#: upstream/_guides/kafka-streams.adoc:943
#, no-wrap
msgid "package org.acme.kafka.streams.aggregator.rest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:727
#: upstream/_guides/kafka-streams.adoc:947
#, no-wrap
msgid ""
"import java.net.URI;\n"
"import java.net.URISyntaxException;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:736
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:739
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.streams."
"GetWeatherStationDataResult;\n"
"import org.acme.kafka.streams.aggregator.streams.KafkaStreamsPipeline;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:743
#: upstream/_guides/kafka-streams.adoc:966
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Path(\"/weather-stations\")\n"
"public class WeatherStationEndpoint {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:746
#: upstream/_guides/kafka-streams.adoc:969
#, no-wrap
msgid "    @Inject\n"
"    InteractiveQueries interactiveQueries;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:751
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/data/{id}\")\n"
"    public Response getWeatherStationData(@PathParam(\"id\") int id) {\n"
"        GetWeatherStationDataResult result = interactiveQueries."
"getWeatherStationData(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:761
#, no-wrap
msgid ""
"        if (result.getResult().isPresent()) {  // <1>\n"
"            return Response.ok(result.getResult().get()).build();\n"
"        }\n"
"        else {\n"
"            return Response.status(Status.NOT_FOUND.getStatusCode(),\n"
"                    \"No data found for weather station \" + id).build();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:763
#, fuzzy
msgid ""
"Depending on whether a value was obtained, either return that value or a 404 "
"response"
msgstr "値が取得されたかどうかに応じて、その値を返すか、404 レスポンスを返すかのどちらかを選択します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:765
#, fuzzy
msgid ""
"With this code in place, it's time to rebuild the application and the "
"`aggregator` service in Docker Compose:"
msgstr "このコードを用意して、Docker Composeでアプリケーションと `aggregator` サービスを再構築しましょう。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:771
#, no-wrap
msgid ""
"./mvnw clean package -f aggregator/pom.xml\n"
"docker-compose stop aggregator\n"
"docker-compose up --build -d\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:776
#, fuzzy
msgid ""
"This will rebuild the `aggregator` container and restart its service.  Once "
"that's done, you can invoke the service's REST API to obtain the temperature "
"data for one of the existing stations.  To do so, you can use `httpie` in "
"the tooling container launched before:"
msgstr ""
"これにより、 `aggregator` コンテナが再構築され、サービスが再起動されます。これが完了したら、サービスの REST API "
"を呼び出して、既存のステーションの 1 つの温度データを取得することができます。そのためには、前に起動したツーリングコンテナで `httpie` "
"を使用します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:780
#, no-wrap
msgid "http aggregator:8080/weather-stations/data/1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:786
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 85\n"
"Content-Type: application/json\n"
"Date: Tue, 18 Jun 2019 19:29:16 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:795
#, no-wrap
msgid ""
"{\n"
"    \"avg\": 12.9,\n"
"    \"count\": 146,\n"
"    \"max\": 41.0,\n"
"    \"min\": -25.6,\n"
"    \"stationId\": 1,\n"
"    \"stationName\": \"Hamburg\"\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:797
#, no-wrap, fuzzy
msgid "Scaling Out"
msgstr "スケーリングアウト"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:804
#, fuzzy
msgid ""
"A very interesting trait of Kafka Streams applications is that they can be "
"scaled out, i.e. the load and state can be distributed amongst multiple "
"application instances running the same pipeline.  Each node will then "
"contain a subset of the aggregation results, but Kafka Streams provides you "
"with https://kafka.apache.org/22/documentation/streams/developer-guide/"
"interactive-queries.html#querying-remote-state-stores-for-the-entire-app[an "
"API] to obtain the information which node is hosting a given key.  The "
"application can then either fetch the data directly from the other instance, "
"or simply point the client to the location of that other node."
msgstr ""
"つまり、同じパイプラインを実行している複数のアプリケーションインスタンス間で負荷や状態を分散させることができます。各ノードには集約結果のサブセットが含まれますが、Kafka "
"Streams は、与えられたキーをホストしているノードの情報を取得するための link:https://kafka.apache.org/22/"
"documentation/streams/developer-guide/interactive-queries.html#querying-"
"remote-state-stores-for-the-entire-app[API "
"を]提供しています。アプリケーションは、他のインスタンスから直接データを取得するか、クライアントにその他のノードの場所を指定するだけです。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:806
#, fuzzy
msgid ""
"Launching multiple instances of the `aggregator` application will make look "
"the overall architecture like so:"
msgstr "`aggregator` アプリケーションの複数のインスタンスを起動すると、全体のアーキテクチャがこのようになります。"

#. type: Target for macro image
#: upstream/_guides/kafka-streams.adoc:807
#, no-wrap
msgid "kafka-streams-guide-architecture-distributed.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:810
#, fuzzy
msgid ""
"The `InteractiveQueries` class must be adjusted slightly for this "
"distributed architecture:"
msgstr "`InteractiveQueries` クラスは、この分散型アーキテクチャ用に少し調整する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:819
#, no-wrap
msgid ""
"public GetWeatherStationDataResult getWeatherStationData(int id) {\n"
"    StreamsMetadata metadata = streams.metadataForKey(                  // "
"<1>\n"
"            TopologyProducer.WEATHER_STATIONS_STORE,\n"
"            id,\n"
"            Serdes.Integer().serializer()\n"
"    );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:827
#, no-wrap
msgid ""
"    if (metadata == null || metadata == StreamsMetadata.NOT_AVAILABLE) {\n"
"        LOG.warn(\"Found no metadata for key {}\", id);\n"
"        return GetWeatherStationDataResult.notFound();\n"
"    }\n"
"    else if (metadata.host().equals(host)) {                            // "
"<2>\n"
"        LOG.info(\"Found data for key {} locally\", id);\n"
"        Aggregation result = getWeatherStationStore().get(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:845
#, no-wrap
msgid ""
"        if (result != null) {\n"
"            return GetWeatherStationDataResult.found(WeatherStationData."
"from(result));\n"
"        }\n"
"        else {\n"
"            return GetWeatherStationDataResult.notFound();\n"
"        }\n"
"    }\n"
"    else {                                                              // "
"<3>\n"
"        LOG.info(\n"
"            \"Found data for key {} on remote host {}:{}\",\n"
"            id,\n"
"            metadata.host(),\n"
"            metadata.port()\n"
"        );\n"
"        return GetWeatherStationDataResult.foundRemotely(metadata.host(), "
"metadata.port());\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:858
#, no-wrap
msgid ""
"public List<PipelineMetadata> getMetaData() {                           // "
"<4>\n"
"    return streams.allMetadataForStore(TopologyProducer."
"WEATHER_STATIONS_STORE)\n"
"            .stream()\n"
"            .map(m -> new PipelineMetadata(\n"
"                    m.hostInfo().host() + \":\" + m.hostInfo().port(),\n"
"                    m.topicPartitions()\n"
"                        .stream()\n"
"                        .map(TopicPartition::toString)\n"
"                        .collect(Collectors.toSet()))\n"
"            )\n"
"            .collect(Collectors.toList());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:860
#, fuzzy
msgid "The streams metadata for the given weather station id is obtained"
msgstr "与えられた気象観測所IDのストリームメタデータが取得されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:861
#, fuzzy
msgid ""
"The given key (weather station id) is maintained by the local application "
"node, i.e. it can answer the query itself"
msgstr "与えられたキー(測候所ID)はローカルのアプリケーションノードによって管理されています。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:862
#, fuzzy
msgid ""
"The given key is maintained by another application node; in this case the "
"information about that node (host and port) will be returned"
msgstr "与えられたキーは別のアプリケーションノードによって管理されています; この場合、そのノードに関する情報（ホストとポート）が返されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:863
#, fuzzy
msgid ""
"The `getMetaData()` method is added to provide callers with a list of all "
"the nodes in the application cluster."
msgstr "`getMetaData()` メソッドが追加され、アプリケーション・クラスタ内の全ノードのリストを呼び出し元に提供するようになりました。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:865
#, fuzzy
msgid "The `GetWeatherStationDataResult` type must be adjusted accordingly:"
msgstr "`GetWeatherStationDataResult` のタイプは、それに合わせて調整する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:879
#, no-wrap
msgid ""
"    private static GetWeatherStationDataResult NOT_FOUND =\n"
"            new GetWeatherStationDataResult(null, null, null);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:883
#, no-wrap
msgid ""
"    private final WeatherStationData result;\n"
"    private final String host;\n"
"    private final Integer port;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:890
#, no-wrap
msgid ""
"    private GetWeatherStationDataResult(WeatherStationData result, String "
"host,\n"
"            Integer port) {\n"
"        this.result = result;\n"
"        this.host = host;\n"
"        this.port = port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:894
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult found(WeatherStationData data) "
"{\n"
"        return new GetWeatherStationDataResult(data, null, null);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:898
#, no-wrap
msgid ""
"    public static GetWeatherStationDataResult foundRemotely(String host, int "
"port) {\n"
"        return new GetWeatherStationDataResult(null, host, port);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:906
#, no-wrap
msgid ""
"    public Optional<WeatherStationData> getResult() {\n"
"        return Optional.ofNullable(result);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:910
#, no-wrap
msgid ""
"    public Optional<String> getHost() {\n"
"        return Optional.ofNullable(host);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:915
#, no-wrap
msgid ""
"    public OptionalInt getPort() {\n"
"        return port != null ? OptionalInt.of(port) : OptionalInt.empty();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:919
#, fuzzy
msgid ""
"Also the return type for `getMetaData()` must be defined (`aggregator/src/"
"main/java/org/acme/kafka/streams/aggregator/streams/PipelineMetadata.java`):"
msgstr ""
"また、 `getMetaData()` のリターンタイプも定義する必要があります ( `aggregator/src/main/java/org/"
"acme/kafka/streams/aggregator/streams/PipelineMetadata.java`)。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:925
#, no-wrap
msgid "import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:927
#, no-wrap
msgid "public class PipelineMetadata {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:930
#, no-wrap
msgid "    public String host;\n"
"    public Set<String> partitions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:936
#, no-wrap
msgid ""
"    public PipelineMetadata(String host, Set<String> partitions) {\n"
"        this.host = host;\n"
"        this.partitions = partitions;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:939
#, fuzzy
msgid "Lastly, the REST endpoint class must be updated:"
msgstr "最後に、RESTエンドポイントクラスを更新する必要があります。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:958
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import javax.ws.rs.core.Response;\n"
"import javax.ws.rs.core.Response.Status;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:962
#, no-wrap
msgid ""
"import org.acme.kafka.streams.aggregator.streams."
"GetWeatherStationDataResult;\n"
"import org.acme.kafka.streams.aggregator.streams.KafkaStreamsPipeline;\n"
"import org.acme.kafka.streams.aggregator.streams.PipelineMetadata;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:976
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/data/{id}\")\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Response getWeatherStationData(@PathParam(\"id\") int id) {\n"
"        GetWeatherStationDataResult result = interactiveQueries."
"getWeatherStationData(id);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:990
#, no-wrap
msgid ""
"        if (result.getResult().isPresent()) {                     // <1>\n"
"            return Response.ok(result.getResult().get()).build();\n"
"        }\n"
"        else if (result.getHost().isPresent()) {                  // <2>\n"
"            URI otherUri = getOtherUri(result.getHost().get(), result."
"getPort().getAsInt(),\n"
"                    id);\n"
"            return Response.seeOther(otherUri).build();\n"
"        }\n"
"        else {                                                    // <3>\n"
"            return Response.status(Status.NOT_FOUND.getStatusCode(),\n"
"                    \"No data found for weather station \" + id).build();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:997
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/meta-data\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<PipelineMetadata> getMetaData() {                 // <4>\n"
"        return interactiveQueries.getMetaData();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1007
#, no-wrap
msgid ""
"    private URI getOtherUri(String host, int port, int id) {\n"
"        try {\n"
"            return new URI(\"http://\" + host + \":\" + port + \"/weather-"
"stations/data/\" + id);\n"
"        }\n"
"        catch (URISyntaxException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1009
#, fuzzy
msgid "The data was found locally, so return it"
msgstr "データはローカルで見つかったので、それを返す"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1010
#, fuzzy
msgid ""
"The data is maintained by another node, so reply with a redirect (HTTP "
"status code 303) if the data for the given key is stored on one of the other "
"nodes."
msgstr ""
"データは他のノードで管理されているので、指定されたキーのデータが他のノードに保存されている場合は、リダイレクト(HTTPステータスコード303)で返信してください。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1011
#, fuzzy
msgid "No data was found for the given weather station id"
msgstr "データが見つかりませんでした。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1012
#, fuzzy
msgid ""
"Exposes information about all the hosts forming the application cluster"
msgstr "アプリケーションクラスタを形成しているすべてのホストの情報を表示します。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1015
#, fuzzy
msgid ""
"Now stop the `aggregator` service again and rebuild it.  Then let's spin up "
"three instances of it:"
msgstr "ここで再び `aggregator` サービスを停止して再構築します。そして、3つのインスタンスをスピンアップしてみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1021
#, no-wrap
msgid ""
"./mvnw clean package -f aggregator/pom.xml\n"
"docker-compose stop aggregator\n"
"docker-compose up --build -d --scale aggregator=3\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1026
#, fuzzy
msgid ""
"When invoking the REST API on any of the three instances, it might either be "
"that the aggregation for the requested weather station id is stored locally "
"on the node receiving the query, or it could be stored on one of the other "
"two nodes."
msgstr ""
"3つのインスタンスのいずれかでREST "
"APIを呼び出す場合、要求されたウェザーステーションIDの集約は、クエリを受信したノードにローカルに格納されるか、他の2つのノードのいずれかに格納されるかのどちらかであるかもしれません。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1030
#, fuzzy
msgid ""
"As the load balancer of Docker Compose will distribute requests to the "
"`aggregator` service in a round-robin fashion, we'll invoke the actual nodes "
"directly.  The application exposes information about all the host names via "
"REST:"
msgstr ""
"Docker Composeのロードバランサーがラウンドロビン方式で `aggregator` "
"サービスにリクエストを配信するので、実際のノードを直接呼び出すことにします。アプリケーションはREST経由ですべてのホスト名の情報を公開しています。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1034
#, no-wrap
msgid "http aggregator:8080/weather-stations/meta-data\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1040
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 202\n"
"Content-Type: application/json\n"
"Date: Tue, 18 Jun 2019 20:00:23 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1061
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        \"host\": \"2af13fe516a9:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-2\"\n"
"        ]\n"
"    },\n"
"    {\n"
"        \"host\": \"32cc8309611b:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-1\"\n"
"        ]\n"
"    },\n"
"    {\n"
"        \"host\": \"1eb39af8d587:8080\",\n"
"        \"partitions\": [\n"
"            \"temperature-values-0\"\n"
"        ]\n"
"    }\n"
"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1065
#, fuzzy
msgid ""
"Retrieve the data from one of the three hosts shown in the response (your "
"actual host names will differ):"
msgstr "レスポンスに表示されている 3 つのホストのうちの 1 つからデータを取得します (実際のホスト名は異なります)。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1069
#, no-wrap
msgid "http 2af13fe516a9:8080/weather-stations/data/1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1072
#, fuzzy
msgid ""
"If that node holds the data for key \"1\", you'll get a response like this:"
msgstr "そのノードがキー「1」のデータを保持している場合は、このようなレスポンスが得られます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1080
#, no-wrap
msgid ""
"HTTP/1.1 200 OK\n"
"Connection: keep-alive\n"
"Content-Length: 74\n"
"Content-Type: application/json\n"
"Date: Tue, 11 Jun 2019 19:16:31 GMT\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1089
#, no-wrap
msgid ""
"{\n"
"  \"avg\": 11.9,\n"
"  \"count\": 259,\n"
"  \"max\": 50.0,\n"
"  \"min\": -30.1,\n"
"  \"stationId\": 1,\n"
"  \"stationName\": \"Hamburg\"\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1092
#, fuzzy
msgid "Otherwise, the service will send a redirect:"
msgstr "そうでない場合、サービスはリダイレクトを送信します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1100
#, no-wrap
msgid ""
"HTTP/1.1 303 See Other\n"
"Connection: keep-alive\n"
"Content-Length: 0\n"
"Date: Tue, 18 Jun 2019 20:01:03 GMT\n"
"Location: http://1eb39af8d587:8080/weather-stations/data/1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1103
#, fuzzy
msgid ""
"You can also have _httpie_ automatically follow the redirect by passing the "
"`--follow option`:"
msgstr "また、 `--follow option` を渡すことで _httpie が_自動的にリダイレクトに従うようにすることもできます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1107
#, no-wrap
msgid "http --follow 2af13fe516a9:8080/weather-stations/data/1\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1109
#, no-wrap, fuzzy
msgid "Running Natively"
msgstr "ネイティブランニング"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1113
#, fuzzy
msgid ""
"The Quarkus extension for Kafka Streams enables the execution of stream "
"processing applications natively via GraalVM without further configuration."
msgstr ""
"Kafka "
"Streams用のQuarkus拡張機能を使用すると、GraalVMを介してストリーム処理アプリケーションをネイティブに実行することができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1116
#, fuzzy
msgid ""
"To run both the `producer` and `aggregator` applications in native mode, the "
"Maven builds can be executed using the `native` profile:"
msgstr ""
"`producer` と `aggregator` アプリケーションをネイティブモードで実行するには、 `native` プロファイルを使用して "
"Maven ビルドを実行できます。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1121
#, no-wrap
msgid ""
"./mvnw clean package -f producer/pom.xml -Pnative -Dnative-image.container-"
"runtime=docker\n"
"./mvnw clean package -f aggregator/pom.xml -Pnative -Dnative-image.container-"
"runtime=docker\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1124
#, fuzzy
msgid ""
"Now create an environment variable named `QUARKUS_MODE` and with value set "
"to \"native\":"
msgstr "ここで、 `QUARKUS_MODE` という名前の環境変数を作成し、値を\"native\"に設定します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1128
#, no-wrap
msgid "export QUARKUS_MODE=native\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1133
#, fuzzy
msgid ""
"This is used by the Docker Compose file to use the correct `Dockerfile` when "
"building the `producer` and `aggregator` images.  The Kafka Streams "
"application can work with less than 50 MB RSS in native mode.  To do so, add "
"the `Xmx` option to the program invocation in `aggregator/src/main/docker/"
"Dockerfile.native`:"
msgstr ""
"これは、 `producer` と `aggregator` 画像をビルドする際に正しい `Dockerfile` を使用するために Docker "
"Compose ファイルで使用されます。Kafka Streams アプリケーションは、ネイティブモードでは 50 MB 未満の RSS "
"で動作します。そのためには、 `aggregator/src/main/docker/Dockerfile.native` のプログラム呼び出しに "
"`Xmx` オプションを追加します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1137
#, no-wrap
msgid "CMD [\"./application\", \"-Dquarkus.http.host=0.0.0.0\", \"-Xmx32m\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1141
#, fuzzy
msgid ""
"Now start Docker Compose as described above (don't forget to rebuild the "
"container images)."
msgstr "ここで、上記のようにDocker Composeを起動します（コンテナイメージの再構築を忘れずに）。"

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1142
#, no-wrap, fuzzy
msgid "Kafka Streams Health Checks"
msgstr "カフカストリームの健康診断"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1145
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka-"
"streams` will automatically add:"
msgstr ""
"`quarkus-smallrye-health` の拡張子を使用している場合は、 `quarkus-kafka-streams` "
"が自動的に追加されます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1147
#, fuzzy
msgid ""
"a readiness health check to validate that all topics declared in the "
"`quarkus.kafka-streams.topics` property are created,"
msgstr ""
"`quarkus.kafka-streams.topics` "
"プロパティで宣言されたすべてのトピックが作成されているかどうかを検証するために、準備の健全性チェックを行います。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1148
#, fuzzy
msgid "a liveness health check based on the Kafka Streams state."
msgstr "カフカストリームの状態をもとにした活力健康診断。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1150
#, fuzzy
msgid ""
"So when you access the `/health` endpoint of your application you will have "
"information about the state of the Kafka Streams and the available and/or "
"missing topics."
msgstr ""
"そのため、アプリケーションの `/health` エンドポイントにアクセスすると、Kafka "
"ストリームの状態や、利用可能なトピックや不足しているトピックについての情報を得ることができます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1152
#, fuzzy
msgid "This is an example of when the status is `DOWN`:"
msgstr "これは、ステータスが `DOWN`."

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1155
#, no-wrap
msgid "curl -i http://aggregator:8080/health\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1159
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 454\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1180
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams state health check\",  <1>\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"state\": \"CREATED\"\n"
"            }\n"
"        },\n"
"        {\n"
"            \"name\": \"Kafka Streams topics health check\",  <2>\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"available_topics\": \"weather-stations,temperature-"
"values\",\n"
"                \"missing_topics\": \"hygrometry-values\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1182
#, fuzzy
msgid "Liveness health check. Also available at `/health/live` endpoint."
msgstr "活力のある健康チェック。 `/health/live` エンドポイントでもご利用いただけます。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1183
#, fuzzy
msgid "Readiness health check. Also available at `/health/ready` endpoint."
msgstr "準備状態の健康チェック。 `/health/ready` エンドポイントでも利用可能。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1185
#, fuzzy
msgid ""
"So as you can see, the status is `DOWN` as soon as one of the `quarkus.kafka-"
"streams.topics` is missing or the Kafka Streams `state` is not `RUNNING`."
msgstr ""
"だから、ご覧のように、 `quarkus.kafka-streams.topics` のいずれかが欠けているか、カフカストリーム `state` が "
"`RUNNING` でないとすぐにステータスが `DOWN` になります。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1188
#, fuzzy
msgid ""
"If no topics are available, the `available_topics` key will not be present "
"in the `data` field of the `Kafka Streams topics health check`.  As well as "
"if no topics are missing, the `missing_topics` key will not be present in "
"the `data` field of the `Kafka Streams topics health check`."
msgstr ""
"トピックがない場合、 `Kafka Streams topics health check`.の `data` フィールドに "
"`available_topics` キーは表示されません。また、トピックがない場合は、 `Kafka Streams topics health "
"check` の `data` フィールドに `missing_topics` キーは表示されません。"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1190
#, fuzzy
msgid ""
"You can of course disable the health check of the `quarkus-kafka-streams` "
"extension by setting the `quarkus.kafka-streams.health.enabled` property to "
"`false` in your `application.properties`."
msgstr ""
"`quarkus.kafka-streams.health.enabled` `false` もちろん、 `quarkus-kafka-streams` "
"拡張モジュールのヘルスチェックを無効にするには、 `application.properties`."

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1192
#, fuzzy
msgid ""
"Obviously you can create your liveness and readiness probes based on the "
"respective endpoints `/health/live` and `/health/ready`."
msgstr ""
"もちろん、それぞれのエンドポイント `/health/live` と `/health/ready` "
"に基づいて、活性度と準備状態のプローブを作成することができます。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:1193
#, no-wrap, fuzzy
msgid "Liveness health check"
msgstr "活性度チェック"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1196
#, fuzzy
msgid "Here is an example of the liveness check:"
msgstr "活力チェックの一例をご紹介します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1200
#, no-wrap
msgid "curl -i http://aggregator:8080/health/live\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1204
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 225\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1217
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams state health check\",\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"state\": \"CREATED\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1219
#, fuzzy
msgid "The `state` is coming from the `KafkaStreams.State` enum."
msgstr "`state` は `KafkaStreams.State` enum から来ています。"

#. type: Title ===
#: upstream/_guides/kafka-streams.adoc:1220
#, no-wrap, fuzzy
msgid "Readiness health check"
msgstr "準備状態の健康チェック"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1223
#, fuzzy
msgid "Here is an example of the readiness check:"
msgstr "ここでは、準備態勢チェックの一例をご紹介します。"

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1227
#, no-wrap
msgid "curl -i http://aggregator:8080/health/ready\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1231
#, no-wrap
msgid ""
"HTTP/1.1 503 Service Unavailable\n"
"content-type: application/json; charset=UTF-8\n"
"content-length: 265\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka-streams.adoc:1244
#, no-wrap
msgid ""
"{\n"
"    \"status\": \"DOWN\",\n"
"    \"checks\": [\n"
"        {\n"
"            \"name\": \"Kafka Streams topics health check\",\n"
"            \"status\": \"DOWN\",\n"
"            \"data\": {\n"
"                \"missing_topics\": \"weather-stations,temperature-values\"\n"
"            }\n"
"        }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka-streams.adoc:1246
#, no-wrap, fuzzy
msgid "Going Further"
msgstr "さらなる飛躍を目指して"

#. type: Plain text
#: upstream/_guides/kafka-streams.adoc:1252
#, fuzzy
msgid ""
"This guide has shown how you can build stream processing applications using "
"Quarkus and the Kafka Streams APIs, both in JVM and native modes.  For "
"running your KStreams application in production, you could also add health "
"checks and metrics for the data pipeline.  Refer to the Quarkus guides on "
"link:micrometer[Micrometer], link:microprofile-metrics[MicroProfile "
"Metrics], and link:microprofile-health[health checks] to learn more."
msgstr ""
"このガイドでは、QuarkusとKafka Streams "
"APIを使用して、JVMとネイティブモードの両方でストリーム処理アプリケーションを構築する方法を紹介しました。KStreamsアプリケーションを本番環境で実行するために、データパイプラインのヘルスチェックやメトリクスを追加することもできます。詳細については、 "
"link:micrometer[マイクロメーター]、 link:microprofile-metrics[マイクロプロファイルメトリクス]、 link:"
"microprofile-health[ヘルスチェック]に関するQuarkusのガイドを参照してください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-properties.adoc:6
#, no-wrap
msgid "Quarkus - Using Security with .properties File"
msgstr "Quarkus - .propertiesファイルでセキュリティを使用する"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:13
msgid ""
"Quarkus provides support for properties file based authentication that is "
"intended for development and testing purposes. It is not recommended that "
"this be used in production as at present only plaintext and MD5 hashed "
"passwords are used, and properties files are generally too limited to use in "
"production."
msgstr ""
"Quarkusでは、開発とテストを目的としたプロパティファイルベースの認証をサポートしています。現在のところ、平文とMD5ハッシュ化されたパスワードしか使用されておらず、プロパティファイルは一般的に本番環境で使用するには制限が多すぎるため、本番環境で使用することはお勧めできません。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:15
msgid "Add the following to your `pom.xml`:"
msgstr "以下を `pom.xml` に追加してください："

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:22
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-elytron-security-properties-file</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:29
msgid ""
"The elytron-security-properties-file extension currently supports two "
"different realms for the storage of authentication and authorization "
"information. Both support storage of this information in properties files. "
"The following sections detail the specific configuration properties."
msgstr ""
"elytron-security-properties-file "
"拡張機能は、現在、認証と認可情報の保存のための2つの異なる領域をサポートしています。どちらもこの情報のプロパティファイルへの保存をサポートしています。以下のセクションでは、特定の設定プロパティについて詳しく説明します。"

#. type: Title ===
#: upstream/_guides/security-properties.adoc:32
#, no-wrap
msgid "Properties Files Realm Configuration"
msgstr "プロパティファイルレルム設定"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:35
msgid ""
"The properties files realm supports mapping of users to password and users "
"to roles with a combination of properties files. They are configured with "
"properties starting with `quarkus.security.users.file`."
msgstr ""
"プロパティファイルのレルムは、プロパティファイルの組み合わせを使用して、ユーザーをパスワードに、ユーザーをロールにマッピングすることをサポートしています。これらは "
"`quarkus.security.users.file` で始まるプロパティで構成されています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:36
#, no-wrap
msgid "example application.properties file section for property files realm"
msgstr "プロパティファイルレルムの application.properties ファイルセクションの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:44
#, no-wrap
msgid ""
"quarkus.security.users.file.enabled=true\n"
"quarkus.security.users.file.users=test-users.properties\n"
"quarkus.security.users.file.roles=test-roles.properties\n"
"quarkus.security.users.file.realm-name=MyRealm\n"
"quarkus.security.users.file.plain-text=true\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/security-properties.adoc:46
#, no-wrap
msgid "Users.properties"
msgstr "ユーザーズプロパティ"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:49
msgid ""
"The `quarkus.security.users.file.users` configuration property specifies a "
"classpath resource which is a properties file with a user to password "
"mapping, one per line. The following <<test-users-example>> illustrates the "
"format:"
msgstr ""
"`quarkus.security.users.file.users` "
"設定プロパティは、クラスパスリソースを指定します。これは、1行に1つずつ、ユーザーとパスワードをマッピングしたプロパティファイルです。以下の link:"
"#test-users-example[[test-users-example] は]そのフォーマットを示しています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:51
#, no-wrap
msgid "example test-users.properties file"
msgstr "例：test-users.propertiesファイル"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:58
#, no-wrap
msgid "scott=jb0ss <1>\n"
"jdoe=p4ssw0rd <2>\n"
"stuart=test\n"
"noadmin=n0Adm1n\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:60
msgid "User `scott` has password defined as `jb0ss`"
msgstr "ユーザー `scott` のパスワードは `jb0ss` と定義されています。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:61
msgid "User `jdoe` has password defined as `p4ssw0rd`"
msgstr "ユーザー `jdoe` のパスワードは `p4ssw0rd` と定義されています。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:65
msgid ""
"This file has the usernames and passwords stored in plain text, which is not "
"recommended. If plain-text is set to false (or omitted) in the config then "
"passwords must be stored in the form `MD5 ( username : realm : password )`. "
"This can be generated for the first example above by running the command "
"`echo -n scott:MyRealm:jb0ss | md5` from the command line."
msgstr ""
"このファイルには、ユーザ名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false "
"に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` "
"の形式で保存されなければなりません。これは上の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` "
"コマンドを実行することで生成することができます。"

#. type: Title ====
#: upstream/_guides/security-properties.adoc:66
#, no-wrap
msgid "Roles.properties"
msgstr "Roles.properties"

#. type: Block title
#: upstream/_guides/security-properties.adoc:68
#, no-wrap
msgid "example test-roles.properties file"
msgstr "例：test-roles.propertiesファイル"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:75
#, no-wrap
msgid ""
"scott=Admin,admin,Tester,user <1>\n"
"jdoe=NoRolesUser <2>\n"
"stuart=admin,user <3>\n"
"noadmin=user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:77
msgid ""
"User `scott` has been assigned the roles `Admin`, `admin`, `Tester` and "
"`user`"
msgstr "ユーザー `scott` には `Admin`, `admin`, `Tester` および `user`"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:78
msgid "User `jdoe` has been assigned the role `NoRolesUser`"
msgstr "ユーザー `jdoe` に役割が割り当てられています。 `NoRolesUser`"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:79
msgid "User `stuart` has been assigned the roles `admin` and `user`."
msgstr "ユーザー `stuart` には `admin` と `user` の役割が割り当てられています。"

#. type: Title ===
#: upstream/_guides/security-properties.adoc:80
#, no-wrap
msgid "Embedded Realm Configuration"
msgstr "エンベデッドレルムの設定"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:83
msgid ""
"The embedded realm also supports mapping of users to password and users to "
"roles. It uses the main `application.properties` Quarkus configuration file "
"to embed this information. They are configured with properties starting with "
"`quarkus.security.users.embedded`."
msgstr ""
"埋め込まれたレルムは、ユーザーのパスワードへのマッピングやユーザーのロールへのマッピングもサポートしています。この情報を埋め込むには、メインの "
"`application.properties` Quarkus設定ファイルを使用します。これらは、 `quarkus.security.users."
"embedded` で始まるプロパティで設定されます。"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:85
msgid ""
"The following is an example application.properties file section illustrating "
"the embedded realm configuration:"
msgstr "以下は、組み込みレルムの設定を示すapplication.propertiesファイルのセクションの例です。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:86
#, no-wrap
msgid "example application.properties file section for embedded realm"
msgstr "埋め込みレルム用のapplication.propertiesファイルセクションの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:99
#, no-wrap
msgid ""
"quarkus.security.users.embedded.enabled=true\n"
"quarkus.security.users.embedded.plain-text=true\n"
"quarkus.security.users.embedded.users.scott=jb0ss\n"
"quarkus.security.users.embedded.users.stuart=test\n"
"quarkus.security.users.embedded.users.jdoe=p4ssw0rd\n"
"quarkus.security.users.embedded.users.noadmin=n0Adm1n\n"
"quarkus.security.users.embedded.roles.scott=Admin,admin,Tester,user\n"
"quarkus.security.users.embedded.roles.stuart=admin,user\n"
"quarkus.security.users.embedded.roles.jdoe=NoRolesUser\n"
"quarkus.security.users.embedded.roles.noadmin=user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:104
msgid ""
"As with the first example this file has the usernames and passwords stored "
"in plain text, which is not recommended. If plain-text is set to false (or "
"omitted) in the config then passwords must be stored in the form `MD5 ( "
"username : realm : password )`. This can be generated for the first example "
"above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the "
"command line."
msgstr ""
"最初の例と同様に、このファイルにはユーザ名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false "
"に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` "
"の形式で保存されなければなりません。これは上記の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` "
"コマンドを実行することで生成することができます。"

#. type: Title ====
#: upstream/_guides/security-properties.adoc:106
#, no-wrap
msgid "Embedded Users"
msgstr "組込ユーザー"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:109
msgid ""
"The user to password mappings are specified in the `application.properties` "
"file by properties keys of the form `quarkus.security.users.embedded.users."
"<user>=<password>`. The following <<password-example>> illustrates the "
"syntax with 4 user to password mappings:"
msgstr ""
"ユーザーからパスワードへのマッピングは、 `application.properties` ファイル内で `quarkus.security.users."
"embedded.users.&amp;lt;user&amp;gt;=&amp;lt;password&amp;gt;` "
"形式のプロパティキーで指定します。以下の link:#password-example[[password-example] は]、4 "
"つのユーザーからパスワードへのマッピングの構文を示しています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:111
#, no-wrap
msgid "Example Passwords"
msgstr "パスワードの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:118
#, no-wrap
msgid ""
"quarkus.security.users.embedded.users.scott=jb0ss # <1>\n"
"quarkus.security.users.embedded.users.stuart=test # <2>\n"
"quarkus.security.users.embedded.users.jdoe=p4ssw0rd\n"
"quarkus.security.users.embedded.users.noadmin=n0Adm1n\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:120
msgid "User `scott` has password `jb0ss`"
msgstr "ユーザー `scott` はパスワード `jb0ss` を持っています"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:121
msgid "User `stuart` has password `test`"
msgstr "ユーザー `stuart` はパスワード `test` を持っています"

#. type: Title ====
#: upstream/_guides/security-properties.adoc:122
#, no-wrap
msgid "Embedded Roles"
msgstr "組込ロール"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:125
msgid ""
"The user to role mappings are specified in the `application.properties` file "
"by properties keys of the form `quarkus.security.users.embedded.roles.<user>="
"role1[,role2[,role3[,...]]]`. The following <<roles-example>> illustrates "
"the syntax with 4 user to role mappings:"
msgstr ""
"ユーザとロールのマッピングは、 `application.properties` ファイルで `quarkus.security.users."
"embedded.roles.&amp;lt;user&amp;gt;=role1[,role2[,role3[,…​]]]` "
"形式のプロパティ・キーで指定されます。以下の link:#roles-example[[role-"
"example]]は、4つのユーザとロールをマッピングした構文を示しています。"

#. type: Block title
#: upstream/_guides/security-properties.adoc:127
#, no-wrap
msgid "Example Roles"
msgstr "ロールの例"

#. type: delimited block -
#: upstream/_guides/security-properties.adoc:134
#, no-wrap
msgid ""
"quarkus.security.users.embedded.roles.scott=Admin,admin,Tester,user # <1>\n"
"quarkus.security.users.embedded.roles.stuart=admin,user # <2>\n"
"quarkus.security.users.embedded.roles.jdoe=NoRolesUser\n"
"quarkus.security.users.embedded.roles.noadmin=user\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-properties.adoc:136
msgid "User `scott` has roles `Admin`, `admin`, `Tester`, and `user`"
msgstr "ユーザー `scott` には `Admin`, `admin`, `Tester`, および `user`"

#. type: Plain text
#: upstream/_guides/security-properties.adoc:137
msgid "User `stuart` has roles `admin` and `user`"
msgstr "ユーザー `stuart` には `admin` と `user`"

#. type: Title ==
#: upstream/_guides/kogito.adoc:433
#, no-wrap, fuzzy
msgid "References"
msgstr "参考文献"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:115
#, fuzzy
msgid "link:security[Quarkus Security]"
msgstr "link:security[Quarkusのセキュリティ]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/scheduler.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Scheduling Periodic Tasks"
msgstr "Quarkus - 定期的なタスクのスケジューリング"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:12
#, fuzzy
msgid ""
"Modern applications often need to run specific tasks periodically.  In this "
"guide, you learn how to schedule periodic tasks."
msgstr "最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクをスケジュールする方法を学びます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:14
#, fuzzy
msgid ""
"If you need a clustered scheduler use the link:quartz[Quartz extension]."
msgstr "クラスタ化されたスケジューラが必要な場合は、 link:quartz[Quartz拡張機能を]使用してください。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:23
#, fuzzy
msgid "less than 10 minutes"
msgstr "１０分足らず"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:28
#, fuzzy
msgid ""
"In this guide, we create a straightforward application accessible using HTTP "
"to get the current value of a counter.  This counter is periodically (every "
"10 seconds) incremented."
msgstr ""
"このガイドでは、カウンタの現在値を取得するためにHTTPを使用してアクセスできる簡単なアプリケーションを作成します。このカウンタは定期的に(10秒ごとに)インクリメントされます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:30
#, fuzzy
msgid "image:scheduling-task-architecture.png[alt=Architecture]"
msgstr "image:scheduling-task-architecture.png[alt=Architecture]"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:39
#, fuzzy
msgid ""
"The solution is located in the `scheduler-quickstart` {quickstarts-tree-url}/"
"scheduler-quickstart[directory]."
msgstr ""
"ソリューションは `scheduler-quickstart` {quickstarts-tree-url}/scheduler-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:53
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=scheduler-quickstart \\\n"
"    -DclassName=\"org.acme.scheduler.CountResource\" \\\n"
"    -Dpath=\"/count\" \\\n"
"    -Dextensions=\"scheduler\"\n"
"cd scheduler-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:57
#, fuzzy
msgid "It generates:"
msgstr "生成します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:59
#, fuzzy
msgid "the Maven structure"
msgstr "メイヴン構造体"

#. type: Plain text
#: upstream/_guides/quartz.adoc:60
#, fuzzy
msgid "a landing page accessible on `http://localhost:8080`"
msgstr ""
"ランディングページ `&lt;a href=\"http://localhost:8080\" class=\"bare\"&gt;http://"
"localhost:8080&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/quartz.adoc:61
#, fuzzy
msgid "example `Dockerfile` files for both `native` and `jvm` modes"
msgstr "`native` と `jvm` の両方のモードに対応した `Dockerfile` ファイルの例"

#. type: Plain text
#: upstream/_guides/quartz.adoc:62
#, fuzzy
msgid "the application configuration file"
msgstr "アプリケーション設定ファイル"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:62
#, fuzzy
msgid "an `org.acme.scheduler.CountResource` resource"
msgstr "`org.acme.scheduler.CountResource` リソース"

#. type: Plain text
#: upstream/_guides/quartz.adoc:64
#, fuzzy
msgid "an associated test"
msgstr "関連試験"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:65
#, fuzzy
msgid "The Maven project also imports the Quarkus scheduler extension."
msgstr "Mavenプロジェクトは、Quarkusスケジューラ拡張機能もインポートします。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:68
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`scheduler` extension to your project by running the following command in "
"your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`scheduler` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:72
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"scheduler\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:82
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-scheduler</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/quartz.adoc:120
#, no-wrap, fuzzy
msgid "Creating a scheduled job"
msgstr "スケジュールされたジョブの作成"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:88
#, fuzzy
msgid ""
"In the `org.acme.scheduler` package, create the `CounterBean` class, with "
"the following content:"
msgstr "`org.acme.scheduler` パッケージで、以下の内容の `CounterBean` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:92 upstream/_guides/scheduler.adoc:152
#: upstream/_guides/scheduler.adoc:181
#, no-wrap
msgid "package org.acme.scheduler;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:97
#, no-wrap
msgid ""
"import java.util.concurrent.atomic.AtomicInteger;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
"import io.quarkus.scheduler.Scheduled;\n"
"import io.quarkus.scheduler.ScheduledExecution;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:100
#, no-wrap
msgid "@ApplicationScoped              // <1>\n"
"public class CounterBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:102
#, no-wrap
msgid "    private AtomicInteger counter = new AtomicInteger();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:106
#, no-wrap
msgid "    public int get() {  // <2>\n"
"        return counter.get();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:111
#, no-wrap
msgid ""
"    @Scheduled(every=\"10s\")     // <3>\n"
"    void increment() {\n"
"        counter.incrementAndGet(); // <4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:117
#, no-wrap
msgid ""
"    @Scheduled(cron=\"0 15 10 * * ?\") <5>\n"
"    void cronJob(ScheduledExecution execution) {\n"
"        counter.incrementAndGet();\n"
"        System.out.println(execution.getScheduledFireTime());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:124
#, no-wrap
msgid ""
"    @Scheduled(cron = \"{cron.expr}\") <6>\n"
"    void cronJobWithExpressionInConfig() {\n"
"       counter.incrementAndGet();\n"
"       System.out.println(\"Cron expression configured in application."
"properties\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:146
#, fuzzy
msgid "Declare the bean in the _application_ scope"
msgstr "_アプリケーション_スコープでビーンを宣言する"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:127
#, fuzzy
msgid "The `get()` method allows retrieving the current value."
msgstr "`get()` メソッドでは、現在の値を取得することができます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:130
#, fuzzy
msgid ""
"Use the `@Scheduled` annotation to instruct Quarkus to run this method every "
"10 seconds provided a worker thread is available (Quarkus is using 10 worker "
"threads for the scheduler). If it is not available the method invocation "
"should be re-scheduled by default i.e it should be invoked as soon as "
"possible. The invocation of the scheduled method does not depend on the "
"status or result of the previous invocation."
msgstr ""
"`@Scheduled` "
"アノテーションを使用して、ワーカースレッドが利用可能であれば10秒ごとにこのメソッドを実行するようにQuarkusに指示します（Quarkusはスケジューラに10個のワーカースレッドを使用しています）。ワーカースレッドが利用できない場合は、メソッドの呼び出しをデフォルトで再スケジューリングする必要があります。スケジュールされたメソッドの呼び出しは、前回の呼び出しのステータスや結果には依存しません。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:131
#, fuzzy
msgid ""
"The code is pretty straightforward. Every 10 seconds, the counter is "
"incremented."
msgstr "コードはとても簡単です。10秒ごとにカウンタがインクリメントされます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:132
#, fuzzy
msgid ""
"Define a job with a cron-like expression. The annotated method is executed "
"at 10:15am every day."
msgstr "cronのような式でジョブを定義します。アノテーションされたメソッドは毎日午前10時15分に実行されます。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:133
#, fuzzy
msgid ""
"Define a job with a cron-like expression `cron.expr` which is configurable "
"in `application.properties`."
msgstr "`cron.expr` `application.properties` で設定可能な cron-like 式 でジョブを定義します。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:205
#, no-wrap, fuzzy
msgid "Updating the application configuration file"
msgstr "アプリケーション設定ファイルの更新"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:137
#, fuzzy
msgid ""
"Edit the `application.properties` file and add the `cron.expr` configuration:"
""
msgstr "`application.properties` ファイルを編集し、 `cron.expr` の設定を追加します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:143
#, no-wrap
msgid ""
"# By default, the syntax used for cron expressions is based on Quartz - http:"
"//www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger."
"html\n"
"# You can change the syntax using the following property:\n"
"# quarkus.scheduler.cron-type=unix\n"
"cron.expr=*/5 * * * * ?\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/quartz.adoc:237
#, no-wrap, fuzzy
msgid "Updating the resource and the test"
msgstr "リソースとテストの更新"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:148
#, fuzzy
msgid "Edit the `CountResource` class, and update the content to:"
msgstr "`CountResource` クラスを編集して、内容を更新します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:161
#, no-wrap
msgid "@Path(\"/count\")\n"
"public class CountResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:164
#, no-wrap
msgid "    @Inject\n"
"    CounterBean counter;            // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:172
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        return \"count: \" + counter.get();  // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler.adoc:174
#, fuzzy
msgid "Inject the `CounterBean`"
msgstr "を注入します。 `CounterBean`"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:175
#, fuzzy
msgid "Send back the current counter value"
msgstr "現在のカウンタの値を送り返す"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:177
#, fuzzy
msgid ""
"We also need to update the tests. Edit the `CountResourceTest` class to "
"match:"
msgstr "テストも更新する必要があります。 `CountResourceTest` クラスを一致するように編集します。"

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:187
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.containsString;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:190
#, no-wrap
msgid "@QuarkusTest\n"
"public class CountResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler.adoc:199
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .when().get(\"/count\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(containsString(\"count\")); // <1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler.adoc:203
#, fuzzy
msgid "Ensure that the response contains `count`"
msgstr "レスポンスに以下が含まれていることを確認してください。 `count`"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:209
#, fuzzy
msgid ""
"Run the application with: `./mvnw compile quarkus:dev`.  In another "
"terminal, run `curl localhost:8080/count` to check the counter value.  After "
"a few seconds, re-run `curl localhost:8080/count` to verify the counter has "
"been incremented."
msgstr ""
"`./mvnw compile quarkus:dev` でアプリケーションを実行してください。別のターミナルで `curl localhost:"
"8080/count` を実行して、カウンタの値を確認します。数秒後に `curl localhost:8080/count` "
"を再実行して、カウンタがインクリメントされていることを確認します。"

#. type: Plain text
#: upstream/_guides/scheduler.adoc:212
#, fuzzy
msgid ""
"Observe the console to verify that the message `Cron expression configured "
"in application.properties` has been displayed indicating that the cron job "
"using an expression configured in `application.properties` has been "
"triggered."
msgstr ""
"コンソールを観察して、 `application.properties` で構成された式を使用する cron ジョブがトリガされたことを示すメッセージ "
"`Cron expression configured in application.properties` が表示されたことを確認します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:394
#, fuzzy
msgid ""
"As usual, the application can be packaged using `./mvnw clean package` and "
"executed using the `-runner.jar` file.  You can also generate the native "
"executable with `./mvnw clean package -Pnative`."
msgstr ""
"いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` "
"ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative`."

#. type: Title ==
#: upstream/_guides/scheduler.adoc:217
#, no-wrap, fuzzy
msgid "Scheduler Configuration Reference"
msgstr "スケジューラ設定リファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/vault.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using HashiCorp Vault"
msgstr "Quarkus - Using HashiCorp Vault"

#. type: Plain text
#: upstream/_guides/vault.adoc:21
#, fuzzy
msgid ""
"https://www.vaultproject.io/[HashiCorp Vault] is a multi-purpose tool aiming "
"at protecting sensitive data, such as credentials, certificates, access "
"tokens, encryption keys, ... In the context of Quarkus, several use cases "
"are supported:"
msgstr ""
"link:https://www.vaultproject.io/[HashiCorp "
"Vault]は、クレデンシャル、証明書、アクセストークン、暗号化キーなどの機密データの保護を目的とした多目的ツールです。"

#. type: Plain text
#: upstream/_guides/vault.adoc:24
#, fuzzy
msgid ""
"mounting a map of properties stored into the https://www.vaultproject.io/"
"docs/secrets/kv/index.html[Vault kv secret engine] as an Eclipse "
"MicroProfile config source"
msgstr ""
"link:https://www.vaultproject.io/docs/secrets/kv/index.html[Vault kv "
"シークレットエンジン]に保存されたプロパティのマップを Eclipse MicroProfile の設定ソースとしてマウントします。"

#. type: Plain text
#: upstream/_guides/vault.adoc:25
#, fuzzy
msgid ""
"fetching credentials from Vault when configuring an Agroal datasource, as "
"documented in the {vault-datasource-guide}"
msgstr ""
"Agroal データソースを構成する際に、{vault-datasource-guide} で説明されているように、Vault "
"から資格情報をフェッチします。"

#. type: Plain text
#: upstream/_guides/vault.adoc:26
#, fuzzy
msgid "accessing Vault _kv secret engine_ programmatically"
msgstr "Vault _kv の秘密エンジンに_プログラムでアクセスする"

#. type: Plain text
#: upstream/_guides/vault.adoc:27
#, fuzzy
msgid ""
"support for the https://www.vaultproject.io/docs/secrets/totp[TOTP Secret "
"Engine]"
msgstr ""
"link:https://www.vaultproject.io/docs/secrets/totp[TOTPシークレットエンジンの]サポート"

#. type: Plain text
#: upstream/_guides/vault.adoc:29
#, fuzzy
msgid ""
"support for the https://www.vaultproject.io/docs/secrets/transit[Transit "
"Secret Engine] as documented in the {vault-transit-guide}"
msgstr ""
"link:https://www.vaultproject.io/docs/secrets/"
"transit[トランジットシークレットエンジンの]サポートは {vault-transit-guide} で文書化されています。"

#. type: Plain text
#: upstream/_guides/vault.adoc:30
#, fuzzy
msgid ""
"support for several authentication methods as documented in the {vault-auth-"
"guide}"
msgstr "で説明されているように、いくつかの認証方法をサポートしています。"

#. type: Plain text
#: upstream/_guides/vault.adoc:33
#, fuzzy
msgid ""
"Under the hood, the Quarkus Vault extension takes care of authentication "
"when negotiating a client Vault token plus any transparent token or lease "
"renewals according to _ttl_ and _max-ttl._"
msgstr ""
"Quarkus Vault拡張機能では、クライアントのVaultトークンをネゴシエートする際の認証と、 _ttl_と _max-"
"ttl_に応じた透過的なトークンやリースの更新を行います _。_"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:51
#, fuzzy
msgid "roughly 20 minutes"
msgstr "ざっと20分"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:55
#, fuzzy
msgid "Docker installed"
msgstr "Dockerのインストール"

#. type: Title ==
#: upstream/_guides/vault.adoc:46
#, no-wrap, fuzzy
msgid "Starting Vault"
msgstr "ボールトを起動する"

#. type: Plain text
#: upstream/_guides/vault.adoc:49
#, fuzzy
msgid "Let's start Vault in development mode:"
msgstr "開発モードでVaultを起動してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:53
#, no-wrap
msgid ""
"docker run --rm --cap-add=IPC_LOCK -e VAULT_ADDR=http://localhost:8200 -p "
"8200:8200 -d --name=dev-vault vault:{vault-version}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:56
#, fuzzy
msgid "You can check that vault is running with:"
msgstr "でVaultが実行されていることを確認することができます。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:59
#, no-wrap
msgid "docker logs dev-vault\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:107
#: upstream/_guides/vault-transit.adoc:136
#, fuzzy
msgid "You should see:"
msgstr "見た方がいいですよ。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:66
#, no-wrap
msgid "==> Vault server configuration:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:75
#, no-wrap
msgid ""
"             Api Address: http://0.0.0.0:8200\n"
"                     Cgo: disabled\n"
"         Cluster Address: https://0.0.0.0:8201\n"
"              Listener 1: tcp (addr: \"0.0.0.0:8200\", cluster address: \"0."
"0.0.0:8201\", max_request_duration: \"1m30s\", max_request_size: "
"\"33554432\", tls: \"disabled\")\n"
"               Log Level: info\n"
"                   Mlock: supported: true, enabled: false\n"
"                 Storage: inmem\n"
"                 Version: Vault v{vault-version}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:79
#, no-wrap
msgid ""
"WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\n"
"and starts unsealed with a single unseal key. The root token is already\n"
"authenticated to the CLI, so you can immediately begin using Vault.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:81
#, no-wrap
msgid "You may need to set the following environment variable:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:83
#, no-wrap
msgid "    $ export VAULT_ADDR='http://0.0.0.0:8200'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:86
#, no-wrap
msgid ""
"The unseal key and root token are displayed below in case you want to\n"
"seal/unseal the Vault or re-authenticate.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:89
#, no-wrap
msgid ""
"Unseal Key: 0lZ2/vzpa92pH8gersSn2h9b5tmzd4m5sqIdMC/4PDs=\n"
"Root Token: {root-token}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:91
#, no-wrap
msgid "Development mode should NOT be used in production installations!\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:93
#, no-wrap
msgid "==> Vault server started! Log data will stream in below:\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:96
#, fuzzy
msgid ""
"In development mode, Vault gets configured with several options that makes "
"it convenient:"
msgstr "開発モードでは、Vaultはそれを便利にするいくつかのオプションで構成されます。"

#. type: Plain text
#: upstream/_guides/vault.adoc:99
#, fuzzy
msgid ""
"Vault is already initialized with one key share (whereas in normal mode this "
"has to be done explicitly and the number of key shares is 5 by default)"
msgstr ""
"Vault はすでに 1 つのキーシェアで初期化されています （通常のモードではこれは明示的に行う必要があり、キーシェアの数はデフォルトでは 5 "
"となっています）。"

#. type: Plain text
#: upstream/_guides/vault.adoc:101
#, fuzzy
msgid ""
"the unseal key and the root token are displayed in the logs (please write "
"down the root token, we will need it in the following step)"
msgstr "unseal キーと root トークンがログに表示されます (root トークンは次のステップで必要になるのでメモしておいてください)"

#. type: Plain text
#: upstream/_guides/vault.adoc:102
#, fuzzy
msgid "Vault is unsealed"
msgstr "金庫室の封印が解除されています"

#. type: Plain text
#: upstream/_guides/vault.adoc:103
#, fuzzy
msgid "in-memory storage"
msgstr "メモリ内記憶装置"

#. type: Plain text
#: upstream/_guides/vault.adoc:104
#, fuzzy
msgid "TLS is disabled"
msgstr "TLSが無効になっている"

#. type: Plain text
#: upstream/_guides/vault.adoc:105
#, fuzzy
msgid "a _kv secret engine v2_ is mounted at `secret/`"
msgstr "_ＫＶシークレットエンジンＶ２を_搭載しています。 `secret/`"

#. type: delimited block =
#: upstream/_guides/vault.adoc:111
#, fuzzy
msgid ""
"By default Quarkus assumes that a _kv secret engine_ in version *2* mounted "
"at path `secret/` will be used.  If that is not the case, please use "
"properties `quarkus.vault.kv-secret-engine-version` and `quarkus.vault.kv-"
"secret-engine-mount-path` accordingly."
msgstr ""
"デフォルトでは、Quarkusは、パス `secret/` にマウントされたバージョン *2*の "
"_kvシークレットエンジン_が使用されると想定しています。そうでない場合は、プロパティ `quarkus.vault.kv-secret-engine-"
"version` と `quarkus.vault.kv-secret-engine-mount-path` を適宜使用してください。"

#. type: Plain text
#: upstream/_guides/vault.adoc:115
#, fuzzy
msgid ""
"In the following step, we are going to add a `userpass` authentication that "
"we will use from the Quarkus application, to access a secret stored in the "
"_kv secret engine_."
msgstr ""
"次のステップでは、Quarkusアプリケーションから使用する `userpass` 認証を追加して、 "
"_kv秘密エンジン_に保存されている秘密にアクセスします。"

#. type: Plain text
#: upstream/_guides/vault.adoc:117
#, fuzzy
msgid "First open a shell inside the vault container:"
msgstr "まず、金庫の容器の中の貝殻を開けます。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:121
#, no-wrap
msgid "docker exec -it dev-vault sh\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:124
#, fuzzy
msgid "Set the `VAULT_TOKEN` with the value that was printed in the logs:"
msgstr "`VAULT_TOKEN` に、ログに印刷されていた値を設定します。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:128
#, no-wrap
msgid "export VAULT_TOKEN={root-token}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:131
#, fuzzy
msgid "You can check Vault's status using the CLI command `vault status`:"
msgstr "Vault のステータスは、CLI コマンドを使用して確認できます `vault status`."

#. type: delimited block -
#: upstream/_guides/vault.adoc:145
#, no-wrap
msgid ""
"Key             Value\n"
"---             -----\n"
"Seal Type       shamir\n"
"Initialized     true\n"
"Sealed          false\n"
"Total Shares    1\n"
"Threshold       1\n"
"Version         1.6.0\n"
"Cluster Name    vault-cluster-b07e80d8\n"
"Cluster ID      55bd74b6-eaaf-3862-f7ce-3473ab86c57f\n"
"HA Enabled      false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:148
#, fuzzy
msgid "Now let's add a secret configuration for our application:"
msgstr "では、アプリケーションに秘密の設定を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:152
#, no-wrap
msgid ""
"vault kv put secret/myapps/vault-quickstart/config a-private-key=123456\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:155
#, fuzzy
msgid ""
"We have defined a path `secret/myapps/vault-quickstart` in Vault that we "
"need to give access to from the Quarkus application."
msgstr ""
"Vaultでは、Quarkusアプリケーションからアクセスできるようにする必要があるパス `secret/myapps/vault-"
"quickstart` を定義しました。"

#. type: Plain text
#: upstream/_guides/vault.adoc:157
#, fuzzy
msgid ""
"Create a policy that gives read access to `secret/myapps/vault-quickstart` "
"and subpaths:"
msgstr "`secret/myapps/vault-quickstart` とサブパスへの読み取りアクセスを与えるポリシーを作成します。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:165
#, no-wrap
msgid ""
"cat <<EOF | vault policy write vault-quickstart-policy -\n"
"path \"secret/data/myapps/vault-quickstart/*\" {\n"
"  capabilities = [\"read\"]\n"
"}\n"
"EOF\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/vault.adoc:175
#, fuzzy
msgid ""
"When using a _kv secret engine version 2_, secrets are written and fetched "
"at path `<mount>/*data*/<secret-path>` as opposed to `<mount>/<secret-path>` "
"in a _kv secret engine version 1_.  It does not change any of the CLI "
"commands (i.e. you do not specify `data` in your path).  However it does "
"change the policies, since capabilities are applied to the real path. In the "
"example above, the path is `secret/*data*/myapps/vault-quickstart/\\*` since "
"we are working with a _kv secret engine version 2_.  It would be `secret/"
"myapps/vault-quickstart/*` with a _kv secret engine version 1_."
msgstr ""
"_kvシークレットエンジンバージョン2を_使用している場合、シークレットはパス `&amp;lt;mount&amp;gt;/ *data*/"
"&amp;lt;secret-path&amp;gt;`とは対照的に、 _kvシークレットエンジンのバージョン1_では "
"`&amp;lt;mount&amp;gt;/&amp;lt;secret-path&amp;gt;` "
"となります。これはCLIコマンドを変更しません(つまり、パスに `data` "
"を指定しません)。しかし、実際のパスに能力が適用されるので、ポリシーは変更されます。上の例では、パスは `secret/ *data*/myapps/"
"vault-quickstart/*`私たちはKVシーク _レットエンジンバージョン2_で作業しています。それは "
"_kvシークレットエンジンバージョン1_で `secret/myapps/vault-quickstart/*` になるでしょう。"

#. type: Plain text
#: upstream/_guides/vault.adoc:178
#, fuzzy
msgid ""
"And finally, let's enable the _userpass auth secret engine_, and create user "
"`bob` with access to the `vault-quickstart-policy`:"
msgstr ""
"最後に、 _userpass auth シークレットエンジンを_有効にして、 `bob` にアクセスできるユーザ `vault-quickstart-"
"policy` を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:150
#, no-wrap
msgid ""
"vault auth enable userpass\n"
"vault write auth/userpass/users/bob password=sinclair policies=vault-"
"quickstart-policy\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/vault.adoc:188
#, fuzzy
msgid ""
"Quarkus supports additional Vault Authentication methods. Check the {vault-"
"auth-guide} for details."
msgstr "Quarkusは、追加のVault認証方法をサポートしています。詳細については、{vault-auth-guide}を確認してください。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:100
#, fuzzy
msgid "To check that the configuration is correct, try logging in:"
msgstr "設定が正しいことを確認するには、ログインしてみてください。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:104
#, no-wrap
msgid "vault login -method=userpass username=bob password=sinclair\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:113
#, no-wrap
msgid ""
"Success! You are now authenticated. The token information displayed below\n"
"is already stored in the token helper. You do NOT need to run \"vault "
"login\"\n"
"again. Future Vault requests will automatically use this token.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:124
#, no-wrap
msgid ""
"Key                    Value\n"
"---                    -----\n"
"token                  {client-token}\n"
"token_accessor         OKNipTAgxWbxsrjixASNiwdY\n"
"token_duration         768h\n"
"token_renewable        true\n"
"token_policies         [\"default\" \"vault-quickstart-policy\"]\n"
"identity_policies      []\n"
"policies               [\"default\" \"vault-quickstart-policy\"]\n"
"token_meta_username    bob\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:218
#, fuzzy
msgid ""
"Now set `VAULT_TOKEN` to the `token` above (instead of the root token), and "
"try reading the vault-quickstart secret config:"
msgstr ""
"では、上記の `VAULT_TOKEN` を (ルートトークンではなく) `token` に設定し、Vault-quickstart "
"のシークレット設定を読み込んでみてください。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:223
#, no-wrap
msgid ""
"export VAULT_TOKEN={client-token}\n"
"vault kv get secret/myapps/vault-quickstart/config\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:233
#, no-wrap
msgid ""
"======== Data ========\n"
"Key              Value\n"
"---              -----\n"
"a-private-key    123456\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vault.adoc:235
#, no-wrap, fuzzy
msgid "Create a Quarkus application with a secret configuration"
msgstr "秘密の設定でQuarkusアプリケーションを作成する"

#. type: delimited block -
#: upstream/_guides/vault.adoc:246
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vault-quickstart \\\n"
"    -DclassName=\"org.acme.quickstart.GreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"vault\"\n"
"cd vault-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:250
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the `vault` "
"extension to your project by running the following command in your project "
"base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `vault` "
"拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:254
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"vault\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:264
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-vault</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:267
#, fuzzy
msgid "Configure access to Vault from the `{config-file}`:"
msgstr "`{config-file}` から Vault へのアクセスを設定します。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:164
#, no-wrap
msgid "# vault url\n"
"quarkus.vault.url=http://localhost:8200\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:168
#, no-wrap
msgid ""
"# vault authentication\n"
"quarkus.vault.authentication.userpass.username=bob\n"
"quarkus.vault.authentication.userpass.password=sinclair\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:279
#, no-wrap
msgid ""
"# path within the kv secret engine where is located the vault-quickstart "
"secret configuration\n"
"quarkus.vault.secret-config-kv-path=myapps/vault-quickstart/config\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:282
#, fuzzy
msgid ""
"This should mount whatever keys are stored in `secret/myapps/vault-"
"quickstart` as MicroProfile Config properties."
msgstr ""
"これは、 `secret/myapps/vault-quickstart` に保存されているすべてのキーを MicroProfile Config "
"プロパティとしてマウントする必要があります。"

#. type: Plain text
#: upstream/_guides/vault.adoc:284
#, fuzzy
msgid "Let's verify that by adding a new endpoint in GreetingResource:"
msgstr "GreetingResourceに新しいエンドポイントを追加して検証してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:292
#, no-wrap
msgid "    @ConfigProperty(name = \"a-private-key\")\n"
"    String privateKey;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:302
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/private-key\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String privateKey() {\n"
"        return privateKey;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:305
#, fuzzy
msgid "Now compile the application and run it:"
msgstr "では、アプリケーションをコンパイルして実行してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:86
#, no-wrap
msgid ""
"./mvnw clean install\n"
"java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:313
#, fuzzy
msgid "Finally test the new endpoint:"
msgstr "最後に新しいエンドポイントをテストします。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:92 upstream/_guides/vault-auth.adoc:163
#, no-wrap
msgid "curl http://localhost:8080/hello/private-key\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:324
#, no-wrap
msgid "123456\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vault.adoc:326
#, no-wrap, fuzzy
msgid "Programmatic access to the KV secret engine"
msgstr "KVシークレットエンジンへのプログラムによるアクセス"

#. type: Plain text
#: upstream/_guides/vault.adoc:331
#, fuzzy
msgid ""
"Sometimes secrets are retrieved from an arbitrary path that is known only at "
"runtime through an application specific property, or a method argument for "
"instance.  In that case it is possible to inject a Quarkus "
"`VaultKVSecretEngine`, and retrieve secrets programmatically."
msgstr ""
"秘密は、アプリケーション固有のプロパティやメソッドの引数などを介して、実行時にのみ知られている任意のパスから取得されることがあります。その場合、Quarkus "
"`VaultKVSecretEngine` を注入して、プログラムで秘密を取得することが可能です。"

#. type: Plain text
#: upstream/_guides/vault.adoc:333
#, fuzzy
msgid "For instance, in `GreetingResource`, add:"
msgstr "例えば、 `GreetingResource` で、追加します。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:338
#, no-wrap
msgid "@Inject\n"
"VaultKVSecretEngine kvSecretEngine;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:211
#: upstream/_guides/kubernetes-client.adoc:224
#, no-wrap
msgid "...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:347
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/secrets/{vault-path}\")\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"public String getSecrets(@PathParam(\"vault-path\") String vaultPath) {\n"
"    return kvSecretEngine.readSecret(\"myapps/vault-quickstart/\" + "
"vaultPath).toString();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:350
#, fuzzy
msgid "Add a new key in Vault:"
msgstr "Vaultに新しいキーを追加します。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:353
#, no-wrap
msgid "vault kv put secret/myapps/vault-quickstart/private mysecret=abc\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:356
#, fuzzy
msgid ""
"Restart the application after rebuilding it, and test it with the new "
"endpoint:"
msgstr "アプリケーションを再構築した後にアプリケーションを再起動し、新しいエンドポイントでテストします。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:360
#, no-wrap
msgid "curl http://localhost:8080/hello/secrets/private\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:366
#, no-wrap
msgid "{mysecret=abc}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vault.adoc:369
#, no-wrap, fuzzy
msgid "TOTP Secrets Engine"
msgstr "TOTPシークレットエンジン"

#. type: Plain text
#: upstream/_guides/vault.adoc:372
#, fuzzy
msgid ""
"The https://www.vaultproject.io/docs/secrets/totp/[Vault TOTP secrets "
"engine] generates time-based credentials according to the TOTP standard."
msgstr ""
"link:https://www.vaultproject.io/docs/secrets/totp/[Vault TOTP "
"シークレットエンジンは]、TOTP 標準に従って時間ベースのクレデンシャルを生成します。"

#. type: Plain text
#: upstream/_guides/vault.adoc:374
#, fuzzy
msgid ""
"Vault TOTP supports both the generator scenario (like Google Authenticator) "
"and the provider scenario (like the Google.com sign in)."
msgstr ""
"Vault TOTPは、ジェネレーターのシナリオ（Google Authenticatorのような）とプロバイダのシナリオ（Google."
"comのサインインのような）の両方をサポートしています。"

#. type: Plain text
#: upstream/_guides/vault.adoc:376
#, fuzzy
msgid ""
"The Vault extension integrates with the Vault TOTP secret engine by "
"providing an `io.quarkus.vault.VaultTOTPSecretEngine` class."
msgstr ""
"Vault 拡張機能は、 `io.quarkus.vault.VaultTOTPSecretEngine` クラスを提供することで、Vault TOTP "
"シークレットエンジンと統合されます。"

#. type: delimited block -
#: upstream/_guides/vault.adoc:383
#, no-wrap
msgid ""
"import io.quarkus.vault.VaultTOTPSecretEngine;\n"
"import io.quarkus.vault.secrets.totp.CreateKeyParameters;\n"
"import io.quarkus.vault.secrets.totp.KeyConfiguration;\n"
"import io.quarkus.vault.secrets.totp.KeyDefinition;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:386
#, no-wrap
msgid "@Inject\n"
"VaultTOTPSecretEngine vaultTOTPSecretEngine;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:389
#, no-wrap
msgid ""
"CreateKeyParameters createKeyParameters = new "
"CreateKeyParameters(\"Google\", \"test@gmail.com\");\n"
"createKeyParameters.setPeriod(\"30m\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:391
#, no-wrap
msgid "/** Google Authentication logic */\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:394
#, no-wrap
msgid ""
"final Optional<KeyDefinition> myKey = vaultTOTPSecretEngine\n"
"                                            .createKey(\"my_key_2\", "
"createKeyParameters); // <1> <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:396
#, no-wrap
msgid ""
"final String keyCode = vaultTOTPSecretEngine.generateCode(\"my_key_2\"); // "
"<3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:398
#, no-wrap
msgid "/** Google Login logic */\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:400
#, no-wrap
msgid ""
"boolean valid = vaultTOTPSecretEngine.validateCode(\"my_key_2\", keyCode); //"
" <4>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:402
#, fuzzy
msgid "Create a key to generate codes."
msgstr "コードを生成するキーを作成します。"

#. type: Plain text
#: upstream/_guides/vault.adoc:403
#, fuzzy
msgid ""
"`KeyDefinition` class contains an embeddable base64 QR code that can be used "
"by third-party code generators."
msgstr ""
"`KeyDefinition` クラスには、サードパーティのコードジェネレーターが使用できる埋め込み可能なbase64 QRコードが含まれています。"

#. type: Plain text
#: upstream/_guides/vault.adoc:404
#, fuzzy
msgid "Generates a code (not using third-party generator)."
msgstr "コードを生成します（サードパーティ製のジェネレータは使用しません）。"

#. type: Plain text
#: upstream/_guides/vault.adoc:405
#, fuzzy
msgid "Validates that the code is valid."
msgstr "コードが有効であることを検証します。"

#. type: Title ==
#: upstream/_guides/vault.adoc:406
#, no-wrap, fuzzy
msgid "Vault Health Check"
msgstr "保管庫の健康チェック"

#. type: Plain text
#: upstream/_guides/vault.adoc:410
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` "
"can add a readiness health check to validate the connection to the Vault "
"server. This is disabled by default."
msgstr ""
"`quarkus-smallrye-health` 拡張機能を使用している場合、 `quarkus-vault` は、Vault "
"サーバーへの接続を検証するための準備状態の健全性チェックを追加することができます。これは、既定では無効になっています。"

#. type: Plain text
#: upstream/_guides/vault.adoc:412
#, fuzzy
msgid ""
"If enabled, when you access the `/health/ready` endpoint of your application "
"you will have information about the connection validation status."
msgstr ""
"この機能を有効にすると、アプリケーションの `/health/ready` "
"エンドポイントにアクセスしたときに、接続の検証状態に関する情報が表示されます。"

#. type: Plain text
#: upstream/_guides/vault.adoc:414
#, fuzzy
msgid ""
"This behavior can be enabled by setting the `quarkus.vault.health.enabled` "
"property to `true` in your `application.properties`."
msgstr ""
"この動作を有効にするには、 `application.properties` の `quarkus.vault.health.enabled` "
"プロパティを `true` に設定します。"

#. type: Plain text
#: upstream/_guides/vault.adoc:416
#, fuzzy
msgid ""
"Only if Vault is initialized, unsealed and active, the health endpoint "
"returns that Vault is ready to serve requests."
msgstr ""
"Vault が初期化され、シールドされておらず、アクティブな場合に限り、ヘルス エンドポイントは、Vault "
"がリクエストに対応する準備ができていることを返します。"

#. type: Plain text
#: upstream/_guides/vault.adoc:418
#, fuzzy
msgid ""
"You can change a bit this behaviour by using `quarkus.vault.health.stand-by-"
"ok` and `quarkus.vault.health.performance-stand-by-ok` to `true` in your "
"`application.properties`."
msgstr ""
"あなたの `quarkus.vault.health.stand-by-ok` と `quarkus.vault.health.performance-"
"stand-by-ok` を `true` にすることで、この動作を少し変更することができます `application.properties`."

#. type: Labeled list
#: upstream/_guides/vault.adoc:419
#, no-wrap, fuzzy
msgid "stand-by-ok"
msgstr "スタンバイオク"

#. type: Plain text
#: upstream/_guides/vault.adoc:420
#, fuzzy
msgid ""
"Specifies if being a standby should still return the active status code "
"instead of the standby status code."
msgstr "待機中であっても、待機状態コードではなくアクティブ状態コードを返すかどうかを指定します。"

#. type: Labeled list
#: upstream/_guides/vault.adoc:421
#, no-wrap, fuzzy
msgid "performance-stand-by-ok"
msgstr "パフォーマンステックバイオク"

#. type: Plain text
#: upstream/_guides/vault.adoc:422
#, fuzzy
msgid ""
"Specifies if being a performance standby should still return the active "
"status code instead of the performance standby status code."
msgstr "パフォーマンス待機状態であっても、パフォーマンス待機状態コードではなくアクティブ状態コードを返すかどうかを指定します。"

#. type: Plain text
#: upstream/_guides/vault.adoc:424
#, fuzzy
msgid ""
"You can inject `io.quarkus.vault.VaultSystemBackendEngine` to run system "
"operations programmatically."
msgstr ""
"`io.quarkus.vault.VaultSystemBackendEngine` を注入して、システム操作をプログラム的に実行することができます。"

#. type: Plain text
#: upstream/_guides/vault.adoc:426
#, fuzzy
msgid ""
"When the readiness probe is failing in Kubernetes, then the application is "
"not reachable. This means that if Vault is failing, all services depending "
"on Vault will become unreachable and maybe this is not the desired state, so "
"use this flag according to your requirements."
msgstr ""
"KubernetesでReadyness "
"probeが失敗している場合、アプリケーションに到達できない状態になります。これは、Vaultが失敗しているとVaultに依存している全てのサービスが到達不能になることを意味しており、もしかしたらこれは望ましい状態ではないかもしれないので、要件に応じてこのフラグを使いましょう。"

#. type: Title ==
#: upstream/_guides/vault.adoc:427
#, no-wrap, fuzzy
msgid "TLS"
msgstr "ティーエルエス"

#. type: Plain text
#: upstream/_guides/vault.adoc:430
#, fuzzy
msgid ""
"In production mode, TLS should be activated between the Quarkus application "
"and Vault to prevent _man-in-the-middle_ attacks."
msgstr "本番モードでは、 _中間_者攻撃を防ぐために、QuarkusアプリケーションとVaultの間でTLSを有効にする必要があります。"

#. type: Plain text
#: upstream/_guides/vault.adoc:432
#, fuzzy
msgid "There are several ways to configure the Quarkus application:"
msgstr "Quarkusアプリケーションを設定する方法はいくつかあります。"

#. type: Plain text
#: upstream/_guides/vault.adoc:435
#, fuzzy
msgid ""
"through the standard `javax.net.ssl.trustStore` system property, which "
"should refer to a JKS truststore containing the trusted certificates"
msgstr ""
"`javax.net.ssl.trustStore` このプロパティは、信頼された証明書を含む JKS truststore "
"を参照しなければなりません。"

#. type: Plain text
#: upstream/_guides/vault.adoc:436
#, fuzzy
msgid ""
"using property `quarkus.vault.tls.ca-cert`, which should refer to a pem "
"encoded file."
msgstr "プロパティ `quarkus.vault.tls.ca-cert` を使用します。"

#. type: Plain text
#: upstream/_guides/vault.adoc:441
#, fuzzy
msgid ""
"If `quarkus.vault.tls.ca-cert` is not set and the Quarkus application is "
"using the Kubernetes authentication, TLS will be active and use the CA "
"certificate bundle located in `/var/run/secrets/kubernetes.io/serviceaccount/"
"ca.crt`.  If you want to disable this behavior (for instance when using a "
"trust store), you need to set it explicitly using: `quarkus.vault.tls.use-"
"kubernetes-ca-cert=false`."
msgstr ""
"`quarkus.vault.tls.ca-cert` "
"が設定されておらず、QuarkusアプリケーションがKubernetes認証を使用している場合、TLSがアクティブになり、 `/var/run/"
"secrets/kubernetes.io/serviceaccount/ca.crt` "
"にあるCA証明書バンドルが使用されます。この動作を無効にしたい場合（例えば、トラストストアを使用している場合など）は、 `quarkus.vault."
"tls.use-kubernetes-ca-cert=false` を使用して明示的に設定する必要があります。"

#. type: Plain text
#: upstream/_guides/vault.adoc:445
#, fuzzy
msgid ""
"The last relevant property is `quarkus.vault.tls.skip-verify`, which allows "
"to communicate with Vault using TLS, but without checking the certificate "
"authenticity. This may be convenient in development, but is strongly "
"discouraged in production as it is not more secure than talking to Vault in "
"plain HTTP."
msgstr ""
"最後の関連プロパティは `quarkus.vault.tls.skip-verify` で、これは TLS を使用して Vault "
"と通信することができますが、証明書の真正性をチェックする必要はありません。これは、 開発では便利かもしれませんが、本番環境では、プレーン HTTP で "
"Vault と通信するよりも安全ではないため、強くお勧めしません。"

#. type: Title ==
#: upstream/_guides/vault.adoc:446
#, no-wrap, fuzzy
msgid "Vault Provisioning"
msgstr "保管庫のプロビジョニング"

#. type: Plain text
#: upstream/_guides/vault.adoc:450
#, fuzzy
msgid ""
"Beside the typical client use cases, the Quarkus extension can be used to "
"provision Vault as well, for instance as part of a CD pipeline. Specific CDI "
"beans support this scenario:"
msgstr ""
"典型的なクライアントのユースケースの他に、Quarkusエクステンションは、例えばCDパイプラインの一部としてVaultのプロビジョニングにも使用できます。特定のCDIビーンがこのシナリオをサポートしています。"

#. type: Plain text
#: upstream/_guides/vault.adoc:452
#, fuzzy
msgid ""
"`VaultSystemBackendEngine`: create Vault Policies. See the https://www."
"vaultproject.io/api-docs/system/policy[Vault documentation]."
msgstr ""
"`VaultSystemBackendEngine`: Vault ポリシーを作成します。V link:https://www.vaultproject."
"io/api-docs/system/policy[ault のドキュメント]を参照してください。"

#. type: Plain text
#: upstream/_guides/vault.adoc:453
#, fuzzy
msgid ""
"`VaultKubernetesAuthService`. See the https://www.vaultproject.io/api-docs/"
"auth/kubernetes[Vault documentation]."
msgstr ""
"`VaultKubernetesAuthService` 。 link:https://www.vaultproject.io/api-docs/"
"auth/kubernetes[Vault のドキュメントを]参照してください。"

#. type: Plain text
#: upstream/_guides/vault.adoc:454
#, fuzzy
msgid ""
"Configure the Kubernetes Auth Method (Kubernetes host, certificates, keys, .."
".)"
msgstr "Kubernetes認証方法の設定（Kubernetesホスト、証明書、鍵、..."

#. type: Plain text
#: upstream/_guides/vault.adoc:455
#, fuzzy
msgid ""
"Create Kubernetes Auth Roles (association between Kubernetes service "
"accounts, Kubernetes namespaces and Vault policies)"
msgstr ""
"Kubernetes Authロールの作成（Kubernetesサービスアカウント、Kubernetesネームスペース、Vaultポリシー間の関連付け"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:68
#, fuzzy
msgid "For instance:"
msgstr "例えば"

#. type: delimited block -
#: upstream/_guides/vault.adoc:462
#, no-wrap
msgid "@Inject\n"
"VaultSystemBackendEngine vaultSystemBackendEngine;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:465
#, no-wrap
msgid "@Inject\n"
"VaultKubernetesAuthService vaultKubernetesAuthService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:473
#, no-wrap
msgid ""
"  String rules = \"path \\\"transit/*\\\" {\\n\" +\n"
"          \"  capabilities = [ \\\"create\\\", \\\"read\\\", \\\"update\\\" "
"]\\n\" +\n"
"          \"}\";\n"
"  String policyName = \"sys-test-policy\";\n"
"  vaultSystemBackendEngine.createUpdatePolicy(policyName, rules);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:478
#, no-wrap
msgid ""
"  String roleName = \"test-auth-k8s\";\n"
"  List<String> boundServiceAccountNames = asList(\"vault-auth\");\n"
"  List<String> boundServiceAccountNamespaces = asList(\"default\");\n"
"  List<String> tokenPolicies = asList(policyName);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:483
#, no-wrap
msgid ""
"  vaultKubernetesAuthService.createRole(roleName, new "
"VaultKubernetesAuthRole()\n"
"          .setBoundServiceAccountNames(boundServiceAccountNames)\n"
"          .setBoundServiceAccountNamespaces(boundServiceAccountNamespaces)\n"
"          .setTokenPolicies(tokenPolicies));\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:487
#, fuzzy
msgid ""
"Like any client, a provisioning program would have to authenticate using one "
"of the supported Auth methods, and get the appropriate grants through one or "
"more policies. Example:"
msgstr ""
"他のクライアントと同様に、プロビジョニングプログラムはサポートされている Auth "
"メソッドのいずれかを使って認証を行い、1つ以上のポリシーを使って適切なグラントを取得しなければなりません。例"

#. type: delimited block -
#: upstream/_guides/vault.adoc:494
#, no-wrap
msgid ""
"# create Policies\n"
"path \"sys/policy/*\" {\n"
"  capabilities = [\"read\", \"create\", \"update\", \"delete\"]\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault.adoc:499
#, no-wrap
msgid ""
"# create Kubernetes Auth Roles\n"
"path \"auth/kubernetes/role/*\" {\n"
"  capabilities = [\"read\", \"create\", \"update\", \"delete\"]\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault.adoc:502
#, fuzzy
msgid ""
"You should adjust to the minimal set of access rights depending on your "
"specific use case."
msgstr "特定のユースケースに応じて、アクセス権の最小セットを調整する必要があります。"

#. type: Plain text
#: upstream/_guides/vault.adoc:507
#, fuzzy
msgid ""
"As a general matter, you should consider reading the extensive https://www."
"vaultproject.io/docs/[Vault documentation] and apply best practices."
msgstr ""
"一般的な問題として、広範な link:https://www.vaultproject.io/docs/"
"[Vaultのドキュメント]を読み、ベストプラクティスを適用することを検討する必要があります。"

#. type: Plain text
#: upstream/_guides/vault.adoc:511
#, fuzzy
msgid ""
"The features exposed today through the Vault extension covers only a small "
"fraction of what the product is capable of.  Still, it addresses already "
"some of the most common microservices scenarii (e.g. sensitive configuration "
"and database credentials), which goes a long way towards creating secured "
"applications."
msgstr ""
"Vault "
"拡張機能を通して今日公開された機能は、製品ができることのほんの一部をカバーしているに過ぎません。しかし、最も一般的なマイクロサービスのいくつか（機密性の高い設定やデータベースの資格情報など）にはすでに対応しており、これは安全なアプリケーションの作成に向けた長い道のりとなっています。"

#. type: Plain text
#: upstream/_guides/vault.adoc:520
#, fuzzy
msgid "https://www.vaultproject.io/[HashiCorp Vault]"
msgstr "link:https://www.vaultproject.io/[ハシコープボールト]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/deploying-to-google-cloud.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Deploying to Google Cloud Platform (GCP)"
msgstr "Quarkus - Google Cloud Platform（GCP）へのデプロイメント"

#. type: Title ==
#: upstream/_guides/deploying-to-google-cloud.adoc:13
#: upstream/_guides/deploying-to-google-cloud.adoc:33
#, no-wrap, fuzzy
msgid "Login to Google Cloud"
msgstr "Googleクラウドにログイン"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:14
#, fuzzy
msgid "Deploying a function to Google Cloud Functions"
msgstr "Googleクラウド機能に機能をデプロイする"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:15
#, fuzzy
msgid "Deploying a JAR to Google App Engine Standard"
msgstr "JARをGoogle App Engine標準にデプロイする"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:16
#, fuzzy
msgid "Deploying a Docker image to Google App Engine Flexible Custom Runtimes"
msgstr "DockerイメージをGoogle App Engineにデプロイする 柔軟なカスタムランタイム"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:17
#, fuzzy
msgid "Deploying a Docker image to Google Cloud Run"
msgstr "DockerイメージをGoogle Cloud Runにデプロイする"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:21
#, fuzzy
msgid "For this guide you need:"
msgstr "このガイドには、あなたが必要です。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:23
#, fuzzy
msgid "Roughly 1 hour for all modalities"
msgstr "すべてのモダリティで約1時間"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:24
#, fuzzy
msgid "JDK 11"
msgstr "JDK 11"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:26
#, fuzzy
msgid ""
"https://cloud.google.com/[A Google Cloud Account].  Free accounts work."
msgstr "link:https://cloud.google.com/[Googleクラウドのアカウントです]。無料アカウントの仕事。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:27
#, fuzzy
msgid "https://cloud.google.com/sdk[Cloud SDK CLI Installed]"
msgstr "link:https://cloud.google.com/sdk[クラウドSDK CLIがインストールされている]"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:29
#, fuzzy
msgid ""
"This guide will take as input an application developed in the link:getting-"
"started[Getting Started guide]."
msgstr "このガイドでは、 link:getting-started[入門ガイド]で開発されたアプリケーションを入力として使用します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:32
#, fuzzy
msgid ""
"Make sure you have the getting-started application at hand, or clone the Git "
"repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-"
"archive-url}[archive]. The solution is located in the `getting-started` "
"directory."
msgstr ""
"手元に get-started アプリケーションがあることを確認するか、Git リポジトリをクローンします: `git clone "
"{quickstarts-clone-url}` 、もしくは {quickstarts-archive-url}[archive] "
"をダウンロードしてください。ソリューションは `getting-started` ディレクトリにあります。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:36
#, fuzzy
msgid ""
"Login to Google Cloud is necessary for deploying the application and it can "
"be done as follows:"
msgstr "アプリケーションのデプロイにはGoogle Cloudへのログインが必要で、以下のように行います。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:40
#, no-wrap
msgid "gcloud auth login\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/deploying-to-google-cloud.adoc:42
#, no-wrap, fuzzy
msgid "Deploying to Google Cloud Functions"
msgstr "Googleクラウド機能へのデプロイ"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:45
#, fuzzy
msgid ""
"Quarkus supports deploying your application to Google Cloud Functions via "
"the following extensions:"
msgstr ""
"Quarkusは、次の拡張機能を使用して、アプリケーションをGoogle Cloud Functionsにデプロイすることをサポートしています。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:47
#, fuzzy
msgid ""
"link:gcp-functions[Google Cloud Functions]: Build functions using the Google "
"Cloud Functions API."
msgstr ""
"link:gcp-functions[Google Cloud Functions]。Google Cloud Functions API "
"を使用して関数を構築します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:49
#, fuzzy
msgid ""
"link:gcp-functions-http[Google Cloud Functions HTTP binding]: Build "
"functions using Quarkus HTTP APIs: RESTEasy (JAX-RS), Undertow (Servlet), "
"Vert.x Web, or link:funqy-http[Funqy HTTP]."
msgstr ""
"link:gcp-functions-http[Google Cloud Functions HTTPバインディング]。Quarkus HTTP "
"APIを使用して関数を構築できます。RESTEasy（JAX-RS）、Undertow（サーブレット）、Vert.x Web、または link:"
"funqy-http[Funqy HTTP]。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:50
#, fuzzy
msgid ""
"link:funqy-gcp-functions[Funky Google Cloud Functions]: Build functions "
"using Funqy."
msgstr "link:funqy-gcp-functions[ファンキーなGoogle Cloudの関数]。Funqyを使って関数を構築します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:53
#, fuzzy
msgid ""
"Each extension supports a specific kind of application development, follow "
"the specific guides for more information on how to develop, package and "
"deploy your applications using them."
msgstr ""
"各拡張機能は特定の種類のアプリケーション開発をサポートしており、それらを使用してアプリケーションを開発、パッケージ化、デプロイする方法の詳細については、特定のガイドに従ってください。"

#. type: Title ==
#: upstream/_guides/deploying-to-google-cloud.adoc:54
#, no-wrap, fuzzy
msgid "Deploying to Google App Engine Standard"
msgstr "Google App Engine Standardへのデプロイ"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:57
#, fuzzy
msgid ""
"We will only cover the Java 11 runtime as the Java 8 runtime uses its own "
"Servlet engine which is not compatible with Quarkus."
msgstr ""
"Java 8ランタイムはQuarkusと互換性のない独自のサーブレットエンジンを使用しているため、Java 11ランタイムのみをカバーします。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:59
#, fuzzy
msgid ""
"First of all, make sure to have an App Engine environment initialized for "
"your Google Cloud project, if not, initialize one via `gcloud app create --"
"project=[YOUR_PROJECT_ID]`."
msgstr ""
"`gcloud app create --project=[YOUR_PROJECT_ID]`まず最初に、Google Cloud プロジェクト用に "
"App Engine 環境が初期化されていることを確認します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:61
#, fuzzy
msgid ""
"Then, you will need to create a `src/main/appengine/app.yaml` file, let's "
"keep it minimalistic with only the selected engine:"
msgstr ""
"次に、 `src/main/appengine/app.yaml` "
"ファイルを作成する必要がありますが、選択したエンジンだけで最低限のものにしておきましょう。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:65
#, no-wrap
msgid "runtime: java11\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:68
#, fuzzy
msgid "This will create a default service for your App Engine application."
msgstr "これにより、App Engineアプリケーションのデフォルトサービスが作成されます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:70
#, fuzzy
msgid ""
"Then, you can choose to build the application by yourself or letting "
"`gcloud` or the Google Cloud Maven plugin build it for you."
msgstr ""
"その後、自分でアプリケーションを構築するか、 `gcloud` または Google Cloud Maven プラグインに構築を任せるかを選択できます。"

#. type: Title ===
#: upstream/_guides/deploying-to-google-cloud.adoc:71
#, no-wrap, fuzzy
msgid "Building the application manually"
msgstr "アプリケーションを手動で構築する"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:74
#, fuzzy
msgid ""
"Set up your application to be packaged as an uber-jar via your `application."
"properties` file:"
msgstr ""
"`application.properties` ファイルを介して、アプリケーションをuber-jarとしてパッケージ化するように設定します。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:78
#, no-wrap
msgid "quarkus.package.type=uber-jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:81
#, fuzzy
msgid ""
"Use Maven to build the application using `mvn clean package`, it will "
"generate a single JAR that contains all the classes of your application "
"including its dependencies."
msgstr ""
"`mvn clean package` を使用してアプリケーションを構築するために Maven を使用します。 "
"を使用すると、依存関係を含むアプリケーションのすべてのクラスを含む単一の JAR を生成します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:83
#, fuzzy
msgid ""
"Finally, use `gcloud` to deploy your application as an App Engine service."
msgstr "最後に、 `gcloud` を使用して、アプリケーションを App Engine サービスとしてデプロイします。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:87
#, no-wrap
msgid "gcloud app deploy target/getting-started-1.0-SNAPSHOT-runner.jar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:90
#, fuzzy
msgid ""
"This command will upload your application jar and launch it on App Engine."
msgstr "このコマンドは、アプリケーション jar をアップロードし、App Engine で起動します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:92
#: upstream/_guides/deploying-to-google-cloud.adoc:101
#: upstream/_guides/deploying-to-google-cloud.adoc:163
#, fuzzy
msgid ""
"When done, the output will display the URL of your application (target url), "
"you can use it with curl or directly open it in your browser using `gcloud "
"app browse`."
msgstr "`gcloud app browse`完了すると、出力にはアプリケーションの URL (ターゲット URL) が表示されます。"

#. type: Title ===
#: upstream/_guides/deploying-to-google-cloud.adoc:93
#, no-wrap, fuzzy
msgid "Building the application via gcloud"
msgstr "gcloud経由でアプリケーションを構築する"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:96
#, fuzzy
msgid ""
"You can choose to let `gcloud` build your application for you, this is the "
"simplest way to deploy to App Engine."
msgstr "`gcloud` にアプリケーションを構築させることができます。これは App Engine にデプロイする最もシンプルな方法です。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:99
#, fuzzy
msgid ""
"Just launch `gcloud app deploy` in the root of your project, it will upload "
"all your project files (the list can be reduced via the `.gcloudignore` "
"file), package your JAR via Maven (or Gradle) and launch it on App Engine."
msgstr ""
"プロジェクトのルートで `gcloud app deploy` を起動するだけで、すべてのプロジェクトファイルをアップロードし（ `."
"gcloudignore` ファイルを介してリストを減らすことができます）、Maven（または Gradle）を介して JAR をパッケージ化し、App "
"Engine で起動します。"

#. type: Title ===
#: upstream/_guides/deploying-to-google-cloud.adoc:102
#, no-wrap, fuzzy
msgid "Building the application via the Google Cloud Maven plugin"
msgstr "Google Cloud Mavenプラグインを介したアプリケーションの構築"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:105
#, fuzzy
msgid ""
"You can also let Maven control the deployment of your application using the "
"App Engine Maven plugin."
msgstr "また、App Engine Mavenプラグインを使用して、Mavenでアプリケーションのデプロイを制御することもできます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:107
#, fuzzy
msgid "First, add the plugin to your `pom.xml`:"
msgstr "まず、プラグインを `pom.xml` に追加します。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:120
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>com.google.cloud.tools</groupId>\n"
"    <artifactId>appengine-maven-plugin</artifactId>\n"
"    <version>2.4.0</version>\n"
"    <configuration>\n"
"        <projectId>GCLOUD_CONFIG</projectId> <1>\n"
"        <version>gettingstarted</version>\n"
"        <artifact>${project.build.directory}/getting-started-${project."
"version}-runner.jar</artifact> <2>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:123
#, fuzzy
msgid "Use the default `gcloud` configuration"
msgstr "デフォルトの `gcloud` 設定を使用します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:124
#, fuzzy
msgid ""
"Override the default JAR name to the one generated by the Quarkus Maven "
"plugin"
msgstr "デフォルトのJAR名を、Quarkus Mavenプラグインによって生成されたものにオーバーライドします。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:126
#, fuzzy
msgid ""
"Then you would be able to use Maven to build and deploy your application to "
"App Engine via `mvn clean package appengine:deploy`."
msgstr ""
"その後、Mavenを使用してアプリケーションを構築し、 `mvn clean package appengine:deploy` を経由してApp "
"Engineにデプロイすることができます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:128
#, fuzzy
msgid ""
"When it’s done, the output will display the URL of your application (target "
"URL), you can use it with curl or directly open it in your browser using "
"`gcloud app browse`."
msgstr "`gcloud app browse`それが完了すると、出力にはアプリケーションの URL (ターゲット URL) が表示されます。"

#. type: Title ==
#: upstream/_guides/deploying-to-google-cloud.adoc:129
#, no-wrap, fuzzy
msgid "Deploying to Google App Engine Flexible Custom Runtimes"
msgstr "Google App Engineへのデプロイメント 柔軟なカスタム ランタイム"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:132
#, fuzzy
msgid ""
"Before all, make sure to have an App Engine environment initialized for your "
"Google Cloud project, if not, initialize one via `gcloud app create --"
"project=[YOUR_PROJECT_ID]`."
msgstr ""
"`gcloud app create --project=[YOUR_PROJECT_ID]`その前に、Google Cloud プロジェクト用に "
"App Engine 環境が初期化されていることを確認してください。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:134
#, fuzzy
msgid ""
"App Engine Flexible Custom Runtimes uses a Docker image to run your "
"application."
msgstr "App Engine Flexible Custom RuntimesはDockerイメージを使用してアプリケーションを実行します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:136
#, fuzzy
msgid ""
"First, create an `app.yaml` file at the root of your project with the "
"following content:"
msgstr "まず、プロジェクトのルートに以下の内容の `app.yaml` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:141
#, no-wrap
msgid "runtime: custom\n"
"env: flex\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:144
#, fuzzy
msgid ""
"App Engine Flexible Custom Runtimes deploys your application as a Docker "
"container, you can choose to deploy one of the Dockerfile provided inside "
"your application."
msgstr ""
"App Engine Flexible Custom "
"Runtimesは、アプリケーションをDockerコンテナとしてデプロイしますが、アプリケーション内で提供されるDockerfileのいずれかを選択してデプロイすることができます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:146
#: upstream/_guides/deploying-to-google-cloud.adoc:177
#, fuzzy
msgid "Both JVM and native executable versions will work."
msgstr "JVM版とネイティブ実行ファイル版の両方が動作します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:148
#: upstream/_guides/deploying-to-google-cloud.adoc:179
#, fuzzy
msgid "To deploy a JVM application:"
msgstr "JVMアプリケーションをデプロイするには"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:150
#: upstream/_guides/deploying-to-google-cloud.adoc:181
#, fuzzy
msgid ""
"Copy the JVM Dockerfile to the root directory of your project: `cp src/main/"
"docker/Dockerfile.jvm Dockerfile`."
msgstr ""
"JVMのDockerfileをプロジェクトのルートディレクトリにコピーします: `cp src/main/docker/Dockerfile.jvm "
"Dockerfile`."

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:151
#: upstream/_guides/deploying-to-google-cloud.adoc:182
#, fuzzy
msgid "Build your application using `mvn clean package`."
msgstr "`mvn clean package` を使用してアプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:153
#: upstream/_guides/deploying-to-google-cloud.adoc:184
#, fuzzy
msgid "To deploy a native application:"
msgstr "ネイティブアプリケーションをデプロイするには"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:155
#: upstream/_guides/deploying-to-google-cloud.adoc:186
#, fuzzy
msgid ""
"Copy the native Dockerfile to the root directory of your project: `cp src/"
"main/docker/Dockerfile.native Dockerfile`."
msgstr ""
"ネイティブのDockerfileをプロジェクトのルートディレクトリにコピーします: `cp src/main/docker/Dockerfile."
"native Dockerfile`."

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:156
#: upstream/_guides/deploying-to-google-cloud.adoc:187
#, fuzzy
msgid ""
"Build your application as a native executable using `mvn clean package -"
"Dnative`."
msgstr "`mvn clean package -Dnative` を使用して、アプリケーションをネイティブ実行ファイルとしてビルドします。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:159
#, fuzzy
msgid ""
"Finally, launch `gcloud app deploy` in the root of your project, it will "
"upload all your project files (the list can be reduced via the `."
"gcloudignore` file), build your Dockerfile and launch it on App Engine "
"Flexible custom runtime."
msgstr ""
"最後に、プロジェクトのルートで `gcloud app deploy` を起動すると、すべてのプロジェクトファイルをアップロードし（ `."
"gcloudignore` ファイルを介してリストを縮小することができます）、Dockerfile をビルドし、App Engine Flexible "
"カスタムランタイム上で起動します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:161
#, fuzzy
msgid ""
"It uses Cloud Build to build your Docker image and deploy it to Google "
"Container Registry (GCR)."
msgstr ""
"Cloud Buildを使用してDockerイメージを構築し、Google Container Registry（GCR）にデプロイします。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:166
#, fuzzy
msgid ""
"App Engine Flexible custom runtimes support link:https://cloud.google.com/"
"appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-"
"yaml#updated_health_checks[health checks], it is strongly advised to provide "
"them thanks to Quarkus link:microprofile-health[Microprofile Health] support."
""
msgstr ""
"App Engine Flexibleカスタムランタイムは link:https://cloud.google.com/appengine/docs/"
"flexible/custom-runtimes/configuring-your-app-with-app-"
"yaml#updated_health_checks[ヘルスチェックを]サポートしていますが、Quarkus link:microprofile-"
"health[Microprofile Health]のサポートにより、ヘルス link:https://cloud.google.com/"
"appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-"
"yaml#updated_health_checks[チェックを]提供することを強くお勧めします。"

#. type: Title ==
#: upstream/_guides/deploying-to-google-cloud.adoc:167
#, no-wrap, fuzzy
msgid "Deploying to Google Cloud Run"
msgstr "Google Cloud Runへのデプロイ"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:170
#, fuzzy
msgid ""
"Google Cloud Run allows you to run your Docker containers inside Google "
"Cloud Platform in a managed way."
msgstr ""
"Google Cloud Runでは、Google Cloud Platform内でDockerコンテナを管理された方法で実行することができます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:173
#, fuzzy
msgid ""
"By default, Quarkus listens on port 8080, and it's also the Cloud Run "
"default port.  No need to use the `PORT` environment variable defined in "
"Cloud Run to customize the Quarkus HTTP port."
msgstr ""
"デフォルトでは、Quarkusは8080番ポートをリッスンし、これはCloud Runのデフォルトポートでもあります。Cloud "
"Runで定義された環境変数 `PORT` を使用して、QuarkusのHTTPポートをカスタマイズする必要はありません。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:175
#, fuzzy
msgid ""
"Cloud Run will use Cloud Build to build your Docker image and deploy it to "
"Google Container Registry (GCR)."
msgstr ""
"Cloud RunはCloud Buildを使用してDockerイメージを構築し、Google Container "
"Registry（GCR）にデプロイします。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:190
#, fuzzy
msgid ""
"Then, create a `.gcloudignore` file to tell gcloud which files should be not "
"be uploaded for Cloud Build, without it, it defaults to `.gitignore` that "
"usually exclude the target directory where you packaged application has been "
"created."
msgstr ""
"次に、Cloud Buildのためにアップロードすべきでないファイルをgcloudに伝えるための `.gcloudignore` "
"ファイルを作成します。これがない場合、デフォルトは `.gitignore` "
"で、通常はパッケージ化されたアプリケーションが作成されたターゲットディレクトリを除外します。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:192
#, fuzzy
msgid "In this example, I only exclude the `src` directory:"
msgstr "この例では、 `src` ディレクトリだけを除外しています。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:196
#, no-wrap
msgid "src/\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:200
#, fuzzy
msgid ""
"Then, use Cloud Build to build your image, it will upload to a Google Cloud "
"Storage bucket all the files of your application (except the ones ignored by "
"the `.gcloudignore`file), build your Docker image and push it to Google "
"Container Registry (GCR)."
msgstr ""
"その後、Cloud Buildを使ってイメージをビルドすると、アプリケーションのすべてのファイル（`."
"gcloudignore`fileで無視されたファイルを除く）をGoogle Cloud "
"Storageバケットにアップロードし、DockerイメージをビルドしてGoogle Container Registry (GCR)にプッシュします。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:204
#, no-wrap
msgid "gcloud builds submit --tag gcr.io/PROJECT-ID/helloworld\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:207
#, fuzzy
msgid ""
"You can also build your image locally and push it to a publicly accessible "
"Docker registry, then use this image in the next step."
msgstr ""
"また、イメージをローカルにビルドして、公開されているDockerレジストリにプッシュし、次のステップでこのイメージを使用することもできます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:209
#, fuzzy
msgid "Finally, use Cloud Run to launch your application."
msgstr "最後に、Cloud Runを使ってアプリケーションを起動します。"

#. type: delimited block -
#: upstream/_guides/deploying-to-google-cloud.adoc:213
#, no-wrap
msgid ""
"gcloud run deploy --image gcr.io/PROJECT-ID/helloworld --platform managed\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:217
#, fuzzy
msgid ""
"Cloud run will ask you questions on the service name, the region and whether "
"or not unauthenticated calls are allowed.  After you answer to these "
"questions, it will deploy your application."
msgstr ""
"Cloud run "
"は、サービス名、リージョン、認証されていない通話が許可されているかどうかについて質問をします。これらの質問に答えると、アプリケーションがデプロイされます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:219
#, fuzzy
msgid ""
"When the deployment is done, the output will display the URL to access your "
"application."
msgstr "デプロイが完了すると、出力にはアプリケーションにアクセスするためのURLが表示されます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:224
#, fuzzy
msgid ""
"You can find a set of extensions to access various Google Cloud Services in "
"the Quarkiverse (a GitHub organization for Quarkus extensions maintained by "
"the community), including PubSub, BigQuery, Storage, Spanner, Firestore "
"(visit the repository for an accurate list of supported services)."
msgstr ""
"PubSub、BigQuery、Storage、Spanner、Firestore（サポートされているサービスの正確なリストはリポジトリを参照してください）など、さまざまなGoogle "
"Cloud "
"Servicesにアクセスするための拡張機能のセットをQuarkiverse（コミュニティによってメンテナンスされているQuarkus拡張機能のためのGitHub組織）で見つけることができます。"

#. type: Plain text
#: upstream/_guides/deploying-to-google-cloud.adoc:225
#, fuzzy
msgid ""
"You can find some documentation about them in the link:https://github.com/"
"quarkiverse/quarkiverse-google-cloud-services[Quarkiverse Google Cloud "
"Services repository]."
msgstr ""
"これらについてのドキュメントは、 link:https://github.com/quarkiverse/quarkiverse-google-"
"cloud-services[QuarkiverseのGoogle Cloud Servicesリポジトリ]にあります。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/writing-extensions.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Writing Your Own Extension"
msgstr "Quarkus - 独自の拡張機能の作成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:16
#, fuzzy
msgid ""
"Quarkus extensions add a new developer focused behavior to the core "
"offering, and consist of two distinct parts, buildtime augmentation and "
"runtime container. The augmentation part is responsible for all metadata "
"processing, such as reading annotations, XML descriptors etc. The output of "
"this augmentation phase is recorded bytecode which is responsible for "
"directly instantiating the relevant runtime services."
msgstr ""
"Quarkusの拡張機能は、コアサービスに開発者向けの新しい動作を追加したもので、ビルド時の拡張とランタイムコンテナという2つの異なる部分から構成されています。拡張部分は、アノテーションやXML記述子の読み込みなど、すべてのメタデータ処理を担当します。この拡張フェーズの出力は、関連するランタイムサービスを直接インスタンス化するためのバイトコードとして記録されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:19
#, fuzzy
msgid ""
"This means that metadata is only processed once at build time, which both "
"saves on startup time, and also on memory usage as the classes etc that are "
"used for processing are not loaded (or even present) in the runtime JVM."
msgstr ""
"これは、メタデータがビルド時に一度だけ処理されることを意味し、起動時間の節約と、処理に使用されるクラスなどがランタイムJVMにロードされない（あるいは存在しない）ため、メモリ使用量の節約の両方を実現しています。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:20
#, no-wrap, fuzzy
msgid "Extension philosophy"
msgstr "拡張哲学"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:23
#, fuzzy
msgid ""
"This section is a work in progress and gathers the philosophy under which "
"extensions should be designed and written."
msgstr "このセクションは現在進行形の作業であり、拡張機能がどのように設計され、どのように書かれるべきかの哲学を集めたものです。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:24
#, no-wrap, fuzzy
msgid "Why an extension framework"
msgstr "なぜ拡張フレームワークなのか"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:30
#, fuzzy
msgid ""
"Quarkus’s mission is to transform your entire application including the "
"libraries it uses, into an artifact that uses significantly less resources "
"than traditional approaches. These can then be used to build native "
"applications using GraalVM.  To do this you need to analyze and understand "
"the full \"closed world\" of the application.  Without the full and complete "
"context, the best that can be achieved is partial and limited generic "
"support.  By using the Quarkus extension approach, we can bring Java "
"applications in line with memory footprint constrained environments like "
"Kubernetes or cloud platforms."
msgstr ""
"Quarkusの使命は、使用するライブラリを含むアプリケーション全体を、従来のアプローチよりも大幅に少ないリソースしか使用しない人工物に変換することです。これらを使用して、GraalVMを使用してネイティブアプリケーションを構築することができます。これを行うためには、アプリケーションの完全な「クローズドワールド」を分析し、理解する必要があります。完全で完全なコンテキストがなければ、最高のものは部分的で限定的なジェネリックサポートです。Quarkusの拡張アプローチを使用することで、Kubernetesやクラウドプラットフォームのようなメモリフットプリントに制約のある環境に合わせてJavaアプリケーションを導入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:33
#, fuzzy
msgid ""
"The Quarkus extension framework results in significantly improved resource "
"utilization even when GraalVM is not used (e.g. in HotSpot).  Let’s list the "
"actions an extension performs:"
msgstr ""
"Quarkus拡張フレームワークは、GraalVMを使用していない場合でも（HotSpotなど）、リソース利用率を大幅に改善します。拡張機能が実行するアクションをリストアップしてみましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:35
#, fuzzy
msgid "Gather build time metadata and generate code"
msgstr "ビルド時のメタデータを収集し、コードを生成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:36
#, fuzzy
msgid ""
"This part has nothing to do with GraalVM, it is how Quarkus starts "
"frameworks “at build time”"
msgstr "この部分はGraalVMとは何の関係もありませんが、Quarkusがフレームワークを\"ビルド時に\"起動する方法です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:37
#, fuzzy
msgid ""
"The extension framework facilitates reading metadata, scanning classes as "
"well as generating classes as needed"
msgstr "拡張フレームワークは、必要に応じてメタデータの読み込み、クラスのスキャン、クラスの生成を容易にします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:38
#, fuzzy
msgid ""
"A small part of the extension work is executed at runtime via the generated "
"classes, while the bulk of the work is done at build time (called deployment "
"time)"
msgstr "拡張作業のごく一部は生成されたクラスを介して実行時に実行され、作業の大部分はビルド時に行われます (デプロイメント時と呼ばれます)"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:39
#, fuzzy
msgid ""
"Enforce opinionated and sensible defaults based on the close world view of "
"the application (e.g. an application with no `@Entity` does not need to "
"start Hibernate ORM)"
msgstr ""
"アプリケーションの近い世界観に基づいて、意見を述べた賢明なデフォルトを強制する（例えば、 `@Entity` "
"のないアプリケーションは、Hibernate ORM を起動する必要はありません）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:40
#, fuzzy
msgid ""
"An extension hosts Substrate VM code substitution so that libraries can run "
"on GraalVM"
msgstr "拡張機能は Substrate VM のコード置換をホストし、ライブラリを GraalVM 上で実行できるようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:41
#, fuzzy
msgid ""
"Most changes are pushed upstream to help the underlying library run on "
"GraalVM"
msgstr "ほとんどの変更は、基礎となるライブラリがGraalVM上で動作するように上流にプッシュされます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:42
#, fuzzy
msgid ""
"Not all changes can be pushed upstream, extensions host Substrate VM "
"substitutions - which is a form of code patching - so that libraries can run"
msgstr ""
"すべての変更を上流にプッシュできるわけではなく、拡張機能は Substrate VM 置換をホストしており、これはコードパッチの一形態です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:43
#, fuzzy
msgid ""
"Host Substrate VM code substitution to help dead code elimination based on "
"the application needs"
msgstr "ホスト基板VMのコード置換により、アプリケーションのニーズに基づいたデッドコードの排除を支援します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:44
#, fuzzy
msgid ""
"This is application dependant and cannot really be shared in the library "
"itself"
msgstr "これはアプリケーションに依存しており、ライブラリ自体で共有することはできません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:45
#, fuzzy
msgid ""
"For example, Quarkus optimizes the Hibernate code because it knows it only "
"needs a specific connection pool and cache provider"
msgstr ""
"たとえば、Quarkusは、特定の接続プールとキャッシュプロバイダだけが必要であることを知っているため、Hibernateコードを最適化します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:46
#, fuzzy
msgid "Send metadata to GraalVM for example classes in need of reflection"
msgstr "メタデータをGraalVMに送信します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:47
#, fuzzy
msgid ""
"This information is not static per library (e.g. Hibernate) but the "
"framework has the semantic knowledge and knows which classes need to have "
"reflection (for example @Entity classes)"
msgstr ""
"この情報はライブラリ(Hibernateなど)ごとに静的ではありませんが、フレームワークはセマンティックな知識を持っており、どのクラスがリフレクションを必要とするかを知っています(例えば@Entityクラスなど)。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:48
#, no-wrap, fuzzy
msgid "Favor build time work over runtime work"
msgstr "ランタイムワークよりもビルドタイムワークを好む"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:52
#, fuzzy
msgid ""
"As much as possible favor doing work at build time (deployment part of the "
"extension) as opposed to let the framework do work at startup time (runtime)."
"  The more is done there, the smaller Quarkus applications using that "
"extension will be and the faster they will load."
msgstr ""
"可能な限り、フレームワークに起動時（ランタイム）に作業をさせるのではなく、ビルド時（拡張機能のデプロイメント部分）に作業を行うことをお勧めします。そこでの作業が多いほど、その拡張機能を使用しているQuarkusアプリケーションは小さくなり、ロードが速くなります。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:53
#, no-wrap, fuzzy
msgid "How to expose configuration"
msgstr "設定を公開する方法"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:57
#, fuzzy
msgid ""
"Quarkus simplifies the most common usages.  This means that its defaults "
"might be different than the library it integrates."
msgstr "Quarkusは、最も一般的な使用法を簡略化しています。つまり、そのデフォルトは、統合されているライブラリとは異なる場合があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:60
#, fuzzy
msgid ""
"To make the simple experience easiest, unify the configuration in "
"`application.properties` via MicroProfile Config.  Avoid library specific "
"configuration files, or at least make them optional: e.g. `persistence.xml` "
"for Hibernate ORM is optional."
msgstr ""
"シンプルな体験を最も簡単にするために、MicroProfile Configを経由して `application.properties` "
"で設定を統一してください。ライブラリ固有の設定ファイルは避けるか、少なくともオプションにしてください: 例: `persistence.xml` の "
"Hibernate ORM はオプションです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:65
#, fuzzy
msgid ""
"Extensions should see the configuration holistically as a Quarkus "
"application instead of focusing on the library experience.  For example "
"`quarkus.database.url` and friends are shared between extensions as defining "
"a database access is a shared task (instead of a `hibernate.` property for "
"example).  The most useful configuration options should be exposed as "
"`quarkus.[extension].` instead of the natural namespace of the library.  "
"Less common properties can live in the library namespace."
msgstr ""
"拡張機能は、ライブラリエクスペリエンスに焦点を当てるのではなく、Quarkusアプリケーションとして全体的に設定を見るべきです。例えば、データベースアクセスの定義が共有タスクであるように、 "
"`quarkus.database.url` とフレンドは拡張機能間で共有されます（例えば `hibernate.` "
"プロパティの代わりに）。最も便利な設定オプションは、ライブラリの自然な名前空間ではなく、 `quarkus.[extension].` "
"として公開されるべきです。あまり一般的ではないプロパティは、ライブラリの名前空間に置くことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:69
#, fuzzy
msgid ""
"To fully enable the close world assumptions that Quarkus can optimize best, "
"it is better to consider configuration options as build time settled vs "
"overridable at runtime.  Of course properties like host, port, password "
"should be overridable at runtime.  But many properties like enable caching "
"or setting the JDBC driver can safely require a rebuild of the application."
msgstr ""
"Quarkusが最適化できるクローズワールドの仮定を完全に有効にするためには、ビルド時に設定された設定オプションと実行時にオーバーライド可能な設定オプションを検討するのが良いでしょう。もちろん、ホスト、ポート、パスワードなどのプロパティは、実行時にオーバーライド可能でなければなりません。しかし、キャッシングを有効にしたり、JDBCドライバを設定したりするような多くのプロパティは、アプリケーションの再構築を安全に要求することができます。"

# 
# 
# 
#. === API
#. TODO: Describe where to put APIs
#. I wonder if that content should be in the technical aspects
#. === Substitution and recorders
#. TODO: Describe where Substitutions and recorders should live
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:81
#, no-wrap, fuzzy
msgid "Expose your components via CDI"
msgstr "CDI経由でコンポーネントを公開"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:86
#, fuzzy
msgid ""
"Since CDI is the central programming model when it comes to component "
"composition, frameworks and extensions should expose their components as "
"beans that are easily consumable by user applications.  For example, "
"Hibernate ORM exposes `EntityManagerFactory` and `EntityManager` beans, the "
"connection pool exposes `DataSource` beans etc.  Extensions must register "
"these bean definitions at build time."
msgstr ""
"CDI "
"はコンポーネントの構成に関しては中心的なプログラミングモデルであるため、フレームワークや拡張機能はそのコンポーネントを、ユーザアプリケーションが容易に消費できる豆として公開しなければなりません。例えば、Hibernate "
"ORM は `EntityManagerFactory` と `EntityManager` のビーンを公開し、接続プールは `DataSource` "
"のビーンを公開します。拡張機能は、ビルド時にこれらのビーン定義を登録しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:87
#, no-wrap, fuzzy
msgid "Beans backed by classes"
msgstr "クラスに裏付けられた豆"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:90
#, fuzzy
msgid ""
"An extension can produce an <<cdi-reference."
"adoc#additional_beans,`AdditionalBeanBuildItem`>> to instruct the container "
"to read a bean definition from a class as if it was part of the original "
"application:"
msgstr ""
"拡張機能は  link:cdi-reference."
"html#additional_beans[`AdditionalBeanBuildItem`]コンテナに、元のアプリケーションの一部であるかのようにクラスからビーンの定義を読み込むように指示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:91
#, no-wrap, fuzzy
msgid "Bean Class Registered by `AdditionalBeanBuildItem`"
msgstr "登録されている豆クラス `AdditionalBeanBuildItem`"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:96
#, no-wrap
msgid "@Singleton <1>\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:101
#, no-wrap
msgid "   public String echo(String val) {\n"
"      return val;\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:103
#, fuzzy
msgid ""
"If a bean registered by an `AdditionalBeanBuildItem` does not specify a "
"scope then `@Dependent` is assumed."
msgstr "`AdditionalBeanBuildItem` で登録されたビーンがスコープを指定しない場合は `@Dependent` とする。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:105
#, fuzzy
msgid "All other beans can inject such a bean:"
msgstr "他のすべての豆は、このような豆を注入することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:106
#, no-wrap, fuzzy
msgid "Bean Injecting a Bean Produced by an `AdditionalBeanBuildItem`"
msgstr "によって製造された豆を注入する。 `AdditionalBeanBuildItem`"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:249
#, no-wrap
msgid "@Path(\"/hello\")\n"
"public class ExampleResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:114
#, no-wrap
msgid "    @Inject\n"
"    Echo echo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:121
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello(String foo) {\n"
"        return echo.echo(foo);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:124
#, fuzzy
msgid ""
"And vice versa - the extension bean can inject application beans and beans "
"provided by other extensions:"
msgstr "また、その逆もまた然り - 拡張機能ビーンは、他の拡張機能によって提供されるアプリケーションビーンやビーンを注入することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:125
#, no-wrap, fuzzy
msgid "Extension Bean Injection Example"
msgstr "拡張豆の注入例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:130
#, no-wrap
msgid "@Singleton\n"
"public class Echo {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:133
#, no-wrap
msgid "    @Inject\n"
"    DataSource dataSource;  <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:136
#, no-wrap
msgid "    @Inject\n"
"    Instance<List<String>> listsOfStrings; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:139
#, no-wrap
msgid "    //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:141
#, fuzzy
msgid "Inject a bean provided by other extension."
msgstr "他の拡張機能で提供されているビーンをインジェクトします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:142
#, fuzzy
msgid "Inject all beans matching the type `List<String>`."
msgstr "タイプ `List&amp;lt;String&amp;gt;` に一致するすべてのビーンズを注入します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:144
#, no-wrap, fuzzy
msgid "Bean initialization"
msgstr "Beanの初期化"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:151
#, fuzzy
msgid ""
"Some components may require additional initialization based on information "
"collected during augmentation.  The most straightforward solution is to "
"obtain a bean instance and call a method directly from a build step.  "
"However, it is _illegal_ to obtain a bean instance during the augmentation "
"phase.  The reason is that the CDI container is not started yet.  It's "
"started during the <<bootstrap-three-phases,Static init bootstrap phase>>."
msgstr ""
"コンポーネントによっては、オーグメンテーション中に収集された情報に基づいて、追加の初期化が必要になる場合があります。最も簡単な解決策は、ビーンのインスタンスを取得し、ビルドステップから直接メソッドを呼び出すことです。しかし、増強フェーズ中にBeanインスタンスを取得することは "
"_違法_です。理由は、CDIコンテナがまだ起動していないからです。 link:#bootstrap-three-phases[Static "
"initのブートストラップフェーズの]間に起動されています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:153
#, fuzzy
msgid ""
"`BUILD_AND_RUN_TIME_FIXED` and `RUN_TIME` config roots can be injected in "
"any bean. `RUN_TIME` config roots should only be injected after the "
"bootstrap though."
msgstr ""
"`BUILD_AND_RUN_TIME_FIXED` と `RUN_TIME` config roots は、どのBeanにも注入することができます。 "
"`RUN_TIME` config roots は、ブートストラップの後にのみ注入すべきです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:159
#, fuzzy
msgid ""
"It is possible to invoke a bean method from a <<bytecode-recording,recorder "
"method>> though.  If you need to access a bean in a `@Record(STATIC_INIT)` "
"build step then is must either depend on the `BeanContainerBuildItem` or "
"wrap the logic in a `BeanContainerListenerBuildItem`.  The reason is simple -"
" we need to make sure the CDI container is fully initialized and started.  "
"However, it is safe to expect that the CDI container is fully initialized "
"and running in a `@Record(RUNTIME_INIT)` build step.  You can obtain a "
"reference to the container via `CDI.current()` or Quarkus-specific `Arc."
"container()`."
msgstr ""
"しかし、 link:#bytecode-recording[レコーダメソッド]からビーンメソッドを呼び出すことは可能です。 "
"`@Record(STATIC_INIT)` ビルドステップでビーンにアクセスする必要がある場合は、 `BeanContainerBuildItem` "
"に依存するか、 `BeanContainerListenerBuildItem` "
"でロジックをラップしなければなりません。理由は簡単で、CDIコンテナが完全に初期化されて起動していることを確認する必要があるからです。しかし、CDI "
"コンテナは `@Record(RUNTIME_INIT)` "
"ビルドステップで完全に初期化されて実行されていると思っておいた方が安全です。コンテナへの参照は、 `CDI.current()` "
"またはQuarkus固有の `Arc.container()`."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:161
#, fuzzy
msgid ""
"Don't forget to make sure the bean state guarantees the visibility, e.g. via "
"the `volatile` keyword."
msgstr "`volatile` ビーンの状態が可視性を保証していることを確認することを忘れないでください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:165
#, fuzzy
msgid ""
"There is one significant drawback of this \"late initialization\" approach.  "
"An _uninitialized_ bean may be accessed by other extensions or application "
"components that are instantiated during bootstrap.  We'll cover a more "
"robust solution in the <<synthetic_beans>>."
msgstr ""
"この「遅い初期化」アプローチには、1つの重大な欠点があります。 "
"_初期化されていない_Beanは、ブートストラップ中にインスタンス化された他の拡張機能やアプリケーションコンポーネントからアクセスされる可能性があります。 "
"link:#synthetic_beans[synthetic_beans]]で、よりロバストな解決策を取り上げます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:166
#, no-wrap, fuzzy
msgid "Default beans"
msgstr "デフォルトの豆"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:171
#, fuzzy
msgid ""
"A very useful pattern of creating such beans but also giving application "
"code the ability to easily override some of the beans with custom "
"implementations, is to use the `@DefaultBean` that Quarkus provides.  This "
"is best explained with an example."
msgstr ""
"このようなビーンを作成しつつ、アプリケーションコードにカスタム実装でビーンの一部を簡単にオーバーライドする機能を与えるという非常に便利なパターンは、Quarkusが提供している "
"`@DefaultBean` を使用することです。これは例を挙げて説明するのが一番です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:173
#, fuzzy
msgid ""
"Let us assume that the Quarkus extension needs to provide a `Tracer` bean "
"which application code is meant to inject into its own beans."
msgstr ""
"ここでは、Quarkus拡張機能が `Tracer` "
"ビーンを提供する必要があると仮定して、アプリケーションコードがそれ自身のビーンに注入されることを意味します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:178
#, no-wrap
msgid "@Dependent\n"
"public class TracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:183
#, no-wrap
msgid ""
"    @Produces\n"
"    public Tracer tracer(Reporter reporter, Configuration configuration) {\n"
"        return new Tracer(reporter, configuration);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:189
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Configuration configuration() {\n"
"        // create a Configuration\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:196
#, no-wrap
msgid ""
"    @Produces\n"
"    @DefaultBean\n"
"    public Reporter reporter(){\n"
"        // create a Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:199
#, fuzzy
msgid ""
"If for example application code wants to use `Tracer`, but also needs to use "
"a custom `Reporter` bean, such a requirement could easily be done using "
"something like:"
msgstr ""
"例えば、アプリケーションコードが `Tracer` を使用したいが、カスタムの `Reporter` Bean "
"を使用する必要がある場合、そのような要件は、次のようなものを使用して簡単に行うことができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:205
#, no-wrap
msgid "@Dependent\n"
"public class CustomTracerConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:211
#, no-wrap
msgid ""
"    @Produces\n"
"    public Reporter reporter(){\n"
"        // create a custom Reporter\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:213
#, no-wrap, fuzzy
msgid ""
"How to Override a Bean Defined by a Library/Quarkus Extension that doesn't "
"use @DefaultBean"
msgstr "DefaultBeanを使用しないライブラリ/Quarkus拡張で定義されたBeanをオーバーライドする方法"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:218
#, fuzzy
msgid ""
"Although `@DefaultBean` is the recommended approach, it is also possible for "
"application code to override beans provided by an extension by marking beans "
"as a CDI `@Alternative` and including `@Priority` annotation.  Let's show a "
"simple example.  Suppose we work on an imaginary \"quarkus-parser\" "
"extension and we have a default bean implementation:"
msgstr ""
"`@DefaultBean` が推奨されていますが、ビーンズを CDI `@Alternative` としてマークし、 `@Priority` "
"アノテーションを含めることで、アプリケーションコードが拡張機能によって提供されるビーンズをオーバーライドすることも可能です。簡単な例を示しましょう。架空の\"quarkus-"
"parser\"拡張機能で作業をしていて、デフォルトのビーンの実装を持っているとします。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:223
#, no-wrap
msgid "@Dependent\n"
"class Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:228
#, no-wrap
msgid ""
"  String[] parse(String expression) {\n"
"    return expression.split(\"::\");\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:231
#, fuzzy
msgid "And our extension also consumes this parser:"
msgstr "そして、私たちの拡張機能はこのパーサも消費します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:236
#, no-wrap
msgid "@ApplicationScoped\n"
"class ParserService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:239
#, no-wrap
msgid "  @Inject\n"
"  Parser parser;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:242
#, no-wrap
msgid "  //...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:245
#, fuzzy
msgid ""
"Now, if a user or even some other extension needs to override the default "
"implementation of the `Parser` the simplest solution is to use CDI "
"`@Alternative` + `@Priority`:"
msgstr ""
"さて、ユーザーや他の拡張機能が `Parser` のデフォルトの実装を上書きする必要がある場合、最も簡単な解決策は CDI `@Alternative` "
"+ `@Priority` を使用することです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:252
#, no-wrap
msgid ""
"@Alternative <1>\n"
"@Priority(1) <2>\n"
"@Singleton\n"
"class MyParser extends Parser {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:257
#, no-wrap
msgid "  String[] parse(String expression) {\n"
"    // my super impl...\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:259
#, fuzzy
msgid "`MyParser` is an alternative bean."
msgstr "`MyParser` は代替豆です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:260
#, fuzzy
msgid ""
"Enables the alternative. The priority could be any number to override the "
"default bean but if there are multiple alternatives the highest priority "
"wins."
msgstr ""
"代替案を有効にします。優先度はデフォルトのビーンを上書きするために任意の数値を指定できますが、複数の代替案がある場合は、最も高い優先度のものが優先されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:262
#, fuzzy
msgid ""
"CDI alternatives are only considered during injection and type-safe "
"resolution. For example the default implementation would still receive "
"observer notifications."
msgstr ""
"CDI の代替案は、インジェクションと型安全解決の間のみ考慮されます。例えば、デフォルトの実装では、オブザーバー通知を受け取ることになります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:240
msgid "Synthetic beans"
msgstr "合成Bean"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:269
#, fuzzy
msgid ""
"Sometimes it is very useful to be able to register a synthetic bean.  Bean "
"attributes of a synthetic bean are not derived from a java class, method or "
"field.  Instead, the attributes are specified by an extension."
msgstr ""
"合成ビーンを登録できると非常に便利なことがあります。合成ビーンのビーン属性は，javaクラス，メソッド，フィールドから派生したものではありません。その代わりに、属性は拡張子によって指定されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:272
#, fuzzy
msgid ""
"Since the CDI container does not control the instantiation of a synthetic "
"bean the dependency injection and other services (such as interceptors) are "
"not supported.  In other words, it's up to the extension to provide all "
"required services to a synthetic bean instance."
msgstr ""
"CDIコンテナは合成Beanのインスタンス化を制御しないので、依存性注入や他のサービス(インターセプタなど)はサポートされていません。言い換えれば、合成ビーンのインスタンスに必要なすべてのサービスを提供するのは拡張機能にかかっています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:275
#, fuzzy
msgid ""
"There are several ways to register a <<cdi-reference."
"adoc#synthetic_beans,synthetic bean>> in Quarkus.  In this chapter, we will "
"cover a use case that can be used to initialize extension beans in a safe "
"manner (compared to <<bean_init>>)."
msgstr ""
"Quarkusで link:cdi-reference."
"html#synthetic_beans[合成ビーンを]登録する方法はいくつかあります。この章では、安全な方法で拡張ビーンを初期化できるユースケースを取り上げます（ "
"link:#bean_init[[bean_init]]と比較して）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:277
#, fuzzy
msgid "The `SyntheticBeanBuildItem` can be used to register a synthetic bean:"
msgstr "`SyntheticBeanBuildItem` で合成豆を登録することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:279
#, fuzzy
msgid ""
"whose instance can be easily produced through a <<bytecode-"
"recording,recorder>>,"
msgstr "そのインスタンスは、 link:#bytecode-recording[レコーダー]を介して簡単に生成することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:280
#, fuzzy
msgid ""
"to provide a \"context\" bean that holds all the information collected "
"during augmentation so that the real components do not need any \"late "
"initialization\" because they can inject the context bean directly."
msgstr ""
"を提供するために、実際のコンポーネントはコンテキスト・ビーンを直接注入することができるので、\"遅い初期化\"を必要としないように、拡張中に収集されたすべての情報を保持する\"コンテキスト\"ビーンを提供します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:281
#, no-wrap, fuzzy
msgid "Instance Produced Through Recorder"
msgstr "レコーダーを通して生成されたインスタンス"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:291
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo(\"parameters are recorder "
"in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:293
#, fuzzy
msgid ""
"The string value is recorded in the bytecode and used to initialize the "
"instance of `Foo`."
msgstr "文字列の値はバイトコードに記録され、 `Foo`."

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:294
#, no-wrap, fuzzy
msgid "\"Context\" Holder"
msgstr "\"文脈」ホルダー"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:304
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT)\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(TestContext.class)."
"scope(Singleton.class)\n"
"                .runtimeValue(recorder.createContext(\"parameters are "
"recorder in the bytecode\")) <1>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:306
#, fuzzy
msgid "The \"real\" components can inject the `TestContext` directly."
msgstr "本物の」コンポーネントは、 `TestContext` を直接注入することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:307
#, no-wrap, fuzzy
msgid "Some types of extensions"
msgstr "拡張機能のいくつかのタイプ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:310
#, fuzzy
msgid "There exist multiple stereotypes of extension, let's list a few."
msgstr "拡張子の固定観念は複数存在しますが、いくつか挙げてみましょう。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:311
#, no-wrap, fuzzy
msgid "Bare library running"
msgstr "ベアライブラリの実行"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:316
#, fuzzy
msgid ""
"This is the less sophisticated extension.  It consists of a set of patches "
"to make sure a library runs on GraalVM.  If possible, contribute these "
"patches upstream, not in extensions.  Second best is to write Substrate VM "
"substitutions, which are patches applied during native image compilation."
msgstr ""
"これはあまり洗練されていない拡張機能です。これは、ライブラリがGraalVM上で動作するようにするためのパッチのセットで構成されています。可能であれば、これらのパッチは拡張機能の中ではなく、アップストリームで貢献してください。二番目に良いのは、ネイティブイメージのコンパイル時に適用されるパッチである "
"Substrate VM substitutions を書くことです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:317
#, no-wrap, fuzzy
msgid "Get a framework running"
msgstr "実行中のフレームワークを取得する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:320
#, fuzzy
msgid ""
"A framework at runtime typically reads configuration, scan the classpath and "
"classes for metadata (annotations, getters etc), build a metamodel on top of "
"which it runs, find options via the service loader pattern, prepare "
"invocation calls (reflection), proxy interfaces, etc. + These operations "
"should be done at build time and the metamodel be passed to the recorder DSL "
"that will generate classes that will be executed at runtime and boot the "
"framework."
msgstr ""
"実行時のフレームワークは通常、設定を読み込み、クラスパスとクラスをスキャンしてメタデータ(アノテーションやゲッターなど)を探し、その上にメタモデルを構築し、サービスローダパターンを介してオプションを見つけ、呼び出し呼び出し(リフレクション)やプロキシインターフェイスなどを準備します。+ "
"これらの操作はビルド時に行われ、メタモデルは実行時に実行されるクラスを生成するレコーダDSLに渡され、フレームワークを起動します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:321
#, no-wrap, fuzzy
msgid "Get a CDI portable extension running"
msgstr "CDI ポータブルエクステンションを実行する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:326
#, fuzzy
msgid ""
"The CDI portable extension model is very flexible.  Too flexible to benefit "
"from the build time boot promoted by Quarkus.  Most extension we have seen "
"do not make use of these extreme flexibility capabilities.  The way to port "
"a CDI extension to Quarkus is to rewrite it as a Quarkus extension which "
"will define the various beans at build time (deployment time in extension "
"parlance)."
msgstr ""
"CDIポータブル拡張モデルは非常に柔軟性が高い。Quarkusが推進するビルドタイムブートの恩恵を受けるには、あまりにも柔軟性が高すぎます。私たちが見てきたほとんどの拡張機能は、このような極端な柔軟性の機能を利用していません。CDI拡張をQuarkusに移植する方法は、ビルド時（拡張の言い方ではデプロイ時）に様々なビーンを定義するQuarkus拡張として書き換えることです。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:327
#, no-wrap, fuzzy
msgid "Technical aspect"
msgstr "技術的な側面"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:330
#, no-wrap, fuzzy
msgid "Three Phases of Bootstrap and Quarkus Philosophy"
msgstr "BootstrapとQuarkusの3つのフェーズの考え方"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:333
#, fuzzy
msgid "There are three distinct bootstrap phases of a Quarkus app:"
msgstr "Quarkusアプリには、3つの異なるブートストラップフェーズがあります。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:15
#, no-wrap, fuzzy
msgid "Augmentation"
msgstr "補強"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:339
#, fuzzy
msgid ""
"This is the first phase, and is done by the <<Build Step Processors>>. These "
"processors have access to Jandex annotation information and can parse any "
"descriptors and read annotations, but should not attempt to load any "
"application classes. The output of these build steps is some recorded "
"bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/"
"gizmo), that is used to actually bootstrap the application at runtime. "
"Depending on the `io.quarkus.deployment.annotations.ExecutionTime` value of "
"the `@io.quarkus.deployment.annotations.Record` annotation associated with "
"the build step, the step may be run in a different JVM based on the "
"following two modes."
msgstr ""
"これは最初のフェーズであり、 link:#Build Step Processors[[Build Step "
"Processors]]によって行われます。これらのプロセッサはJandexのアノテーション情報へのアクセス権を持ち、任意の記述子を解析してアノテーションを読み込むことができますが、アプリケーションクラスをロードしようとはしません。これらのビルドステップの出力は、Gizmo(ext/"
"gizmo)と呼ばれるObjectWeb "
"ASMプロジェクトの拡張機能を使用して記録されたバイトコードで、実行時にアプリケーションを実際にブートストラップするために使用されます。ビルドステップに関連付けられた "
"`@io.quarkus.deployment.annotations.Record` アノテーションの `io.quarkus.deployment."
"annotations.ExecutionTime` の値に応じて、ステップは以下の 2 つのモードに基づいて異なる JVM で実行されます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:340
#, no-wrap, fuzzy
msgid "Static Init"
msgstr "スタティックイニット"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:346
#, fuzzy
msgid ""
"If bytecode is recorded with `@Record(STATIC_INIT)` then it will be executed "
"from a static init method on the main class. For a native executable build, "
"this code is executed in a normal JVM as part of the native build process, "
"and any retained objects that are produced in this stage will be directly "
"serialized into the native executable via an image mapped file.  This means "
"that if a framework can boot in this phase then it will have its booted "
"state directly written to the image, and so the boot code does not need to "
"be executed when the image is started."
msgstr ""
"バイトコードが `@Record(STATIC_INIT)` で記録されている場合は、メインクラスの静的 init "
"メソッドから実行されます。ネイティブ実行形式のビルドでは、このコードはネイティブビルドプロセスの一部として通常のJVMで実行され、この段階で生成された保持オブジェクトはイメージマッピングされたファイルを介してネイティブ実行形式に直接シリアライズされます。これは、もしフレームワークがこのフェーズで起動できるならば、その起動状態がイメージに直接書き込まれ、イメージが起動したときに起動コードが実行される必要がないことを意味します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:348
#, fuzzy
msgid ""
"There are some restrictions on what can be done in this stage as the "
"Substrate VM disallows some objects in the native executable. For example "
"you should not attempt to listen on a port or start threads in this phase. "
"In addition, it is disallowed to read run time configuration during static "
"initialization."
msgstr ""
"この段階でできることにはいくつかの制限がありますが、サブストレートVMはネイティブ実行ファイル内のいくつかのオブジェクトを禁止しています。例えば、この段階ではポートをリッスンしようとしたり、スレッドを開始しようとしたりしてはいけません。さらに、静的な初期化中にランタイム設定を読み込むことも禁止されています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:353
#, fuzzy
msgid ""
"In non-native pure JVM mode, there is no real difference between Static and "
"Runtime Init, except that Static Init is always executed first. This mode "
"benefits from the same build phase augmentation as native mode as the "
"descriptor parsing and annotation scanning are done at build time and any "
"associated class/framework dependencies can be removed from the build output "
"jar. In servers like WildFly, deployment related classes such as XML parsers "
"hang around for the life of the application, using up valuable memory. "
"Quarkus aims to eliminate this, so that the only classes loaded at runtime "
"are actually used at runtime."
msgstr ""
"非ネイティブの純粋な JVM モードでは、スタティック Init とランタイム Init の間に実質的な違いはありませんが、スタティック Init "
"が常に最初に実行されます。このモードは、記述子の解析と注釈のスキャンがビルド時に行われ、関連するクラス/"
"フレームワークの依存関係をビルド出力ジャーから削除できるため、ネイティブモードと同じビルドフェーズの拡張の恩恵を受けます。WildFlyのようなサーバーでは、XMLパーサーなどのデプロイメント関連のクラスは、アプリケーションが稼働している間、貴重なメモリを使い果たしてしまいます。Quarkusは、これを排除して、実行時にロードされたクラスだけが実行時に実際に使用されるようにすることを目的としています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:356
#, fuzzy
msgid ""
"As an example, the only reason that a Quarkus application should load an XML "
"parser is if the user is using XML in their application. Any XML parsing of "
"configuration should be done in the Augmentation phase."
msgstr ""
"例として、QuarkusアプリケーションがXMLパーサーをロードする唯一の理由は、ユーザーがアプリケーションでXMLを使用している場合です。設定のXMLパースは、拡張フェーズで行う必要があります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:357
#, no-wrap, fuzzy
msgid "Runtime Init"
msgstr "ランタイムイニット"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:361
#, fuzzy
msgid ""
"If bytecode is recorded with `@Record(RUNTIME_INIT)` then it is executed "
"from the application's main method. This code will be run on native "
"executable boot. In general as little code as possible should be executed in "
"this phase, and should be restricted to code that needs to open ports etc."
msgstr ""
"バイトコードが `@Record(RUNTIME_INIT)` "
"で記録されている場合は、アプリケーションのメインメソッドから実行されます。このコードはネイティブの実行可能なブートで実行されます。一般的に、このフェーズで実行されるコードは可能な限り少なくし、ポートなどを開く必要があるコードに限定してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:363
#, fuzzy
msgid ""
"Pushing as much as possible into the `@Record(STATIC_INIT)` phase allows for "
"two different optimizations:"
msgstr "可能な限り `@Record(STATIC_INIT)` フェーズに押し込むことで、2つの異なる最適化が可能になります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:365
#, fuzzy
msgid ""
"In both native executable and pure JVM mode this allows the app to start as "
"fast as possible since processing was done during build time. This also "
"minimizes the classes/native code needed in the application to pure runtime "
"related behaviors."
msgstr ""
"ネイティブ実行形式と純粋なJVMモードの両方で、これにより、処理はビルド時に行われるため、アプリをできるだけ速く起動することができます。これはまた、アプリケーションで必要とされるクラス/"
"ネイティブコードを、純粋なランタイム関連の動作に最小限に抑えます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:368
#, fuzzy
msgid ""
"Another benefit with native executable mode is that Substrate can more "
"easily eliminate features that are not used. If features are directly "
"initialized via bytecode, Substrate can detect that a method is never called "
"and eliminate that method. If config is read at runtime, Substrate cannot "
"reason about the contents of the config and so needs to keep all features in "
"case they are required."
msgstr ""
"ネイティブ実行モードのもう一つの利点は、Substrate "
"が使用されない機能をより簡単に排除できることです。バイトコードを介して機能が直接初期化されている場合、サブストレートはメソッドが決して呼び出されないことを検出し、そのメソッドを削除することができます。実行時に "
"config が読み込まれる場合、Substrate は config "
"の内容を推論することができないため、必要な場合に備えてすべての機能を保持しておく必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:373
#, fuzzy
msgid ""
"Your extension project should be setup as a multi-module project with two "
"submodules:"
msgstr "拡張プロジェクトは、2つのサブモジュールを持つマルチモジュールプロジェクトとして設定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:375
#, fuzzy
msgid ""
"A deployment time submodule that handles the build time processing and "
"bytecode recording."
msgstr "ビルド時の処理とバイトコードの記録を行うデプロイメント時間サブモジュールです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:377
#, fuzzy
msgid ""
"A runtime submodule that contains the runtime behavior that will provide the "
"extension behavior in the native executable or runtime JVM."
msgstr "ネイティブ実行ファイルまたはランタイムJVMで拡張動作を提供するランタイム動作を含むランタイムサブモジュール。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:379
#, fuzzy
msgid ""
"You may want to use the `create-extension` mojo of `io.quarkus:quarkus-maven-"
"plugin` to create these Maven modules - see the next section."
msgstr ""
"これらのMavenモジュールを作成するには、 `io.quarkus:quarkus-maven-plugin` の `create-"
"extension` mojo を使用するとよいでしょう - 次のセクションを参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:384
#, fuzzy
msgid ""
"Your runtime artifact should depend on `io.quarkus:quarkus-core`, and "
"possibly the runtime artifacts of other Quarkus modules if you want to use "
"functionality provided by them.  You will also need to include the `io."
"quarkus:quarkus-bootstrap-maven-plugin` to generate the Quarkus extension "
"descriptor included into the runtime artifact, if you are using the Quarkus "
"parent pom it will automatically inherit the correct configuration.  "
"Furthermore, you'll need to configure the `maven-compiler-plugin` to detect "
"the `quarkus-extension-processor` annotation processor."
msgstr ""
"ランタイムアーティファクトは、 `io.quarkus:quarkus-core` "
"に依存する必要があります。また、他のQuarkusモジュールが提供する機能を使用したい場合は、他のQuarkusモジュールのランタイムアーティファクトに依存することもあります。また、ランタイムアーチファクトに含まれるQuarkus拡張記述子を生成するために "
"`io.quarkus:quarkus-bootstrap-maven-plugin` を含める必要があります。さらに、 `maven-compiler-"
"plugin` を設定して `quarkus-extension-processor` アノテーションプロセッサを検出する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:387
#, fuzzy
msgid ""
"By convention the deployment time artifact has the `-deployment` suffix, and "
"the runtime artifact has no suffix (and is what the end user adds to their "
"project)."
msgstr ""
"慣例では、デプロイメント時間アーティファクトは `-deployment` "
"という接尾辞を持ち、ランタイムアーティファクトは接尾辞を持ちません（エンドユーザーがプロジェクトに追加するものです）。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:397
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"      <groupId>io.quarkus</groupId>\n"
"      <artifactId>quarkus-core</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:429
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n"
"            <!-- Executions configuration can be inherited from quarkus-"
"build-parent -->\n"
"            <executions>\n"
"                <execution>\n"
"                    <goals>\n"
"                        <goal>extension-descriptor</goal>\n"
"                    </goals>\n"
"                    <configuration>\n"
"                         <deployment>${project.groupId}:${project."
"artifactId}-deployment:${project.version}</deployment>\n"
"                   </configuration>\n"
"               </execution>\n"
"           </executions>\n"
"        </plugin>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:432
#, fuzzy
msgid "The above `maven-compiler-plugin` configuration requires version 3.5+."
msgstr "上記の `maven-compiler-plugin` の設定には、バージョン 3.5+ が必要です。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:437
#, fuzzy
msgid ""
"Under no circumstances can the runtime module depend on a deployment "
"artifact. This would result in pulling all the deployment time code into "
"runtime scope, which defeats the purpose of having the split."
msgstr ""
"いかなる場合でも、ランタイムモジュールがデプロイメントアーティファクトに依存することはできません。これは、すべてのディプロイメントタイムコードをランタイムスコープに引き込む結果となり、スプリットの目的が達成されないことになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:442
#, fuzzy
msgid ""
"Your deployment time module should depend on `io.quarkus:quarkus-core-"
"deployment`, your runtime artifact, and possibly the deployment artifacts of "
"other Quarkus modules if you want to use functionality provided by them.  "
"You will also need to configure the `maven-compiler-plugin` to detect the "
"`quarkus-extension-processor` annotation processor."
msgstr ""
"デプロイメントタイムモジュールは、 `io.quarkus:quarkus-core-deployment` "
"、ランタイムアーティファクト、および他のQuarkusモジュールが提供する機能を使用する場合は、他のQuarkusモジュールのデプロイメントアーティファクトに依存する必要があります。また、 "
"`quarkus-extension-processor` アノテーションプロセッサを検出するように `maven-compiler-plugin` "
"を設定する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:451
#, no-wrap
msgid ""
"<dependencies>\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-core-deployment</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:468
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>org.apache.maven.plugins</groupId>\n"
"            <artifactId>maven-compiler-plugin</artifactId>\n"
"            <configuration>\n"
"                <annotationProcessorPaths>\n"
"                    <path>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-extension-processor</artifactId>\n"
"                    </path>\n"
"                </annotationProcessorPaths>\n"
"            </configuration>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:470
#, no-wrap, fuzzy
msgid "Create new extension modules using Maven"
msgstr "Mavenを使って新しい拡張モジュールを作成する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:473
#, fuzzy
msgid ""
"The `create-extension` mojo of `io.quarkus:quarkus-maven-plugin` can be used "
"to generate stubs of Maven modules needed for implementing a new Quarkus "
"extension."
msgstr ""
"`io.quarkus:quarkus-maven-plugin` の `create-extension` mojo は、新しい Quarkus "
"拡張機能の実装に必要な Maven モジュールのスタブを生成するために使用できます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:475
#, fuzzy
msgid ""
"This mojo can be currently used only for adding extensions to an established "
"source tree hosting multiple extensions in one subdirectory, such as https://"
"github.com/quarkusio/quarkus[Quarkus] or https://github.com/apache/camel-"
"quarkus[Camel Quarkus]. Creating extension projects from scratch is not "
"supported yet."
msgstr ""
"このモジョは、現在のところ、 link:https://github.com/quarkusio/quarkus[Quarkus]や link:"
"https://github.com/apache/camel-quarkus[Camel "
"Quarkus]のように、1つのサブディレクトリに複数の拡張機能をホストする確立されたソースツリーに拡張機能を追加するためにのみ使用できます。ゼロから拡張プロジェクトを作成することはまだサポートされていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:477
#, fuzzy
msgid ""
"As and example, let's add a new extension called `my-ext` to the Quarkus "
"source tree:"
msgstr "例として、Quarkusのソースツリーに `my-ext` という新しい拡張機能を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:487
#, no-wrap
msgid ""
"git clone https://github.com/quarkusio/quarkus.git\n"
"cd quarkus\n"
"cd extensions\n"
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create-extension -N \\\n"
"    -Dquarkus.artifactIdBase=my-ext \\\n"
"    -Dquarkus.artifactIdPrefix=quarkus- \\\n"
"    -Dquarkus.nameBase=\"My Extension\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:490
#, fuzzy
msgid "The above sequence of commands does the following:"
msgstr "上記の一連のコマンドは以下のようなことを行います。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:492
#, fuzzy
msgid "Creates four new Maven modules:"
msgstr "4つの新しいMavenモジュールを作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:493
#, fuzzy
msgid "`quarkus-my-ext-parent` in the `extensions/my-ext` directory"
msgstr "`extensions/my-ext` ディレクトリ内の `quarkus-my-ext-parent`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:494
#, fuzzy
msgid "`quarkus-my-ext` in the `extensions/my-ext/runtime` directory"
msgstr "`extensions/my-ext/runtime` ディレクトリ内の `quarkus-my-ext`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:495
#, fuzzy
msgid ""
"`quarkus-my-ext-deployment` in the `extensions/my-ext/deployment` directory; "
"a basic `MyExtProcessor` class is generated in this module."
msgstr ""
"`extensions/my-ext/deployment` ディレクトリの `quarkus-my-ext-deployment`; 基本的な "
"`MyExtProcessor` クラスはこのモジュールで生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:496
#, fuzzy
msgid ""
"`quarkus-my-ext-integration-test` in the `integration-tests/my-ext/"
"deployment` directory; an empty JAX-RS Resource class and two test classes "
"(for JVM mode and native mode) are generated in this module."
msgstr ""
"`integration-tests/my-ext/deployment` ディレクトリの `quarkus-my-ext-integration-"
"test`; 空の JAX-RS Resource クラスと 2 つのテストクラス (JVM モードとネイティブモード用) "
"がこのモジュールで生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:497
#, fuzzy
msgid "Links these three modules where necessary:"
msgstr "必要に応じて、これらの3つのモジュールをリンクします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:498
#, fuzzy
msgid ""
"`quarkus-my-ext-parent` is added to the `<modules>` of `quarkus-extensions-"
"parent`"
msgstr ""
"`&amp;lt;modules&amp;gt;` の `quarkus-my-ext-parent` を追加しました。 `quarkus-"
"extensions-parent`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:499
#, fuzzy
msgid ""
"`quarkus-my-ext` is added to the `<dependencyManagement>` of the Quarkus BOM "
"(Bill of Materials) `bom/application/pom.xml`"
msgstr ""
"QuarkusのBOM（部品表）の `&amp;lt;dependencyManagement&amp;gt;` に `quarkus-my-ext` "
"が追加されました。 `bom/application/pom.xml`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:500
#, fuzzy
msgid ""
"`quarkus-my-ext-deployment` is added to the `<dependencyManagement>` of the "
"Quarkus BOM (Bill of Materials) `bom/application/pom.xml`"
msgstr ""
"QuarkusのBOM（部品表）の `&amp;lt;dependencyManagement&amp;gt;` に `quarkus-my-ext-"
"deployment` が追加されました。 `bom/application/pom.xml`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:501
#, fuzzy
msgid ""
"`quarkus-my-ext-integration-test` is added to the `<modules>` of `quarkus-"
"integration-tests-parent`"
msgstr ""
"`&amp;lt;modules&amp;gt;` の `quarkus-my-ext-integration-test` を追加しました。 "
"`quarkus-integration-tests-parent`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:503
#, fuzzy
msgid ""
"A Maven build performed immediately after generating the modules should fail "
"due to a `fail()` assertion in one of the test classes."
msgstr ""
"モジュールを生成した直後に実行された Maven ビルドは、テストクラスの 1 つに `fail()` アサーションがあるために失敗します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:506
#, fuzzy
msgid ""
"There is one step (specific to the Quarkus source tree) that you should do "
"manually when creating a new extension: create a `quarkus-extension.yaml` "
"file that describe your extension inside the runtime module `src/main/"
"resources/META-INF` folder."
msgstr ""
"それは、ランタイムモジュール `src/main/resources/META-INF` フォルダ内に拡張機能を記述する `quarkus-"
"extension.yaml` ファイルを作成することです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:508
#, fuzzy
msgid ""
"This is the `quarkus-extension.yaml` of the `quarkus-agroal` extension, you "
"can use it as an example:"
msgstr "`quarkus-agroal` の拡張子の `quarkus-extension.yaml` です。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:522
#, no-wrap
msgid ""
"name: \"Agroal - Database connection pool\"\n"
"metadata:\n"
"  keywords:\n"
"  - \"agroal\"\n"
"  - \"database-connection-pool\"\n"
"  - \"datasource\"\n"
"  - \"jdbc\"\n"
"  guide: \"https://quarkus.io/guides/datasource\"\n"
"  categories:\n"
"  - \"data\"\n"
"  status: \"stable\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:525
#, fuzzy
msgid ""
"Note that the parameters of the mojo that will be constant for all the "
"extensions added to this source tree are configured in `extensions/pom.xml` "
"so that they do not need to be passed on the command line each time a new "
"extension is added:"
msgstr ""
"このソースツリーに追加されたすべての拡張機能に対して一定となる mojo のパラメータは `extensions/pom.xml` "
"で設定されているため、新しい拡張機能が追加されるたびにコマンドラインで渡す必要がないことに注意してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:542
#, no-wrap
msgid ""
"<plugin>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-maven-plugin</artifactId>\n"
"    <version>${quarkus.version}</version>\n"
"    <inherited>false</inherited>\n"
"    <!-- Settings for stubbing new extensions via\n"
"           ./mvnw quarkus:create-extension -N -Dquarkus.artifactIdBase=my-"
"ext -Dquarkus.nameBase=\"My Extension\"\n"
"    -->\n"
"    <configuration>\n"
"        <namePrefix xml:space=\"preserve\">Quarkus - </namePrefix>\n"
"        <bomPath>../bom/application/pom.xml</bomPath>\n"
"        <itestParentPath>../integration-tests/pom.xml</itestParentPath>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:547
#, fuzzy
msgid ""
"The `nameBase` parameter of the mojo is optional.  If you do not specify it "
"on the command line, the plugin will derive it from `artifactIdBase` by "
"replacing dashes with spaces and uppercasing each token.  So you may "
"consider omitting explicit `nameBase` in some cases."
msgstr ""
"mojo の `nameBase` "
"パラメータはオプションです。コマンドラインで指定しなかった場合、プラグインはダッシュをスペースに置き換え、各トークンを大文字にすることで "
"`artifactIdBase` からそれを導き出します。そのため、場合によっては明示的な `nameBase` "
"を省略することを検討してもよいでしょう。"

#.  The following link should point to the mojo page once https://github.com/quarkusio/quarkusio.github.io/issues/265 is fixed
#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:550
#, fuzzy
msgid ""
"Please refer to https://github.com/quarkusio/quarkus/blob/{quarkus-version}/"
"devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo."
"java[CreateExtensionMojo JavaDoc] for all the available options of the mojo."
msgstr ""
"モジョで利用可能なすべてのオプションについては、 link:https://github.com/quarkusio/quarkus/blob/"
"{quarkus-version}/devtools/maven/src/main/java/io/quarkus/maven/"
"CreateExtensionMojo.java[CreateExtensionMojo JavaDoc]を参照してください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:551
#, no-wrap, fuzzy
msgid "Build Step Processors"
msgstr "ビルドステッププロセッサ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:556
#, fuzzy
msgid ""
"Work is done at augmentation time by _build steps_ which produce and consume "
"_build items_.  The build steps found in the deployment modules that "
"correspond to the extensions in the project build are automatically wired "
"together and executed to produce the final build artifact(s)."
msgstr ""
"作業は、 _ビルドアイテムを_生成して消費する "
"_ビルドステップ_によって拡張時に行われます。プロジェクトビルドの拡張機能に対応するデプロイメントモジュールで見つかったビルドステップは、自動的に配線されて実行され、最終的なビルド成果物が生成されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:557
#, no-wrap, fuzzy
msgid "Build steps"
msgstr "ビルドステップ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:563
#, fuzzy
msgid ""
"A _build step_ is a method which is annotated with the `@io.quarkus."
"deployment.annotations.BuildStep` annotation.  Each build step may "
"<<consuming-values,consume>> items that are produced by earlier stages, and "
"<<producing-values,produce>> items that can be consumed by later stages. "
"Build steps are normally only run when they produce a build item that is "
"ultimately consumed by another step."
msgstr ""
"_ビルドステップ_とは、 `@io.quarkus.deployment.annotations.BuildStep` "
"アノテーションが付けられたメソッドのことである。各ビルドステップは、以前のステージで生成されたアイテムを link:#consuming-"
"values[消費し]たり、後のステージで消費可能なアイテムを link:#producing-"
"values[生成し]たりします。ビルドステップは通常、最終的に別のステップで消費されるビルドアイテムを生成する場合にのみ実行されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:566
#, fuzzy
msgid ""
"Build steps are normally placed on plain classes within an extension's "
"deployment module.  The classes are automatically instantiated during the "
"augment process and utilize <<injection,injection>>."
msgstr ""
"ビルドステップは通常、拡張機能のデプロイモジュール内のプレーンクラスに配置されます。クラスは拡張処理の間に自動的にインスタンス化され、 link:"
"#injection[インジェクションを]利用します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:568
#, no-wrap, fuzzy
msgid "Build items"
msgstr "ビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:574
#, fuzzy
msgid ""
"Build items are concrete, final subclasses of the abstract `io.quarkus."
"builder.item.BuildItem` class.  Each build item represents some unit of "
"information that must be passed from one stage to another.  The base "
"`BuildItem` class may not itself be directly subclassed; rather, there are "
"abstract subclasses for each of the kinds of build item subclasses that "
"_may_ be created: <<simple-build-items,simple>>, <<multi-build-"
"items,multi>>, and <<empty-build-items,empty>>."
msgstr ""
"ビルド項目は、抽象 `io.quarkus.builder.item.BuildItem` "
"クラスの具体的な最終サブクラスです。各ビルド項目は、ある段階から別の段階に渡される必要のある情報の単位を表します。基底 `BuildItem` "
"クラス自体が直接サブクラス化されているわけではなく、作成される _可能性のある_ビルド・アイテム・サブクラスの種類（ link:#simple-"
"build-items[単純]、 link:#multi-build-items[複数]、 link:#empty-build-"
"items[空]）ごとに抽象サブクラスが存在します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:576
#, fuzzy
msgid ""
"Think of build items as a way for different extensions to communicate with "
"one another.  For example, a build item can:"
msgstr "ビルド項目は、異なる拡張機能が互いに通信するための方法と考えてください。たとえば、ビルド項目には次のようなものがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:578
#, fuzzy
msgid "expose the fact that a database configuration exists"
msgstr "データベースの設定が存在することを公開します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:579
#, fuzzy
msgid ""
"consume that database configuration (e.g. a connection pool extension or an "
"ORM extension)"
msgstr "データベース設定を消費する (接続プール拡張やORM拡張など)"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:581
#, fuzzy
msgid ""
"ask an extension to do work for another extension: e.g. an extension wanting "
"to define a new CDI bean and asking the ArC extension to do so"
msgstr "別の拡張機能に作業を依頼する: 例えば、新しい CDI Bean を定義したい拡張機能が ArC 拡張機能にそうするように依頼します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:583
#, fuzzy
msgid "This is a very flexible mechanism."
msgstr "これは非常に柔軟な仕組みです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:586
#, fuzzy
msgid ""
"`BuildItem` instances should be immutable, as the producer/consumer model "
"does not allow for mutation to be correctly ordered. This is not enforced "
"but failure to adhere to this rule can result in race conditions."
msgstr ""
"`BuildItem` インスタンスは不変でなければなりません。プロデューサー/"
"コンシューマーモデルでは突然変異が正しく順序付けられないためです。これは強制されていませんが、このルールを守らないと競合状態になる可能性があります。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:588
#, no-wrap, fuzzy
msgid "Simple build items"
msgstr "シンプルなビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:594
#, fuzzy
msgid ""
"Simple build items are final classes which extend `io.quarkus.builder.item."
"SimpleBuildItem`.  Simple build items may only be produced by one step in a "
"given build; if multiple steps in a build declare that they produce the same "
"simple build item, an error is raised.  Any number of build steps may "
"consume a simple build item.  A build step which consumes a simple build "
"item will always run _after_ the build step which produced that item."
msgstr ""
"シンプルビルド項目は `io.quarkus.builder.item.SimpleBuildItem` "
"を継承する最終クラスです。ビルド中の複数のステップが同じシンプルなビルド項目を生成すると宣言した場合、エラーが発生します。ビルド中の複数のステップが同じ単純なビルド項目を生成すると宣言すると、エラーが発生します。シンプルビルドアイテムを消費するビルドステップは、常にそのアイテムを生成したビルドステップの "
"_後_に実行されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:595
#, no-wrap, fuzzy
msgid "Example of a single build item"
msgstr "単品のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:604
#, no-wrap
msgid ""
"/**\n"
" * The build item which represents the Jandex index of the application,\n"
" * and would normally be used by many build steps to find usages\n"
" * of annotations.\n"
" */\n"
"public final class ApplicationIndexBuildItem extends SimpleBuildItem {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:606
#, no-wrap
msgid "    private final Index index;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:610
#, no-wrap
msgid ""
"    public ApplicationIndexBuildItem(Index index) {\n"
"        this.index = index;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:615
#, no-wrap
msgid "    public Index getIndex() {\n"
"        return index;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:619
#, no-wrap, fuzzy
msgid "Multi build items"
msgstr "マルチビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:624
#, fuzzy
msgid ""
"Multiple or \"multi\" build items are final classes which extend `io.quarkus."
"builder.item.MultiBuildItem`.  Any number of multi build items of a given "
"class may be produced by any number of steps, but any steps which consume "
"multi build items will only run _after_ every step which can produce them "
"has run."
msgstr ""
"マルチビルドアイテムまたは「マルチ」ビルドアイテムは、 `io.quarkus.builder.item.MultiBuildItem`."
"指定されたクラスのマルチビルドアイテムは、いくつでものステップによって生成することができますが、マルチビルドアイテムを消費するステップは、マルチビルドアイテムを生成できるすべてのステップが実行された "
"_後に_のみ実行されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:625
#, no-wrap, fuzzy
msgid "Example of a multiple build item"
msgstr "複数のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:631
#, no-wrap
msgid ""
"public final class ServiceWriterBuildItem extends MultiBuildItem {\n"
"    private final String serviceName;\n"
"    private final List<String> implementations;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:641
#, no-wrap
msgid ""
"    public ServiceWriterBuildItem(String serviceName, String... "
"implementations) {\n"
"        this.serviceName = serviceName;\n"
"        // Make sure it's immutable\n"
"        this.implementations = Collections.unmodifiableList(\n"
"            Arrays.asList(\n"
"                implementations.clone()\n"
"            )\n"
"        );\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:645
#, no-wrap
msgid ""
"    public String getServiceName() {\n"
"        return serviceName;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:650
#, no-wrap
msgid ""
"    public List<String> getImplementations() {\n"
"        return implementations;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:652
#, no-wrap, fuzzy
msgid "Example of multiple build item usage"
msgstr "複数のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:667
#, no-wrap
msgid ""
"/**\n"
" * This build step produces a single multi build item that declares two\n"
" * providers of one configuration-related service.\n"
" */\n"
"@BuildStep\n"
"public ServiceWriterBuildItem registerOneService() {\n"
"    return new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyFirstConfigConverterImpl.class.getName(),\n"
"        MySecondConfigConverterImpl.class.getName()\n"
"    );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:686
#, no-wrap
msgid ""
"/**\n"
" * This build step produces several multi build items that declare multiple\n"
" * providers of multiple configuration-related services.\n"
" */\n"
"@BuildStep\n"
"public void registerSeveralServices(\n"
"    BuildProducer<ServiceWriterBuildItem> providerProducer\n"
") {\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        Converter.class.getName(),\n"
"        MyThirdConfigConverterImpl.class.getName(),\n"
"        MyFourthConfigConverterImpl.class.getName()\n"
"    ));\n"
"    providerProducer.produce(new ServiceWriterBuildItem(\n"
"        ConfigSource.class.getName(),\n"
"        MyConfigSourceImpl.class.getName()\n"
"    ));\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:697
#, no-wrap
msgid ""
"/**\n"
" * This build step aggregates all the produced service providers\n"
" * and outputs them as resources.\n"
" */\n"
"@BuildStep\n"
"public void produceServiceFiles(\n"
"    List<ServiceWriterBuildItem> items,\n"
"    BuildProducer<GeneratedResourceBuildItem> resourceProducer\n"
") throws IOException {\n"
"    // Aggregate all of the providers\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:708
#, no-wrap
msgid ""
"    Map<String, Set<String>> map = new HashMap<>();\n"
"    for (ServiceWriterBuildItem item : items) {\n"
"        String serviceName = item.getName();\n"
"        for (String implName : item.getImplementations()) {\n"
"            map.computeIfAbsent(\n"
"                serviceName,\n"
"                (k, v) -> new LinkedHashSet<>()\n"
"            ).add(implName);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:729
#, no-wrap
msgid ""
"    // Now produce the resource(s) for the SPI files\n"
"    for (Map.Entry<String, Set<String>> entry : map.entrySet()) {\n"
"        String serviceName = entry.getKey();\n"
"        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {\n"
"            try (OutputStreamWriter w = new OutputStreamWriter(os, "
"StandardCharsets.UTF_8)) {\n"
"                for (String implName : entry.getValue()) {\n"
"                    w.write(implName);\n"
"                    w.write(System.lineSeparator());\n"
"                }\n"
"            }\n"
"            w.flush();\n"
"            resourceProducer.produce(\n"
"                new GeneratedResourceBuildItem(\n"
"                    \"META-INF/services/\" + serviceName,\n"
"                    os.toByteArray()\n"
"                )\n"
"            );\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:732
#, no-wrap, fuzzy
msgid "Empty build items"
msgstr "空のビルドアイテム"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:737
#, fuzzy
msgid ""
"Empty build items are final (usually empty) classes which extend `io.quarkus."
"builder.item.EmptyBuildItem`.  They represent build items that don't "
"actually carry any data, and allow such items to be produced and consumed "
"without having to instantiate empty classes.  They cannot themselves be "
"instantiated."
msgstr ""
"空のビルド項目は `io.quarkus.builder.item.EmptyBuildItem` を拡張した最終的な (通常は空の) "
"クラスです。これは実際にはデータを持たないビルド項目を表し、空のクラスをインスタンス化することなく、そのような項目を生成したり消費したりすることを可能にします。これらはそれ自体をインスタンス化することはできません。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:738
#, no-wrap, fuzzy
msgid "Example of an empty build item"
msgstr "空のビルド項目の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:744
#, no-wrap
msgid ""
"public final class NativeImageBuildItem extends EmptyBuildItem {\n"
"    // empty\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:749
#, fuzzy
msgid ""
"Empty build items can represent \"barriers\" which can impose ordering "
"between steps.  They can also be used in the same way that popular build "
"systems use \"pseudo-targets\", which is to say that the build item can "
"represent a conceptual goal that does not have a concrete representation."
msgstr ""
"空のビルド項目は、ステップ間の順序付けを強制する「障壁」を表すことができます。また、一般的なビルドシステムが「擬似ターゲット」を使用しているのと同じように使用することもできます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:750
#, no-wrap, fuzzy
msgid "Example of usage of an empty build item in a \"pseudo-target\" style"
msgstr "擬似ターゲット」スタイルでの空のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:765
#, no-wrap
msgid ""
"/**\n"
" * Contrived build step that produces the native image on disk.  The main "
"augmentation\n"
" * step (which is run by Maven or Gradle) would be declared to consume this "
"empty item,\n"
" * causing this step to be run.\n"
" */\n"
"@BuildStep\n"
"@Produce(NativeImageBuildItem.class)\n"
"void produceNativeImage() {\n"
"    // ...\n"
"    // (produce the native image)\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:767
#, no-wrap, fuzzy
msgid "Example of usage of an empty build item in a \"barrier\" style"
msgstr "バリア」スタイルでの空のビルド項目の使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:779
#, no-wrap
msgid ""
"/**\n"
" * This would always run after {@link #produceNativeImage()} completes, "
"producing\n"
" * an instance of {@code SomeOtherBuildItem}.\n"
" */\n"
"@BuildStep\n"
"@Consume(NativeImageBuildItem.class)\n"
"SomeOtherBuildItem secondBuildStep() {\n"
"    return new SomeOtherBuildItem(\"foobar\");\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:782
#, no-wrap, fuzzy
msgid "Injection"
msgstr "射出成形"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:785
#, fuzzy
msgid ""
"Classes which contain build steps support the following types of injection:"
msgstr "ビルドステップを含むクラスは、以下のタイプのインジェクションをサポートしています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:787
#, fuzzy
msgid "Constructor parameter injection"
msgstr "コンストラクタのパラメータ注入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:788
#, fuzzy
msgid "Field injection"
msgstr "フィールドインジェクション"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:789
#, fuzzy
msgid "Method parameter injection (for build step methods only)"
msgstr "メソッド・パラメータのインジェクション（ビルド・ステップ・メソッドのみ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:792
#, fuzzy
msgid ""
"Build step classes are instantiated and injected for each build step "
"invocation, and are discarded afterwards.  State should only be communicated "
"between build steps by way of build items, even if the steps are on the same "
"class."
msgstr ""
"ビルドステップクラスは、各ビルドステップの呼び出しごとにインスタンス化されて注入され、その後破棄されます。ビルドステップが同じクラス上にある場合でも、ステートはビルドアイテムを介してのみ、ビルドステップ間で通信されるべきです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:795
#, fuzzy
msgid ""
"Final fields are not considered for injection, but can be populated by way "
"of constructor parameter injection if desired.  Static fields are never "
"considered for injection."
msgstr ""
"最終フィールドはインジェクションのために考慮されませんが、必要に応じてコンストラクタのパラメータをインジェクションすることで入力することができます。静的なフィールドはインジェクションのために考慮されることはありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:797
#, fuzzy
msgid "The types of values that can be injected include:"
msgstr "注入できる値の種類には、以下のようなものがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:799
#, fuzzy
msgid "<<build-items,Build items>> produced by previous build steps"
msgstr "前のビルドステップで生成された link:#build-items[アイテムをビルドする]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:800
#, fuzzy
msgid ""
"<<producing-values,Build producers>> to produce items for subsequent build "
"steps"
msgstr "後続のビルドステップのためのアイテムを生産するための link:#producing-values[ビルドプロデューサー]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:801
#, fuzzy
msgid "<<configuration-roots,Configuration root>> types"
msgstr "link:#configuration-roots[設定ルートの]種類"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:802
#, fuzzy
msgid "Template objects for <<bytecode-recording,bytecode recording>>"
msgstr "link:#bytecode-recording[バイトコード記録]用テンプレートオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:805
#, fuzzy
msgid ""
"Objects which are injected into a build step method or its class _must not_ "
"be used outside of that method's execution."
msgstr "ビルドステップ・メソッドまたはそのクラスに注入されたオブジェクトは、そのメソッドの実行外で使用してはなり _ませ_ん。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:808
#, fuzzy
msgid ""
"Injection is resolved at compile time via an annotation processor, and the "
"resulting code does not have permission to inject private fields or invoke "
"private methods."
msgstr ""
"インジェクションはコンパイル時にアノテーション・プロセッサを介して解決され、結果として得られるコードにはプライベート・フィールドを注入したり、プライベート・メソッドを呼び出したりする権限がありません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:810
#, no-wrap, fuzzy
msgid "Producing values"
msgstr "価値観のプロデュース"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:813
#, fuzzy
msgid ""
"A build step may produce values for subsequent steps in several possible "
"ways:"
msgstr "ビルドステップは、いくつかの可能な方法で後続のステップの値を生成することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:815
#, fuzzy
msgid ""
"By returning a <<simple-build-items,simple build item>> or <<multi-build-"
"items,multi build item>> instance"
msgstr ""
"link:#simple-build-items[シンプルなビルドアイテム]または link:#multi-build-"
"items[マルチビルドアイテムの]インスタンスを返すことで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:816
#, fuzzy
msgid "By returning a `List` of a multi build item class"
msgstr "マルチビルドアイテムクラスの `List` を返すことで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:817
#, fuzzy
msgid "By injecting a `BuildProducer` of a simple or multi build item class"
msgstr "シンプルまたはマルチビルドアイテムクラスの `BuildProducer` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:819
#, fuzzy
msgid ""
"By annotating the method with `@io.quarkus.deployment.annotations.Produce`, "
"giving the class name of a <<empty-build-items,empty build item>>"
msgstr ""
"メソッドに `@io.quarkus.deployment.annotations.Produce` をアノテーションすることで、 link:"
"#empty-build-items[空のビルド項目の]クラス名を与えることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:822
#, fuzzy
msgid ""
"If a simple build item is declared on a build step, it _must_ be produced "
"during that build step, otherwise an error will result.  Build producers "
"which are injected into steps _must not_ be used outside of that step."
msgstr ""
"ビルドステップ上で単純なビルド項目が宣言されている場合、そのビルドステップ中に生成する "
"_必要があり_、そうしないとエラーになります。ステップに注入されたビルドプロデューサは、そのステップの外で使用しては _いけません_。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:828
#, fuzzy
msgid ""
"Note that a `@BuildStep` method will only be called if it produces something "
"that another consumer or the final output requires. If there is no consumer "
"for a particular item then it will not be produced. What is required will "
"depend on the final target that is being produced.  For example, when "
"running in developer mode the final output will not ask for GraalVM-specific "
"build items such as `ReflectiveClassBuildItem`, so methods that only produce "
"these items will not be invoked."
msgstr ""
"`@BuildStep` "
"メソッドは、他の消費者が必要とするものを生成する場合、または最終的な出力が必要とする場合にのみ呼び出されることに注意してください。特定のアイテムの消費者がいない場合、それは生産されません。何が必要かは、生成される最終ターゲットに依存します。例えば、開発者モードで実行している場合、最終出力は "
"`ReflectiveClassBuildItem` のような GraalVM "
"固有のビルド項目を要求しないため、これらの項目のみを生成するメソッドは呼び出されません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:830
#, no-wrap, fuzzy
msgid "Consuming values"
msgstr "消費する価値観"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:833
#, fuzzy
msgid ""
"A build step may consume values from previous steps in the following ways:"
msgstr "ビルドステップでは、以下の方法で前のステップの値を消費することがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:835
#, fuzzy
msgid "By injecting a <<simple-build-items,simple build item>>"
msgstr "link:#simple-build-items[シンプルなビルド項目を]注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:836
#, fuzzy
msgid "By injecting an `Optional` of a simple build item class"
msgstr "シンプルなビルド項目クラスの `Optional` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:837
#, fuzzy
msgid ""
"By injecting a `List` of a <<multi-build-items,multi build item>> class"
msgstr "link:#multi-build-items[マルチビルドアイテムクラス]の `List` を注入することで"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:839
#, fuzzy
msgid ""
"By annotating the method with `@io.quarkus.deployment.annotations.Consume`, "
"giving the class name of a <<empty-build-items,empty build item>>"
msgstr ""
"メソッドに `@io.quarkus.deployment.annotations.Consume` をアノテーションすることで、 link:"
"#empty-build-items[空のビルド項目の]クラス名を与えることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:842
#, fuzzy
msgid ""
"Normally it is an error for a step which is included to consume a simple "
"build item that is not produced by any other step.  In this way, it is "
"guaranteed that all of the declared values will be present and non-`null` "
"when a step is run."
msgstr ""
"通常、含まれるステップが他のステップで生成されない単純なビルド項目を消費するのはエラーです。このようにして、ステップが実行されたときに宣言されたすべての値が存在し、 "
"`null` ではないことが保証されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:845
#, fuzzy
msgid ""
"Sometimes a value isn't necessary for the build to complete, but might "
"inform some behavior of the build step if it is present.  In this case, the "
"value can be optionally injected."
msgstr ""
"ビルドを完了させるためには必要のない値ですが、値が存在する場合にはビルドステップの動作に何らかの情報を提供することがあります。この場合、オプションで値を注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:847
#, fuzzy
msgid ""
"Multi build values are always considered _optional_.  If not present, an "
"empty list will be injected."
msgstr "複数のビルド値は常に _オプション_とみなされます。存在しない場合は、空のリストが注入されます。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:849
#, no-wrap, fuzzy
msgid "Weak value production"
msgstr "弱い価値生産"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:854
#, fuzzy
msgid ""
"Normally a build step is included whenever it produces any build item which "
"is in turn consumed by any other build step.  In this way, only the steps "
"necessary to produce the final artifact(s) are included, and steps which "
"pertain to extensions which are not installed or which only produce build "
"items which are not relevant for the given artifact type are excluded."
msgstr ""
"通常、ビルドステップは、他のビルドステップによって消費されるビルド項目を生成する際には必ず含まれます。このようにして、最終的な成果物を生成するために必要なステップだけが含まれ、インストールされていない拡張機能に関連するステップや、与えられた成果物の種類に関係のないビルド項目を生成するだけのステップは除外される。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:857
#, fuzzy
msgid ""
"For cases where this is not desired behavior, the `@io.quarkus.deployment."
"annotations.Weak` annotation may be used.  This annotation indicates that "
"the build step should not automatically be included solely on the basis of "
"producing the annotated value."
msgstr ""
"これが望ましい動作ではない場合は、 `@io.quarkus.deployment.annotations.Weak` "
"アノテーションを使用することができます。このアノテーションは、アノテーションされた値を生成することだけに基づいて、ビルドステップを自動的に含めるべきではないことを示しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:858
#, no-wrap, fuzzy
msgid "Example of producing a build item weakly"
msgstr "ビルドアイテムを弱く出す例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:874
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the "
"ExecutorClassBuildItem.\n"
" */\n"
"@BuildStep\n"
"void createExecutor(\n"
"        @Weak BuildProducer<GeneratedClassBuildItem> classConsumer,\n"
"        BuildProducer<ExecutorClassBuildItem> executorClassConsumer\n"
") {\n"
"        ClassWriter cw = new ClassWriter(Gizmo.ASM_API_VERSION);\n"
"        String className = generateClassThatCreatesExecutor(cw); // <1>\n"
"        classConsumer.produce(new GeneratedClassBuildItem(true, className, "
"cw.toByteArray()));\n"
"        executorClassConsumer.produce(new "
"ExecutorClassBuildItem(className));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:876
#, fuzzy
msgid ""
"This method (not provided in this example) would generate the class using "
"the ASM API."
msgstr "このメソッド（この例では提供されていません）は、ASM APIを使用してクラスを生成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:883
#, fuzzy
msgid ""
"Certain types of build items are generally always consumed, such as "
"generated classes or resources.  An extension might produce a build item "
"along with a generated class to facilitate the usage of that build item.  "
"Such a build step would use the `@Weak` annotation on the generated class "
"build item, while normally producing the other build item.  If the other "
"build item is ultimately consumed by something, then the step would run and "
"the class would be generated.  If nothing consumes the other build item, the "
"step would not be included in the build process."
msgstr ""
"一般的に、生成されたクラスやリソースなど、特定のタイプのビルド項目は常に消費されます。拡張モジュールは、そのビルド項目の使用を容易にするために、 "
"生成されたクラスと一緒にビルド項目を生成するかもしれません。そのようなビルドステップでは、生成されたクラスのビルド項目に `@Weak` "
"アノテーションを使用し、通常は他のビルド項目を生成します。他のビルド項目が最終的に何かによって消費される場合は、ステップが実行され、クラスが生成されます。他のビルド項目が何も消費されなければ、そのステップはビルドプロセスには含まれません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:886
#, fuzzy
msgid ""
"In the example above, `GeneratedClassBuildItem` would only be produced if "
"`ExecutorClassBuildItem` is consumed by some other build step."
msgstr ""
"上記の例では、 `GeneratedClassBuildItem` は、 `ExecutorClassBuildItem` "
"が他のビルドステップで消費された場合にのみ生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:889
#, fuzzy
msgid ""
"Note that when using <<bytecode-recording,bytecode recording>>, the "
"implicitly generated class can be declared to be weak by using the "
"`optional` attribute of the `@io.quarkus.deployment.annotations.Record` "
"annotation."
msgstr ""
"link:#bytecode-recording[バイトコード記録を]使用する場合、 `@io.quarkus.deployment."
"annotations.Record` アノテーションの `optional` "
"属性を使用することで、暗黙的に生成されたクラスを弱いものと宣言することができることに注意してください。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:890
#, no-wrap, fuzzy
msgid ""
"Example of using a bytecode recorder where the generated class is weakly "
"produced"
msgstr "生成されたクラスが弱く生成されるバイトコードレコーダーを使用した例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:902
#, no-wrap
msgid ""
"/**\n"
" * This build step is only run if something consumes the ExecutorBuildItem.\n"
" */\n"
"@BuildStep\n"
"@Record(value = ExecutionTime.RUNTIME_INIT, optional = true) // <1>\n"
"ExecutorBuildItem createExecutor( // <2>\n"
"        ExecutorTemplate executorTemplate,\n"
"        ThreadPoolConfig threadPoolConfig\n"
") {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:911
#, no-wrap
msgid ""
"    return new ExecutorBuildItem(\n"
"        setupTemplate.setupRunTime(\n"
"            shutdownContextBuildItem,\n"
"            threadPoolConfig,\n"
"            launchModeBuildItem.getLaunchMode()\n"
"        )\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:913
#, fuzzy
msgid "Note the `optional` attribute."
msgstr "`optional` 属性に注意してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:914
#, fuzzy
msgid ""
"This example is using recorder proxies; see the section on <<bytecode-"
"recording,bytecode recording>> for more information."
msgstr ""
"この例では、レコーダーのプロキシを使用しています。詳細については、 link:#bytecode-"
"recording[バイトコード記録の]セクションを参照してください。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:915
#: upstream/_guides/writing-extensions.adoc:2148
#, no-wrap, fuzzy
msgid "Capabilities"
msgstr "機能"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:921
#, fuzzy
msgid ""
"The `@BuildStep` annotation has a `providesCapabilities` property that can "
"be used to provide capability information to other extensions about what is "
"present in the current application. Capabilities are simply strings that are "
"used to describe an extension. Capabilities should generally be named after "
"an extensions root package, for example the transactions extension will "
"provide `io.quarkus.transactions`."
msgstr ""
"`@BuildStep` アノテーションには `providesCapabilities` "
"プロパティがあり、これを使用して、現在のアプリケーションに何が存在するかについてのケイパビリティ情報を他の拡張機能に提供することができます。ケイパビリティとは、拡張機能を説明するために使用される単純な文字列です。 "
"`io.quarkus.transactions`能力は一般的には拡張機能のルートパッケージにちなんだ名前をつけなければなりません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:924
#, fuzzy
msgid ""
"To check if a capability is present you can inject the `io.quarkus."
"deployment.Capabilities` object and call `isCapabilityPresent`."
msgstr ""
"ケイパビリティが存在するかどうかを確認するには、 `io.quarkus.deployment.Capabilities` オブジェクトを注入して "
"`isCapabilityPresent` を呼び出すことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:926
#, fuzzy
msgid ""
"Capabilities should be used when checking for the presence of an extension "
"rather than class path based checks."
msgstr "機能は、クラスパスに基づいたチェックではなく、拡張機能の存在をチェックするときに使用しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:927
#, no-wrap, fuzzy
msgid "Application Archives"
msgstr "アプリケーションアーカイブ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:933
#, fuzzy
msgid ""
"The `@BuildStep` annotation can also register marker files that determine "
"which archives on the class path are considered to be 'Application "
"Archives', and will therefore get indexed. This is done via the "
"`applicationArchiveMarkers`. For example the ArC extension registers `META-"
"INF/beans.xml`, which means that all archives on the class path with a "
"`beans.xml` file will be indexed."
msgstr ""
"`@BuildStep` "
"アノテーションは、クラスパス上のどのアーカイブが「アプリケーションアーカイブ」とみなされてインデックス化されるかを決定するマーカーファイルを登録することもできます。これは "
"`applicationArchiveMarkers` を通して行われます。た と えば ArC 拡張は `META-INF/beans.xml` "
"を登録します。これは、クラスパス上の `beans.xml` ファイルを持つすべてのアーカイブがインデッ クスされることを意味します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:935
#, fuzzy
msgid ""
"`BuildStep.applicationArchiveMarkers()` is deprecated and will be removed at "
"some point post Quarkus 1.1. Extensions are encouraged to use `io.quarkus."
"deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem` instead."
msgstr ""
"`BuildStep.applicationArchiveMarkers()` は非推奨で、Quarkus 1."
"1以降のある時点で削除される予定です。拡張機能は、代わりに `io.quarkus.deployment.builditem."
"AdditionalApplicationArchiveMarkerBuildItem` を使用することをお勧めします。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:936
#, no-wrap, fuzzy
msgid "Using Thread's Context Class Loader"
msgstr "スレッドのコンテキストクラスローダーの使用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:942
#, fuzzy
msgid ""
"The build step will be run with a TCCL that can load user classes from the "
"deployment in a transformer-safe way.  This class loader only lasts for the "
"life of the augmentation, and is discarded afterwards.  The classes will be "
"loaded again in a different class loader at runtime.  This means that "
"loading a class during augmentation does not stop it from being transformed "
"when running in the development/test mode."
msgstr ""
"ビルドステップは、デプロイメントからユーザークラスをトランスフォーマーセーフな方法でロードできるTCCLを使って実行されます。このクラス・ローダは拡張の期間だけ持続し、その後は破棄されます。クラスは実行時に別のクラス・ローダで再びロードされます。つまり、オーグメンテーション中にクラスをロードしても、開発/"
"テストモードで実行しているときにクラスがトランスフォームされるのを止めることはありません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:943
#, no-wrap, fuzzy
msgid "Adding external JARs to the indexer with IndexDependencyBuildItem"
msgstr "IndexDependencyBuildItemで外部JARをインデクサに追加する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:947
#, fuzzy
msgid ""
"The index of scanned classes will not automatically include your external "
"class dependencies.  To add dependencies, create a `@BuildStep` that "
"produces `IndexDependencyBuildItem` objects, for a `groupId` and "
"`artifactId`."
msgstr ""
"スキャンされたクラスのインデックスには、外部クラスの依存関係は自動的には含まれません。依存関係を追加するには、 `groupId` と "
"`artifactId` に対して `IndexDependencyBuildItem` オブジェクトを生成する `@BuildStep` "
"を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:949
#, fuzzy
msgid ""
"It is important to specify all the required artifacts to be added to the "
"indexer. No artifacts are implicitly added transitively."
msgstr "インデクサーに追加する必要のあるすべてのアーティファクトを指定することが重要です。暗黙的に通過的に追加されるアーティファクトはありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:951
#, fuzzy
msgid ""
"The `Amazon Alexa` extension adds dependent libraries from the Alexa SDK "
"that are used in Jackson JSON transformations, in order for the reflective "
"classes to identified and included at `BUILD_TIME`."
msgstr ""
"`Amazon Alexa` 拡張機能は、Jackson JSON 変換で使用される Alexa SDK "
"からの依存ライブラリを追加し、反射クラスを識別して `BUILD_TIME`."

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:965
#, no-wrap
msgid ""
"   @BuildStep\n"
"    void addDependencies(BuildProducer<IndexDependencyBuildItem> "
"indexDependency) {\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-runtime\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-model\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-lambda-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-servlet-support\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-dynamodb-persistence-adapter\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-apache-client\"));\n"
"        indexDependency.produce(new IndexDependencyBuildItem(\"com.amazon."
"alexa\", \"ask-sdk-model-runtime\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:968
#, fuzzy
msgid ""
"With the artifacts added to the `Jandex` indexer, you can now search the "
"index to identify classes implementing an interface, sub-classes of a "
"specific class, or classes with a target annotation."
msgstr ""
"`Jandex` "
"インデクサに追加された成果物により、インターフェイスを実装しているクラス、特定のクラスのサブクラス、ターゲットアノテーションを持つクラスを識別するためにインデックスを検索することができるようになりました。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:971
#, fuzzy
msgid ""
"For example, the `Jackson` extension uses code like below to search for "
"annotations used in JSON deserialization, and add them to the reflective "
"hierarchy for `BUILD_TIME` analysis."
msgstr ""
"例えば、 `Jackson` 拡張機能では、以下のようなコードを使用して、JSON デシリアライゼーションで使用されるアノテーションを検索し、 "
"`BUILD_TIME` 解析用のリフレクティブ階層に追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:976
#, no-wrap
msgid ""
"    DotName JSON_DESERIALIZE = DotName.createSimple(JsonDeserialize.class."
"getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:978
#, no-wrap
msgid "    IndexView index = combinedIndexBuildItem.getIndex();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:987
#, no-wrap
msgid ""
"    // handle the various @JsonDeserialize cases\n"
"    for (AnnotationInstance deserializeInstance : index."
"getAnnotations(JSON_DESERIALIZE)) {\n"
"        AnnotationTarget annotationTarget = deserializeInstance.target();\n"
"        if (CLASS.equals(annotationTarget.kind())) {\n"
"            DotName dotName = annotationTarget.asClass().name();\n"
"            Type jandexType = Type.create(dotName, Type.Kind.CLASS);\n"
"            reflectiveHierarchyClass.produce(new "
"ReflectiveHierarchyBuildItem(jandexType));\n"
"        }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:997
#, fuzzy
msgid ""
"Configuration in Quarkus is based on SmallRye Config, an implementation of "
"the MicroProfile Config specification.  All of the standard features of MP-"
"Config are supported; in addition, there are several extensions which are "
"made available by the SmallRye Config project as well as by Quarkus itself."
msgstr ""
"Quarkusでの設定は、MicroProfile Config仕様の実装であるSmallRye Configに基づいています。MP-"
"Configの標準機能はすべてサポートされています。さらに、SmallRye "
"ConfigプロジェクトやQuarkus自身が利用できる拡張機能もいくつかあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:999
#, fuzzy
msgid ""
"The value of these properties is configured in a `application.properties` "
"file that follows the MicroProfile config format."
msgstr ""
"これらのプロパティの値は、MicroProfile の設定形式に従う `application.properties` ファイルで設定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1001
#, fuzzy
msgid ""
"Configuration of Quarkus extensions is injection-based, using annotations."
msgstr "Quarkus拡張機能の設定は、アノテーションを使用してインジェクションベースで行われます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1002
#, no-wrap, fuzzy
msgid "Configuration Keys"
msgstr "設定キー"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1005
#, fuzzy
msgid ""
"Leaf configuration keys are mapped to non-`private` fields via the `@io."
"quarkus.runtime.annotations.ConfigItem` annotation."
msgstr ""
"リーフ構成キーは、 `@io.quarkus.runtime.annotations.ConfigItem` アノテーションを介して `private` "
"以外のフィールドにマッピングされます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1008
#, fuzzy
msgid ""
"Though the SmallRye Config project is used for implementation, the standard "
"`@ConfigProperty` annotation does not have the same semantics that are "
"needed to support configuration within extensions."
msgstr ""
"実装には SmallRye Config プロジェクトが使用されていますが、標準の `@ConfigProperty` "
"アノテーションは、拡張機能内での設定をサポートするために必要なセマンティクスを持っていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1011
#, fuzzy
msgid ""
"Configuration keys are normally derived from the field names that they are "
"tied to.  This is done by de-camel-casing the name and then joining the "
"segments with hyphens (`-`).  Some examples:"
msgstr ""
"設定キーは通常、関連付けられたフィールド名から派生します。これは、名前を脱キャメル化し、ハイフンでセグメントを結合することで行われます ( `-"
"`)。いくつかの例を示します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1013
#, fuzzy
msgid "`bindAddress` becomes `bind-address`"
msgstr "`bindAddress` になります。 `bind-address`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1014
#, fuzzy
msgid "`keepAliveTime` becomes `keep-alive-time`"
msgstr "`keepAliveTime` になります。 `keep-alive-time`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1015
#, fuzzy
msgid "`requestDNSTimeout` becomes `request-dns-timeout`"
msgstr "`requestDNSTimeout` になります。 `request-dns-timeout`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1017
#, fuzzy
msgid ""
"The name can also be explicitly specified by giving a `name` attribute to "
"the `@ConfigItem` annotation."
msgstr "`@ConfigItem` アノテーションに `name` 属性を与えることで、名前を明示的に指定することもできます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1020
#, fuzzy
msgid ""
"Though it is possible to override the configuration key name using the "
"`name` attribute of `@ConfigItem`, normally this should only be done in "
"cases where (for example) the configuration key name is the same as a Java "
"keyword."
msgstr ""
"`@ConfigItem` の `name` 属性を使って設定キー名を上書きすることは可能ですが、通常は (たとえば) 設定キー名が Java "
"キーワードと同じ場合にのみ行うべきです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1021
#, no-wrap, fuzzy
msgid "Configuration Value types"
msgstr "設定値の種類"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1025
#, fuzzy
msgid ""
"The type of the field with the `@ConfigItem` annotation determines the "
"conversion that is applied to it.  Quarkus extensions may use the full range "
"of configuration types made available by SmallRye Config, which includes:"
msgstr ""
"`@ConfigItem` "
"アノテーションを持つフィールドのタイプによって、そのフィールドに適用される変換が決まります。Quarkus拡張機能では、SmallRye "
"Configで利用可能な設定タイプのすべてを使用することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1027
#, fuzzy
msgid "All primitive types and primitive wrapper types"
msgstr "すべてのプリミティブ型とプリミティブラッパー型"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1028
#, fuzzy
msgid "`String`"
msgstr "`String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1029
#, fuzzy
msgid ""
"Any type which has a constructor accepting a single argument of type "
"`String` or `CharSequence`"
msgstr "コンストラクタが `String` あるいは型の単一の引数を受け取る型。 `CharSequence`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1030
#, fuzzy
msgid ""
"Any type which has a static method named `of` which accepts a single "
"argument of type `String`"
msgstr "`of` という名前の静的メソッドを持ち、型の単一の引数を受け付ける型。 `String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1031
#, fuzzy
msgid ""
"Any type which has a static method named `valueOf` or `parse` which accepts "
"a single argument of type `CharSequence` or `String`"
msgstr ""
"`valueOf` または `parse` という名前の静的メソッドを持ち、 `CharSequence` または の型の単一の引数を受け取る型。 "
"`String`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1032
#, fuzzy
msgid "`java.time.Duration`"
msgstr "`java.time.Duration`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1033
#, fuzzy
msgid "`java.util.regex.Pattern`"
msgstr "`java.util.regex.Pattern`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1034
#, fuzzy
msgid "`java.nio.file.Path`"
msgstr "`java.nio.file.Path`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1035
#, fuzzy
msgid "`io.quarkus.runtime.configuration.MemorySize` to represent data sizes"
msgstr "`io.quarkus.runtime.configuration.MemorySize` データサイズを表現するために"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1036
#, fuzzy
msgid ""
"`java.net.InetSocketAddress`, `java.net.InetAddress` and `org.wildfly.common."
"net.CidrAddress`"
msgstr ""
"`java.net.InetSocketAddress`, `java.net.InetAddress` `org.wildfly.common.net."
"CidrAddress`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1037
#, fuzzy
msgid "A `List` or `Optional` of any of the above types"
msgstr "上記のいずれかのタイプの `List` または `Optional`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1038
#, fuzzy
msgid "`OptionalInt`, `OptionalLong`, `OptionalDouble`"
msgstr "`OptionalInt`, `OptionalLong`. `OptionalDouble`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1041
#, fuzzy
msgid ""
"In addition, custom converters may be registered by adding their fully "
"qualified class name in file `META-INF/services/org.eclipse.microprofile."
"config.spi.Converter`."
msgstr ""
"さらに、カスタムコンバータは、ファイル `META-INF/services/org.eclipse.microprofile.config.spi."
"Converter` に完全修飾されたクラス名を追加して登録することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1043
#, fuzzy
msgid ""
"Though these implicit converters use reflection, Quarkus will automatically "
"ensure that they are loaded at the appropriate time."
msgstr "これらの暗黙のコンバータは反射を使用しますが、Quarkusは自動的に適切なタイミングでロードされるようにします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1044
#, no-wrap, fuzzy
msgid "Optional Values"
msgstr "オプション値"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1050
#, fuzzy
msgid ""
"If the configuration type is one of the optional types, then empty values "
"are allowed for the configuration key; otherwise, specification of an empty "
"value will result in a configuration error which prevents the application "
"from starting.  This is especially relevant to configuration properties of "
"inherently emptiable values such as `List`, `Set`, and `String`.  Such value "
"types will never be empty; in the event of an empty value, an empty "
"`Optional` is always used."
msgstr ""
"そうでない場合、空の値を指定すると設定エラーとなり、アプリケーションが起動できなくなります。これは特に、 `List` ・ `Set` ・ "
"`String` のような本質的に空の値を持つ設定プロパティに関係します。このような値型は決して空になることはありません。空の値の場合、常に空の "
"`Optional` が使われます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1051
#, no-wrap, fuzzy
msgid "Configuration Default Values"
msgstr "設定のデフォルト値"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1055
#, fuzzy
msgid ""
"A configuration item can be marked to have a default value.  The default "
"value is used when no matching configuration key is specified in the "
"configuration."
msgstr "構成項目には、デフォルト値を持つようにマークを付けることができます。既定値は、構成に一致する構成キーが指定されていない場合に使用されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1058
#, fuzzy
msgid ""
"Configuration items with a primitive type (such as `int` or `boolean`) "
"implicitly use a default value of `0` or `false`.  The sole exception to "
"this rule is the `char` type which does not have an implicit default value."
msgstr ""
"プリミティブ型（ `int` や `boolean` など）を持つ設定項目は、暗黙のうちに `0` や `false` "
"のデフォルト値を使用します。このルールの唯一の例外は、暗黙のデフォルト値を持たない `char` タイプです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1062
#, fuzzy
msgid ""
"A property with a default value is not implicitly optional.  If a non-"
"optional configuration item with a default value is explicitly specified to "
"have an empty value, the application will report a configuration error and "
"will not start.  If it is desired for a property to have a default value and "
"also be optional, it must have an `Optional` type as described above."
msgstr ""
"デフォルト値を持つプロパティは、暗黙のうちにオプションではありません。デフォルト値を持つオプションではない設定項目が空の値を持つように明示的に指定されている場合、アプリケーションは設定エラーを報告し、起動しません。プロパティにデフォルト値を持たせてオプションにしたい場合は、上述のように "
"`Optional` 型を持つ必要があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1063
#, no-wrap, fuzzy
msgid "Configuration Groups"
msgstr "設定グループ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1067
#, fuzzy
msgid ""
"Configuration values are always collected into grouping classes which are "
"marked with the `@io.quarkus.runtime.annotations.ConfigGroup` annotation.  "
"These classes contain a field for each key within its group.  In addition, "
"configuration groups can be nested."
msgstr ""
"設定値は常に `@io.quarkus.runtime.annotations.ConfigGroup` "
"アノテーションでマークされたグループ化クラスに集められます。これらのクラスには、グループ内の各キーのフィールドが含まれています。さらに、設定グループは入れ子にすることができます。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1068
#, no-wrap, fuzzy
msgid "Optional Configuration Groups"
msgstr "オプションの設定グループ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1074
#, fuzzy
msgid ""
"A nested configuration group may be wrapped with an `Optional` type.  In "
"this case, the group is not populated unless one or more properties within "
"that group are specified in the configuration.  If the group is populated, "
"then any required properties in the group must also be specified otherwise a "
"configuration error will be reported and the application will not start."
msgstr ""
"入れ子になっている設定グループは `Optional` "
"型で包まれている場合があります。この場合、そのグループ内の1つ以上のプロパティが設定で指定されていない限り、そのグループは生成されません。グループが設定されている場合は、そのグループ内の必須プロパティも指定しなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1075
#, no-wrap, fuzzy
msgid "Configuration Maps"
msgstr "設定マップ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1080
#, fuzzy
msgid ""
"A `Map` can be used for configuration at any position where a configuration "
"group would be allowed.  The key type of such a map *must* be `String`, and "
"its value may be either a configuration group class or a valid leaf type.  "
"The configuration key segment following the map's key segment will be used "
"as the key for map values."
msgstr ""
"`Map` は、構成グループが許可されている任意の位置で構成に使用できます。このようなマップのキー タイプは `String` である "
"*必要があり*、その値は構成グループ クラスまたは有効なリーフ タイプのいずれかである "
"*必要*があります。マップのキーセグメントに続く設定キーセグメントが、マップ値のキーとして使用されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1082
#, no-wrap, fuzzy
msgid "Configuration Roots"
msgstr "設定のルーツ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1088
#, fuzzy
msgid ""
"Configuration roots are configuration groups that appear in the root of the "
"configuration tree.  A configuration property's full name is determined by "
"joining the string `quarkus.` with the hyphenated name of the fields that "
"form the path from the root to the leaf field.  For example, if I define a "
"configuration root group called `ThreadPool`, with a nested group in a field "
"named `sizing` that in turn contains a field called `minSize`, the final "
"configuration property will be called `quarkus.thread-pool.sizing.min-size`."
msgstr ""
"構成ルートは、構成ツリーのルートに表示される構成グループです。構成プロパティのフルネームは、文字列 `quarkus.` と、ルートからリーフ "
"フィールドへのパスを形成するフィールドのハイフン名を結合することで決定されます。たとえば、 `ThreadPool` "
"という名前のコンフィギュレーション・ルート・グループを定義すると、 `sizing` という名前のフィールドに `minSize` "
"という名前のフィールドを含む入れ子のグループがあり、最終的なコンフィギュレーション・プロパティは `quarkus.thread-pool.sizing."
"min-size` と呼ばれるようになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1092
#, fuzzy
msgid ""
"A configuration root's name can be given with the `name` property, or it can "
"be inferred from the class name.  If the latter, then the configuration key "
"will be the class name, minus any `Config` or `Configuration` suffix, broken "
"up by camel-case, lowercased, and re-joined using hyphens (`-`)."
msgstr ""
"設定ルートの名前は `name` プロパティで指定することもできますし、クラス名から推測することもできます。後者の場合、設定キーはクラス名から "
"`Config` や `Configuration` の接尾辞を除いたものとなり、キャメルケースで区切って小文字にし、ハイフン ( `-`) "
"で再結合されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1097
#, fuzzy
msgid ""
"A configuration root's class name can contain an extra suffix segment for "
"the case where there are configuration roots for multiple <<Configuration "
"Root Phases>>.  Classes which correspond to the `BUILD_TIME` and "
"`BUILD_AND_RUN_TIME_FIXED` may end with `BuildTimeConfig` or "
"`BuildTimeConfiguration`, and classes which correspond to the `RUN_TIME` "
"phase may end with `RuntimeConfig`, `RunTimeConfig`, `RuntimeConfiguration` "
"or `RunTimeConfiguration`."
msgstr ""
"設定ルートのクラス名には、複数の link:#Configuration Root "
"Phases[[設定ルートフェーズ]]に対応する設定ルートが存在する場合のために、余分なサフィックスセグメントを含めることができます。 "
"`BUILD_TIME` と `BUILD_AND_RUN_TIME_FIXED` に対応するクラスは `BuildTimeConfig` または "
"`BuildTimeConfiguration` で終わることがあり、 `RUN_TIME` フェーズに対応するクラスは "
"`RuntimeConfig`, `RunTimeConfig`, `RuntimeConfiguration` または "
"`RunTimeConfiguration` で終わることがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1101
#, fuzzy
msgid ""
"Note: The current implementation is still using injection site to determine "
"the root set, so to avoid migration problems, it is recommended that the "
"injection site (field or parameter) have the same name as the configuration "
"root class until this change is complete."
msgstr ""
"注: "
"現在の実装では、ルートセットを決定するためにインジェクションサイトを使用しているため、移行の問題を避けるために、この変更が完了するまではインジェクションサイト(フィールドまたはパラメータ)に設定ルートクラスと同じ名前を付けることをお勧めします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1102
#, no-wrap, fuzzy
msgid "Configuration Root Phases"
msgstr "設定ルートフェーズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1106
#, fuzzy
msgid ""
"Configuration roots are strictly bound by configuration phase, and "
"attempting to access a configuration root from outside of its corresponding "
"phase will result in an error.  A configuration root dictates when its "
"contained keys are read from configuration, and when they are available to "
"applications.  The phases defined by `io.quarkus.runtime.annotations."
"ConfigPhase` are as follows:"
msgstr ""
"コンフィギュレーション・ルートはコンフィギュレーション・フェイズに厳密に拘束されており、対応するフェイズの外からコンフィギュレーション・ルートにアクセスしようとするとエラーになります。コンフィギュレーションルートは、その中に含まれる鍵がいつコンフィギュレーションから読み出され、それがアプリケーションから利用可能になるかを決定します。 "
"`io.quarkus.runtime.annotations.ConfigPhase` で定義されているフェーズは以下の通りです。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1137
#, no-wrap, fuzzy
msgid ""
"| Phase name\n"
"| Read & avail. at build time\n"
"| Avail. at run time\n"
"| Read during static init\n"
"| Re-read during startup (native executable)\n"
"| Notes\n"
"\n"
"| BUILD_TIME\n"
"| ✓\n"
"| ✗\n"
"| ✗\n"
"| ✗\n"
"| Appropriate for things which affect build.\n"
"\n"
"| BUILD_AND_RUN_TIME_FIXED\n"
"| ✓\n"
"| ✓\n"
"| ✗\n"
"| ✗\n"
"| Appropriate for things which affect build and must be visible for run time "
"code.  Not read from config at run time.\n"
"\n"
"| RUN_TIME\n"
"| ✗\n"
"| ✓\n"
"| ✓\n"
"| ✓\n"
"| Not available at build, read at start in all modes.\n"
"\n"
msgstr ""
"| "
"フェーズ名｜ビルド時に読み込んで利用可能｜実行時に利用可能｜スタティックinit時に読み込んで利用可能｜起動時に再読込（ネイティブ実行ファイル）｜注意事項"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1140
#, fuzzy
msgid ""
"For all cases other than the `BUILD_TIME` case, the configuration root class "
"and all of the configuration groups and types contained therein must be "
"located in, or reachable from, the extension's run time artifact.  "
"Configuration roots of phase `BUILD_TIME` may be located in or reachable "
"from either of the extension's run time or deployment artifacts."
msgstr ""
"`BUILD_TIME` "
"以外のすべてのケースでは、設定ルートクラスと、そこに含まれるすべての設定グループと型は、拡張機能のランタイム・アーティファクト内にあるか、拡張機能のランタイム・アーティファクトからアクセス可能でなければなりません。フェーズ "
"`BUILD_TIME` "
"の設定ルートは、拡張機能のランタイム・アーティファクトまたはデプロイメント・アーティファクトのいずれかにあるか、またはそこから到達可能なものでなければなりません。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1141
#, no-wrap, fuzzy
msgid "Configuration Example"
msgstr "設定例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1148
#, no-wrap
msgid ""
"import io.quarkus.runtime.annotations.ConfigItem;\n"
"import io.quarkus.runtime.annotations.ConfigGroup;\n"
"import io.quarkus.runtime.annotations.DefaultConverter\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1151
#, no-wrap
msgid "import java.io.File;\n"
"import java.util.logging.Level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1154
#, no-wrap
msgid "@ConfigGroup <1>\n"
"public class FileConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1160
#, no-wrap
msgid ""
"    /**\n"
"     * Enable logging to a file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"true\")\n"
"    boolean enable;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1166
#, no-wrap
msgid ""
"    /**\n"
"     * The log format.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p "
"[%c{1.}] (%t) %s%e%n\")\n"
"    String format;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1172
#, no-wrap
msgid ""
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1178
#, no-wrap
msgid ""
"    /**\n"
"     * The name of the file in which logs will be written.\n"
"     */\n"
"    @ConfigItem(defaultValue = \"application.log\")\n"
"    File path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1186
#, no-wrap
msgid ""
"/**\n"
" * Logging configuration.\n"
" */\n"
"@ConfigRoot(phase = ConfigPhase.RUN_TIME) <2>\n"
"public class LogConfiguration {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1188
#, no-wrap
msgid "    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1194
#, no-wrap
msgid ""
"    /**\n"
"     * Configuration properties for the logging file handler.\n"
"     */\n"
"    FileConfig file;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1197
#, no-wrap
msgid "public class LoggingProcessor {\n"
"    // ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1204
#, no-wrap
msgid ""
"    /**\n"
"     * Logging configuration.\n"
"     */\n"
"    <3>\n"
"    LogConfiguration config;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1208
#, fuzzy
msgid ""
"A configuration property name can be split into segments. For example, a "
"property name like `quarkus.log.file.enable` can be split into the following "
"segments:"
msgstr ""
"構成プロパティ名は、セグメントに分割することができます。例えば、 `quarkus.log.file.enable` "
"のようなプロパティ名は、以下のセグメントに分割することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1210
#, fuzzy
msgid ""
"`quarkus` - a namespace claimed by Quarkus which is a prefix for all "
"`@ConfigRoot` classes,"
msgstr "`quarkus` - Quarkusによって主張された名前空間で、すべての `@ConfigRoot` クラスのプレフィックスです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1211
#, fuzzy
msgid ""
"`log` - a name segment which corresponds to the `LogConfiguration` class "
"annotated with `@ConfigRoot`,"
msgstr "`log` - `@ConfigRoot` でアノテーションされた `LogConfiguration` クラスに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1212
#, fuzzy
msgid ""
"`file` - a name segment which corresponds to the `file` field in this class,"
msgstr "`file` - このクラスの `file` フィールドに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1213
#, fuzzy
msgid ""
"`enabled` - a name segment which corresponds to `enable` field in "
"`FileConfig` class annotated with `@ConfigGroup`."
msgstr ""
"`enabled` - `@ConfigGroup` でアノテーションされた `FileConfig` クラスの `enable` "
"フィールドに対応する名前セグメント。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1217
#, fuzzy
msgid ""
"The `FileConfig` class is annotated with `@ConfigGroup` to indicate that "
"this is an aggregate configuration object containing a collection of "
"configurable properties, rather than being a simple configuration key type."
msgstr ""
"`FileConfig` クラスには `@ConfigGroup` "
"というアノテーションが付けられており、これは単純な構成キー型ではなく、構成可能なプロパティのコレクションを含む集約的な構成オブジェクトであることを示しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1222
#, fuzzy
msgid ""
"The `@ConfigRoot` annotation indicates that this object is a configuration "
"root group, in this case one which corresponds to a `log` segment. A class "
"name is used to link configuration root group with the segment from a "
"property name. The `Configuration` part is stripped off from a "
"`LogConfiguration` class name and the remaining `Log` is lowercased to "
"become a `log`. Since all `@ConfigRoot` annotated classes uses `quarkus` as "
"a prefix, this finally becomes `quarkus.log` and represents the properties "
"which names begin with `quarkus.log.*`."
msgstr ""
"`@ConfigRoot` アノテーションは、このオブジェクトが構成ルート・グループであることを示し、この場合は `log` "
"セグメントに対応するものです。クラス名は、プロパティ名からセグメントとコンフィギュレーション・ルート・グループをリンクするために使用されます。 "
"`Configuration` の部分は `LogConfiguration` のクラス名から取り除かれ、残りの `Log` は小文字化されて "
"`log` になります。 `@ConfigRoot` アノテーションされたクラスはすべて `quarkus` "
"をプレフィックスとして使用しているため、最終的に `quarkus.log` となり、 `quarkus.log.*` "
"で始まる名前のプロパティを表します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1224
#, fuzzy
msgid ""
"Here the `LoggingProcessor` injects a `LogConfiguration` instance "
"automatically by detecting the `@ConfigRoot` annotation."
msgstr ""
"ここでは `LoggingProcessor` は `@ConfigRoot` アノテーションを検出して `LogConfiguration` "
"インスタンスを自動的に注入します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1226
#, fuzzy
msgid ""
"A corresponding `application.properties` for the above example could be:"
msgstr "上記の例に対応する `application.properties` は、次のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1232
#, no-wrap
msgid ""
"quarkus.log.file.enable=true\n"
"quarkus.log.file.level=DEBUG\n"
"quarkus.log.file.path=/tmp/debug.log\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1235
#, fuzzy
msgid ""
"Since `format` is not defined in these properties, the default value from "
"`@ConfigItem` will be used instead."
msgstr "これらのプロパティでは `format` が定義されていないので、代わりに `@ConfigItem` のデフォルト値が使用されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1237
#, no-wrap, fuzzy
msgid "Enhanced conversion"
msgstr "強化された変換"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1241
#, fuzzy
msgid ""
"You can use enhanced conversion of a config item by using the `@ConvertWith` "
"annotation which accepts a `Converter` class object.  If the annotation is "
"present on a config item, the implicit or custom built in converter in use "
"will be overridden by the value provided.  To do, see the example below "
"which converts `YES` or `NO` values to `boolean`."
msgstr ""
"`Converter` クラス・オブジェクトを受け付ける `@ConvertWith` "
"アノテーションを使用することで、コンフィグ項目の拡張変換を使用することができます。アノテーションが設定項目に存在する場合、使用中の暗黙の、あるいはカスタムのビルトインコンバータは、提供された値によって上書きされます。これを行うには、 "
"`YES` または `NO` の値を `boolean` に変換する以下の例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1251
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Config item with enhanced converter\n"
"     */\n"
"    @ConvertWith(YesNoConverter.class) // <1>\n"
"    @ConfigItem(defaultValue = \"NO\")\n"
"    Boolean answer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1254
#, no-wrap
msgid ""
"    public static class YesNoConverter implements Converter<Boolean> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1256
#, no-wrap
msgid "        public YesNoConverter() {}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1262
#, no-wrap
msgid ""
"        @Override\n"
"        public Boolean convert(String s) {\n"
"            if (s == null || s.isEmpty()) {\n"
"                return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1269
#, no-wrap
msgid ""
"            switch (s) {\n"
"                case \"YES\":\n"
"                    return true;\n"
"                case \"NO\":\n"
"                    return false;\n"
"            }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1274
#, no-wrap
msgid ""
"            throw new IllegalArgumentException(\"Unsupported value \" + s + "
"\" given\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1276
#, fuzzy
msgid ""
"Override the default `Boolean` converter and use the provided converter "
"which accepts a `YES` or `NO` config values."
msgstr ""
"デフォルトの `Boolean` コンバータを上書きし、 `YES` または `NO` の設定値を受け付ける提供されたコンバータを使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1279
#, fuzzy
msgid "The corresponding `application.properties` will look like."
msgstr "対応する `application.properties` は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1282
#, no-wrap
msgid "quarkus.some.answer=YES\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1287
#, fuzzy
msgid ""
"Enum values (config items) are translated to skewed-case (hyphenated) by "
"default. The table below illustrates an enum name and their canonical "
"equivalence:"
msgstr ""
"列挙型の値(設定項目)は、デフォルトではスキューテッド・ケース(ハイフン付き)に変換されます。以下の表は、列挙型名とその正準等価性を示しています。"

#. type: Table
#: upstream/_guides/writing-extensions.adoc:1312
#, no-wrap, fuzzy
msgid ""
"|Java enum| Canonical equivalent\n"
"\n"
"|DISCARD\n"
"|discard\n"
"\n"
"|READ_UNCOMMITTED\n"
"|read-uncommitted\n"
"\n"
"|SIGUSR1\n"
"|sigusr1\n"
"\n"
"|JavaEnum\n"
"|java-enum\n"
"\n"
"|MAKING_LifeDifficult\n"
"|making-life-difficult\n"
"\n"
"|YeOldeJBoss\n"
"|ye-olde-jboss\n"
"\n"
"|camelCaseEnum\n"
"|camel-case-enum\n"
"\n"
msgstr "|Java enum| 正準等価"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1315
#, fuzzy
msgid ""
"To use the default behaviour which is based on implicit converter or a "
"custom defined one add `@DefaultConverter` annotation to the configuration "
"item"
msgstr ""
"暗黙のコンバータまたはカスタム定義されたコンバータに基づくデフォルトの動作を使用するには、設定項目に `@DefaultConverter` "
"アノテーションを追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1326
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeLogConfig {\n"
"    /**\n"
"     * The level of logs to be written into the file.\n"
"     */\n"
"    @DefaultConverter // <1>\n"
"    @ConfigItem(defaultValue = \"ALL\")\n"
"    Level level;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1328
#, fuzzy
msgid ""
"Use the default converter (built in or a custom converter) to convert `Level."
"class` enum."
msgstr "`Level.class` enum を変換するには、デフォルトのコンバータ（内蔵またはカスタムコンバータ）を使用します。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1331
#, no-wrap, fuzzy
msgid "Conditional Step Inclusion"
msgstr "条件付きステップインクルージョン"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1337
#, fuzzy
msgid ""
"It is possible to only include a given `@BuildStep` under certain conditions."
"  The `@BuildStep` annotation has two optional parameters: `onlyIf` and "
"`onlyIfNot`.  These parameters can be set to one or more classes which "
"implement `BooleanSupplier`.  The build step will only be included when the "
"method returns `true` (for `onlyIf`) or `false` (for `onlyIfNot`)."
msgstr ""
"特定の条件下では、与えられた `@BuildStep` のみを含めることが可能です。 `@BuildStep` アノテーションには、 `onlyIf` "
"と `onlyIfNot` の 2 つのオプションのパラメータがあります。これらのパラメータは、 `BooleanSupplier` を実装した 1 "
"つ以上のクラスに設定できます。ビルド・ステップは、メソッドが `true` (for `onlyIf`) または `false` (for "
"`onlyIfNot`) を返した場合にのみ含まれます。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1340
#, fuzzy
msgid ""
"The condition class can inject <<configuration-roots,configuration roots>> "
"as long as they belong to a build-time phase.  Run time configuration is not "
"available for condition classes."
msgstr ""
"条件クラスは、ビルド時のフェーズに属している限り、 link:#configuration-"
"roots[設定のルートを]注入することができます。ランタイム設定は条件クラスでは利用できません。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:1343
#, fuzzy
msgid ""
"The condition class may also inject a value of type `io.quarkus.runtime."
"LaunchMode`.  Constructor parameter and field injection is supported."
msgstr ""
"条件クラスは、型 `io.quarkus.runtime.LaunchMode` "
"の値を注入することもできます。コンストラクタのパラメータとフィールドの注入がサポートされています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:1344
#, no-wrap, fuzzy
msgid "An example of a conditional build step"
msgstr "条件付きビルドステップの例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1351
#, no-wrap
msgid ""
"@BuildStep(onlyIf = IsDevMode.class)\n"
"LogCategoryBuildItem enableDebugLogging() {\n"
"    return new LogCategoryBuildItem(\"org.your.quarkus.extension\", Level."
"DEBUG);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1354
#, no-wrap
msgid ""
"static class IsDevMode implements BooleanSupplier {\n"
"    LaunchMode launchMode;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1359
#, no-wrap
msgid ""
"    public boolean getAsBoolean() {\n"
"        return launchMode == LaunchMode.DEVELOPMENT;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1362
#, no-wrap, fuzzy
msgid "Bytecode Recording"
msgstr "バイトコード記録"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1366
#, fuzzy
msgid ""
"One of the main outputs of the build process is recorded bytecode. This "
"bytecode actually sets up the runtime environment. For example, in order to "
"start Undertow, the resulting application will have some bytecode that "
"directly registers all Servlet instances and then starts Undertow."
msgstr ""
"ビルドプロセスの主な出力の一つは、記録されたバイトコードです。このバイトコードは実際にランタイム環境を設定します。例えば、Undertowを起動するために、結果として得られるアプリケーションは、すべてのサーブレットインスタンスを直接登録してUndertowを起動するバイトコードを持つことになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1372
#, fuzzy
msgid ""
"As writing bytecode directly is complex, this is instead done via bytecode "
"recorders. At deployment time, invocations are made on recorder objects that "
"contain the actual runtime logic, but instead of these invocations "
"proceeding as normal they are intercepted and recorded (hence the name). "
"This recording is then used to generate bytecode that performs the same "
"sequence of invocations at runtime. This is essentially a form of deferred "
"execution where invocations made at deployment time get deferred until "
"runtime."
msgstr ""
"バイトコードを直接書くのは複雑なので、代わりにバイトコードレコーダを使って行います。デプロイ時には、実際のランタイムロジックを含むレコーダオブジェクト上で呼び出しが行われますが、これらの呼び出しは通常通りに進行するのではなく、傍受されて記録されます（この名前の由来）。この記録は、実行時に同じシーケンスの呼び出しを実行するバイトコードを生成するために使用されます。これは基本的には繰延実行の一形態で、デプロイ時に行われた呼び出しは実行時まで延期されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1374
#, fuzzy
msgid ""
"Let's look at the classic 'Hello World' type example. To do this the Quarkus "
"way we would create a recorder as follows:"
msgstr "古典的な「Hello World」タイプの例を見てみましょう。これをQuarkusの方法で行うには、次のようにレコーダーを作成します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1379
#, no-wrap
msgid "@Recorder\n"
"class HelloRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1383
#, no-wrap
msgid ""
"  public void sayHello(String name) {\n"
"    System.out.println(\"Hello\" + name);\n"
"  }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1388
#, fuzzy
msgid "And then create a build step that uses this recorder:"
msgstr "そして、このレコーダーを使用するビルドステップを作成します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1396
#, no-wrap
msgid ""
"@Record(RUNTIME_INIT)\n"
"@BuildStep\n"
"public void helloBuildStep(HelloRecorder recorder) {\n"
"    recorder.sayHello(\"World\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1401
#, fuzzy
msgid ""
"When this build step is run nothing is printed to the console. This is "
"because the `HelloRecorder` that is injected is actually a proxy that "
"records all invocations. Instead if we run the resulting Quarkus program we "
"will see 'Hello World' printed to the console."
msgstr ""
"このビルドステップを実行してもコンソールには何も表示されません。これは、注入された `HelloRecorder` "
"が実際にはすべての呼び出しを記録するプロキシだからです。代わりに、結果のQuarkusプログラムを実行すると、コンソールに「Hello "
"World」が表示されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1406
#, fuzzy
msgid ""
"Methods on a recorder can return a value, which must be proxiable (if you "
"want to return a non-proxiable item wrap it in `io.quarkus.runtime."
"RuntimeValue`). These proxies may not be invoked directly, however they can "
"be passed into other recorder methods. This can be any recorder method, "
"including from other `@BuildStep` methods, so a common pattern is to produce "
"`BuildItem` instances that wrap the results of these recorder invocations."
msgstr ""
"レコーダーのメソッドは値を返すことができますが、その値はプロキシ可能なものでなければなりません (プロキシ不可能な項目を返したい場合は `io."
"quarkus.runtime.RuntimeValue` "
"でラップしてください)。これらのプロキシは直接呼び出すことはできませんが、他のレコーダのメソッドに渡すことができます。これは、他の "
"`@BuildStep` メソッドからも含めて、どのレコーダ・メソッドでもよいので、これらのレコーダ呼び出しの結果をラップした `BuildItem` "
"インスタンスを生成するのが一般的なパターンです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1410
#, fuzzy
msgid ""
"For instance, in order to make arbitrary changes to a Servlet deployment "
"Undertow has a `ServletExtensionBuildItem`, which is a `MultiBuildItem` that "
"wraps a `ServletExtension` instance. I can return a `ServletExtension` from "
"a recorder in another module, and Undertow will consume it and pass it into "
"the recorder method that starts Undertow."
msgstr ""
"例えば、サーブレットのデプロイメントに任意の変更を加えるために、Undertow には `ServletExtensionBuildItem` があり、 "
"`ServletExtension` インスタンスをラップする `MultiBuildItem` があります。別のモジュールのレコーダから "
"`ServletExtension` を返すと、Undertow はそれを消費して Undertow を起動するレコーダメソッドに渡します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1414
#, fuzzy
msgid ""
"At runtime the bytecode will be invoked in the order it is generated. This "
"means that build step dependencies implicitly control the order that "
"generated bytecode is run. In the example above we know that the bytecode "
"that produces a `ServletExtensionBuildItem` will be run before the bytecode "
"that consumes it."
msgstr ""
"実行時には、バイトコードは生成された順番で呼び出されます。つまり、ビルドステップの依存関係は、生成されたバイトコードが実行される順序を暗黙的に制御することを意味します。上の例では、 "
"`ServletExtensionBuildItem` を生成するバイトコードは、それを消費するバイトコードの前に実行されることがわかっています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1416
#, fuzzy
msgid "The following objects can be passed to recorders:"
msgstr "以下のオブジェクトをレコーダに渡すことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1418
#, fuzzy
msgid "Primitives"
msgstr "プリミティブ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1419
#, fuzzy
msgid "String"
msgstr "ひもじ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1420
#, fuzzy
msgid "Class<?> objects"
msgstr "クラス&lt;?"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1421
#, fuzzy
msgid "Objects returned from a previous recorder invocation"
msgstr "前回のレコーダ呼び出しから返されたオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1422
#, fuzzy
msgid ""
"Objects with a no-arg constructor and getter/setters for all properties (or "
"public fields)"
msgstr "すべてのプロパティ (またはパブリックフィールド) のための、引数なしのコンストラクタとゲッター/セッターを持つオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1423
#, fuzzy
msgid ""
"Objects with a constructor annotated with `@RecordableConstructor` with "
"parameter names that match field names"
msgstr ""
"フィールド名と一致するパラメータ名を持つ `@RecordableConstructor` でアノテーションされたコンストラクタを持つオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1424
#, fuzzy
msgid ""
"Any arbitrary object via the `io.quarkus.deployment.recording."
"RecorderContext#registerSubstitution(Class, Class, Class)` mechanism"
msgstr ""
"`io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, "
"Class, Class)` メカニズムを介した任意のオブジェクト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1425
#, fuzzy
msgid "Arrays, Lists and Maps of the above"
msgstr "上記の配列、リスト、マップ"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1427
#, no-wrap, fuzzy
msgid "RecorderContext"
msgstr "レコーダコンテキスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1433
#, fuzzy
msgid ""
"`io.quarkus.deployment.recording.RecorderContext` provides some convenience "
"methods to enhance bytecode recording, this includes the ability to register "
"creation functions for classes without no-arg constructors, to register an "
"object substitution (basically a transformer from a non-serializable object "
"to a serializable one and vice versa), and to create a class proxy. This "
"interface can be directly injected as a method parameter into any `@Record` "
"method."
msgstr ""
"`io.quarkus.deployment.recording.RecorderContext` "
"はバイトコード記録を強化するための便利なメソッドをいくつか提供しています。これには、no-arg "
"のコンストラクタを使用しないクラスの作成関数の登録、オブジェクト置換の登録（基本的にはシリアライズ可能でないオブジェクトからシリアライズ可能なオブジェクトへの変換、およびその逆）、およびクラスプロキシの作成機能が含まれています。このインターフェイスは、 "
"`@Record` の任意のメソッドにメソッドパラメータとして直接注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1437
#, fuzzy
msgid ""
"Calling `classProxy` with a given class name will create a `Class` that can "
"be passed into recorder methods, and at runtime will be substituted with the "
"class whose name was passed in to `classProxy`. This is basically a "
"convenience to avoid the need to explicitly load classes in the recorders."
msgstr ""
"指定したクラス名で `classProxy` を呼び出すと、レコーダのメソッドに渡すことができる `Class` が作成され、実行時には "
"`classProxy` "
"に渡された名前のクラスで置き換えられます。これは基本的には、レコーダで明示的にクラスをロードする必要がないようにするための便宜的なものです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1438
#, no-wrap, fuzzy
msgid "Printing step execution time"
msgstr "印刷ステップ実行時間"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1443
#, fuzzy
msgid ""
"At times, it can be useful to know how the exact time each startup task "
"(which is the result of each bytecode recording) takes when the application "
"is run.  The simplest way to determine this information is to set the "
"`quarkus.debug.print-startup-times` property to `true` when running the "
"application.  The output will look something like:"
msgstr ""
"時には、アプリケーションの実行時に各起動タスク（各バイトコードの記録の結果である）がどのくらいの正確な時間を要するかを知ることが有用です。この情報を知る最も簡単な方法は、アプリケーションの実行時に "
"`quarkus.debug.print-startup-times` プロパティを `true` に設定することです。出力は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1456
#, no-wrap
msgid ""
"Build step LoggingResourceProcessor.setupLoggingRuntimeInit completed in: "
"42ms\n"
"Build step ConfigGenerationBuildStep.checkForBuildTimeConfigChange completed "
"in: 4ms\n"
"Build step SyntheticBeansProcessor.initRuntime completed in: 0ms\n"
"Build step ConfigBuildStep.validateConfigProperties completed in: 1ms\n"
"Build step ResteasyStandaloneBuildStep.boot completed in: 95ms\n"
"Build step VertxHttpProcessor.initializeRouter completed in: 1ms\n"
"Build step VertxHttpProcessor.finalizeRouter completed in: 4ms\n"
"Build step LifecycleEventsBuildStep.startupEvent completed in: 1ms\n"
"Build step VertxHttpProcessor.openSocket completed in: 93ms\n"
"Build step ShutdownListenerBuildStep.setupShutdown completed in: 1ms\n"
msgstr ""

#. TODO: config integration
#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1461
#, no-wrap, fuzzy
msgid "Contexts and Dependency Injection"
msgstr "コンテキストと依存性インジェクション"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1463
#, no-wrap, fuzzy
msgid "Extension Points"
msgstr "拡張ポイント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1468
#, fuzzy
msgid ""
"As a CDI based runtime, Quarkus extensions often make CDI beans available as "
"part of the extension behavior.  However, Quarkus DI solution does not "
"support CDI Portable Extensions.  Instead, Quarkus extensions can make use "
"of various link:cdi-reference[Build Time Extension Points]."
msgstr ""
"CDIベースのランタイムとして、Quarkusの拡張機能では、拡張機能の動作の一部としてCDIビーンズを利用できるようにすることがよくあります。しかし、Quarkus "
"DIソリューションはCDIポータブル拡張をサポートしていません。代わりに、Quarkusの拡張機能は、さまざまな link:cdi-"
"reference[Build Time Extension Pointsを]利用することができます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1469
#, no-wrap, fuzzy
msgid "Extension Health Check"
msgstr "拡張健康診断"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1472
#, fuzzy
msgid ""
"Health checks are provided via the `quarkus-smallrye-health` extension. It "
"provides both liveness and readiness checks capabilities."
msgstr ""
"健康チェックは `quarkus-smallrye-health` "
"の拡張子を介して提供されます。これは、活力と準備状態のチェック機能の両方を提供します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1474
#, fuzzy
msgid ""
"When writing an extension, it's beneficial to provide health checks for the "
"extension, that can be automatically included without the developer needing "
"to write their own."
msgstr "拡張機能を書くときには、開発者が自分で書かなくても自動的に含まれるようにすることができる拡張機能のヘルスチェックを提供することが有益です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1476
#, fuzzy
msgid "In order to provide a health check, you should do the following:"
msgstr "健康診断を行うためには、以下のようにしましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1479
#, fuzzy
msgid ""
"Import the `quarkus-smallrye-health` extension as an **optional** dependency "
"in your runtime module so it will not impact the size of the application if "
"health check is not included."
msgstr ""
"`quarkus-smallrye-health` 拡張モジュールを "
"*オプションの*依存関係としてランタイムモジュールにインポートすることで、ヘルスチェックが含まれていない場合でもアプリケーションのサイズに影響を与えないようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1481
#, fuzzy
msgid ""
"Create your health check following the link:microprofile-health[Quarkus - "
"MicroProfile Health] guide. We advise providing only readiness check for an "
"extension (liveness check is designed to express the fact that an "
"application is up and needs to be lightweight)."
msgstr ""
"link:microprofile-health[Quarkus - MicroProfile "
"Health]ガイドに従って、ヘルスチェックを作成します。拡張機能のレディネスチェックのみを提供することをお勧めします（ライブネスチェックは、アプリケーションが起動していることや軽量化が必要であることを表現するために設計されています）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1482
#, fuzzy
msgid ""
"Import the `quarkus-smallrye-health-spi` library in your deployment module."
msgstr "デプロイメント モジュールに `quarkus-smallrye-health-spi` ライブラリをインポートします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1483
#, fuzzy
msgid ""
"Add a build step in your deployment module that produces a `HealthBuildItem`."
""
msgstr "デプロイメントモジュールにビルドステップを追加して、 `HealthBuildItem`."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1484
#, fuzzy
msgid ""
"Add a way to disable the extension health check via a config item `quarkus."
"<extension>.health.enabled` that should be enabled by default."
msgstr ""
"デフォルトで有効になっているはずの設定項目 `quarkus.&amp;lt;extension&amp;gt;.health.enabled` "
"を介して、拡張機能のヘルスチェックを無効にする方法を追加しました。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1486
#, fuzzy
msgid ""
"Following is an example from the Agroal extension that provides a "
"`DataSourceHealthCheck` to validate the readiness of a datasource."
msgstr ""
"以下は、データソースの準備状況を検証するために `DataSourceHealthCheck` を提供する Agroal 拡張モジュールの例です。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1494
#, no-wrap
msgid ""
"@BuildStep\n"
"HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) "
"{\n"
"    return new HealthBuildItem(\"io.quarkus.agroal.runtime.health."
"DataSourceHealthCheck\",\n"
"            agroalBuildTimeConfig.healthEnabled);\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1496
#, no-wrap, fuzzy
msgid "Extension Metrics"
msgstr "拡張メトリクス"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1501
#, fuzzy
msgid ""
"The `quarkus-micrometer` extension and the `quarkus-smallrye-metrics` "
"extension provide support for collecting metrics.  As a compatibility note, "
"the `quarkus-micrometer` extension adapts the MP Metrics API to Micrometer "
"library primitives, so the `quarkus-micrometer` extension can be enabled "
"without breaking code that relies on the MP Metrics API.  Note that the "
"metrics emitted by Micrometer are different, see the `quarkus-micrometer` "
"extension documentation for more information."
msgstr ""
"`quarkus-micrometer` 拡張モジュールと `quarkus-smallrye-metrics` "
"拡張モジュールは、メトリクスを収集するためのサポートを提供します。互換性についての注意点として、 `quarkus-micrometer` "
"拡張モジュールは MP Metrics API を Micrometer ライブラリのプリミティブに適応させているので、MP Metrics API "
"に依存しているコードを壊すことなく `quarkus-micrometer` 拡張モジュールを有効にすることができます。Micrometer "
"が出力するメトリクスは異なることに注意してください。詳細は `quarkus-micrometer` 拡張モジュールのドキュメントを参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1503
#, fuzzy
msgid ""
"The compatibility layer for MP Metrics APIs will move to a different "
"extension in the future."
msgstr "MP Metrics API の互換性レイヤは、将来的には別の拡張機能に移行する予定です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1505
#, fuzzy
msgid ""
"There are two broad patterns that extensions can use to interact with an "
"optional metrics extension to add their own metrics:"
msgstr ""
"このような場合、「Element Import」（インポート）は、「Element Import」（インポート）と呼ばれ、「Element "
"Import」（インポート）は、「Element Import」（インポート）と呼ばれます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1507
#, fuzzy
msgid ""
"Consumer pattern: An extension declares a `MetricsFactoryConsumerBuildItem` "
"and uses that to provide a bytecode recorder to the metrics extension. When "
"the metrics extension has initialized, it will iterate over registered "
"consumers to initialize them with a `MetricsFactory`. This factory can be "
"used to declare API-agnostic metrics, which can be a good fit for extensions "
"that provide an instrumentable object for gathering statistics (e.g. "
"Hibernate's `Statistics` class)."
msgstr ""
"コンシューマパターン。拡張機能は `MetricsFactoryConsumerBuildItem` "
"を宣言し、それを使ってメトリクス拡張機能にバイトコード・レコーダを提供します。 "
"`MetricsFactory`このように、このクラスでは、「Element Import」という名前のクラスを使用しています。このファクトリは、API "
"にとらわれないメトリクスを宣言するために使用することができ、統計情報を収集するための計測可能なオブジェクトを提供する拡張機能（Hibernate の "
"`Statistics` クラスなど）に適しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1509
#, fuzzy
msgid ""
"Binder pattern: An extension can opt to use completely different gathering "
"implementations depending on the metrics system. An "
"`Optional<MetricsCapabilityBuildItem> metricsCapability` build step "
"parameter can be used to declare or otherwise initialize API-specific "
"metrics based on the active metrics extension (e.g. \"smallrye-metrics\" or "
"\"micrometer\"). This pattern can be combined with the consumer pattern by "
"using `MetricsFactory::metricsSystemSupported()` to test the active metrics "
"extension within the recorder."
msgstr ""
"バインダーパターン。このような場合には、「Element Import」（要素）は、「Element Import」（要素）と呼ばれ、「Element "
"Import」（要素）は、「Element Import」（要素）と呼ばれます。 "
"`Optional&amp;lt;MetricsCapabilityBuildItem&amp;gt; metricsCapability` "
"ビルドステップパラメータを使用して、アクティブなメトリクス拡張に基づく API "
"固有のメトリクスを宣言したり、そうでなければ初期化したりすることができます（例：\"smallrye-"
"metrics\"や\"micrometer\"）。このパターンは、 `MetricsFactory::"
"metricsSystemSupported()` "
"を使用して、レコーダ内でアクティブなメトリクス拡張をテストすることで、コンシューマパターンと組み合わせることができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1511
#, fuzzy
msgid ""
"Remember that support for metrics is optional. Extensions can use an "
"`Optional<MetricsCapabilityBuildItem> metricsCapability` parameter in their "
"build step to test for the presence of an enabled metrics extension. "
"Consider using additional configuration to control behavior of metrics. "
"Datasource metrics can be expensive, for example, so additional "
"configuration flags are used enable metrics collection on individual "
"datasources."
msgstr ""
"この図では、「Element Import」（要素）と「Element Import」（要素）の間の関係を説明しています。 "
"`Optional&amp;lt;MetricsCapabilityBuildItem&amp;gt; metricsCapability` "
"この図では、「Element Import」（要素）と「Element Import」（要素）の間の関係を説明します。UML 2.0 "
"コンポジット構造体は、クラス間の相互作用を表すものではありません。例えば、データソース・メトリクスは高価な場合があるため、追加の構成フラグを使用して、個々のデータソースでのメトリクス収集を有効にします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1513
#, fuzzy
msgid ""
"When adding metrics for your extension, you may find yourself in one of the "
"following situations:"
msgstr "拡張機能のメトリクスを追加するとき、以下のいずれかの状況に陥ることがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1515
#, fuzzy
msgid ""
"An underlying library used by the extension is using a specific Metrics API "
"directly (either MP Metrics, Micrometer, or some other)."
msgstr ""
"拡張機能で使用される基礎となるライブラリは、特定のメトリクス API を直接使用しています (MP Metrics, Micrometer, "
"または他のもの)。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1516
#, fuzzy
msgid ""
"An underlying library uses its own mechanism for collecting metrics and "
"makes them available at runtime using its own API, e.g. Hibernate's "
"`Statistics` class, or Vert.x `MetricsOptions`."
msgstr ""
"`Statistics` `MetricsOptions`基礎となるライブラリは、メトリクスを収集するために独自のメカニズムを使用し、独自の API "
"を使用して実行時に利用できるようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1517
#, fuzzy
msgid ""
"An underlying library does not provide metrics (or there is no library at "
"all) and you want to add instrumentation."
msgstr "このような場合には、「インストルメンテーション」を追加する必要があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1518
#, no-wrap, fuzzy
msgid "Case 1: The library uses a metrics library directly"
msgstr "ケース1：ライブラリはメトリクスライブラリを直接使用する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1521
#, fuzzy
msgid "If the library directly uses a metrics API, there are two options:"
msgstr "ライブラリが直接メトリクス API を使用する場合は、2 つのオプションがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1523
#, fuzzy
msgid ""
"Use an `Optional<MetricsCapabilityBuildItem> metricsCapability` parameter to "
"test which metrics API is supported (e.g. \"smallrye-metrics\" or "
"\"micrometer\") in your build step, and use that to selectively declare or "
"initialize API-specific beans or build items."
msgstr ""
"`Optional&amp;lt;MetricsCapabilityBuildItem&amp;gt; metricsCapability` "
"パラメータを使用して、ビルドステップでどのメトリクス API がサポートされているか (例: \"smallrye-metrics\" や "
"\"micrometer\" など) をテストし、API 固有のビーンやビルド項目を選択的に宣言または初期化するために使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1525
#, fuzzy
msgid ""
"Create a separate build step that consumes a `MetricsFactory`, and use the "
"`MetricsFactory::metricsSystemSupported()` method within the bytecode "
"recorder to initialize required resources if the desired metrics API is "
"supported (e.g. \"smallrye-metrics\" or \"micrometer\")."
msgstr ""
"`MetricsFactory` を消費する別のビルド・ステップを作成し、バイトコード・レコーダ内で `MetricsFactory::"
"metricsSystemSupported()` メソッドを使用して、必要なメトリクス API "
"がサポートされている場合に必要なリソースを初期化します（例：\"smallrye-metrics\" や \"micrometer\"）。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1527
#, fuzzy
msgid ""
"Extensions may need to provide a fallback if there is no active metrics "
"extension or the extension doesn't support the API required by the library."
msgstr ""
"アクティブなメトリクス拡張子がない場合や、拡張子がライブラリが必要とする API "
"をサポートしていない場合、拡張子はフォールバックを提供する必要がある場合があります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1528
#, no-wrap, fuzzy
msgid "Case 2: The library provides its own metric API"
msgstr "ケース 2: ライブラリが独自のメトリック API を提供する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1531
#, fuzzy
msgid "There are two examples of a library providing its own metrics API:"
msgstr "独自のメトリクス API を提供するライブラリの例は 2 つあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1533
#, fuzzy
msgid ""
"The extension defines an instrumentable object as Agroal does with `io."
"agroal.api.AgroalDataSourceMetrics`, or"
msgstr ""
"この拡張機能は、Agroal が `io.agroal.api.AgroalDataSourceMetrics` "
"で行っているように、インストルメント可能なオブジェクトを定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1534
#, fuzzy
msgid ""
"The extension provides its own abstraction of metrics, as Jaeger does with "
"`io.jaegertracing.spi.MetricsFactory`."
msgstr ""
"Jaeger が `io.jaegertracing.spi.MetricsFactory` "
"で行っているように、拡張機能は独自のメトリクスの抽象化を提供します。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1535
#, no-wrap, fuzzy
msgid "Observing instrumentable objects"
msgstr "計装可能な物体の観察"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1538
#, fuzzy
msgid ""
"Let's take the instrumentable object (`io.agroal.api."
"AgroalDataSourceMetrics`) case first. In this case, you can do the following:"
""
msgstr ""
"まず、インストルメント可能なオブジェクト ( `io.agroal.api.AgroalDataSourceMetrics`) "
"の場合を取り上げてみましょう。この場合は以下のようにします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1540
#, fuzzy
msgid ""
"Define a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that "
"uses a `RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` "
"consumer. For example, the following creates a "
"`MetricsFactoryConsumerBuildItem` if and only if metrics are enabled both "
"for Agroal generally, and for a datasource specifically:"
msgstr ""
"`MetricsFactoryConsumerBuildItem` `RUNTIME_INIT` または Recorder を使用して "
"コンシューマを定義する を生成する。例えば、以下は、Agroal 一般とデータソースの両方でメトリクスが有効になっている場合にのみ、 を生成します。 "
"`STATIC_INIT` `MetricsFactory` `BuildStep` `MetricsFactoryConsumerBuildItem`"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1549
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void registerMetrics(AgroalMetricsRecorder recorder,\n"
"        DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,\n"
"        BuildProducer<MetricsFactoryConsumerBuildItem> datasourceMetrics,\n"
"        List<AggregatedDataSourceBuildTimeConfigBuildItem> "
"aggregatedDataSourceBuildTimeConfigs) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1561
#, no-wrap
msgid ""
"    for (AggregatedDataSourceBuildTimeConfigBuildItem "
"aggregatedDataSourceBuildTimeConfig : aggregatedDataSourceBuildTimeConfigs) "
"{\n"
"        // Create a MetricsFactory consumer to register metrics for a data "
"source\n"
"        // IFF metrics are enabled globally and for the data source\n"
"        // (they are enabled for each data source by default if they are "
"also enabled globally)\n"
"        if (dataSourcesBuildTimeConfig.metricsEnabled &&\n"
"                aggregatedDataSourceBuildTimeConfig.getJdbcConfig()."
"enableMetrics.orElse(true)) {\n"
"            datasourceMetrics.produce(new MetricsFactoryConsumerBuildItem(\n"
"                    recorder."
"registerDataSourceMetrics(aggregatedDataSourceBuildTimeConfig.getName())));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1564
#, fuzzy
msgid ""
"The associated recorder should use the provided `MetricsFactory` to register "
"metrics. For Agroal, this means using the `MetricFactory` API to observe `io."
"agroal.api.AgroalDataSourceMetrics` methods. For example:"
msgstr ""
"関連するレコーダは、提供された `MetricsFactory` を使用してメトリクスを登録する必要があります。Agroal の場合、これは "
"`MetricFactory` API を使用して `io.agroal.api.AgroalDataSourceMetrics` "
"メソッドを観測することを意味します。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1574
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerDataSourceMetrics(String "
"dataSourceName) {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            String tagValue = DataSourceUtil.isDefault(dataSourceName) ? "
"\"default\" : dataSourceName;\n"
"            AgroalDataSourceMetrics metrics = getDataSource(dataSourceName)."
"getMetrics();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1582
#, no-wrap
msgid ""
"            // When using MP Metrics, the builder uses the VENDOR registry "
"by default.\n"
"            metricsFactory.builder(\"agroal.active.count\")\n"
"                    .description(\n"
"                            \"Number of active connections. These "
"connections are in use and not available to be acquired.\")\n"
"                    .tag(\"datasource\", tagValue)\n"
"                    .buildGauge(metrics::activeCount);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1585
#, fuzzy
msgid ""
"The `MetricsFactory` provides a fluid builder for registration of metrics, "
"with the final step constructing gauges or counters based on a `Supplier` or "
"`ToDoubleFunction`. Timers can either wrap `Callable`, `Runnable`, or "
"`Supplier` implementations, or can use a `TimeRecorder` to accumulate chunks "
"of time. The underlying metrics extension will create appropriate artifacts "
"to observe or measure the defined functions."
msgstr ""
"`MetricsFactory` はメトリクスを登録するための流体ビルダーを提供し、最終的なステップでは `Supplier` または "
"`ToDoubleFunction` に基づいてゲージやカウンターを構築します。タイマーは、 `Callable` 、 `Runnable` 、または "
"`Supplier` の実装をラップしたり、 `TimeRecorder` "
"を使用して時間の塊を蓄積したりすることができます。このように、「Element Import」は、「Element Import」と呼ばれています。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:1586
#, no-wrap, fuzzy
msgid "Using a Metrics API-specific implementation"
msgstr "メトリクス API 固有の実装を使用する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1589
#, fuzzy
msgid ""
"Using metrics-API specific implementations may be preferred in some cases. "
"Jaeger, for example, defines its own metrics interface, `io.jaegertracing."
"spi.MetricsFactory`, that it uses to define counters and gauges. A direct "
"mapping from that interface to the metrics system will be the most efficient."
" In this case, it is important to isolate these specialized implementations "
"and to avoid eager classloading to ensure the metrics API remains an "
"optional, compile-time dependency."
msgstr ""
"メトリクス API 固有の実装を使用することが好ましい場合もあります。たとえば、Jaeger "
"は、カウンタとゲージを定義するために使用する独自のメトリクス・インタフェース（ `io.jaegertracing.spi."
"MetricsFactory` ）を定義しています。このような場合には、「Element Import」（要素）は、「Element "
"Import」（要素）と呼ばれ、「Element Import」（要素）は「Element "
"Import」（要素）と呼ばれます。この場合は、これらの特殊な実装を分離し、熱心なクラスローディングを避けて、メトリクス API "
"がコンパイル時の依存関係にあるオプションのままであることを確実にすることが重要です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1591
#, fuzzy
msgid ""
"`Optional<MetricsCapabilityBuildItem> metricsCapability` can be used in the "
"build step to selectively control initialization of beans or the production "
"of other build items. The Jaeger extension, for example, can use the "
"following to control initialization of specialized Metrics API adapters:"
msgstr ""
"`Optional&amp;lt;MetricsCapabilityBuildItem&amp;gt; metricsCapability` "
"は、ビーンズの初期化や他のビルド項目の生成を選択的に制御するために、ビルドステップで使用することができます。Jaeger "
"拡張モジュールでは、例えば、以下のようにして、特殊な Metrics API アダプタの初期化を制御することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1599
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig "
"buildTimeConfig, JaegerConfig jaeger,\n"
"        ApplicationConfig appConfig, Optional<MetricsCapabilityBuildItem> "
"metricsCapability) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1602
#, no-wrap
msgid ""
"    // Indicates that this extension would like the SSL support to be "
"enabled\n"
"    extensionSslNativeSupport.produce(new "
"ExtensionSslNativeSupportBuildItem(Feature.JAEGER.getName()));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1616
#, no-wrap
msgid ""
"    if (buildTimeConfig.enabled) {\n"
"        // To avoid dependency creep, use two separate recorder methods for "
"the two metrics systems\n"
"        if (buildTimeConfig.metricsEnabled && metricsCapability.isPresent()) "
"{\n"
"            if (metricsCapability.get().metricsSupported(MetricsFactory."
"MICROMETER)) {\n"
"                jdr.registerTracerWithMicrometerMetrics(jaeger, appConfig);\n"
"            } else {\n"
"                jdr.registerTracerWithMpMetrics(jaeger, appConfig);\n"
"            }\n"
"        } else {\n"
"            jdr.registerTracerWithoutMetrics(jaeger, appConfig);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1619
#, fuzzy
msgid ""
"A recorder consuming a `MetricsFactory` can use `MetricsFactory::"
"metricsSystemSupported()` can be used to control initialization of metrics "
"objects during bytecode recording in a similar way."
msgstr ""
"`MetricsFactory` を消費するレコーダは、 `MetricsFactory::metricsSystemSupported()` "
"を使用して、バイトコード記録中のメトリクスオブジェクトの初期化を同様の方法で制御することができます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1620
#, no-wrap, fuzzy
msgid "Case 3: It is necessary to collect metrics within the extension code"
msgstr "ケース3：拡張コード内でメトリクスを収集する必要がある"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1623
#, fuzzy
msgid ""
"To define your own metrics from scratch, you have two basic options: Use the "
"generic `MetricFactory` builders, or follow the binder pattern, and create "
"instrumentation specific to the enabled metrics extension."
msgstr "この図では、「Element Import Import」という名前を使用して、「Element Import」という名前を定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1625
#, fuzzy
msgid ""
"To use the extension-agnostic `MetricFactory` API, your processor can define "
"a `BuildStep` that produces a `MetricsFactoryConsumerBuildItem` that uses a "
"`RUNTIME_INIT` or `STATIC_INIT` Recorder to define a `MetricsFactory` "
"consumer."
msgstr ""
"拡張子に依存しない `MetricFactory` API を使用するために、プロセッサは `RUNTIME_INIT` または "
"`STATIC_INIT` Recorder を使用して `MetricsFactory` コンシューマを定義する "
"`MetricsFactoryConsumerBuildItem` を生成する `BuildStep` を定義することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1633
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(ExecutionTime.RUNTIME_INIT)\n"
"MetricsFactoryConsumerBuildItem registerMetrics(MyExtensionRecorder "
"recorder) {\n"
"    return new MetricsFactoryConsumerBuildItem(recorder.registerMetrics());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1636
#, fuzzy
msgid ""
"The associated recorder should use the provided `MetricsFactory` to register "
"metrics, for example"
msgstr "関連するレコーダーは、提供された `MetricsFactory` を使用してメトリクスを登録する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1640
#, no-wrap
msgid "final LongAdder extensionCounter = new LongAdder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1649
#, no-wrap
msgid ""
"/* RUNTIME_INIT */\n"
"public Consumer<MetricsFactory> registerMetrics() {\n"
"    return new Consumer<MetricsFactory>() {\n"
"        @Override\n"
"        public void accept(MetricsFactory metricsFactory) {\n"
"            metricsFactory.builder(\"my.extension.counter\")\n"
"                    .buildGauge(extensionCounter::longValue);\n"
"            ....\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1652
#, fuzzy
msgid ""
"Remember that metrics extensions are optional. Keep metrics-related "
"initialization isolated from other setup for your extension, and structure "
"your code to avoid eager imports of metrics APIs. Gathering metrics can also "
"be expensive. Consider using additional extension-specific configuration to "
"control behavior of metrics if the presence/absence of metrics support isn't "
"sufficient."
msgstr ""
"UML 2.0 図では、「Element Import」という名前で、「Element "
"Import」という名前を使用しています。メトリクス関連の初期化は、拡張のための他のセットアップから分離しておき、メトリクス API "
"の熱心なインポートを避けるためにコードを構造化してください。UML 2.0 図では、「UML 2.0」と「UML 2.0」の間には、「UML 2."
"0」と「UML 2.0」があります。UML 2.0 コンポジット構造体は、「UML 2.0 コンポジット構造体」と呼ばれています。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1653
#, no-wrap, fuzzy
msgid "Customizing JSON handling from an extension"
msgstr "拡張機能からJSON処理をカスタマイズする"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1656
#, fuzzy
msgid ""
"Extensions often need to register serializers and/or deserializers for types "
"the extension provides."
msgstr "拡張機能はしばしば、拡張機能が提供する型のシリアライザやデシリアライザを登録する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1659
#, fuzzy
msgid ""
"For this, both Jackson and JSON-B extensions provide a way to register "
"serializer/deserializer from within an extension deployment module."
msgstr ""
"このため、Jackson 拡張モジュールと JSON-B 拡張モジュールの両方で、拡張モジュール内からシリアライザ/"
"デシリアライザを登録する方法を提供しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1661
#, fuzzy
msgid ""
"Keep in mind that not everybody will need JSON, so you need to make it "
"optional."
msgstr "すべての人がJSONを必要とするわけではないことを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1664
#, fuzzy
msgid ""
"If an extension intends to provide JSON related customization, it is "
"strongly advised to provide customization for both Jackson and JSON-B."
msgstr ""
"拡張機能がJSON関連のカスタマイズを提供しようとする場合は、JacksonとJSON-Bの両方のカスタマイズを提供することを強くお勧めします。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1665
#, no-wrap, fuzzy
msgid "Customizing Jackson"
msgstr "ジャクソンのカスタマイズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1668
#, fuzzy
msgid ""
"First, add an *optional* dependency to `quarkus-jackson` on your extension's "
"runtime module."
msgstr "まず、拡張機能のランタイムモジュールに `quarkus-jackson` に *オプションの*依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1676
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1679
#, fuzzy
msgid ""
"Then create a serializer or a deserializer (or both) for Jackson, an example "
"of which can be seen in the `mongodb-panache` extension."
msgstr ""
"次に、Jackson 用のシリアライザまたはデシリアライザ (またはその両方) を作成します。 `mongodb-panache` "
"の拡張モジュールで例を見ることができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1694
#, no-wrap
msgid ""
"public class ObjectIdSerializer extends StdSerializer<ObjectId> {\n"
"    public ObjectIdSerializer() {\n"
"        super(ObjectId.class);\n"
"    }\n"
"    @Override\n"
"    public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, "
"SerializerProvider serializerProvider)\n"
"            throws IOException {\n"
"        if (objectId != null) {\n"
"            jsonGenerator.writeString(objectId.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1697
#, fuzzy
msgid ""
"Add a dependency to `quarkus-jackson-spi` on your extension's deployment "
"module."
msgstr "`quarkus-jackson-spi` への依存関係をエクステンションのデプロイメントモジュールに追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1704
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jackson-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1708
#, fuzzy
msgid ""
"Add a build step to your processor to register a Jackson module via the "
"`JacksonModuleBuildItem`.  You need to name your module in a unique way "
"across all Jackson modules."
msgstr ""
"`JacksonModuleBuildItem` を経由して、Jackson "
"モジュールを登録するためのビルドステップをプロセッサに追加してください。モジュールの名前は、すべてのJacksonモジュールに共通するユニークな方法で命名する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1719
#, no-wrap
msgid ""
"@BuildStep\n"
"JacksonModuleBuildItem registerJacksonSerDeser() {\n"
"    return new JacksonModuleBuildItem.Builder(\"ObjectIdModule\")\n"
"                    .add(io.quarkus.mongodb.panache.jackson."
"ObjectIdSerializer.class.getName(),\n"
"                            io.quarkus.mongodb.panache.jackson."
"ObjectIdDeserializer.class.getName(),\n"
"                            ObjectId.class.getName())\n"
"                    .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1722
#, fuzzy
msgid ""
"The Jackson extension will then use the produced build item to register a "
"module within Jackson automatically."
msgstr "そして、Jackson 拡張モジュールは、生成されたビルドアイテムを使用して、Jackson 内で自動的にモジュールを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1726
#, fuzzy
msgid ""
"If you need more customization capabilities than registering a module, you "
"can produce a CDI bean that implements `io.quarkus.jackson."
"ObjectMapperCustomizer` via an `AdditionalBeanBuildItem`.  More info about "
"customizing Jackson can be found on the JSON guide link:rest-"
"json#configuring-json-support[Configuring JSON support]"
msgstr ""
"モジュールを登録する以上のカスタマイズ機能が必要な場合は、 `io.quarkus.jackson.ObjectMapperCustomizer` "
"を実装した CDI Bean を `AdditionalBeanBuildItem` を介して作成することができます。Jackson "
"のカスタマイズについての詳細は、JSON ガイドの JS link:rest-json#configuring-json-support[ON "
"サポートの設定]を参照してください。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:1727
#, no-wrap, fuzzy
msgid "Customizing JSON-B"
msgstr "JSON-Bのカスタマイズ"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1729
#, fuzzy
msgid ""
"First, add an *optional* dependency to `quarkus-jsonb` on your extension's "
"runtime module."
msgstr "まず、拡張機能のランタイムモジュールに `quarkus-jsonb` に *オプションの*依存関係を追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1737
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb</artifactId>\n"
"  <optional>true</optional>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1740
#, fuzzy
msgid ""
"Then create a serializer and/or a deserializer for JSON-B, an example of "
"which can be seen in the `mongodb-panache` extension."
msgstr ""
"次に、JSON-B用のシリアライザおよび/またはデシリアライザを作成します。 `mongodb-panache` 拡張モジュールに例があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1751
#, no-wrap
msgid ""
"public class ObjectIdSerializer implements JsonbSerializer<ObjectId> {\n"
"    @Override\n"
"    public void serialize(ObjectId obj, JsonGenerator generator, "
"SerializationContext ctx) {\n"
"        if (obj != null) {\n"
"            generator.write(obj.toString());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1754
#, fuzzy
msgid ""
"Add a dependency to `quarkus-jsonb-spi` on your extension's deployment "
"module."
msgstr "`quarkus-jsonb-spi` への依存関係をエクステンションのデプロイメントモジュールに追加します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1761
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-jsonb-spi</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1764
#, fuzzy
msgid ""
"Add a build step to your processor to register the serializer via the "
"`JsonbSerializerBuildItem`."
msgstr "ビルドステップをプロセッサに追加して、 `JsonbSerializerBuildItem` を経由してシリアライザを登録します。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1771
#, no-wrap
msgid ""
"@BuildStep\n"
"JsonbSerializerBuildItem registerJsonbSerializer() {\n"
"    return new JsonbSerializerBuildItem(io.quarkus.mongodb.panache.jsonb."
"ObjectIdSerializer.class.getName()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1774
#, fuzzy
msgid ""
"The JSON-B extension will then use the produced build item to register your "
"serializer/deserializer automatically."
msgstr "JSON-B拡張機能は、生成されたビルド項目を使用して、シリアライザ/デシリアライザを自動的に登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1778
#, fuzzy
msgid ""
"If you need more customization capabilities than registering a serializer or "
"a deserializer, you can produce a CDI bean that implements `io.quarkus.jsonb."
"JsonbConfigCustomizer` via an `AdditionalBeanBuildItem`.  More info about "
"customizing JSON-B can be found on the JSON guide link:rest-json#configuring-"
"json-support[Configuring JSON support]"
msgstr ""
"シリアライザやデシリアライザを登録する以上のカスタマイズ機能が必要な場合は、 `io.quarkus.jsonb."
"JsonbConfigCustomizer` を実装した CDI Bean を `AdditionalBeanBuildItem`.JSON-B "
"のカスタマイズについての詳細は、JSON ガイドの link:rest-json#configuring-json-support[JSON "
"サポートの設定]に記載されています。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1779
#, no-wrap, fuzzy
msgid "Testing Extensions"
msgstr "拡張機能のテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1786
#, fuzzy
msgid ""
"Testing of Quarkus extensions should be done with the `io.quarkus.test."
"QuarkusUnitTest` JUnit 5 extension.  This extension allows for Arquillian-"
"style tests that test specific functionalities.  It is not intended for "
"testing user applications, as this should be done via `io.quarkus.test.junit."
"QuarkusTest`.  The main difference is that `QuarkusTest` simply boots the "
"application once at the start of the run, while `QuarkusUnitTest` deploys a "
"custom Quarkus application for each test class."
msgstr ""
"Quarkus 拡張モジュールのテストは `io.quarkus.test.QuarkusUnitTest` JUnit 5 "
"拡張モジュールを使用してください。この拡張機能を使用すると、特定の機能をテストする Arquillian "
"スタイルのテストを行うことができます。ユーザーアプリケーションのテストは `io.quarkus.test.junit.QuarkusTest` "
"を経由して行う必要があるため、ユーザーアプリケーションのテストを目的としたものではありません。主な違いは、 `QuarkusTest` "
"は実行開始時にアプリケーションを起動するだけなのに対し、 `QuarkusUnitTest` は各テストクラスごとにカスタムの Quarkus "
"アプリケーションを展開する点です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1789
#, fuzzy
msgid ""
"These tests should be placed in the deployment module, if additional Quarkus "
"modules are required for testing their deployment modules should also be "
"added as test scoped dependencies."
msgstr ""
"これらのテストはデプロイメントモジュールに配置する必要があります。Quarkusモジュールのテストに追加のQuarkusモジュールが必要な場合は、それらのデプロイメントモジュールもテストスコープ付きの依存関係として追加する必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1791
#, fuzzy
msgid ""
"Note that `QuarkusUnitTest` is in the `quarkus-junit5-internal` module."
msgstr "`QuarkusUnitTest` は `quarkus-junit5-internal` モジュールの中にあることに注意してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1793
#, fuzzy
msgid "An example test class may look like:"
msgstr "テストクラスの例は次のようになります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1797
#, no-wrap
msgid "package io.quarkus.health.test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1799
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1802
#, no-wrap
msgid "import java.util.ArrayList;\n"
"import java.util.List;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1805
#, no-wrap
msgid "import javax.enterprise.inject.Instance;\n"
"import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1815
#, no-wrap
msgid ""
"import org.eclipse.microprofile.health.Health;\n"
"import org.eclipse.microprofile.health.HealthCheck;\n"
"import org.eclipse.microprofile.health.HealthCheckResponse;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.asset.EmptyAsset;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1817
#, no-wrap
msgid "import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1819
#, no-wrap
msgid "public class FailingUnitTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1827
#, no-wrap
msgid ""
"    @RegisterExtension                                                       "
"           // <1>\n"
"    static final QuarkusUnitTest config = new QuarkusUnitTest()\n"
"            .setArchiveProducer(() ->\n"
"                    ShrinkWrap.create(JavaArchive.class)                     "
"           // <2>\n"
"                            .addClasses(FailingHealthCheck.class)\n"
"                            .addAsManifestResource(EmptyAsset.INSTANCE, "
"\"beans.xml\")\n"
"            );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1831
#, no-wrap
msgid ""
"    @Inject                                                                  "
"           // <3>\n"
"    @Health\n"
"    Instance<HealthCheck> checks;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1836
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthServlet() {\n"
"        RestAssured.when().get(\"/health\").then().statusCode(503);          "
"             // <4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1847
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHealthBeans() {\n"
"        List<HealthCheck> check = new ArrayList<>();                         "
"           // <5>\n"
"        for (HealthCheck i : checks) {\n"
"            check.add(i);\n"
"        }\n"
"        assertEquals(1, check.size());\n"
"        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call()."
"getState());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1850
#, fuzzy
msgid ""
"The `QuarkusUnitTest` extension must be used with a static field. If used "
"with a non-static field, the test application is not started."
msgstr ""
"`QuarkusUnitTest` "
"拡張子は、静的フィールドと一緒に使用する必要があります。静的でないフィールドで使用した場合、テストアプリケーションは開始されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1851
#, fuzzy
msgid ""
"This producer is used to build the application to be tested. It uses "
"Shrinkwrap to create a JavaArchive to test"
msgstr ""
"このプロデューサーは、テストされるアプリケーションを構築するために使用されます。Shrinkwrap を使用して、テストする JavaArchive "
"を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1852
#, fuzzy
msgid ""
"It is possible to inject beans from our test deployment directly into the "
"test case"
msgstr "テストデプロイメントからテストケースに直接ビーンを注入することができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1853
#, fuzzy
msgid ""
"This method directly invokes the health check Servlet and verifies the "
"response"
msgstr "このメソッドは、ヘルスチェックサーブレットを直接呼び出し、レスポンスを検証します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1854
#, fuzzy
msgid ""
"This method uses the injected health check bean to verify it is returning "
"the expected result"
msgstr "このメソッドは、注入されたヘルスチェック・ビーンを使用して、それが期待された結果を返していることを確認します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1856
#, fuzzy
msgid ""
"If you want to test that an extension properly fails at build time, use the "
"`setExpectedException` method:"
msgstr ""
"ビルド時に拡張機能が適切に失敗するかどうかをテストしたい場合は、 `setExpectedException` メソッドを使用してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1861
#, no-wrap
msgid "package io.quarkus.hibernate.orm;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1869
#, no-wrap
msgid ""
"import io.quarkus.deployment.configuration.ConfigurationError;\n"
"import io.quarkus.test.QuarkusUnitTest;\n"
"import org.jboss.shrinkwrap.api.ShrinkWrap;\n"
"import org.jboss.shrinkwrap.api.spec.JavaArchive;\n"
"import org.junit.jupiter.api.Assertions;\n"
"import org.junit.jupiter.api.Test;\n"
"import org.junit.jupiter.api.extension.RegisterExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1871
#, no-wrap
msgid "public class PersistenceAndQuarkusConfigTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1878
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    static QuarkusUnitTest runner = new QuarkusUnitTest()\n"
"            .setExpectedException(ConfigurationError.class)                  "
"   <1>\n"
"            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n"
"                    .addAsManifestResource(\"META-INF/some-persistence."
"xml\", \"persistence.xml\")\n"
"                    .addAsResource(\"application.properties\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1886
#, no-wrap
msgid ""
"    @Test\n"
"    public void testPersistenceAndConfigTest() {\n"
"        // should not be called, deployment exception should happen first:\n"
"        // it's illegal to have Hibernate configuration properties in both "
"the\n"
"        // application.properties and in the persistence.xml\n"
"        Assertions.fail();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1891
#, fuzzy
msgid ""
"This tells JUnit that the Quarkus deployment should fail with a specific "
"exception"
msgstr "これは、Quarkus のデプロイが特定の例外で失敗することを JUnit に伝えます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1893
#, no-wrap, fuzzy
msgid "Testing hot reload"
msgstr "ホットリロードのテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1897
#, fuzzy
msgid ""
"It is also possible to write tests that verify an extension works correctly "
"in development mode and can correctly handle updates."
msgstr "開発モードで拡張機能が正しく動作し、アップデートを正しく処理できるかどうかを検証するテストを書くことも可能です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1900
#, fuzzy
msgid ""
"For most extensions this will just work 'out of the box', however it is "
"still a good idea to have a smoke test to verify that this functionality is "
"working as expected. To test this we use `QuarkusDevModeTest`:"
msgstr ""
"ほとんどの拡張機能では、これは「箱から出してすぐに」動作しますが、この機能が期待通りに動作しているかどうかを確認するためにスモークテストを行うことをお勧めします。このテストには "
"`QuarkusDevModeTest`."

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1905
#, no-wrap
msgid "public class ServletChangeTestCase {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1916
#, no-wrap
msgid ""
"    @RegisterExtension\n"
"    final static QuarkusDevModeTest test = new QuarkusDevModeTest()\n"
"            .setArchiveProducer(new Supplier<JavaArchive>() {\n"
"                @Override\n"
"                public JavaArchive get() {\n"
"                    return ShrinkWrap.create(JavaArchive.class)   <1>\n"
"                            .addClass(DevServlet.class)\n"
"                            .addAsManifestResource(new StringAsset(\"Hello "
"Resource\"), \"resources/file.txt\");\n"
"                }\n"
"            });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1922
#, no-wrap
msgid ""
"    @Test\n"
"    public void testServletChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello World\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1924
#, no-wrap
msgid ""
"        test.modifySourceFile(\"DevServlet.java\", new Function<String, "
"String>() {  <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1930
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return s.replace(\"Hello World\", \"Hello Quarkus\");\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1935
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/dev\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Quarkus\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1940
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddServlet() throws InterruptedException {\n"
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1942
#, no-wrap
msgid ""
"        test.addSourceFile(NewServlet.class);                                "
"       <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1947
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new Servlet\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1953
#, no-wrap
msgid ""
"    @Test\n"
"    public void testResourceChange() throws InterruptedException {\n"
"        RestAssured.when().get(\"/file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"Hello Resource\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1955
#, no-wrap
msgid ""
"        test.modifyResourceFile(\"META-INF/resources/file.txt\", new "
"Function<String, String>() { <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1961
#, no-wrap
msgid ""
"            @Override\n"
"            public String apply(String s) {\n"
"                return \"A new resource\";\n"
"            }\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1966
#, no-wrap
msgid ""
"        RestAssured.when().get(\"file.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"A new resource\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1969
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAddResource() throws InterruptedException {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1972
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(404);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1974
#, no-wrap
msgid ""
"        test.addResourceFile(\"META-INF/resources/new.txt\", \"New File\");  "
"<5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:1978
#, no-wrap
msgid ""
"        RestAssured.when().get(\"/new.txt\").then()\n"
"                .statusCode(200)\n"
"                .body(is(\"New File\"));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:198
#, no-wrap
msgid "    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1985
#, fuzzy
msgid ""
"This starts the deployment, your test can modify it as part of the test "
"suite. Quarkus will be restarted between each test method so every method "
"starts with a clean deployment."
msgstr ""
"これによりデプロイメントが開始され、テストはテストスイートの一部として変更することができます。Quarkusは各テストメソッドの間に再起動されるので、すべてのメソッドはクリーンなデプロイメントから始まります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1988
#, fuzzy
msgid ""
"This method allows you to modify the source of a class file. The old source "
"is passed into the function, and the updated source is returned."
msgstr "このメソッドを使用すると、クラス・ファイルのソースを変更することができます。古いソースが関数に渡され、更新されたソースが返されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1991
#, fuzzy
msgid ""
"This method adds a new class file to the deployment. The source that is used "
"will be the original source that is part of the current project."
msgstr ""
"このメソッドは、新しいクラス ファイルをデプロイメントに追加します。使用されるソースは、現在のプロジェクトの一部であるオリジナルのソースになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1993
#, fuzzy
msgid "This method modifies a static resource"
msgstr "このメソッドは静的リソース"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:1995
#, fuzzy
msgid "This method adds a new static resource"
msgstr "このメソッドは新しい静的リソース"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:1996
#, no-wrap, fuzzy
msgid "Native Executable Support"
msgstr "ネイティブ実行ファイルのサポート"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2001
#, fuzzy
msgid ""
"There Quarkus provides a lot of build items that control aspects of the "
"native executable build. This allows for extensions to programmatically "
"perform tasks such as registering classes for reflection or adding static "
"resources to the native executable. Some of these build items are listed "
"below:"
msgstr ""
"Quarkusでは、ネイティブ実行ファイルのビルドの側面を制御する多くのビルド項目を提供しています。これにより、リフレクションのためにクラスを登録したり、ネイティブ実行ファイルに静的リソースを追加したりといったタスクを、拡張機能がプログラムで実行できるようになります。これらのビルド項目の一部を以下に示します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2002
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2004
#, fuzzy
msgid "Includes static resources into the native executable."
msgstr "ネイティブ実行ファイルに静的なリソースをインクルードします。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2005
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceDirectoryBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceDirectoryBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2007
#, fuzzy
msgid "Includes directory's static resources into the native executable."
msgstr "ディレクトリの静的リソースをネイティブ実行ファイルに含めます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2008
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeReinitializedClassBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeReinitializedClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2010
#, fuzzy
msgid ""
"A class that will be reinitialized at runtime by Substrate. This will result "
"in the static initializer running twice."
msgstr "実行時に Substrate によって再初期化されるクラス。これにより、静的イニシャライザが2回実行されることになります。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2011
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageSystemPropertyBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageSystemPropertyBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2013
#, fuzzy
msgid "A system property that will be set at native executable build time."
msgstr "ネイティブ実行ファイルのビルド時に設定されるシステムプロパティです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2014
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceBundleBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"NativeImageResourceBundleBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2016
#, fuzzy
msgid "Includes a resource bundle in the native executable."
msgstr "ネイティブ実行ファイルにリソースバンドルを含みます。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2017
#, no-wrap, fuzzy
msgid "`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2019
#, fuzzy
msgid ""
"Registers a class for reflection in Substrate. Constructors are always "
"registered, while methods and fields are optional."
msgstr "Substrateに反映させるためのクラスを登録します。コンストラクタは常に登録され、メソッドとフィールドはオプションです。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2020
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeInitializedClassBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage."
"RuntimeInitializedClassBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2022
#, fuzzy
msgid ""
"A class that will be initialized at runtime rather than build time. This "
"will cause the build to fail if the class is initialized as part of the "
"native executable build process, so care must be taken."
msgstr ""
"ビルド時ではなく実行時に初期化されるクラス。これは、ネイティブの実行可能なビルドプロセスの一部としてクラスが初期化されるとビルドが失敗する原因となるので、注意が必要です。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2023
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2025
#, fuzzy
msgid ""
"A convenience feature that allows you to control most of the above features "
"from a single build item."
msgstr "1つのビルドアイテムから上記の機能のほとんどをコントロールできる便利な機能です。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2026
#, no-wrap, fuzzy
msgid ""
"`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"
msgstr ""
"`io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2028
#, fuzzy
msgid "Indicates that all charsets should be enabled in native image."
msgstr "ネイティブ画像ですべての文字セットを有効にすることを示します。"

#. type: Labeled list
#: upstream/_guides/writing-extensions.adoc:2029
#, no-wrap, fuzzy
msgid "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"
msgstr "`io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem`"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2032
#, fuzzy
msgid ""
"A convenient way to tell Quarkus that the extension requires SSL and it "
"should be enabled during native image build.  When using this feature, "
"remember to add your extension to the list of extensions that offer SSL "
"support automatically on the https://github.com/quarkusio/quarkus/blob/"
"master/docs/src/main/asciidoc/native-and-ssl.adoc[native and ssl guide]."
msgstr ""
"拡張機能がSSLを必要とし、ネイティブイメージのビルド中に有効にする必要があることをQuarkusに伝える便利な方法です。この機能を使用する場合は、 "
"link:https://github.com/quarkusio/quarkus/blob/master/docs/src/main/asciidoc/"
"native-and-ssl."
"adoc[ネイティブおよびsslガイド]で自動的にSSLサポートを提供する拡張機能のリストに拡張機能を追加することを忘れないでください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2033
#, no-wrap, fuzzy
msgid "IDE support tips"
msgstr "IDE サポートのヒント"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2035
#, no-wrap, fuzzy
msgid "Writing Quarkus extensions in Eclipse"
msgstr "EclipseでQuarkus拡張機能を書く"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2038
#, fuzzy
msgid ""
"The only particular aspect of writing Quarkus extensions in Eclipse is that "
"APT (Annotation Processing Tool) is required as part of extension builds, "
"which means you need to:"
msgstr ""
"EclipseでQuarkus拡張機能を書く際の唯一の特別な点は、拡張機能のビルドの一部としてAPT（Annotation Processing "
"Tool）が必要であることです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2040
#, fuzzy
msgid "Install `m2e-apt` from https://marketplace.eclipse.org/content/m2e-apt"
msgstr ""
"https://marketplace.eclipse.org/content/m2e-apt から `m2e-apt` をインストールします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2041
#, fuzzy
msgid ""
"Define this property in your `pom.xml`: `<m2e.apt.activation>jdt_apt</m2e."
"apt.activation>`, although if you rely on `io.quarkus:quarkus-build-parent` "
"you will get it for free."
msgstr ""
"あなたの `pom.xml`: `&amp;lt;m2e.apt.activation&amp;gt;jdt_apt&amp;lt;/m2e.apt."
"activation&amp;gt;` 、あなたが `io.quarkus:quarkus-build-parent` "
"に依存している場合、あなたは無料でそれを取得しますが、このプロパティを定義します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2042
#, fuzzy
msgid ""
"If you have the `io.quarkus:quarkus-extension-processor` project open at the "
"same time in your IDE (for example, if you have the Quarkus sources checked "
"out and open in your IDE) you will need to close that project. Otherwise, "
"Eclipse will not invoke the APT plugin that it contains."
msgstr ""
"IDEで `io.quarkus:quarkus-extension-processor` "
"プロジェクトを同時に開いている場合（例えば、QuarkusソースをチェックアウトしてIDEで開いている場合など）、そのプロジェクトを閉じる必要があります。そうしないと、Eclipseはそのプロジェクトに含まれるAPTプラグインを起動しません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2043
#, fuzzy
msgid ""
"If you just closed the extension processor project, be sure to do `Maven > "
"Update Project` on the other projects in order for Eclipse to pick up the "
"extension processor from the Maven repository."
msgstr ""
"拡張プロセッサプロジェクトを閉じたばかりの場合は、EclipseがMavenリポジトリから拡張プロセッサをピックアップするために、他のプロジェクトで "
"`Maven &amp;gt; Update Project` を実行するようにしてください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2044
#, no-wrap, fuzzy
msgid "Troubleshooting / Debugging Tips"
msgstr "トラブルシューティング / デバッグのヒント"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2046
#, no-wrap, fuzzy
msgid "Dump the Generated Classes to the File System"
msgstr "生成されたクラスをファイルシステムにダンプする"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2051
#, fuzzy
msgid ""
"During the augmentation phase Quarkus extensions generate new and modify "
"existing classes for various purposes.  Sometimes you need to inspect the "
"generated bytecode to debug or understand an issue.  There are three system "
"properties that allow you to dump the classes to the filesystem:"
msgstr ""
"拡張フェーズでは、Quarkusの拡張機能は、さまざまな目的のために既存のクラスを新規に生成したり変更したりします。デバッグや問題の理解のために、生成されたバイトコードを検査する必要がある場合もあります。クラスをファイルシステムにダンプするための3つのシステムプロパティがあります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2053
#, fuzzy
msgid ""
"`quarkus.debug.generated-classes-dir` - to dump the generated classes, such "
"as bean metadata"
msgstr "`quarkus.debug.generated-classes-dir` - ビーンのメタデータのような生成されたクラスをダンプします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2054
#, fuzzy
msgid ""
"`quarkus.debug.transformed-classes-dir` - to dump the transformed classes, e."
"g. Panache entities"
msgstr ""
"`quarkus.debug.transformed-classes-dir` - 変換されたクラス、例えば Panache "
"エンティティをダンプします。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2055
#, fuzzy
msgid ""
"`quarkus.debug.generated-sources-dir` - to dump the ZIG files; ZIG file is a "
"textual representation of the generated code that is referenced in the stack "
"traces"
msgstr ""
"`quarkus.debug.generated-sources-dir` - ZIG ファイルをダンプします。ZIG "
"ファイルは、スタックトレースで参照される生成コードのテキスト表現です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2057
#, fuzzy
msgid ""
"These properties are especially useful in the development mode or when "
"running the tests where the generated/transformed classes are only held in "
"memory in a class loader."
msgstr "これらのプロパティは、開発モードや、生成/変換されたクラスがクラス・ローダのメモリにしか保持されないテストを実行するときに特に便利です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2059
#, fuzzy
msgid ""
"For example, you can specify the `quarkus.debug.generated-classes-dir` "
"system property to have these classes written out to disk for inspection in "
"the development mode:"
msgstr ""
"例えば、 `quarkus.debug.generated-classes-dir` system "
"プロパティを指定して、開発モードで検査のためにこれらのクラスをディスクに書き出すようにすることができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2063
#, no-wrap
msgid "./mvnw quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2066
#, fuzzy
msgid ""
"The property value could be either an absolute path, such as `/home/foo/"
"dump` on a Linux machine, or a path relative to the user working directory, "
"i.e. `dump` corresponds to the `{user.dir}/target/dump` in the dev mode and "
"`{user.dir}/dump` when running the tests."
msgstr ""
"`dump` `{user.dir}/target/dump` `{user.dir}/dump` プロパティ値は、Linux マシンの `/home/"
"foo/dump` のような絶対パスか、ユーザの作業ディレクトリからの相対パスのどちらかになります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2068
#, fuzzy
msgid ""
"You should see a line in the log for each class written to the directory:"
msgstr "ディレクトリに書き込まれた各クラスのログに一行が表示されるはずです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2072
#, no-wrap
msgid ""
"INFO  [io.qua.run.boo.StartupActionImpl] (main) Wrote /path/to/my/app/target/"
"dump-classes/io/quarkus/arc/impl/ActivateRequestContextInterceptor_Bean."
"class\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2075
#, fuzzy
msgid "The property is also honored when running tests:"
msgstr "このプロパティは、テストを実行する際にも優先されます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2079
#, no-wrap
msgid ""
"./mvnw clean test -Dquarkus.debug.generated-classes-dir=target/dump-"
"generated-classes\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2082
#, fuzzy
msgid ""
"Analogously, you can use the `quarkus.debug.transformed-classes-dir` and "
"`quarkus.debug.transformed-classes-dir` properties to dump the relevant "
"output."
msgstr ""
"同様に、 `quarkus.debug.transformed-classes-dir` と `quarkus.debug.transformed-"
"classes-dir` プロパティを使用して、関連する出力をダンプすることができます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2084
#, no-wrap, fuzzy
msgid "Multi-module Maven Projects and the Development Mode"
msgstr "マルチモジュールMavenプロジェクトと開発モード"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2089
#, fuzzy
msgid ""
"It's not uncommon to develop an extension in a multi-module Maven project "
"that also contains an \"example\" module.  However, if you want to run the "
"example in the development mode then the `-DnoDeps` system property must be "
"used in order to exclude the local project dependencies.  Otherwise, Quarkus "
"attempts to monitor the extension classes and this may result in weird class "
"loading issues."
msgstr ""
"マルチモジュールのMavenプロジェクトで拡張機能を開発する場合、\"example\"モジュールも含まれていることは珍しくありません。しかし、開発モードで例を実行したい場合は、ローカルプロジェクトの依存関係を除外するために、 "
"`-DnoDeps` "
"システムプロパティを使用する必要があります。そうしないと、Quarkusは拡張クラスを監視しようとするため、奇妙なクラスロードの問題が発生する可能性があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2093
#, no-wrap
msgid "./mvnw compile quarkus:dev -DnoDeps\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2095
#, no-wrap, fuzzy
msgid "Indexer does not include your external dependency"
msgstr "インデクサには、あなたの外部依存関係が含まれていません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2098
#, fuzzy
msgid ""
"Remember to add `IndexDependencyBuildItem` artifacts to your `@BuildStep`."
msgstr "`IndexDependencyBuildItem` の成果物を `@BuildStep` に追加することを忘れないでください。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2099
#, no-wrap, fuzzy
msgid "Sample Test Extension"
msgstr "サンプルテスト拡張"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2102
#, fuzzy
msgid ""
"We have an extension that is used to test for regressions in the extension "
"processing. It is located in {quarkus-tree-url}/core/test-extension "
"directory. In this section we touch on some of the tasks an extension author "
"will typically need to perform using the test-extension code to illustrate "
"how the task could be done."
msgstr ""
"拡張機能の処理でリグレッションのテストを行うための拡張機能を用意しています。これは {quarkus-tree-url}/core/test-"
"extension "
"ディレクトリにあります。このセクションでは、拡張機能の作者がテスト拡張コードを使って実行する必要があるタスクのいくつかに触れ、どのようにタスクが実行できるかを説明します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2103
#, no-wrap, fuzzy
msgid "Features and Capabilities"
msgstr "特徴と機能"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2105
#, no-wrap, fuzzy
msgid "Features"
msgstr "特徴"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2109
#, fuzzy
msgid ""
"A _feature_ represents a functionality provided by an extension.  The name "
"of the feature gets displayed in the log during application bootstrap."
msgstr "_機能は_、拡張機能によって提供される機能を表します。機能の名前は、アプリケーションの起動時にログに表示されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2110
#, no-wrap, fuzzy
msgid "Example Startup Lines"
msgstr "スタートアップラインの例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2115
#, no-wrap
msgid ""
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT "
"started in 0.061s.\n"
"2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, "
"test-extension] <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2117
#, fuzzy
msgid "A list of features installed in the runtime image"
msgstr "ランタイムイメージにインストールされている機能のリスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2119
#, fuzzy
msgid ""
"A feature can be registered in a <<Build Step Processors>> method that "
"produces a `FeatureBuildItem`:"
msgstr "機能を登録できるのは、 link:#Build Step Processors[] `FeatureBuildItem`."

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2120
#, no-wrap, fuzzy
msgid "TestProcessor#feature()"
msgstr "TestProcessor#feature()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2127
#, no-wrap
msgid ""
"    @BuildStep\n"
"    FeatureBuildItem feature() {\n"
"        return new FeatureBuildItem(\"test-extension\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2132
#, fuzzy
msgid ""
"The name of the feature should only contain lowercase characters, words are "
"separated by dash; e.g. `security-jpa`.  An extension should provide at most "
"one feature and the name must be unique.  If multiple extensions register a "
"feature of the same name the build fails."
msgstr ""
"`security-"
"jpa`機能の名前は小文字のみで、単語はダッシュで区切ってください。1つの拡張モジュールが提供する機能は最大でも1つでなければならず、その名前は一意でなければなりません。複数の拡張モジュールが同じ名前の機能を登録した場合、ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2136
#, fuzzy
msgid ""
"The feature name should also map to a label in the extension's `devtools/"
"common/src/main/filtered/extensions.json` entry so that the feature name "
"displayed by the startup line matches a label that one can used to select "
"the extension when creating a project using the Quarkus maven plugin as "
"shown in this example taken from the link:rest-json[Writing JSON REST "
"Services] guide where the `resteasy-jackson` feature is referenced:"
msgstr ""
"機能名は、 `resteasy-jackson` 機能が参照されている link:rest-json[Writing JSON REST "
"Services]ガイドの例に示されているように、起動時に表示される機能名が、Quarkus "
"mavenプラグインを使用してプロジェクトを作成する際に拡張機能を選択するために使用できるラベルと一致するように、拡張機能の `devtools/"
"common/src/main/filtered/extensions.json` エントリ内のラベルにもマッピングする必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2146
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=rest-json \\\n"
"    -DclassName=\"org.acme.rest.json.FruitResource\" \\\n"
"    -Dpath=\"/fruits\" \\\n"
"    -Dextensions=\"resteasy-jackson\"\n"
"cd rest-json\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2153
#, fuzzy
msgid ""
"A _capability_ represents a technical capability that can be queried by "
"other extensions.  An extension may provide multiple capabilities and "
"multiple extensions can provide the same capability.  By default, "
"capabilities are not displayed to users."
msgstr ""
"_ケイパビリティ_は、他のエクステンションから問い合わせ可能な技術的なケイパビリティを表します。1つのエクステンションが複数のケイパビリティを提供し、複数のエクステンションが同じケイパビリティを提供することができます。デフォルトでは、ケイパビリティはユーザーに表示されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2155
#, fuzzy
msgid ""
"Capabilities can be registered in a <<Build Step Processors>> method that "
"produces a `CapabilityBuildItem`:"
msgstr ""
"能力は、 `CapabilityBuildItem` を生成する link:#Build Step Processors[[Build Step "
"Processors]]メソッドに登録することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2156
#, no-wrap, fuzzy
msgid "TestProcessor#capability()"
msgstr "TestProcessor#capability()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2164
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void capabilities(BuildProducer<CapabilityBuildItem> capabilityProducer) "
"{\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-"
"transactions\"));\n"
"        capabilityProducer.produce(new CapabilityBuildItem(\"org.acme.test-"
"metrics\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2167
#, fuzzy
msgid ""
"Extensions can consume registered capabilities using the `Capabilities` "
"build item:"
msgstr "拡張機能は、 `Capabilities` ビルド項目を使用して登録された機能を消費することができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2168
#, no-wrap, fuzzy
msgid "TestProcessor#doSomeCoolStuff()"
msgstr "TestProcessor#doSomeCoolStuff()"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2177
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void doSomeCoolStuff(Capabilities capabilities) {\n"
"        if (capabilities.isPresent(Capability.TRANSACTIONS)) {\n"
"          // do something only if JTA transactions are in...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2181
#, fuzzy
msgid ""
"Capabilities should follow the naming conventions of Java packages; e.g. `io."
"quarkus.security.jpa`.  Capabilities provided by core extensions should be "
"listed in the `io.quarkus.deployment.Capability` enum and their name should "
"always start with the `io.quarkus` prefix."
msgstr ""
"`io.quarkus.security.jpa`機能はJavaパッケージの命名規則に従うべきです。コア拡張機能によって提供される機能は `io."
"quarkus.deployment.Capability` enum にリストされ、その名前は常に `io.quarkus` で始まるべきです。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2182
#, no-wrap, fuzzy
msgid "Bean Defining Annotations"
msgstr "Bean定義アノテーション"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2184
#, fuzzy
msgid ""
"The CDI layer processes CDI beans that are either explicitly registered or "
"that it discovers based on bean defining annotations as defined in http://"
"docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[2.5.1. "
"Bean defining annotations]. You can expand this set of annotations to "
"include annotations your extension processes using a "
"`BeanDefiningAnnotationBuildItem` as shown in this "
"`TestProcessor#registerBeanDefinningAnnotations` example:"
msgstr ""
"CDI レイヤは、明示的に登録された CDI ビーン、または link:http://docs.jboss.org/cdi/spec/2.0/cdi-"
"spec.html#bean_defining_annotations[2.5.1] で定義されているビーン定義アノテーションに基づいて検出された "
"CDI ビーンを処理する。 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#bean_defining_annotations[ビーン]定義アノテーション。このアノテーションのセットを拡張して、この "
"`TestProcessor#registerBeanDefinningAnnotations` の例に示すように、 "
"`BeanDefiningAnnotationBuildItem` を使用して拡張機能が処理するアノテーションを含めることができます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2185
#, no-wrap, fuzzy
msgid "Register a Bean Defining Annotation"
msgstr "Bean定義アノテーションの登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2191
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.jboss.jandex.DotName;\n"
"import io.quarkus.extest.runtime.TestAnnotation;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2195
#, no-wrap
msgid ""
"public final class TestProcessor {\n"
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation."
"class.getName());\n"
"    static DotName TEST_ANNOTATION_SCOPE = DotName."
"createSimple(ApplicationScoped.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2205
#, no-wrap
msgid ""
"    @BuildStep\n"
"    BeanDefiningAnnotationBuildItem registerX() {\n"
"        <1>\n"
"        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, "
"TEST_ANNOTATION_SCOPE);\n"
"    }\n"
"...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2215
#, no-wrap
msgid ""
"/**\n"
" * Marker annotation for test configuration target beans\n"
" */\n"
"@Target({ TYPE })\n"
"@Retention(RUNTIME)\n"
"@Documented\n"
"@Inherited\n"
"public @interface TestAnnotation {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2221
#, no-wrap
msgid ""
"/**\n"
" * A sample bean\n"
" */\n"
"@TestAnnotation <2>\n"
"public class ConfiguredBean implements IConfigConsumer {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2225
#, fuzzy
msgid ""
"Register the annotation class and CDI default scope using the Jandex "
"`DotName` class."
msgstr "Jandex `DotName` クラスを使用して、アノテーションクラスと CDI デフォルトスコープを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2226
#, fuzzy
msgid ""
"`ConfiguredBean` will be processed by the CDI layer the same as a bean "
"annotated with the CDI standard @ApplicationScoped."
msgstr ""
"`ConfiguredBean` は CDI 標準の @ApplicationScoped でアノテーションされたビーンと同じように CDI "
"レイヤーによって処理されます。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2227
#, no-wrap, fuzzy
msgid "Parsing Config to Objects"
msgstr "コンフィグをオブジェクトに解析する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2229
#, fuzzy
msgid ""
"One of the main things an extension is likely to do is completely separate "
"the configuration phase of behavior from the runtime phase. Frameworks often "
"do parsing/load of configuration on startup that can be done during build "
"time to both reduce the runtime dependencies on frameworks like xml parsers "
"as well as reducing the startup time the parsing incurs."
msgstr ""
"拡張機能が行う可能性の高い主なことの一つは、動作の設定フェーズをランタイムフェーズから完全に分離することです。フレームワークはしばしば起動時に設定のパース/"
"ロードを行いますが、これはビルド時に行うことができ、xml パーサのようなフレームワークへのランタイム依存を減らし、パースにかかる起動時間を短縮します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2231
#, fuzzy
msgid ""
"An example of parsing a XML config file using JAXB is shown in the "
"`TestProcessor#parseServiceXmlConfig` method:"
msgstr ""
"JAXBを使用してXML設定ファイルを解析する例は、 `TestProcessor#parseServiceXmlConfig` "
"メソッドに示されています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2231
#, no-wrap, fuzzy
msgid "Parsing an XML Configuration into Runtime XmlConfig Instance"
msgstr "XML 設定のランタイム XmlConfig インスタンスへのパース"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2248
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) "
"throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\"); "
"<1>\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <2>\n"
"...\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2251
#, fuzzy
msgid "Look for a config.xml classpath resource"
msgstr "config.xml のクラスパスリソースを探す"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2252
#, fuzzy
msgid "If found, parse using JAXB context for `XmlConfig.class`"
msgstr "見つかった場合は、JAXB コンテキストを使用してパースします。 `XmlConfig.class`"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2256
#, fuzzy
msgid ""
"If there was no /config.xml resource available in the build environment, "
"then a null `RuntimeServiceBuildItem` would be returned and no subsequent "
"logic based on a `RuntimeServiceBuildItem` being produced would execute."
msgstr ""
"ビルド環境で利用可能な /config.xml リソースがない場合は、null `RuntimeServiceBuildItem` が返され、生成された "
"`RuntimeServiceBuildItem` に基づく後続のロジックは実行されません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2259
#, fuzzy
msgid ""
"Typically one is loading a configuration to create some runtime component/"
"service as `parseServiceXmlConfig` is doing. We will come back to the rest "
"of the behavior in `parseServiceXmlConfig` in the following <<Manage Non-CDI "
"Service>> section."
msgstr ""
"通常、 `parseServiceXmlConfig` が行っているように、ランタイムコンポーネント/サービスを作成するために設定をロードしています。 "
"`parseServiceXmlConfig` の動作の残りの部分については、次の link:#Manage Non-CDI Service[[非 "
"CDI サービスの管理]]セクションで説明します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2261
#, fuzzy
msgid ""
"If for some reason you need to parse the config and use it in other build "
"steps in an extension processor, you would need to create an "
"`XmlConfigBuildItem` to pass the parsed XmlConfig instance around."
msgstr ""
"何らかの理由でコンフィグを解析して拡張プロセッサの他のビルドステップで使用する必要がある場合は、 `XmlConfigBuildItem` "
"を作成して解析した XmlConfig インスタンスを渡す必要があります。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2265
#, fuzzy
msgid ""
"If you look at the XmlConfig code you will see that it does carry around the "
"JAXB annotations. If you don't want these in the runtime image, you could "
"clone the XmlConfig instance into some POJO object graph and then replace "
"XmlConfig with the POJO class. We will do this in <<Replacing Classes in the "
"Native Image>>."
msgstr ""
"XmlConfig のコードを見ると、JAXB "
"のアノテーションを持ち歩いていることがわかります。ランタイムイメージにこれらのアノテーションを入れたくない場合は、XmlConfig のインスタンスを "
"POJO オブジェクトグラフにクローンして、XmlConfig を POJO クラスに置き換えることができます。これについては link:"
"#Replacing Classes in the Native Image[[ネイティブイメージでクラスを置き換える]] で説明します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2267
#, no-wrap, fuzzy
msgid "Scanning Deployments Using Jandex"
msgstr "Jandexを使用したスキャニング導入"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2269
#, fuzzy
msgid ""
"If your extension defines annotations or interfaces that mark beans needing "
"to be processed, you can locate these beans using the Jandex API, a Java "
"annotation indexer and offline reflection library. The following "
"`TestProcessor#scanForBeans` method shows how to find the beans annotated "
"with our `@TestAnnotation` that also implement the `IConfigConsumer` "
"interface:"
msgstr ""
"拡張機能で処理が必要なビーンズをマークするアノテーションやインターフェイスを定義している場合は、Java "
"アノテーションインデクサとオフラインリフレクションライブラリである Jandex API を使用して、これらのビーンズを見つけることができます。次の "
"`TestProcessor#scanForBeans` メソッドは、 `IConfigConsumer` インターフェイスも実装している "
"`@TestAnnotation` でアノテーションされたビーンを見つける方法を示しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2270
#, no-wrap, fuzzy
msgid "Example Jandex Usage"
msgstr "ジャンデックスの使用例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2275
#, no-wrap
msgid ""
"    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation."
"class.getName());\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2298
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    void scanForBeans(TestRecorder recorder, BeanArchiveIndexBuildItem "
"beanArchiveIndex, <1>\n"
"            BuildProducer<TestBeanBuildItem> testBeanProducer) {\n"
"        IndexView indexView = beanArchiveIndex.getIndex(); <2>\n"
"        Collection<AnnotationInstance> testBeans = indexView."
"getAnnotations(TEST_ANNOTATION); <3>\n"
"        for (AnnotationInstance ann : testBeans) {\n"
"            ClassInfo beanClassInfo = ann.target().asClass();\n"
"            try {\n"
"                boolean isConfigConsumer = beanClassInfo.interfaceNames()\n"
"                        .stream()\n"
"                        .anyMatch(dotName -> dotName.equals(DotName."
"createSimple(IConfigConsumer.class.getName()))); <4>\n"
"                if (isConfigConsumer) {\n"
"                    Class<IConfigConsumer> beanClass = "
"(Class<IConfigConsumer>) Class.forName(beanClassInfo.name().toString(), "
"false, Thread.currentThread().getContextClassLoader());\n"
"                    testBeanProducer.produce(new "
"TestBeanBuildItem(beanClass)); <5>\n"
"                    log.infof(\"Configured bean: %s\", beanClass);\n"
"                }\n"
"            } catch (ClassNotFoundException e) {\n"
"                log.warn(\"Failed to load bean class\", e);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2300
#, fuzzy
msgid ""
"Depend on a `BeanArchiveIndexBuildItem` to have the build step be run after "
"the deployment has been indexed."
msgstr ""
"デプロイメントがインデックス化された後にビルドステップが実行されるようにするには、 `BeanArchiveIndexBuildItem` "
"に依存します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2301
#, fuzzy
msgid "Retrieve the index."
msgstr "インデックスを取得します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2302
#, fuzzy
msgid "Find all beans annotated with `@TestAnnotation`."
msgstr "`@TestAnnotation` で注釈されたすべての豆を検索する ."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2303
#, fuzzy
msgid ""
"Determine which of these beans also has the `IConfigConsumer` interface."
msgstr "これらのビーンズのうち、どのビーンズが `IConfigConsumer` インターフェイスも持っているかを決定します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2304
#, fuzzy
msgid ""
"Save the bean class in a `TestBeanBuildItem` for use in a latter "
"RUNTIME_INIT build step that will interact with the bean instances."
msgstr ""
"ビーンクラスを `TestBeanBuildItem` に保存して、後の RUNTIME_INIT "
"ビルドステップでビーンインスタンスと対話するために使用します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2305
#, no-wrap, fuzzy
msgid "Interacting With Extension Beans"
msgstr "拡張豆との相互作用"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2307
#, fuzzy
msgid ""
"You can use the `io.quarkus.arc.runtime.BeanContainer` interface to interact "
"with your extension beans. The following `configureBeans` methods illustrate "
"interacting with the beans scanned for in the previous section:"
msgstr ""
"`io.quarkus.arc.runtime.BeanContainer` インターフェイスを使用して、拡張ビーンと対話することができます。以下の "
"`configureBeans` メソッドは、前のセクションでスキャンしたビーンとの対話を説明しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2308
#, no-wrap, fuzzy
msgid "Using CDI BeanContainer Interface"
msgstr "CDI BeanContainerインタフェースの使用"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2317
#, no-wrap
msgid ""
"// TestProcessor#configureBeans\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    void configureBeans(TestRecorder recorder, List<TestBeanBuildItem> "
"testBeans, <1>\n"
"            BeanContainerBuildItem beanContainer, <2>\n"
"            TestRunTimeConfig runTimeConfig) {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2323
#, no-wrap
msgid ""
"        for (TestBeanBuildItem testBeanBuildItem : testBeans) {\n"
"            Class<IConfigConsumer> beanClass = testBeanBuildItem."
"getConfigConsumer();\n"
"            recorder.configureBeans(beanContainer.getValue(), beanClass, "
"buildAndRunTimeConfig, runTimeConfig); <3>\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2333
#, no-wrap
msgid ""
"// TestRecorder#configureBeans\n"
"    public void configureBeans(BeanContainer beanContainer, "
"Class<IConfigConsumer> beanClass,\n"
"            TestBuildAndRunTimeConfig buildTimeConfig,\n"
"            TestRunTimeConfig runTimeConfig) {\n"
"        log.info(\"Begin BeanContainerListener callback\\n\");\n"
"        IConfigConsumer instance = beanContainer.instance(beanClass); <4>\n"
"        instance.loadConfig(buildTimeConfig, runTimeConfig); <5>\n"
"        log.infof(\"configureBeans, instance=%s\\n\", instance);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2335
#, fuzzy
msgid ""
"Consume the `TestBeanBuildItem`s produced from the scanning build step."
msgstr "スキャンビルドステップで生成された `TestBeanBuildItem` を消費する。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2336
#, fuzzy
msgid ""
"Consume the `BeanContainerBuildItem` to order this build step to run after "
"the CDI bean container has been created."
msgstr ""
"CDI Beanコンテナが作成された後にこのビルドステップを実行するために、 `BeanContainerBuildItem` を消費します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2337
#, fuzzy
msgid "Call the runtime recorder to record the bean interactions."
msgstr "ランタイムレコーダを呼び出して、ビーンのインタラクションを記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2338
#, fuzzy
msgid "Runtime recorder retrieves the bean using its type."
msgstr "ランタイムレコーダは、その型を使用してビーンを取得します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2339
#, fuzzy
msgid ""
"Runtime recorder invokes the `IConfigConsumer#loadConfig(...)` method "
"passing in the configuration objects with runtime information."
msgstr ""
"ランタイム・レコーダは `IConfigConsumer#loadConfig(…​)` "
"メソッドを呼び出し、ランタイム情報を含む設定オブジェクトを渡します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2340
#, no-wrap, fuzzy
msgid "Manage Non-CDI Service"
msgstr "非CDIサービスの管理"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2342
#, fuzzy
msgid ""
"A common purpose for an extension is to integrate a non-CDI aware service "
"into the CDI based Quarkus runtime. Step 1 of this task is to load any "
"configuration needed in a STATIC_INIT build step as we did in <<Parsing "
"Config to Objects>>. Now we need to create an instance of the service using "
"the configuration. Let's return to the `TestProcessor#parseServiceXmlConfig` "
"method to see how this can be done."
msgstr ""
"拡張機能の一般的な目的は、CDIを認識しないサービスをCDIベースのQuarkusランタイムに統合することです。このタスクのステップ1では、 link:"
"#Parsing Config to Objects[[Parsing Config to "
"Objects]]で行ったように、STATIC_INITビルドステップで必要な設定をロードします。次に、設定を使用してサービスのインスタンスを作成する必要があります。 "
"`TestProcessor#parseServiceXmlConfig` メソッドに戻って、これがどのようにできるか見てみましょう。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2343
#, no-wrap, fuzzy
msgid "Creating a Non-CDI Service"
msgstr "非CDIサービスの作成"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2363
#, no-wrap
msgid ""
"// TestProcessor#parseServiceXmlConfig\n"
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) "
"throws JAXBException {\n"
"        RuntimeServiceBuildItem serviceBuildItem = null;\n"
"        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);\n"
"        Unmarshaller unmarshaller = context.createUnmarshaller();\n"
"        InputStream is = getClass().getResourceAsStream(\"/config.xml\");\n"
"        if (is != null) {\n"
"            log.info(\"Have XmlConfig, loading\");\n"
"            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);\n"
"            log.info(\"Loaded XmlConfig, creating service\");\n"
"            RuntimeValue<RuntimeXmlConfigService> service = recorder."
"initRuntimeService(config); //<1>\n"
"            serviceBuildItem = new RuntimeServiceBuildItem(service); //<3>\n"
"        }\n"
"        return serviceBuildItem;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2369
#, no-wrap
msgid ""
"// TestRecorder#initRuntimeService\n"
"    public RuntimeValue<RuntimeXmlConfigService> "
"initRuntimeService(XmlConfig config) {\n"
"        RuntimeXmlConfigService service = new "
"RuntimeXmlConfigService(config); //<2>\n"
"        return new RuntimeValue<>(service);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2373
#, no-wrap
msgid ""
"// RuntimeServiceBuildItem\n"
"    final public class RuntimeServiceBuildItem extends SimpleBuildItem {\n"
"    private RuntimeValue<RuntimeXmlConfigService> service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2377
#, no-wrap
msgid ""
"    public RuntimeServiceBuildItem(RuntimeValue<RuntimeXmlConfigService> "
"service) {\n"
"        this.service = service;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2382
#, no-wrap
msgid ""
"    public RuntimeValue<RuntimeXmlConfigService> getService() {\n"
"        return service;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2384
#, fuzzy
msgid "Call into the runtime recorder to record the creation of the service."
msgstr "ランタイムレコーダーに呼び出して、サービスの作成を記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2385
#, fuzzy
msgid ""
"Using the parsed `XmlConfig` instance, create an instance of "
"`RuntimeXmlConfigService` and wrap it in a `RuntimeValue`. Use a "
"`RuntimeValue` wrapper for non-interface objects that are non-proxiable."
msgstr ""
"解析された `XmlConfig` インスタンスを使用して、 `RuntimeXmlConfigService` のインスタンスを作成し、それを "
"`RuntimeValue` でラップします。 `RuntimeValue` ラッパーは、プロキシ不可能な非インターフェイス・オブジェクトに使用します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2386
#, fuzzy
msgid ""
"Wrap the return service value in a `RuntimeServiceBuildItem` for use in a "
"RUNTIME_INIT build step that will start the service."
msgstr ""
"サービスを開始する RUNTIME_INIT ビルドステップで使用するために、サービスの戻り値を `RuntimeServiceBuildItem` "
"でラップします。"

#. type: Title =====
#: upstream/_guides/writing-extensions.adoc:2387
#, no-wrap, fuzzy
msgid "Starting a Service"
msgstr "サービスの開始"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2389
#, fuzzy
msgid ""
"Now that you have recorded the creation of a service during the build phase, "
"you need to record how to start the service at runtime during booting. You "
"do this with a RUNTIME_INIT build step as shown in the "
"`TestProcessor#startRuntimeService` method."
msgstr ""
"ビルドフェーズでのサービスの作成を記録したので、ブート時にランタイムでサービスを起動する方法を記録する必要があります。これを行うには、 "
"`TestProcessor#startRuntimeService` メソッドに示されているように、RUNTIME_INIT "
"ビルドステップを使用します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2390
#, no-wrap, fuzzy
msgid "Starting/Stopping a Non-CDI Service"
msgstr "非CDIサービスの開始/停止"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2406
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, "
"ShutdownContextBuildItem shutdownContextBuildItem , // <1>\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException { //"
" <2>\n"
"        if (serviceBuildItem != null) {\n"
"            log.info(\"Registering service start\");\n"
"            recorder.startRuntimeService(shutdownContextBuildItem, "
"serviceBuildItem.getService()); // <3>\n"
"        } else {\n"
"            log.info(\"No RuntimeServiceBuildItem seen, check config.xml\");\n"
"        }\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<4>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2414
#, no-wrap
msgid ""
"// TestRecorder#startRuntimeService\n"
"    public void startRuntimeService(ShutdownContext shutdownContext, "
"RuntimeValue<RuntimeXmlConfigService> runtimeValue)\n"
"            throws IOException {\n"
"        RuntimeXmlConfigService service = runtimeValue.getValue();\n"
"        service.startService(); //<5>\n"
"        shutdownContext.addShutdownTask(service::stopService); //<6>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2416
#, fuzzy
msgid ""
"We consume a ShutdownContextBuildItem to register the service shutdown."
msgstr "ShutdownContextBuildItemを消費してサービスのシャットダウンを登録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2417
#, fuzzy
msgid ""
"We consume the previously initialized service captured in "
"`RuntimeServiceBuildItem`."
msgstr "`RuntimeServiceBuildItem` で取得した初期化済みのサービスを消費します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2418
#, fuzzy
msgid "Call the runtime recorder to record the service start invocation."
msgstr "ランタイムレコーダーを呼び出して、サービス開始時の呼び出しを記録します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2419
#, fuzzy
msgid ""
"Produce a `ServiceStartBuildItem` to indicate the startup of a service. See "
"<<Startup and Shutdown Events>> for details."
msgstr ""
"サービスの起動を示す `ServiceStartBuildItem` を生成します。詳細は link:#Startup and Shutdown "
"Events[[起動・シャットダウンイベント]]を参照してください。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2420
#, fuzzy
msgid ""
"Runtime recorder retrieves the service instance reference and calls its "
"`startService` method."
msgstr "ランタイム レコーダはサービス インスタンス参照を取得し、その `startService` メソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2421
#, fuzzy
msgid ""
"Runtime recorder registers an invocation of the service instance "
"`stopService` method with the Quarkus `ShutdownContext`."
msgstr ""
"ランタイムレコーダーは、サービスインスタンス `stopService` メソッドの呼び出しをQuarkus `ShutdownContext`."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2424
#, fuzzy
msgid ""
"The code for the `RuntimeXmlConfigService` can be viewed here: {quarkus-blob-"
"url}/core/test-extension/runtime/src/main/java/io/quarkus/extest/runtime/"
"RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"
msgstr ""
"`RuntimeXmlConfigService` のコードはこちらで確認できます。{quarkus-blob-url}/core/test-"
"extension/runtime/src/main/java/io/quarkus/extest/runtime/"
"RuntimeXmlConfigService.java[RuntimeXmlConfigService.java]"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2426
#, fuzzy
msgid ""
"The testcase for validating that the `RuntimeXmlConfigService` has started "
"can be found in the `testRuntimeXmlConfigService` test of "
"`ConfiguredBeanTest` and `NativeImageIT`."
msgstr ""
"`RuntimeXmlConfigService` が起動したことを検証するためのテストケースは、 `ConfiguredBeanTest` と "
"`NativeImageIT` の `testRuntimeXmlConfigService` テストにあります。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2427
#, no-wrap, fuzzy
msgid "Startup and Shutdown Events"
msgstr "スタートアップとシャットダウンのイベント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2430
#, fuzzy
msgid ""
"The Quarkus container supports startup and shutdown lifecycle events to "
"notify components of the container startup and shutdown. There are CDI "
"events fired that components can observe are illustrated in this example:"
msgstr ""
"Quarkusコンテナは、コンテナの起動とシャットダウンをコンポーネントに通知するための起動とシャットダウンのライフサイクルイベントをサポートしています。この例では、コンポーネントが観察できるCDIイベントが発生しています。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2431
#, no-wrap, fuzzy
msgid "Observing Container Startup"
msgstr "コンテナ起動の観察"

#. type: delimited block -
#: upstream/_guides/jms.adoc:115 upstream/_guides/jms.adoc:169
#, no-wrap
msgid ""
"import io.quarkus.runtime.ShutdownEvent;\n"
"import io.quarkus.runtime.StartupEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2445
#, no-wrap
msgid ""
"public class SomeBean {\n"
"    /**\n"
"     * Called when the runtime has started\n"
"     * @param event\n"
"     */\n"
"    void onStart(@Observes StartupEvent event) { // <1>\n"
"        System.out.printf(\"onStart, event=%s%n\", event);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2454
#, no-wrap
msgid ""
"    /**\n"
"     * Called when the runtime is shutting down\n"
"     * @param event\n"
"    */\n"
"    void onStop(@Observes ShutdownEvent event) { // <2>\n"
"        System.out.printf(\"onStop, event=%s%n\", event);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2456
#, fuzzy
msgid "Observe a `StartupEvent` to be notified the runtime has started."
msgstr "ランタイムが開始されたことを通知するために `StartupEvent` を監視します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2457
#, fuzzy
msgid ""
"Observe a `ShutdownEvent` to be notified when the runtime is going to "
"shutdown."
msgstr "ランタイムがシャットダウンしようとしているときに通知されるように `ShutdownEvent` を監視します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2461
#, fuzzy
msgid ""
"What is the relevance of startup and shutdown events for extension authors? "
"We have already seen the use of a `ShutdownContext` to register a callback "
"to perform shutdown tasks in the <<Starting a Service>> section. These "
"shutdown tasks would be called after a `ShutdownEvent` had been sent."
msgstr ""
"拡張機能の作者にとって、起動イベントとシャットダウンイベントの関連性とは何でしょうか？ link:#Starting a "
"Service[サービスの開始]]セクションで、シャットダウンタスクを実行するためのコールバックを登録するために `ShutdownContext` "
"を使用することをすでに見てきました。これらのシャットダウンタスクは `ShutdownEvent` が送信された後に呼び出されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2467
#, fuzzy
msgid ""
"A `StartupEvent` is fired after all `io.quarkus.deployment.builditem."
"ServiceStartBuildItem` producers have been consumed.  The implication of "
"this is that if an extension has services that application components would "
"expect to have been started when they observe a `StartupEvent`, the build "
"steps that invoke the runtime code to start those services needs to produce "
"a `ServiceStartBuildItem` to ensure that the runtime code is run before the "
"`StartupEvent` is sent. Recall that we saw the production of a "
"`ServiceStartBuildItem` in the previous section, and it is repeated here for "
"clarity:"
msgstr ""
"`StartupEvent` は、すべての `io.quarkus.deployment.builditem."
"ServiceStartBuildItem` "
"プロデューサが消費された後に実行されます。このことの意味するところは、拡張機能にアプリケーションコンポーネントが `StartupEvent` "
"を観測したときに開始されたと予想されるサービスがある場合、それらのサービスを開始するためにランタイムコードを呼び出すビルドステップで "
"`ServiceStartBuildItem` を生成して、 `StartupEvent` "
"が送信される前にランタイムコードが実行されるようにする必要があるということです。 `ServiceStartBuildItem` "
"の生成については前のセクションで見たことを思い出してください。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2468
#, no-wrap, fuzzy
msgid "Example of Producing a ServiceStartBuildItem"
msgstr "ServiceStartBuildItemの生成例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2479
#, no-wrap
msgid ""
"// TestProcessor#startRuntimeService\n"
"    @BuildStep\n"
"    @Record(RUNTIME_INIT)\n"
"    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, "
"ShutdownContextBuildItem shutdownContextBuildItem,\n"
"            RuntimeServiceBuildItem serviceBuildItem) throws IOException {\n"
"...\n"
"        return new ServiceStartBuildItem(\"RuntimeXmlConfigService\"); //<1>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2481
#, fuzzy
msgid ""
"Produce a `ServiceStartBuildItem` to indicate that this is a service "
"starting step that needs to run before the `StartupEvent` is sent."
msgstr ""
"`StartupEvent` を送信する前に実行する必要があるサービス開始ステップであることを示すために `ServiceStartBuildItem` "
"を作成します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2482
#, no-wrap, fuzzy
msgid "Register Resources for Use in Native Image"
msgstr "ネイティブイメージで使用するためのリソースを登録する"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2484
#, fuzzy
msgid ""
"Not all configuration or resources can be consumed at build time. If you "
"have classpath resources that the runtime needs to access, you need to "
"inform the build phase that these resources need to be copied into the "
"native image. This is done by producing one or more "
"`NativeImageResourceBuildItem` or `NativeImageResourceBundleBuildItem` in "
"the case of resource bundles. Examples of this are shown in this sample "
"`registerNativeImageResources` build step:"
msgstr ""
"ビルド時にすべてのコンフィギュレーションやリソースを消費できるわけではありません。ランタイムがアクセスする必要のあるクラスパスリソースがある場合、そのリソースをネイティブイメージにコピーする必要があることをビルドフェーズで伝える必要があります。これは、リソースバンドルの場合は1つまたは複数の "
"`NativeImageResourceBuildItem` または `NativeImageResourceBundleBuildItem` "
"を生成することによって行われます。この例を `registerNativeImageResources` ビルドステップのサンプルに示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2485
#, no-wrap, fuzzy
msgid "Registering Resources and ResourceBundles"
msgstr "リソースとリソースバンドルの登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2493
#, no-wrap
msgid ""
"public final class MyExtProcessor {\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBuildItem> resource;\n"
"    @Inject\n"
"    BuildProducer<NativeImageResourceBundleBuildItem> resourceBundle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2497
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void registerNativeImageResources() {\n"
"        resource.produce(new NativeImageResourceBuildItem(\"/security/"
"runtime.keys\")); //<1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2500
#, no-wrap
msgid ""
"        resource.produce(new NativeImageResourceBuildItem(\n"
"                \"META-INF/my-descriptor.xml\")); //<2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2504
#, no-wrap
msgid ""
"        resourceBundle.produce(new NativeImageResourceBuildItem(\"javax.xml."
"bind.Messages\")); //<3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2506
#, fuzzy
msgid ""
"Indicate that the /security/runtime.keys classpath resource should be copied "
"into native image."
msgstr "クラスパスリソース/security/runtime.keysをネイティブイメージにコピーすることを示しています。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2507
#, fuzzy
msgid ""
"Indicate that the `META-INF/my-descriptor.xml` resource should be copied "
"into native image"
msgstr "`META-INF/my-descriptor.xml` リソースをネイティブイメージにコピーすることを示す"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2508
#, fuzzy
msgid ""
"Indicate that the \"javax.xml.bind.Messages\" resource bundle should be "
"copied into native image."
msgstr "javax.xml.bind.Messages\"リソースバンドルをネイティブイメージにコピーすることを示します。"

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2509
#, no-wrap, fuzzy
msgid "Service files"
msgstr "サービスファイル"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2513
#, fuzzy
msgid ""
"If you are using `META-INF/services` files you need to register the files as "
"resources so that your native image can find them, but you also need to "
"register each listed class for reflection so they can be instantiated or "
"inspected at run-time:"
msgstr ""
"`META-INF/services` "
"ファイルを使用している場合は、ネイティブイメージがファイルを見つけられるようにリソースとして登録する必要がありますが、リストされている各クラスを反映させるために登録する必要があります。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2517
#: upstream/_guides/writing-extensions.adoc:2547
#: upstream/_guides/writing-extensions.adoc:2576
#, no-wrap
msgid "public final class MyExtProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2521
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void "
"registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> "
"services) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService."
"class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2526
#, no-wrap
msgid ""
"        // find out all the implementation classes listed in the service "
"files\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread()."
"getContextClassLoader(),\n"
"                                          service);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2534
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be "
"instantiated\n"
"        // in native-image at run-time\n"
"        services.produce(\n"
"            new ServiceProviderBuildItem(io.quarkus.SomeService.class."
"getName(),\n"
"                                         implementations.toArray(new "
"String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2540
#, fuzzy
msgid ""
"`ServiceProviderBuildItem` takes a list of service implementation classes as "
"parameters: if you are not reading them from the service file, make sure "
"that they correspond to the service file contents because the service file "
"will still be read and used at run-time. This is not a substitute for "
"writing a service file."
msgstr ""
"`ServiceProviderBuildItem` "
"は、サービス実装クラスのリストをパラメータとして受け取ります。サービスファイルからそれらを読み込まない場合は、サービスファイルの内容と一致していることを確認してください。これはサービスファイルを書く代わりにはなりません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2543
#, fuzzy
msgid ""
"This only registers the implementation classes for instantiation via "
"reflection (you will not be able to inspect its fields and methods). If you "
"need to do that, you can do it this way:"
msgstr ""
"これは反射を介してインスタンス化のための実装クラスを登録するだけです(そのフィールドやメソッドを検査することはできません)。その必要がある場合は、このようにします。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2552
#, no-wrap
msgid ""
"    @BuildStep\n"
"    void "
"registerNativeImageResources(BuildProducer<NativeImageResourceBuildItem> "
"resource,\n"
"                                     BuildProducer<ReflectiveClassBuildItem> "
"reflectionClasses) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService."
"class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2555
#, no-wrap
msgid ""
"        // register the service file so it is visible in native-image\n"
"        resource.produce(new NativeImageResourceBuildItem(service));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2565
#, no-wrap
msgid ""
"        // register every listed implementation class so they can be "
"inspected/instantiated\n"
"        // in native-image at run-time\n"
"        Set<String> implementations =\n"
"            ServiceUtil.classNamesNamedIn(Thread.currentThread()."
"getContextClassLoader(),\n"
"                                          service);\n"
"        reflectionClasses.produce(\n"
"            new ReflectiveClassBuildItem(true, true, implementations."
"toArray(new String[0])));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2569
#, fuzzy
msgid ""
"While this is the easiest way to get your services running natively, it's "
"less efficient than scanning the implementation classes at build time and "
"generating code that registers them at static-init time instead of relying "
"on reflection."
msgstr ""
"これはサービスをネイティブに動作させる最も簡単な方法ですが、ビルド時に実装クラスをスキャンして、 "
"リフレクションに頼るのではなくスタティックイット時にそれらを登録するコードを生成するよりも効率的ではありません。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2572
#, fuzzy
msgid ""
"You can achieve that by adapting the previous build step to use a static-"
"init recorder instead of registering classes for reflection:"
msgstr ""
"反映のためにクラスを登録するのではなく、スタティックイニットレコーダーを使用するように前のビルドステップを適応させることで、これを実現することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2582
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(ExecutionTime.STATIC_INIT)\n"
"    void registerNativeImageResources(RecorderContext recorderContext,\n"
"                                     SomeServiceRecorder recorder) {\n"
"        String service = \"META-INF/services/\" + io.quarkus.SomeService."
"class.getName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2591
#, no-wrap
msgid ""
"        // read the implementation classes\n"
"        Collection<Class<? extends io.quarkus.SomeService>> "
"implementationClasses = new LinkedHashSet<>();\n"
"        Set<String> implementations = ServiceUtil.classNamesNamedIn(Thread."
"currentThread().getContextClassLoader(),\n"
"                                                                    "
"service);\n"
"        for(String implementation : implementations) {\n"
"            implementationClasses.add((Class<? extends io.quarkus."
"SomeService>)\n"
"                recorderContext.classProxy(implementation));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2596
#, no-wrap
msgid ""
"        // produce a static-initializer with those classes\n"
"        recorder.configure(implementationClasses);\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2599
#, no-wrap
msgid "@Recorder\n"
"public class SomeServiceRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2604
#, no-wrap
msgid ""
"    public void configure(List<Class<? extends io.quarkus.SomeService>> "
"implementations) {\n"
"        // configure our service statically\n"
"        SomeServiceProvider serviceProvider = SomeServiceProvider."
"instance();\n"
"        SomeServiceBuilder builder = serviceProvider."
"getSomeServiceBuilder();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2614
#, no-wrap
msgid ""
"        List<io.quarkus.SomeService> services = new "
"ArrayList<>(implementations.size());\n"
"        // instantiate the service implementations\n"
"        for (Class<? extends io.quarkus.SomeService> implementationClass : "
"implementations) {\n"
"            try {\n"
"                services.add(implementationClass.getConstructor()."
"newInstance());\n"
"            } catch (Exception e) {\n"
"                throw new IllegalArgumentException(\"Unable to instantiate "
"service \" + implementationClass, e);\n"
"            }\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2618
#, no-wrap
msgid ""
"        // build our service\n"
"        builder.withSomeServices(implementations.toArray(new io.quarkus."
"SomeService[0]));\n"
"        ServiceManager serviceManager = builder.build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2623
#, no-wrap
msgid ""
"        // register it\n"
"        serviceProvider.registerServiceManager(serviceManager, Thread."
"currentThread().getContextClassLoader());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2626
#, no-wrap, fuzzy
msgid "Object Substitution"
msgstr "オブジェクトの置換"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2628
#, fuzzy
msgid ""
"Objects created during the build phase that are passed into the runtime need "
"to have a default constructor in order for them to be created and configured "
"at startup of the runtime from the build time state. If an object does not "
"have a default constructor you will see an error similar to the following "
"during generation of the augmented artifacts:"
msgstr ""
"ビルドフェーズで作成されたオブジェクトでランタイムに渡されるものは、ランタイムの起動時にビルド時の状態から作成され設定されるため、デフォルトのコンストラクタを持っている必要があります。オブジェクトがデフォルト・コンストラクタを持たない場合、拡張成果物の生成時に以下のようなエラーが表示されます。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2629
#, no-wrap, fuzzy
msgid "DSAPublicKey Serialization Error"
msgstr "DSAPublicKey シリアル化エラー"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2638
#, no-wrap
msgid ""
"\t[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build "
"threw an exception: java.lang.RuntimeException: Unable to serialize objects "
"of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has "
"no default constructor\n"
"\tat io.quarkus.builder.Execution.run(Execution.java:123)\n"
"\tat io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder."
"java:136)\n"
"\tat io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)\n"
"\tat io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)\n"
"\t... 36 more\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2641
#, fuzzy
msgid ""
"There is a `io.quarkus.runtime.ObjectSubstitution` interface that can be "
"implemented to tell Quarkus how to handle such classes. An example "
"implementation for the `DSAPublicKey` is shown here:"
msgstr ""
"このようなクラスをどのように扱うかをQuarkusに伝えるために実装できる `io.quarkus.runtime."
"ObjectSubstitution` インターフェイスがあります。 `DSAPublicKey` の実装例をここに示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2642
#, no-wrap, fuzzy
msgid "DSAPublicKeyObjectSubstitution Example"
msgstr "DSAPublicKeyObjectSubstitution の例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2646
#, no-wrap
msgid "package io.quarkus.extest.runtime.subst;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2653
#, no-wrap
msgid ""
"import java.security.KeyFactory;\n"
"import java.security.NoSuchAlgorithmException;\n"
"import java.security.interfaces.DSAPublicKey;\n"
"import java.security.spec.InvalidKeySpecException;\n"
"import java.security.spec.X509EncodedKeySpec;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2655
#, no-wrap
msgid "import io.quarkus.runtime.ObjectSubstitution;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2666
#, no-wrap
msgid ""
"public class DSAPublicKeyObjectSubstitution implements "
"ObjectSubstitution<DSAPublicKey, KeyProxy> {\n"
"    private static final Logger log = Logger."
"getLogger(\"DSAPublicKeyObjectSubstitution\");\n"
"    @Override\n"
"    public KeyProxy serialize(DSAPublicKey obj) { //<1>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.serialize\");\n"
"        byte[] encoded = obj.getEncoded();\n"
"        KeyProxy proxy = new KeyProxy();\n"
"        proxy.setContent(encoded);\n"
"        return proxy;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2676
#, no-wrap
msgid ""
"    @Override\n"
"    public DSAPublicKey deserialize(KeyProxy obj) { //<2>\n"
"        log.info(\"DSAPublicKeyObjectSubstitution.deserialize\");\n"
"        byte[] encoded = obj.getContent();\n"
"        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);\n"
"        DSAPublicKey dsaPublicKey = null;\n"
"        try {\n"
"            KeyFactory kf = KeyFactory.getInstance(\"DSA\");\n"
"            dsaPublicKey = (DSAPublicKey) kf."
"generatePublic(publicKeySpec);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2683
#, no-wrap
msgid ""
"        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return dsaPublicKey;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2685
#, fuzzy
msgid ""
"The serialize method takes the object without a default constructor and "
"creates a `KeyProxy` that contains the information necessary to recreate the "
"`DSAPublicKey`."
msgstr ""
"`DSAPublicKey`serialize メソッドは、デフォルトのコンストラクタを持たないオブジェクトを受け取り、 `KeyProxy` "
"を作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2686
#, fuzzy
msgid ""
"The deserialize method uses the `KeyProxy` to recreate the `DSAPublicKey` "
"from its encoded form using the key factory."
msgstr ""
"deserialize メソッドは、 `KeyProxy` を使用して、キーファクトリーを使用してエンコードされた形式から `DSAPublicKey` "
"を再作成します。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2688
#, fuzzy
msgid ""
"An extension registers this substitution by producing an "
"`ObjectSubstitutionBuildItem` as shown in this "
"`TestProcessor#loadDSAPublicKey` fragment:"
msgstr ""
"拡張機能は、この `TestProcessor#loadDSAPublicKey` フラグメントに示すように "
"`ObjectSubstitutionBuildItem` を生成することで、この置換を登録します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2689
#, no-wrap, fuzzy
msgid "Registering an Object Substitution"
msgstr "オブジェクト置換の登録"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2702
#, no-wrap
msgid ""
"    @BuildStep\n"
"    @Record(STATIC_INIT)\n"
"    PublicKeyBuildItem loadDSAPublicKey(TestRecorder recorder,\n"
"            BuildProducer<ObjectSubstitutionBuildItem> substitutions) throws "
"IOException, GeneralSecurityException {\n"
"...\n"
"        // Register how to serialize DSAPublicKey\n"
"        ObjectSubstitutionBuildItem.Holder<DSAPublicKey, KeyProxy> holder = "
"new ObjectSubstitutionBuildItem.Holder(\n"
"                DSAPublicKey.class, KeyProxy.class, "
"DSAPublicKeyObjectSubstitution.class);\n"
"        ObjectSubstitutionBuildItem keysub = new "
"ObjectSubstitutionBuildItem(holder);\n"
"        substitutions.produce(keysub);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2706
#, no-wrap
msgid ""
"        log.info(\"loadDSAPublicKey run\");\n"
"        return new PublicKeyBuildItem(publicKey);\n"
"    }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/writing-extensions.adoc:2708
#, no-wrap, fuzzy
msgid "Replacing Classes in the Native Image"
msgstr "ネイティブイメージでクラスを置き換える"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2710
#, fuzzy
msgid ""
"The Graal SDK supports substitutions of classes in the native image. An "
"example of how one could replace the `XmlConfig/XmlData` classes with "
"versions that have no JAXB annotation dependencies is shown in these example "
"classes:"
msgstr ""
"Graal SDK は、ネイティブイメージ内のクラスの置換をサポートしています。 `XmlConfig/XmlData` のクラスを、JAXB "
"アノテーションに依存しないバージョンのクラスに置き換える方法の例を以下に示します。"

#. type: Block title
#: upstream/_guides/writing-extensions.adoc:2711
#, no-wrap, fuzzy
msgid "Substitution of XmlConfig/XmlData Classes Example"
msgstr "XmlConfig/XmlDataクラスの置換例"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2719
#, no-wrap
msgid ""
"package io.quarkus.extest.runtime.graal;\n"
"import java.util.Date;\n"
"import com.oracle.svm.core.annotate.Substitute;\n"
"import com.oracle.svm.core.annotate.TargetClass;\n"
"import io.quarkus.extest.runtime.config.XmlData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2723
#, no-wrap
msgid ""
"@TargetClass(XmlConfig.class)\n"
"@Substitute\n"
"public final class Target_XmlConfig {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2730
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String address;\n"
"    @Substitute\n"
"    private int port;\n"
"    @Substitute\n"
"    private ArrayList<XData> dataList;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2735
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getAddress() {\n"
"        return address;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2740
#, no-wrap
msgid "    @Substitute\n"
"    public int getPort() {\n"
"        return port;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2745
#, no-wrap
msgid ""
"    @Substitute\n"
"    public ArrayList<XData> getDataList() {\n"
"        return dataList;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2756
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlConfig{\" +\n"
"                \"address='\" + address + '\\'' +\n"
"                \", port=\" + port +\n"
"                \", dataList=\" + dataList +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2760
#, no-wrap
msgid ""
"@TargetClass(XmlData.class)\n"
"@Substitute\n"
"public final class Target_XmlData {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2767
#, no-wrap
msgid ""
"    @Substitute\n"
"    private String name;\n"
"    @Substitute\n"
"    private String model;\n"
"    @Substitute\n"
"    private Date date;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2772
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2777
#, no-wrap
msgid ""
"    @Substitute\n"
"    public String getModel() {\n"
"        return model;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2782
#, no-wrap
msgid ""
"    @Substitute\n"
"    public Date getDate() {\n"
"        return date;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2793
#, no-wrap
msgid ""
"    @Substitute\n"
"    @Override\n"
"    public String toString() {\n"
"        return \"Target_XmlData{\" +\n"
"                \"name='\" + name + '\\'' +\n"
"                \", model='\" + model + '\\'' +\n"
"                \", date='\" + date + '\\'' +\n"
"                '}';\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:2795
#, no-wrap, fuzzy
msgid "Configuration reference documentation"
msgstr "設定参照ドキュメント"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2799
#, fuzzy
msgid ""
"The configuration is an important part of each extension and therefore needs "
"to be properly documented.  Each configuration property should have a proper "
"Javadoc comment."
msgstr ""
"設定は各拡張機能の重要な部分なので、適切に文書化する必要があります。それぞれの設定プロパティには、適切な Javadoc コメントが必要です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2802
#, fuzzy
msgid ""
"While it is handy to have the documentation available when coding, this "
"configuration documentation must also be available in the extension guides.  "
"The Quarkus build automatically generates the configuration documentation "
"for you based on the Javadoc comments but you need to explicitly include it "
"in your guide."
msgstr ""
"コーディング時にドキュメントを利用できるようにしておくと便利ですが、この設定ドキュメントは拡張ガイドでも利用できるようにしておく必要があります。Quarkusのビルドでは、Javadocのコメントに基づいて設定ドキュメントが自動的に生成されますが、ガイドに明示的に含める必要があります。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2804
#, fuzzy
msgid ""
"In this section, we will explain everything you need to know about the "
"configuration reference documentation."
msgstr "このセクションでは、設定参照ドキュメントについて知っておくべきことをすべて説明します。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2805
#, no-wrap, fuzzy
msgid "Writing the documentation"
msgstr "ドキュメントの書き方"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2808
#, fuzzy
msgid ""
"For each configuration property, you need to write some Javadoc explaining "
"its purpose."
msgstr "それぞれの設定プロパティに対して、その目的を説明するJavadocを書く必要があります。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2812
#, fuzzy
msgid ""
"Always make the first sentence meaningful and self-contained as it is "
"included in the summary table."
msgstr "必ず最初の一文に意味を持たせ、まとめ表に記載するように自己完結させましょう。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2815
#, fuzzy
msgid ""
"You can either use standard Javadoc comments or Asciidoc directly as a "
"Javadoc comment."
msgstr "標準のJavadocコメントかAsciidocを直接Javadocコメントとして使うことができます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2819
#, fuzzy
msgid ""
"We assume you are familiar with writing Javadoc comments so let's focus on "
"our Asciidoc support.  While standard Javadoc comments are perfectly fine "
"for simple documentation (recommended even), if you want to include tips, "
"source code extracts, lists... Asciidoc comes in handy."
msgstr ""
"ここでは、Javadocのコメントを書くことに慣れていることを前提としているので、Asciidocのサポートに焦点を当ててみましょう。標準的なJavadocのコメントは単純な文書化には完全に適していますが（推奨されています）、もしあなたがTipsやソースコードの抜粋、リストなどを含めたい場合は、Asciidocが便利です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2821
#, fuzzy
msgid "Here is a typical configuration property commented with Asciidoc:"
msgstr "以下は、Asciidocでコメントされた典型的な設定プロパティです。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2838
#, no-wrap
msgid ""
"/**\n"
" * Class name of the Hibernate ORM dialect. The complete list of bundled "
"dialects is available in the\n"
" * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/"
"dialect/package-summary.html[Hibernate ORM JavaDoc].\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Not all the dialects are supported in GraalVM native executables: we "
"currently provide driver extensions for PostgreSQL,\n"
" * MariaDB, Microsoft SQL Server and H2.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"@ConfigItem\n"
"public Optional<String> dialect;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2842
#, fuzzy
msgid ""
"This is the simple case: you just have to write Asciidoc and mark the "
"comment with the `@asciidoclet` tag.  This tag has two purposes: it is used "
"as a marker for our generation tool but it is also used by the `javadoc` "
"process for proper Javadoc generation."
msgstr ""
"これは簡単なケースです: Asciidoc を書いて、コメントに `@asciidoclet` "
"タグを付ければいいだけです。このタグには2つの目的があります: 生成ツールのマーカーとして使用されますが、 `javadoc` のプロセスで適切な "
"Javadoc 生成のためにも使用されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2844
#, fuzzy
msgid "Now let's consider a more complicated example:"
msgstr "では、もう少し複雑な例を考えてみましょう。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2882
#, no-wrap
msgid ""
"// @formatter:off\n"
"/**\n"
" * Name of the file containing the SQL statements to execute when Hibernate "
"ORM starts.\n"
" * Its default value differs depending on the Quarkus launch mode:\n"
" *\n"
" * * In dev and test modes, it defaults to `import.sql`.\n"
" *   Simply add an `import.sql` file in the root of your resources directory\n"
" *   and it will be picked up without having to set this property.\n"
" *   Pass `no-file` to force Hibernate ORM to ignore the SQL import file.\n"
" * * In production mode, it defaults to `no-file`.\n"
" *   It means Hibernate ORM won't try to execute any SQL import file by "
"default.\n"
" *   Pass an explicit value to force Hibernate ORM to execute the SQL import "
"file.\n"
" *\n"
" * If you need different SQL statements between dev mode, test "
"(`@QuarkusTest`) and in production, use Quarkus\n"
" * https://quarkus.io/guides/config#configuration-profiles[configuration "
"profiles facility].\n"
" *\n"
" * [source,property]\n"
" * .application.properties\n"
" * ----\n"
" * %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql\n"
" * %test.quarkus.hibernate-orm.sql-load-script = import-test.sql\n"
" * %prod.quarkus.hibernate-orm.sql-load-script = no-file\n"
" * ----\n"
" *\n"
" * [NOTE]\n"
" * ====\n"
" * Quarkus supports `.sql` file with SQL statements or comments spread over "
"multiple lines.\n"
" * Each SQL statement must be terminated by a semicolon.\n"
" * ====\n"
" *\n"
" * @asciidoclet\n"
" */\n"
"// @formatter:on\n"
"@ConfigItem\n"
"public Optional<String> sqlLoadScript;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2885
#, fuzzy
msgid "A few comments on this one:"
msgstr "これについてのコメントをいくつか。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2891
#, fuzzy
msgid ""
"Every time you will need the indentation to be respected in the Javadoc "
"comment (think list items spread on multiple lines or indented source code), "
"you will need to disable temporarily the automatic Eclipse formatter (this, "
"even if you don't use Eclipse as the formatter is included in our build).  "
"To do so, use the `// @formatter:off`/`// @formatter:on` markers.  Note the "
"fact that they are separate comments and there is a space after the `//` "
"marker. This is required."
msgstr ""
"Javadocのコメントでインデントを尊重する必要がある場合（複数行にまたがるリスト項目やインデントされたソースコードを考えてみてください）には、Eclipseの自動フォーマッタを一時的に無効にする必要があります（これは、私たちのビルドにはフォーマッタが含まれているので、Eclipseを使用していない場合でも同様です）。これを行うには、 "
"`// @formatter:off`/ `// @formatter:on` マーカーを使用してください。これらは別々のコメントであり、 `//` "
"マーカーの後にスペースがあることに注意してください。これは必須です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2892
#, fuzzy
msgid ""
"As you can see, you can use the full power of Asciidoctor (except for the "
"limitation below)"
msgstr "見ての通り、アサイードクターの威力をフルに使うことができます(以下の制限を除く)"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2897
#, fuzzy
msgid ""
"You cannot use open blocks (`--`) in your Asciidoctor documentation.  All "
"the other types of blocks (source, admonitions...) are supported."
msgstr ""
"Asciidoctor のドキュメントでは、オープンブロック ( `--`) を使用することはできません。他のすべてのタイプのブロック "
"(ソース、アドミッション...) がサポートされています。"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2904
#, fuzzy
msgid ""
"By default, the doc generator will use the hyphenated field name as the key "
"of a `java.util.Map` configuration item.  To override this default and have "
"a user friendly key (independent of implementation details), you may use the "
"`io.quarkus.runtime.annotations.ConfigDocMapKey` annotation.  See the "
"following example,"
msgstr ""
"デフォルトでは、doc ジェネレータは `java.util.Map` "
"設定項目のキーとしてハイフンで囲まれたフィールド名を使用します。このデフォルトを上書きして（実装の詳細とは無関係に）ユーザーフレンドリーなキーを持つためには、 "
"`io.quarkus.runtime.annotations.ConfigDocMapKey` "
"アノテーションを使用することができます。以下の例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2915
#, no-wrap
msgid ""
"@ConfigRoot\n"
"public class SomeConfig {\n"
"    /**\n"
"     * Namespace configuration.\n"
"     */\n"
"    @ConfigItem(name = ConfigItem.PARENT)\n"
"    @ConfigDocMapKey(\"cache-name\") <1>\n"
"    Map<String, CaffeineNamespaceConfig> namespace;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2918
#, fuzzy
msgid ""
"This will generate a configuration map key named `quarkus.some.\"cache-"
"name\"` instead of `quarkus.some.\"namespace\"`."
msgstr ""
"これにより、 `quarkus.some.\"namespace\"` の代わりに `quarkus.some.\"cache-name\"` "
"という名前の構成マップキーが生成されます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2920
#, no-wrap, fuzzy
msgid "Writing section documentation"
msgstr "セクションのドキュメントを書く"

#. type: delimited block =
#: upstream/_guides/writing-extensions.adoc:2924
#, fuzzy
msgid ""
"If you wish to generate configuration section of a given `@ConfigGroup`, "
"Quarkus has got you covered with the `@ConfigDocSection` annotation.  See "
"the code example below:"
msgstr ""
"指定された `@ConfigGroup` の設定セクションを生成したい場合は、 `@ConfigDocSection` "
"アノテーションで対応できます。以下のコード例を参照してください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2933
#, no-wrap
msgid ""
"/**\n"
"* Config group related configuration.\n"
"* Amazing introduction here\n"
"*/\n"
"@ConfigItem\n"
"@ConfigDocSection <1>\n"
"public ConfigGroupConfig configGroup;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2938
#, fuzzy
msgid ""
"This will add a section documentation for the `configGroup` config item in "
"the generated documentation.  Section's title and introduction will be "
"derived from the javadoc of the configuration item. The first sentence from "
"the javadoc is considered as the section title and the remaining sentences "
"used as section introduction.  You can also use the `@asciidoclet` tag as "
"shown above."
msgstr ""
"これは、生成されたドキュメントの中に `configGroup` "
"設定項目のためのセクションドキュメントを追加します。セクションのタイトルと導入は、設定項目の javadoc から派生します。javadoc "
"の最初の文がセクションのタイトルとみなされ、残りの文がセクションの紹介文として使用されます。上記のように `@asciidoclet` "
"タグを使用することもできます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2939
#, no-wrap, fuzzy
msgid "Generating the documentation"
msgstr "ドキュメントの生成"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2942
#, fuzzy
msgid "Generating the documentation is easy:"
msgstr "ドキュメントの生成は簡単です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2944
#, fuzzy
msgid "Running `./mvnw clean install -DskipTests -DskipITs` will do."
msgstr "`./mvnw clean install -DskipTests -DskipITs` を実行すればOKです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2945
#, fuzzy
msgid ""
"You can either do it globally or in a specific extension directory (e.g. "
"`extensions/mailer`)."
msgstr "グローバルに行うことも、特定の拡張機能ディレクトリ ( `extensions/mailer` など) で行うこともできます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2947
#, fuzzy
msgid ""
"The documentation is generated in the global `target/asciidoc/generated/"
"config/` located at the root of the project."
msgstr ""
"ドキュメントはプロジェクトのルートにあるグローバル `target/asciidoc/generated/config/` で生成されます。"

#. type: Title ===
#: upstream/_guides/writing-extensions.adoc:2948
#, no-wrap, fuzzy
msgid "Including the documentation in the extension guide"
msgstr "拡張ガイドにドキュメントを含める"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2951
#, fuzzy
msgid ""
"Now that you have generated the configuration reference documentation for "
"your extension, you need to include it in your guide (and review it)."
msgstr ""
"これで、あなたの拡張機能の設定参照ドキュメントが生成されたので、それをガイドに含める必要があります (そして、それをレビューする必要があります)。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2953
#, fuzzy
msgid "This is simple, include the generated documentation in your guide:"
msgstr "これは簡単で、生成されたドキュメントをガイドに含めます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2957
#, no-wrap
msgid ""
"\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, "
"leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2960
#, fuzzy
msgid ""
"If you are interested in including the generated documentation for the "
"config group, you can use the include statement below"
msgstr "設定グループのために生成されたドキュメントを含めたい場合は、以下のinclude文を使用することができます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2963
#, no-wrap
msgid ""
"\\include::{generated-dir}/config/hyphenated-config-group-class-name-with-"
"runtime-or-deployment-namespace-replaced-by-config-group-namespace.adoc[opts="
"optional, leveloffset=+1]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2966
#, fuzzy
msgid ""
"For example, the `io.quarkus.vertx.http.runtime.FormAuthConfig` "
"configuration group will be generated in a file named `quarkus-vertx-http-"
"config-group-form-auth-config.adoc`."
msgstr ""
"例えば、 `io.quarkus.vertx.http.runtime.FormAuthConfig` 設定グループは `quarkus-vertx-"
"http-config-group-form-auth-config.adoc` という名前のファイルに生成されます。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2969
#, fuzzy
msgid "A few recommendations:"
msgstr "お勧めをいくつか。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2971
#, fuzzy
msgid ""
"`opts=optional` is mandatory as we don't want the build to fail if only part "
"of the configuration documentation has been generated"
msgstr "`opts=optional` は、設定ドキュメントの一部しか生成されていない場合にビルドを失敗させたくないので必須です。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2974
#, fuzzy
msgid ""
"The documentation is generated with a title level of 2 (i.e. `==`).  You "
"usually need to adjust it.  It can be done with `leveloffset=+N`."
msgstr ""
"ドキュメントはタイトルレベルが2(例: `==`)で生成されます。通常はこれを調整する必要があります。これは `leveloffset=+N`."

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2977
#, fuzzy
msgid ""
"It is not recommended to include the whole configuration documentation in "
"the middle of your guide as it's heavy.  If you have an `application."
"properties` extract with your configuration, just do as follows."
msgstr ""
"ガイドの途中に設定ドキュメント全体を入れるのは重いのでお勧めできません。 `application.properties` "
"のエキスが設定と一緒に入っている場合は、以下のようにすればいいだけです。"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2979
#, fuzzy
msgid "First, include a tip just below your `application.properties` extract:"
msgstr "まず、 `application.properties` のエキスのすぐ下にチップを入れます。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2984
#, no-wrap
msgid ""
"[TIP]\n"
"For more information about the extension configuration please refer to the "
"<<configuration-reference, Configuration Reference>>.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2987
#, fuzzy
msgid ""
"Then, at the end of your documentation, include the extensive documentation:"
msgstr "そして、文書の最後には、広範な文書を含めてください。"

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2991
#, no-wrap
msgid "[[configuration-reference]]\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/writing-extensions.adoc:2994
msgid ""
"\\include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, "
"leveloffset=+1]"
msgstr ""

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:2997
#, fuzzy
msgid "Finally, generate the documentation and check it out."
msgstr "最後にドキュメントを生成して確認します。"

#. type: Title ==
#: upstream/_guides/writing-extensions.adoc:2998
#, no-wrap, fuzzy
msgid "Continuous testing of your extension"
msgstr "拡張機能の継続的なテスト"

#. type: Plain text
#: upstream/_guides/writing-extensions.adoc:3003
#, fuzzy
msgid ""
"In order to make it easy for extension authors to test their extensions "
"daily against the latest snapshot of Quarkus, Quarkus has introduced the "
"notion of Ecosystem CI. The Ecosystem CI link:https://github.com/quarkusio/"
"quarkus-ecosystem-ci/blob/master/README.adoc[README] has all the details on "
"how to set up a GitHub Actions job to take advantage of this capability, "
"while this link:https://www.youtube.com/watch?v=VpbRA1n0hHQ[video] provides "
"an overview of what the process looks like."
msgstr ""
"拡張機能の作者が、Quarkusの最新のスナップショットに対して自分の拡張機能を毎日簡単にテストできるようにするために、QuarkusはエコシステムCIという概念を導入しました。Ecosystem "
"CI link:https://github.com/quarkusio/quarkus-ecosystem-ci/blob/master/README."
"adoc[README]には、この機能を利用するためのGitHub Actionsジョブの設定方法の詳細がすべて記載されています。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/funqy-http.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Funqy HTTP Binding (Standalone)"
msgstr "Quarkus - Funqy HTTPバインディング（スタンドアロン"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:13
#, fuzzy
msgid ""
"The guide walks through quickstart code to show you how you can deploy Funqy "
"as a standalone service and invoke on Funqy functions using HTTP."
msgstr ""
"このガイドでは、Funqyをスタンドアロンサービスとしてデプロイし、HTTPを使ってFunqy関数を呼び出す方法をクイックスタートコードで説明します。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:20
#, fuzzy
msgid ""
"The Funqy HTTP binding is not a replacement for REST over HTTP.  Because "
"Funqy needs to be portable across a lot of different protocols and function "
"providers its HTTP binding is very minimalistic and you will lose REST "
"features like linking and the ability to leverage HTTP features like cache-"
"control and conditional GETs.  You may want to consider using Quarkus's JAX-"
"RS, Spring MVC, or Vert.x Web Reactive Routes support instead, although "
"Funqy will have less overhead than these alternatives (except Vert.x which "
"is still super fast)."
msgstr ""
"FunqyのHTTPバインディングはHTTP上のRESTの代わりではありません。Funqyは多くの異なるプロトコルやファンクションプロバイダに移植する必要があるので、HTTPバインディングは非常にミニマムで、リンクのようなREST機能やキャッシュコントロールや条件付きGETのようなHTTP機能を利用する機能を失うことになります。代わりにQuarkusのJAX-"
"RS、Spring MVC、またはVert.x Web Reactive Routesのサポートを使用することを検討すると良いでしょう。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:27
#, fuzzy
msgid "Read about link:funqy[Funqy Basics].  This is a short read!"
msgstr "link:funqy[ファンキーの基本を]読む。短時間で読めます!"

#. type: Title ==
#: upstream/_guides/funqy-http.adoc:31
#, no-wrap, fuzzy
msgid "The Quickstart"
msgstr "クイックスタート"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:36
#, fuzzy
msgid ""
"The solution is located in the `funqy-http-quickstart` {quickstarts-tree-"
"url}/funqy-quickstarts/funqy-http-quickstart[directory]."
msgstr ""
"ソリューションは `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/"
"funqy-http-quickstart[directory] にあります。"

#. type: Title ==
#: upstream/_guides/funqy-http.adoc:37
#, no-wrap, fuzzy
msgid "The Code"
msgstr "コード"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:41
#, fuzzy
msgid ""
"If you look at the Java code, you'll see that there is no HTTP specific API. "
" Its just simple Java methods annotated with `@Funq`.  Simple, easy, "
"straightforward."
msgstr ""
"Javaコードを見ると、HTTP固有のAPIがないことがわかります。単純な Java メソッドに `@Funq` "
"と注釈が付けられているだけです。シンプルで、簡単で、わかりやすい。"

#. type: Title ==
#: upstream/_guides/funqy-http.adoc:42
#, no-wrap, fuzzy
msgid "Maven Dependencies"
msgstr "Mavenの依存関係"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:45
#, fuzzy
msgid ""
"To write Funqy HTTP functions, simply include the `quarkus-funqy-http` "
"dependency into your Quarkus `pom.xml` file:"
msgstr ""
"Funqy HTTP関数を書くには、 `quarkus-funqy-http` 依存関係をQuarkus `pom.xml` "
"ファイルにインクルードするだけです。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:52
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-funqy-http</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/funqy-http.adoc:54
#, no-wrap, fuzzy
msgid "Build Project"
msgstr "ビルドプロジェクト"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:59
#, no-wrap
msgid "mvn clean quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:62
#, fuzzy
msgid "This starts your functions in Quarkus dev mode."
msgstr "これにより、Quarkus devモードでの機能が開始されます。"

#. type: Title ==
#: upstream/_guides/funqy-http.adoc:63
#, no-wrap, fuzzy
msgid "Execute Funqy HTTP functions"
msgstr "Funqy HTTP関数の実行"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:67
#, fuzzy
msgid ""
"The URL path to execute a function is the function name.  For example if "
"your function name is `foo` then the URL path to execute the function would "
"be `/foo`."
msgstr "関数を実行するための URL パスは、関数名です。例えば、関数名が `foo` の場合、関数を実行する URL パスは `/foo`."

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:71
#, fuzzy
msgid ""
"The HTTP POST or GET methods can be used to invoke on a function.  The "
"return value of the function is marshalled to JSON using the Jackson JSON "
"library.  Jackson annotations can be used.  If your function has an input "
"parameter, a POST invocation must use JSON as the input type.  Jackson is "
"also used here for unmarshalling."
msgstr ""
"HTTP POST または GET メソッドを使用して関数を呼び出すことができます。関数の戻り値は、Jackson JSON ライブラリを使用して "
"JSON にマーシャルされます。Jackson "
"アノテーションを使用することができます。関数に入力パラメータがある場合、POST呼び出しは入力タイプとしてJSONを使用しなければなりません。ここでもJacksonはアンマーシャリングに使用されます。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:74
#, fuzzy
msgid ""
"You can invoke the `hello` function defined in {quickstarts-tree-url}/funqy-"
"quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/"
"PrimitiveFunctions.java[PrimitiveFunctions.java] by pointing your browser to "
"http://localhost:8080/hello"
msgstr ""
"ブラウザを http://localhost:8080/hello に向けると、{quickstarts-tree-url}/funqy-"
"quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/"
"PrimitiveFunctions.java[PrimitiveFunctions.java]で定義されている `hello` "
"関数を呼び出すことができます。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:78
#, fuzzy
msgid ""
"Invoking the other functions in the quickstart requires an HTTP POST.  To "
"execute the `greet` function defined in {quickstarts-tree-url}/funqy-"
"quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/"
"GreetingFunction.java[GreetingFunction.java] invoke this curl script."
msgstr ""
"クイックスタートの他の関数を呼び出すには、HTTP POSTが必要です。で定義されている `greet` 関数を実行するには、この curl "
"スクリプトを呼び出します。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:85
#, no-wrap
msgid ""
"curl \"http://localhost:8080/greet\" \\\n"
"-X POST \\\n"
"-H \"Content-Type: application/json\" \\\n"
"-d '{\"name\":\"Bill\"}'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:90
#, fuzzy
msgid ""
"Primitive types can also be passed as input using the standard JSON mapping "
"for them.  To execute the `toLowerCase` function defined in {quickstarts-"
"tree-url}/funqy-quickstarts/funqy-http-quickstart/src/main/java/org/acme/"
"funqy/PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl "
"script:"
msgstr ""
"プリミティブ型は、標準のJSONマッピングを使用して入力として渡すこともできます。で定義されている `toLowerCase` 関数を実行するには、この "
"curl スクリプトを呼び出します。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:97
#, no-wrap
msgid ""
"curl \"http://localhost:8080/toLowerCase\" \\\n"
"-X POST \\\n"
"-H \"Content-Type: application/json\" \\\n"
"-d '\"HELLO WORLD\"'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:101
#, fuzzy
msgid ""
"To execute the `double` function defined in {quickstarts-tree-url}/funqy-"
"quickstarts/funqy-http-quickstart/src/main/java/org/acme/funqy/"
"PrimitiveFunctions.java[PrimitiveFunctions.java] invoke this curl script:"
msgstr ""
"で定義されている `double` 関数を実行するには、{quickstarts-tree-url}/funqy-quickstarts/funqy-"
"http-quickstart/src/main/java/org/acme/funqy/PrimitiveFunctions."
"java[PrimitiveFunctions.java]を呼び出す必要があります。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:108
#, no-wrap
msgid ""
"curl \"http://localhost:8080/double\" \\\n"
"-X POST \\\n"
"-H \"Content-Type: application/json\" \\\n"
"-d '2'\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/funqy-http.adoc:110
#, no-wrap, fuzzy
msgid "GET Query Parameter Mapping"
msgstr "GET クエリパラメータのマッピング"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:116
#, fuzzy
msgid ""
"For GET requests, the Funqy HTTP Binding also has a query parameter mapping "
"for function input parameters.  Only bean style classes and `java.util.Map` "
"can be used for your input parameter.  For bean style classes, query "
"parameter names are mapped to properties on the bean class.  Here's an "
"example of a simple `Map`:"
msgstr ""
"GETリクエストのために、Funqy "
"HTTPバインディングは、関数の入力パラメータのためのクエリパラメータマッピングも持っています。ビーン・スタイル・クラスと `java.util."
"Map` "
"だけが入力パラメータに使用できます。ビーン・スタイル・クラスでは、クエリ・パラメータ名はビーン・クラスのプロパティにマッピングされます。以下は、単純な "
"`Map`."

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:123
#, no-wrap
msgid "@Funq\n"
"public String hello(Map<String, Integer> map) {\n"
"...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:127
#, fuzzy
msgid ""
"Key values must be a primitive type (except char) or `String`.  Values can "
"be primitives (except char), `String`, `OffsetDateTime` or a complex bean "
"style class.  For the above example, here's the corresponding curl request:"
msgstr ""
"キー値は、プリミティブ型（char を除く）か `String` でなければなりません。値は、プリミティブ型 (char を除く)、 `String` "
"、 `OffsetDateTime` 、または複雑なビーン スタイルのクラスを使用できます。上記の例では、対応する curl "
"リクエストを以下に示します。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:131
#, no-wrap
msgid "curl \"http://localhost:8080/a=1&b=2\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:134
#, fuzzy
msgid ""
"The `map` input parameter of the `hello` function would have the key value "
"pairs: `a`->1, `b`->2."
msgstr "`hello` 関数の `map` 入力パラメータは、 `a`→1, `b`→2 というキー値のペアを持ちます。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:136
#, fuzzy
msgid ""
"Bean style classes can also be use as the input parameter type.  Here's an "
"example:"
msgstr "Beanスタイルクラスを入力パラメータ型として使用することもできます。以下に例を示します。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:142
#, no-wrap
msgid "public class Person {\n"
"    String first;\n"
"    String last;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:148
#, no-wrap
msgid ""
"    public String getFirst() { return first; }\n"
"    public void setFirst(String first) { this.first = first; }\n"
"    public String getLast() { return last; }\n"
"    public void setLast(String last) { this.last = last; }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:155
#, no-wrap
msgid ""
"public class MyFunctions {\n"
"    @Funq\n"
"    public String greet(Person p) {\n"
"       return \"Hello \" + p.getFirst() + \" \" + p.getLast();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:159
#, fuzzy
msgid ""
"Property values can be any primitive type except `char`. It can also be "
"`String`, and `OffsetDateTime`.  `OffsetDateTime` query param values must be "
"in ISO-8601 format."
msgstr ""
"プロパティの値は、 `char` 以外の任意のプリミティブ型にすることができます。また、 `String` や `OffsetDateTime` "
"も可能です。 `OffsetDateTime` クエリのパラメータ値は ISO-8601 形式でなければなりません。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:161
#, fuzzy
msgid "You can invoke on this using an HTTP GET and query parameters:"
msgstr "HTTP GET とクエリパラメータを使用して呼び出すことができます。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:165
#, no-wrap
msgid "curl \"http://localhost:8080/greet?first=Bill&last=Burke\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:168
#, fuzzy
msgid ""
"In the above request, the query parameter names are mapped to corresponding "
"properties in the input class."
msgstr "上記のリクエストでは、クエリパラメータ名が入力クラスの対応するプロパティにマッピングされています。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:170
#, fuzzy
msgid ""
"The input class can also have nested bean classes.  Expanding on the "
"previous example:"
msgstr "入力クラスは、入れ子になったビーンクラスを持つこともできます。前の例を拡張します。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:176
#, no-wrap
msgid "public class Family {\n"
"    private Person dad;\n"
"    private Person mom;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:182
#, no-wrap
msgid ""
"    public Person getDad() { return dad; }\n"
"    public void setDad(Person dad) { this.dad = dad; }\n"
"    public Person getMom() { return mom; }\n"
"    public void setMom(Person mom) { this.mom = mom; }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:189 upstream/_guides/funqy-http.adoc:215
#: upstream/_guides/funqy-http.adoc:242 upstream/_guides/funqy-http.adoc:274
#: upstream/_guides/funqy-http.adoc:299
#, no-wrap
msgid ""
"public class MyFunctions {\n"
"    @Funq\n"
"    public String greet(Family family) {\n"
"       ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:193
#, fuzzy
msgid ""
"In this case, query parameters for nested values use the `.` notation.  For "
"example:"
msgstr "この場合、入れ子になった値のクエリパラメータは `.` 表記法を使用します。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:197
#, no-wrap
msgid ""
"curl \"http://localhost:8080/greet?dad.first=John&dad.last=Smith&mom.first="
"Martha&mom.last=Smith\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:200
#, fuzzy
msgid ""
"`java.util.List` and `Set` are also supported as property values.  For "
"example:"
msgstr "`java.util.List` と `Set` もプロパティ値としてサポートされています。例えば"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:205 upstream/_guides/funqy-http.adoc:232
#: upstream/_guides/funqy-http.adoc:264 upstream/_guides/funqy-http.adoc:289
#, no-wrap
msgid "public class Family {\n"
"    ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:208
#, no-wrap
msgid "    List<String> pets;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:219
#, fuzzy
msgid ""
"To invoke a GET request, just list the `pets` query parameter multiple times."
""
msgstr "GETリクエストを呼び出すには、 `pets` クエリパラメータを複数回リストアップするだけです。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:223
#, no-wrap
msgid "curl \"http://localhost:8080/greet?pets=itchy&pets=scratchy\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:227
#, fuzzy
msgid ""
"For more complex types, `List` and `Set` members must have an identifier in "
"the query parameter.  For example:"
msgstr ""
"より複雑な型の場合、 `List` および `Set` のメンバは、クエリパラメータに識別子を持つ必要があります。例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:235
#, no-wrap
msgid "    List<Person> kids;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:248
#, fuzzy
msgid ""
"Each `kids` query parameter must identify the kid they are referencing so "
"that the runtime can figure out which property values go to which members in "
"the list.  Here's the curl request:"
msgstr ""
"`kids` "
"クエリの各パラメータは、参照しているキッドを識別する必要があります。これにより、ランタイムはどのプロパティ値がリストのどのメンバーに属するかを把握することができます。これが "
"curl リクエストです。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:252
#, no-wrap
msgid ""
"curl \"http://localhost:8080/greet?kids.1.first=Buffy&kids.2.first="
"Charlie\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:256
#, fuzzy
msgid ""
"The above URL uses the value `1` and `2` to identity the target member of "
"the list, but any unique string can be used."
msgstr ""
"上記のURLでは、リストの対象メンバーを識別するために `1` と `2` という値を使用していますが、任意の一意の文字列を使用することができます。"

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:259
#, fuzzy
msgid ""
"A property can also be a `java.util.Map`.  The key of the map can be any "
"primitive type and `String`.  For example:"
msgstr "プロパティは `java.util.Map`.マップのキーは、任意のプリミティブ型と `String`.例えば、以下のようになります。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:267
#, no-wrap
msgid "    Map<String, String> address;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:277
#, fuzzy
msgid "The corresponding call would look like this:"
msgstr "対応する呼び出しは次のようになります。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:281
#, no-wrap
msgid ""
"curl \"http://localhost:8080/greet?address.state=MA&address.city=Boston\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/funqy-http.adoc:284
#, fuzzy
msgid ""
"If your `Map` value is a complex type, then just continue the notation by "
"adding the property to set at the end."
msgstr "`Map` の値が複雑な型であれば、最後に set するプロパティを追加して表記を続けるだけです。"

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:292
#, no-wrap
msgid "    Map<String, Address> addresses;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/funqy-http.adoc:304
#, no-wrap
msgid ""
"curl \"http://localhost:8080/greet?addresses.home.state=MA&addresses.home."
"city=Boston\"\n"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/scheduler-reference.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Scheduler Reference Guide"
msgstr "Quarkus - スケジューラーリファレンスガイド"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:20
#, fuzzy
msgid ""
"Modern applications often need to run specific tasks periodically.  There "
"are two scheduler extensions in Quarkus.  The `quarkus-scheduler` extension "
"brings the API and a lightweight in-memory scheduler implementation.  The "
"`quarkus-quartz` extension implements the API from the `quarkus-scheduler` "
"extension and contains a scheduler implementation based on the Quartz "
"library.  You will only need `quarkus-quartz` for more advanced scheduling "
"use cases, such as persistent tasks, clustering and programmatic scheduling "
"of jobs."
msgstr ""
"最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。Quarkusには2つのスケジューラ拡張機能があります。 `quarkus-"
"scheduler` 拡張機能には、APIと軽量なインメモリスケジューラの実装が含まれています。 `quarkus-quartz` 拡張機能は、 "
"`quarkus-scheduler` 拡張機能のAPIを実装し、Quartzライブラリをベースにしたスケジューラの実装が含まれています。 "
"`quarkus-quartz` "
"が必要になるのは、持続的タスク、クラスタリング、ジョブのプログラマティックスケジューリングなど、より高度なスケジューリングのユースケースのみです。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:22
#, fuzzy
msgid ""
"If you add the `quarkus-quartz` dependency to your project the lightweight "
"scheduler implementation from the `quarkus-scheduler` extension is "
"automatically disabled."
msgstr ""
"プロジェクトに `quarkus-quartz` 依存関係を追加すると、 `quarkus-scheduler` "
"拡張モジュールからの軽量スケジューラの実装は自動的に無効になります。"

#. type: Title ==
#: upstream/_guides/scheduler-reference.adoc:23
#, no-wrap, fuzzy
msgid "Scheduled Methods"
msgstr "予定されている方法"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:28
#, fuzzy
msgid ""
"If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is "
"automatically scheduled for invocation.  In fact, such a method must be a "
"non-private non-static method of a CDI bean.  As a consequence of being a "
"method of a CDI bean a scheduled method can be annotated with interceptor "
"bindings, such as `@javax.transaction.Transactional` and `@org.eclipse."
"microprofile.metrics.annotation.Counted`."
msgstr ""
"メソッドに `@io.quarkus.scheduler.Scheduled` "
"をアノテーションすると、自動的に呼び出されるようにスケジュールされます。実際には、そのようなメソッドはCDIビーンの非プライベート非静的メソッドでなければなりません。CDIビーンのメソッドであることの結果として、スケジュールされたメソッドは、 "
"`@javax.transaction.Transactional` や `@org.eclipse.microprofile.metrics."
"annotation.Counted` のようなインターセプターバインディングでアノテーションすることができます。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:30
#, fuzzy
msgid ""
"If there is no CDI scope defined on the declaring class then `@Singleton` is "
"used."
msgstr "宣言クラスにCDIスコープが定義されていない場合は、 `@Singleton` を使用します。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:32
#, fuzzy
msgid ""
"Furthermore, the annotated method must return `void` and either declare no "
"parameters or one parameter of type `io.quarkus.scheduler."
"ScheduledExecution`."
msgstr ""
"さらに、アノテーションされたメソッドは `void` を返し、パラメータを宣言しないか、 `io.quarkus.scheduler."
"ScheduledExecution` 型のパラメータを 1 つだけ宣言する必要があります。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:34
#, fuzzy
msgid ""
"The annotation is repeatable so a single method could be scheduled multiple "
"times."
msgstr "アノテーションは繰り返し可能なので、1つのメソッドを複数回スケジュールすることができます。"

#. type: Title ===
#: upstream/_guides/scheduler-reference.adoc:35
#, no-wrap, fuzzy
msgid "Triggers"
msgstr "トリガー"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:40
#, fuzzy
msgid ""
"A trigger is defined either by the `@Scheduled#cron()` or by the "
"`@Scheduled#every()` attributes.  If both are specified, the cron expression "
"takes precedence.  If none is specified, the build fails with an "
"`IllegalStateException`."
msgstr ""
"トリガーは、 `@Scheduled#cron()` 属性または `@Scheduled#every()` "
"属性によって定義されます。両方が指定されている場合、cron 式が優先されます。何も指定されていない場合、ビルドは "
"`IllegalStateException`."

#. type: Title ====
#: upstream/_guides/scheduler-reference.adoc:41
#, no-wrap, fuzzy
msgid "CRON"
msgstr "クロン"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:45
#, fuzzy
msgid ""
"A CRON trigger is defined by a cron-like expression.  For example `\"0 15 10 "
"* * ?\"` fires at 10:15am every day."
msgstr "CRONトリガは、cronライクな式で定義されています。例えば `\"0 15 10 * * ?\"` は毎日午前10時15分に起動します。"

#. type: Block title
#: upstream/_guides/scheduler-reference.adoc:46
#, no-wrap, fuzzy
msgid "CRON Trigger Example"
msgstr "CRONトリガーの例"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:51
#, no-wrap
msgid "@Scheduled(cron = \"0 15 10 * * ?\")\n"
"void fireAt10AmEveryDay() { }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:56
#, fuzzy
msgid ""
"The syntax used in CRON expressions is controlled by the `quarkus.scheduler."
"cron-type` property.  The values can be `cron4j`, `quartz`, `unix` and "
"`spring`.  `quartz` is used by default."
msgstr ""
"CRON 式で使用される構文は `quarkus.scheduler.cron-type` プロパティによって制御されます。 `quartz` 値は "
"`cron4j`, `quartz`, `unix` および `spring` です。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:58
#, fuzzy
msgid ""
"If a CRON expression starts with `{` and ends with `}` then the scheduler "
"attempts to find a corresponding config property and use the configured "
"value instead."
msgstr ""
"CRON式が `{` で始まり `}` で終わる場合、スケジューラは対応するコンフィグプロパティを検索し、設定された値を代わりに使用しようとします。"

#. type: Block title
#: upstream/_guides/scheduler-reference.adoc:59
#, no-wrap, fuzzy
msgid "CRON Config Property Example"
msgstr "CRON設定プロパティの例"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:64
#, no-wrap
msgid "@Scheduled(cron = \"{myMethod.cron.expr}\")\n"
"void myMethod() { }\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/scheduler-reference.adoc:66
#, no-wrap, fuzzy
msgid "Intervals"
msgstr "インターバル"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:72
#, fuzzy
msgid ""
"An interval trigger defines a period between invocations.  The period "
"expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the "
"value of `@Scheduled#every()` is parsed with `java.time."
"Duration#parse(CharSequence)`.  However, if an expression starts with a "
"digit then the `PT` prefix is added automatically.  So for example, `15m` "
"can be used instead of `PT15M` and is parsed as \"15 minutes\"."
msgstr ""
"インターバル トリガは、呼び出しの間の期間を定義します。ピリオド式は ISO-8601 の期間フォーマット `PnDTnHnMn.nS` "
"に基づいており、 `@Scheduled#every()` の値は `java.time.Duration#parse(CharSequence)` "
"で解析されます。ただし、式が数字で始まる場合は、 `PT` の接頭辞が自動的に追加されます。例えば、 `PT15M` の代わりに `15m` "
"を使用することができ、「15 分」と解析されます。"

#. type: Block title
#: upstream/_guides/scheduler-reference.adoc:73
#, no-wrap, fuzzy
msgid "Interval Trigger Example"
msgstr "インターバルトリガーの例"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:78
#, no-wrap
msgid "@Scheduled(every = \"15m\")\n"
"void every15Mins() { }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:81
#, fuzzy
msgid ""
"If a value starts with `{` and ends with `}` then the scheduler attempts to "
"find a corresponding config property and use the configured value instead."
msgstr ""
"値が `{` で始まり `}` で終わる場合、スケジューラは対応するコンフィグプロパティを探して、設定された値を代わりに使用しようとします。"

#. type: Block title
#: upstream/_guides/scheduler-reference.adoc:82
#, no-wrap, fuzzy
msgid "Interval Config Property Example"
msgstr "インターバル設定プロパティの例"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:87
#, no-wrap
msgid "@Scheduled(every = \"{myMethod.every.expr}\")\n"
"void myMethod() { }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/scheduler-reference.adoc:89
#, no-wrap, fuzzy
msgid "Identity"
msgstr "アイデンティティ"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:94
#, fuzzy
msgid ""
"By default, a unique id is generated for each scheduled method.  This id is "
"used in log messages and during debugging.  Sometimes a possibility to "
"specify an explicit id may come in handy."
msgstr ""
"デフォルトでは、スケジュールされた各メソッドに対して一意の ID が生成されます。このIDはログメッセージやデバッグ中に使用されます。時には、明示的な "
"id を指定することが便利な場合もあります。"

#. type: Block title
#: upstream/_guides/scheduler-reference.adoc:95
#, no-wrap, fuzzy
msgid "Identity Example"
msgstr "アイデンティティの例"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:100
#, no-wrap
msgid "@Scheduled(identity = \"myScheduledMethod\")\n"
"void myMethod() { }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/scheduler-reference.adoc:102
#, no-wrap, fuzzy
msgid "Delayed Execution"
msgstr "遅延実行"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:105
#, fuzzy
msgid ""
"`@Scheduled` provides two ways to delay the time a trigger should start "
"firing at."
msgstr "`@Scheduled` では、トリガーが発射を開始すべき時間を遅らせるための2つの方法を提供しています。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:107
#, fuzzy
msgid ""
"`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay "
"together."
msgstr "`@Scheduled#delay()` と `@Scheduled#delayUnit()` は初期遅延を一緒に形成します。"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:112
#, no-wrap
msgid ""
"@Scheduled(every = \"2s\", delay = 2, delayUnit = TimeUnit.HOUR) <1>\n"
"void everyTwoSeconds() { }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:114
#, fuzzy
msgid ""
"The trigger fires for the first time two hours after the application start."
msgstr "塗布開始から2時間後に初めてトリガーが発射されます。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:116
#, fuzzy
msgid "The final value is always rounded to full second."
msgstr "最終的な値は常に1秒単位で丸められます。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:121
#, fuzzy
msgid ""
"`@Scheduled#delayed()` is a text alternative to the properties above.  The "
"period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` "
"and the value is parsed with `java.time.Duration#parse(CharSequence)`.  "
"However, if an expression starts with a digit, the `PT` prefix is added "
"automatically.  So for example, `15s` can be used instead of `PT15S` and is "
"parsed as \"15 seconds\"."
msgstr ""
"`@Scheduled#delayed()` は、上記のプロパティの代替テキストです。ピリオド式は ISO-8601 duration format "
"`PnDTnHnMn.nS` に基づいており、値は `java.time.Duration#parse(CharSequence)` "
"で解析されます。ただし、式が数字で始まる場合は、 `PT` の接頭辞が自動的に追加されます。そのため、例えば `PT15S` の代わりに `15s` "
"を使用することができ、「15 秒」と解析されます。"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:126
#, no-wrap
msgid "@Scheduled(every = \"2s\", delayed = \"2h\")\n"
"void everyTwoSeconds() { }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:129
#, fuzzy
msgid ""
"If `@Scheduled#delay()` is set to a value greater then zero the value of "
"`@Scheduled#delayed()` is ignored."
msgstr ""
"`@Scheduled#delay()` がゼロよりも大きい値に設定されている場合、 `@Scheduled#delayed()` の値は無視されます。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:132
#, fuzzy
msgid ""
"The main advantage over `@Scheduled#delay()` is that the value is "
"configurable.  If the value starts with `{` and ends with `}` then the "
"scheduler attempts to find a corresponding config property and use the "
"configured value instead:"
msgstr ""
"`@Scheduled#delay()` と比較した場合の主な利点は、値が設定可能であることです。値が `{` で始まり `}` "
"で終わる場合、スケジューラは対応するコンフィグプロパティを見つけようとし、代わりに設定された値を使用します。"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:137
#, no-wrap
msgid ""
"@Scheduled(every = \"2s\", delayed = \"{myMethod.delay.expr}\") <1>\n"
"void everyTwoSeconds() { }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:139
#, fuzzy
msgid "The config property `myMethod.delay.expr` is used to set the delay."
msgstr "遅延の設定には、configプロパティ `myMethod.delay.expr` を使用します。"

#. type: Title ===
#: upstream/_guides/scheduler-reference.adoc:141
#, no-wrap, fuzzy
msgid "Concurrent Execution"
msgstr "同時実行"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:145
#, fuzzy
msgid ""
"By default, a scheduled method can be executed concurrently.  Nevertheless, "
"it is possible to specify the strategy to handle concurrent executions via "
"`@Scheduled#concurrentExecution()`."
msgstr ""
"デフォルトでは、スケジュールされたメソッドは同時に実行することができます。それにもかかわらず、 "
"`@Scheduled#concurrentExecution()` を通じて同時実行を処理するための戦略を指定することが可能です。"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:149
#, no-wrap
msgid ""
"import static io.quarkus.scheduler.Scheduled.ConcurrentExecution.SKIP;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:154
#, no-wrap
msgid ""
"@Scheduled(every = \"1s\", concurrentExecution = SKIP) <1>\n"
"void nonConcurrent() {\n"
"  // we can be sure that this method is never executed concurrently\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:156
#, fuzzy
msgid "Concurrent executions are skipped."
msgstr "同時実行はスキップされます。"

#. type: Title ==
#: upstream/_guides/scheduler-reference.adoc:157
#, no-wrap, fuzzy
msgid "Scheduler"
msgstr "スケジューラ"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:160
#, fuzzy
msgid ""
"Quarkus provides a built-in bean of type `io.quarkus.scheduler.Scheduler` "
"that can be injected and used to pause/resume the scheduler."
msgstr ""
"Quarkusは、 `io.quarkus.scheduler.Scheduler` "
"型のビルトインBeanを提供しており、これを注入してスケジューラを一時停止/再開するために使用することができます。"

#. type: Block title
#: upstream/_guides/scheduler-reference.adoc:161
#, no-wrap, fuzzy
msgid "Scheduler Injection Example"
msgstr "スケジューラインジェクションの例"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:165
#, no-wrap
msgid "import io.quarkus.scheduler.Scheduler;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:829
#, no-wrap
msgid "class MyService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:170
#, no-wrap
msgid "   @Inject\n"
"   Scheduler scheduler;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:179
#, no-wrap
msgid ""
"   void ping() {\n"
"      scheduler.pause(); <1>\n"
"      if (scheduler.isRunning()) {\n"
"         throw new IllegalStateException(\"This should never happen!\");\n"
"      }\n"
"      scheduler.resume(); <2>\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:181
#, fuzzy
msgid "Pause all triggers."
msgstr "すべてのトリガーを一時停止します。"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:182
#, fuzzy
msgid "Resume the scheduler."
msgstr "スケジューラを再開します。"

#. type: Title ==
#: upstream/_guides/scheduler-reference.adoc:183
#, no-wrap, fuzzy
msgid "Programmatic Scheduling"
msgstr "プログラムスケジューリング"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:186
#, fuzzy
msgid ""
"If you need to schedule a job programmatically you'll need to add the link:"
"quartz[Quartz extension] and use the Quartz API directly."
msgstr ""
"プログラムでジョブをスケジュールする必要がある場合は、 link:quartz[Quartz拡張機能を]追加してQuartz "
"APIを直接使用する必要があります。"

#. type: Block title
#: upstream/_guides/scheduler-reference.adoc:187
#, no-wrap, fuzzy
msgid "Programmatic Scheduling with Quartz API"
msgstr "Quartz APIを使用したプログラマティックスケジューリング"

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:191
#, no-wrap
msgid "import org.quartz.Scheduler;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:193
#, no-wrap
msgid "class MyJobs {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/scheduler-reference.adoc:208
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent event, Scheduler quartz) throws "
"SchedulerException {\n"
"        JobDetail job = JobBuilder.newJob(SomeJob.class)\n"
"                .withIdentity(\"myJob\", \"myGroup\")\n"
"                .build();\n"
"        Trigger trigger = TriggerBuilder.newTrigger()\n"
"                .withIdentity(\"myTrigger\", \"myGroup\")\n"
"                .startNow()\n"
"                .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n"
"                        .withIntervalInSeconds(1)\n"
"                        .repeatForever())\n"
"                .build();\n"
"        quartz.scheduleJob(job, trigger);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:211
#, fuzzy
msgid ""
"By default, the scheduler is not started unless a `@Scheduled` business "
"method is found. You may need to force the start of the scheduler for "
"\"pure\" programmatic scheduling. See also <<quartz.adoc#quartz-"
"configuration-reference,Quartz Configuration Reference>>."
msgstr ""
"デフォルトでは、 `@Scheduled` "
"ビジネスメソッドが見つからない限り、スケジューラは起動されません。純粋な」プログラマティックスケジューリングのために、スケジューラを強制的に起動する必要があるかもしれません。 "
"link:quartz.html#quartz-configuration-reference[Quartz設定リファレンス]も参照してください。"

#. type: Title ==
#: upstream/_guides/scheduler-reference.adoc:212
#, no-wrap, fuzzy
msgid "Scheduled Methods and Testing"
msgstr "予定されている方法と試験"

#. type: Plain text
#: upstream/_guides/scheduler-reference.adoc:218
#, fuzzy
msgid ""
"It is often desirable to disable the scheduler when running the tests.  The "
"scheduler can be disabled through the runtime config property `quarkus."
"scheduler.enabled`.  If set to `false` the scheduler is not started even "
"though the application contains scheduled methods.  You can even disable the "
"scheduler for particular <<getting-started-"
"testing#testing_different_profiles,Test Profiles>>."
msgstr ""
"テストを実行する際には、スケジューラを無効にすることが望ましいことがよくあります。スケジューラは、ランタイム設定プロパティ `quarkus."
"scheduler.enabled` を通じて無効にすることができます。 `false` "
"に設定すると、アプリケーションにスケジュールされたメソッドが含まれていても、 スケジューラは起動しません。特定の link:getting-"
"started-testing."
"html#testing_different_profiles[テストプロファイル]に対してスケジューラを無効にすることもできます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/building-substrate-howto.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Building a Custom SubstrateVM"
msgstr "Quarkus - カスタムSubstrateVMの構築"

#. type: Title ===
#: upstream/_guides/building-substrate-howto.adoc:12
#, no-wrap, fuzzy
msgid "Install JVMCI"
msgstr "JVMCI のインストール"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:15
#, fuzzy
msgid "Before anything can be done you must first install a JVMCI build."
msgstr "何かをする前に、まずJVMCIビルドをインストールしなければなりません。"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:18
#, fuzzy
msgid ""
"These can be downloaded from OTN http://www.oracle.com/technetwork/oracle-"
"labs/program-languages/downloads/index.html[here]"
msgstr ""
"これらは link:http://www.oracle.com/technetwork/oracle-labs/program-languages/"
"downloads/index.html[ここで]OTNからダウンロードすることができます"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:22
#, fuzzy
msgid ""
"Note, if you are installing on an alternative system, you can use the "
"developer tools on chrome or firefox to capture a direct URL with an auth "
"param."
msgstr ""
"別のシステムにインストールしている場合は、クロームやファイアフォックスの開発者ツールを使用して、auth パラメーターを指定して直接 URL "
"をキャプチャすることができます。"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:24
#, fuzzy
msgid "After obtaining the download install it and set `JAVA_HOME`"
msgstr "ダウンロードした後、インストールして `JAVA_HOME`"

#. type: delimited block -
#: upstream/_guides/building-substrate-howto.adoc:32
#, no-wrap
msgid ""
"wget -O jvmci.tgz http://download.oracle.com/otn/utilities_drivers/oracle-"
"labs/labsjdk-8u202-jvmci-0.56-darwin-amd64.tar.gz?AuthParam=[GENERATED AUTH "
"TOKEN HERE]\n"
"tar -xzvf jvmci.tgz -C /opt\n"
"# On Mac do labsjdk1.8.0_202-jvmci-0.56/Contents/Home\n"
"export JAVA_HOME=/opt/labsjdk1.8.0_202-jvmci-0.46/\n"
"export PATH=$JAVA_HOME/bin:$PATH\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:37
#, fuzzy
msgid ""
"Get the latest version available as graal tends to keep updating the minimum "
"requirements."
msgstr "graalは最低限の要件を更新し続ける傾向があるので、最新版を入手しましょう。"

#. type: Title ===
#: upstream/_guides/building-substrate-howto.adoc:38
#, no-wrap, fuzzy
msgid "Install MX"
msgstr "MXのインストール"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:41
#, fuzzy
msgid "Now you need to install Graal’s special build tool, `mx`."
msgstr "今、あなたはGraalの特別なビルドツールをインストールする必要があります、 `mx`."

#. type: delimited block -
#: upstream/_guides/building-substrate-howto.adoc:46
#, no-wrap
msgid ""
"git clone https://github.com/graalvm/mx.git\n"
"export PATH=`pwd`/mx:$PATH\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/building-substrate-howto.adoc:48
#, no-wrap, fuzzy
msgid "Checkout and build SubstrateVM"
msgstr "SubstrateVMのチェックアウトとビルド"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:51
#, fuzzy
msgid "You can now check-out and build Substrate:"
msgstr "これでサブストレートのチェックアウトとビルドができるようになりました。"

#. type: delimited block -
#: upstream/_guides/building-substrate-howto.adoc:57
#, no-wrap
msgid ""
"git clone https://github.com/oracle/graal.git\n"
"cd graal/substratevm\n"
"mx build\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:60
#, fuzzy
msgid "Once built, you can quickly run the tools in place"
msgstr "一度構築したら、その場でツールを素早く実行することができます。"

#. type: delimited block -
#: upstream/_guides/building-substrate-howto.adoc:67
#, no-wrap
msgid ""
"echo \"public class HelloWorld { public static void main(String[] args) { "
"System.out.println(\\\"Hello World\\\"); } }\" > HelloWorld.java\n"
"javac HelloWorld.java\n"
"mx native-image HelloWorld\n"
"./helloworld\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/building-substrate-howto.adoc:69
#, no-wrap, fuzzy
msgid "Building a custom GraalVM distribution"
msgstr "カスタムGraalVMディストリビューションの構築"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:74
#, fuzzy
msgid ""
"In order to create a custom GraalVM distribution (necessary for usage in "
"quarkus) you must switch to the vm subdirectory, and use special build "
"options to pick the modules in your distribution."
msgstr ""
"カスタムGraalVMディストリビューション（quarkusで使用するために必要）を作成するためには、vmサブディレクトリに切り替えて、特別なビルドオプションを使用して、ディストリビューションのモジュールを選択する必要があります。"

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:77
#, fuzzy
msgid ""
"For a simple subset VM with just substrate and its native tools execute the "
"following:"
msgstr "基板とそのネイティブツールだけのシンプルなサブセット VM の場合は、以下を実行します。"

#. type: delimited block -
#: upstream/_guides/building-substrate-howto.adoc:83
#, no-wrap
msgid ""
" cd ../vm\n"
" mx --dy /substratevm,/tools build\n"
" tar -czvf my-custom-graal.tgz -C latest_graalvm .\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/building-substrate-howto.adoc:86
#, fuzzy
msgid "For a stock CE build the following will do:"
msgstr "純正CEビルドの場合は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/building-substrate-howto.adoc:91
#, no-wrap
msgid ""
"mx --dy /substratevm,/tools,/sulong,/graal-nodejs build\n"
"tar -czvf my-custom-graal.tgz -C latest_graalvm .\n"
msgstr ""

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/vertx.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using Eclipse Vert.x"
msgstr "Quarkus - Eclipse Vert.xの使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:13
#, fuzzy
msgid ""
"Eclipse https://vertx.io[Vert.x] is a toolkit for building reactive "
"applications.  It is designed to be lightweight and embeddable.  Vert.x "
"defines a reactive execution model and provides a large ecosystem."
msgstr ""
"Eclipse link:https://vertx.io[Vert."
"x]は、リアクティブなアプリケーションを構築するためのツールキットです。軽量で埋め込み可能なように設計されています。Vert."
"xはリアクティブ実行モデルを定義し、大規模なエコシステムを提供します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:18
#, fuzzy
msgid ""
"Quarkus is based on Vert.x, and almost all network-related features rely on "
"Vert.x.  While lots of reactive features from Quarkus don't _show_ Vert.x, "
"it's used underneath.  Quarkus also integrates smoothly with the Vert.x "
"event bus (to enable asynchronous messaging passing between application "
"components) and some reactive clients.  You can also use various Vert.x APIs "
"in your Quarkus application, such as deploying _verticles_, instantiating "
"clients..."
msgstr ""
"QuarkusはVert.xをベースにしており、ほとんどすべてのネットワーク関連機能はVert."
"xに依存しています。Quarkusのリアクティブ機能の多くはVert.xを "
"_表示して_いませんが、その下で使用されています。また、Quarkusは、Vert."
"xイベントバス（アプリケーションコンポーネント間の非同期メッセージングの受け渡しを可能にするため）やいくつかのリアクティブクライアントとスムーズに統合されています。また、Quarkusアプリケーションでは、さまざまなVert."
"x APIを使用することができます（例えば、 _バーティクル_のデプロイ、クライアントのインスタンス化など）。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:24
#, fuzzy
msgid ""
"To access Vert.x, well, you need to enable the `vertx` extension to use this "
"feature.  If you are creating a new project, set the `extensions` parameter "
"are follows:"
msgstr ""
"Vert.xにアクセスするには、まあ、この機能を利用するには、 `vertx` 拡張機能を有効にする必要があります。新規プロジェクトを作成する場合は、 "
"`extensions` パラメータを以下のように設定します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:32
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vertx-quickstart \\\n"
"    -Dextensions=\"vertx\"\n"
"cd vertx-quickstart\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:40
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"vertx\"\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vertx.adoc:52
#, no-wrap, fuzzy
msgid "Native Transport"
msgstr "ネイティブトランスポート"

#. type: Plain text
#: upstream/_guides/vertx.adoc:58
#, fuzzy
msgid ""
"Vert.x is capable of using https://netty.io/wiki/native-transports."
"html[Netty's native transports] which offers performance improvements on "
"certain platforms. To enable them you must include the appropriate "
"dependency for your platform. It's usually a good idea to include both to "
"keep your application platform agnostic. Netty is smart enough to use the "
"correct one, that includes none at all on unsupported platforms:"
msgstr ""
"Vert.x は link:https://netty.io/wiki/native-transports.html[Netty "
"のネイティブトランスポートを]使用することができ、特定のプラットフォームでパフォーマンスを向上させることができます。これを有効にするには、プラットフォームに応じた適切な依存関係を含める必要があります。通常、アプリケーションのプラットフォームに依存しないようにするために、両方を含めるのが良いでしょう。Netty "
"は、サポートされていないプラットフォームでは何も含まれていない正しい方を使うようにしています。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:66
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.netty</groupId>\n"
"  <artifactId>netty-transport-native-epoll</artifactId>\n"
"  <classifier>linux-x86_64</classifier>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:72
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.netty</groupId>\n"
"  <artifactId>netty-transport-native-kqueue</artifactId>\n"
"  <classifier>osx-x86_64</classifier>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:75
#, fuzzy
msgid ""
"You will also have to explicitly configure Vert.x to use the native "
"transport. In `application.properties` add:"
msgstr ""
"また、ネイティブトランスポートを使用するために Vert.x を明示的に設定する必要があります。 `application.properties` "
"で追加します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:79
#, no-wrap
msgid "quarkus.vertx.prefer-native-transport=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:82
#, fuzzy
msgid "Or in `application.yml`:"
msgstr "または `application.yml`."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:88
#, no-wrap
msgid "quarkus:\n"
"  vertx:\n"
"    prefer-native-transport: true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:91
#, fuzzy
msgid "If all is well quarkus will log:"
msgstr "すべてがうまくいけば、クァーカスはログを取ります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:94
#, no-wrap
msgid ""
"[io.qua.ver.cor.run.VertxCoreRecorder] (main) Vertx has Native Transport "
"Enabled: true\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/vertx.adoc:96
#, no-wrap, fuzzy
msgid "Native Linux Transport"
msgstr "ネイティブリナックストランスポート"

#. type: Plain text
#: upstream/_guides/vertx.adoc:99
#, fuzzy
msgid "On Linux you can enable the following socket options:"
msgstr "Linuxでは、以下のソケットオプションを有効にすることができます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:101 upstream/_guides/vertx.adoc:122
#, fuzzy
msgid "SO_REUSEPORT"
msgstr "ＳＯＲＥＵＳＥＰＯＲＴ"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:103 upstream/_guides/vertx.adoc:124
#, no-wrap
msgid "quarkus.http.so-reuse-port=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:105
#, fuzzy
msgid "TCP_QUICKACK"
msgstr "TCP_QUICKACK"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:107
#, no-wrap
msgid "quarkus.http.tcp-quick-ack=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:109
#, fuzzy
msgid "TCP_CORK"
msgstr "TCP_CORK"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:111
#, no-wrap
msgid "quarkus.http.tcp-cork=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:113
#, fuzzy
msgid "TCP_FASTOPEN"
msgstr "TCP_FASTOPEN"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:115
#, no-wrap
msgid "quarkus.http.tcp-fast-open=true\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/vertx.adoc:117
#, no-wrap, fuzzy
msgid "Native MacOS Transport"
msgstr "ネイティブMacOSトランスポート"

#. type: Plain text
#: upstream/_guides/vertx.adoc:120
#, fuzzy
msgid "On MacOS Sierra and above you can enable the following socket options:"
msgstr "MacOS Sierra以上では、以下のソケットオプションを有効にすることができます。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:126
#, no-wrap, fuzzy
msgid "Accessing Vert.x"
msgstr "Vert.xへのアクセス"

#. type: Plain text
#: upstream/_guides/vertx.adoc:129
#, fuzzy
msgid ""
"Once the extension has been added, you can access the _managed_ Vert.x "
"instance using `@Inject`:"
msgstr "拡張機能を追加したら、 `@Inject` を使用して _管理されている_Vert.x インスタンスにアクセスできます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:133 upstream/_guides/vertx.adoc:599
#, no-wrap
msgid "@Inject Vertx vertx;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:137
#, fuzzy
msgid ""
"If you are familiar with Vert.x, you know that Vert.x provides different API "
"models.  For instance _bare_ Vert.x uses callbacks, the Mutiny variants uses "
"`Uni` and `Multi`, the RX Java 2 version uses `Single`, `Maybe`, "
"`Completable`, `Observable` and `Flowable`..."
msgstr ""
"Vert.x に詳しい方は、Vert.x が異なる API モデルを提供していることをご存知でしょう。例えば、素 _の_Vert.x "
"はコールバックを使用し、Mutiny バリアントは `Uni` と `Multi` を使用し、RX Java 2 バージョンは `Single`, "
"`Maybe`, `Completable`, `Observable` と `Flowable`..."

#. type: Plain text
#: upstream/_guides/vertx.adoc:139
#, fuzzy
msgid "Quarkus provides 4 Vert.x APIs:"
msgstr "Quarkusは4つのVert.x APIを提供しています。"

#. type: Table
#: upstream/_guides/vertx.adoc:153
#, no-wrap, fuzzy
msgid ""
"\n"
"| Name | Code | Description\n"
"\n"
"| _bare_ | `@Inject io.vertx.core.Vertx vertx` | _bare_ Vert.x instance, the "
"API uses callbacks.\n"
"\n"
"| https://smallrye.io/smallrye-mutiny/[Mutiny] | `@Inject io.vertx.mutiny."
"core.Vertx vertx` | The Mutiny API for Vert.x.\n"
"\n"
"| RX Java 2 | `@Inject io.vertx.reactivex.core.Vertx vertx` | RX Java 2 Vert."
"x, the API uses RX Java 2 types (deprecated).\n"
"\n"
"| _Axle_ | `@Inject io.vertx.axle.core.Vertx vertx` | Axle Vert.x, the API "
"uses `CompletionStage` and `Reactive Streams` (deprecated).\n"
"\n"
msgstr "| 名前｜コード｜説明"

#. type: Plain text
#: upstream/_guides/vertx.adoc:157
#, fuzzy
msgid ""
"You may inject any of the 4 flavors of `Vertx` as well as the `EventBus` in "
"your Quarkus application beans: `bare`, `Mutiny`, `Axle`, `RxJava2`.  They "
"are just shims and rely on a single _managed_ Vert.x instance."
msgstr ""
"`Vertx` と `EventBus` の4つのフレーバーのいずれかをQuarkusアプリケーションビーンに注入することができます： `bare`, "
"`Mutiny`, `Axle`, `RxJava2`.これらは単なるシムであり、単一の _管理された_Vert.xインスタンスに依存しています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:159
#, fuzzy
msgid "You will pick one or the other depending on your use cases."
msgstr "ユースケースに応じてどちらかを選ぶことになります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:161
#, fuzzy
msgid ""
"`bare`: for advanced usage or if you have existing Vert.x code you want to "
"reuse in your Quarkus application"
msgstr "`bare`: 高度な使用方法や、Quarkusアプリケーションで再利用したい既存のVert.xコードがある場合に使用します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:162
#, fuzzy
msgid ""
"`mutiny`: Mutiny is an event-driven reactive programming API. It uses 2 "
"types: `Uni` and `Multi`. This is the recommended API."
msgstr ""
"`mutiny`: Mutinyはイベント駆動型のリアクティブプログラミングAPIです。 `Uni` と `Multi` "
"の2種類を使用しています。これが推奨APIです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:163
#, fuzzy
msgid ""
"`Axle`: works well with Quarkus and MicroProfile APIs (`CompletionStage` for "
"single results and `Publisher` for streams) - deprecated, it is recommended "
"to switch to Mutiny"
msgstr ""
"`Axle`: QuarkusとMicroProfile APIでうまく動作します (単一の結果については `CompletionStage` "
"、ストリームについては `Publisher` ) - 非推奨、Mutinyに切り替えることを推奨します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:164
#, fuzzy
msgid ""
"`Rx Java 2`: when you need support for a wide range of data transformation "
"operators on your streams - deprecated, it is recommended to switch to "
"Mutiny"
msgstr "`Rx Java 2`: ストリーム上で幅広いデータ変換演算子のサポートが必要な場合 - 非推奨、Mutinyへの切り替えが推奨されます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:166
#, fuzzy
msgid "The following snippets illustrate the difference between these 4 APIs:"
msgstr "以下のスニペットは、これら4つのAPIの違いを説明しています。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:177
#, no-wrap
msgid ""
"// Bare Vert.x:\n"
"vertx.fileSystem().readFile(\"lorem-ipsum.txt\", ar -> {\n"
"    if (ar.succeeded()) {\n"
"        System.out.println(\"Content:\" + ar.result().toString(\"UTF-8\"));\n"
"    } else {\n"
"        System.out.println(\"Cannot read the file: \" + ar.cause()."
"getMessage());\n"
"    }\n"
"});\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:186
#, no-wrap
msgid ""
"// Mutiny Vert.x:\n"
"vertx.fileSystem().readFile(\"lorem-ipsum.txt\")\n"
"    .onItem().transform(buffer -> buffer.toString(\"UTF-8\"))\n"
"    .subscribe()\n"
"    .with(\n"
"            content -> System.out.println(\"Content: \" + content),\n"
"            err -> System.out.println(\"Cannot read the file: \" + err."
"getMessage())\n"
"    );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:194
#, no-wrap
msgid ""
"// Rx Java 2 Vert.x\n"
"vertx.fileSystem().rxReadFile(\"lorem-ipsum.txt\")\n"
"    .map(buffer -> buffer.toString(\"UTF-8\"))\n"
"    .subscribe(\n"
"            content -> System.out.println(\"Content: \" + content),\n"
"            err -> System.out.println(\"Cannot read the file: \" + err."
"getMessage())\n"
"    );\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:205
#, no-wrap
msgid ""
"// Axle API:\n"
"vertx.fileSystem().readFile(\"lorem-ipsum.txt\")\n"
"    .thenApply(buffer -> buffer.toString(\"UTF-8\"))\n"
"    .whenComplete((content, err) -> {\n"
"        if (err != null) {\n"
"            System.out.println(\"Cannot read the file: \" + err."
"getMessage());\n"
"        } else {\n"
"            System.out.println(\"Content: \" + content);\n"
"        }\n"
"    });\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/vertx.adoc:211
#, fuzzy
msgid ""
"If you're not familiar with Mutiny, we recommend to read the link:getting-"
"started-reactive#mutiny[Getting Started with Reactive guide] first."
msgstr ""
"Mutinyに慣れていない場合は、まずGet link:getting-started-reactive#mutiny[ting Started "
"with Reactiveガイド]を読むことをお勧めします。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:213
#, no-wrap, fuzzy
msgid "Using Vert.x in Reactive JAX-RS resources"
msgstr "Reactive JAX-RSリソースでVert.xを使用する"

#. type: Plain text
#: upstream/_guides/vertx.adoc:216
#, fuzzy
msgid ""
"Quarkus web resources support asynchronous processing and streaming results "
"over https://developer.mozilla.org/en-US/docs/Web/API/Server-"
"sent_events[server-sent events]."
msgstr ""
"Quarkusのウェブリソースは、 link:https://developer.mozilla.org/en-US/docs/Web/API/"
"Server-sent_events[サーバーから送信されたイベント]に対する非同期処理と結果のストリーミングをサポートしています。"

#. type: Title ===
#: upstream/_guides/vertx.adoc:217
#, no-wrap, fuzzy
msgid "Asynchronous processing"
msgstr "非同期処理"

#. type: Plain text
#: upstream/_guides/vertx.adoc:220
#, fuzzy
msgid ""
"To asynchronously handle the HTTP request, the endpoint method must return a "
"`java.util.concurrent.CompletionStage` or an `io.smallrye.mutiny.Uni` "
"(requires the `quarkus-resteasy-mutiny` extension):"
msgstr ""
"HTTP リクエストを非同期に処理するには、エンドポイントメソッドは `java.util.concurrent.CompletionStage` "
"または `io.smallrye.mutiny.Uni` を返さなければなりません (拡張子 `quarkus-resteasy-mutiny` "
"が必要です)。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:225 upstream/_guides/vertx.adoc:263
#, no-wrap
msgid "@Path(\"/lorem\")\n"
"public class GreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:235
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> doSomethingAsync() {\n"
"        // Mimic an asynchronous computation.\n"
"        return Uni.createFrom()\n"
"                .item(() -> \"Hello!\")\n"
"                .onItem().delayIt().by(Duration.ofMillis(10));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:244
#, fuzzy
msgid ""
"Then, open your browser to http://localhost:8080/lorem and you should get "
"the message."
msgstr "そして、ブラウザで http://localhost:8080/lorem を開くと、メッセージが表示されるはずです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:247
#, fuzzy
msgid ""
"So far so good.  Now let's use the Vert.x API instead of this artificial "
"delay:"
msgstr "ここまでは順調です。では、この人工的な遅延の代わりに Vert.x API を使ってみましょう。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:254
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:266 upstream/_guides/vertx.adoc:333
#: upstream/_guides/vertx.adoc:522
#, no-wrap
msgid "    @Inject\n"
"    Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:274
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> doSomethingAsync() {\n"
"        return vertx.fileSystem().readFile(\"/META-INF/resources/lorem."
"txt\")\n"
"                .onItem().transform(b -> b.toString(\"UTF-8\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:277
#, fuzzy
msgid ""
"In this code, we inject the `vertx` instance (`io.vertx.mutiny.core.Vertx`) "
"and read a file from the file system."
msgstr ""
"このコードでは、 `vertx` インスタンス ( `io.vertx.mutiny.core.Vertx`) "
"を注入し、ファイルシステムからファイルを読み込んでいます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:279
#, fuzzy
msgid ""
"Create the `src/main/resources/META_INF/resources/lorem.txt` file with the "
"following content:"
msgstr "以下の内容の `src/main/resources/META_INF/resources/lorem.txt` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:283
#, no-wrap
msgid ""
"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod "
"tempor incididunt ut labore et dolore magna aliqua.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:286
#, fuzzy
msgid "Then, refresh the page, you should see the _lorem ipsum_ text."
msgstr "その後、ページを更新すると、 _lorem ipsumの_テキストが表示されるはずです。"

#. type: Title ===
#: upstream/_guides/vertx.adoc:287
#, no-wrap, fuzzy
msgid "Streaming using Server-Sent Events"
msgstr "サーバーから送信されたイベントを使用したストリーミング"

#. type: Plain text
#: upstream/_guides/vertx.adoc:290
#, fuzzy
msgid ""
"Quarkus web resources that need to send content as https://developer.mozilla."
"org/en-US/docs/Web/API/Server-sent_events[server-sent events] must have a "
"method:"
msgstr ""
"link:https://developer.mozilla.org/en-US/docs/Web/API/Server-"
"sent_events[サーバー送信イベント]としてコンテンツを送信する必要があるQuarkusのウェブリソースには、メソッドが必要です。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:292
#, fuzzy
msgid "declaring the `text/event-stream` response content type"
msgstr "`text/event-stream` レスポンスコンテンツ型の宣言"

#. type: Plain text
#: upstream/_guides/vertx.adoc:293
#, fuzzy
msgid ""
"returning a https://www.reactive-streams.org/[Reactive Streams] `Publisher` "
"or Mutiny `Multi` (requires the `quarkus-resteasy-mutiny` extension)"
msgstr ""
"link:https://www.reactive-streams.org/[Reactive Streams] `Publisher` または "
"Mutiny `Multi` を返します ( `quarkus-resteasy-mutiny` の拡張子が必要です)。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:295
#, fuzzy
msgid "In practice, a streaming greeting service would look like:"
msgstr "実際には、ストリーミングのグリーティングサービスは次のようになります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:300
#, no-wrap
msgid "@Path(\"/hello\")\n"
"public class StreamingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:309
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @Path(\"/{name}\")\n"
"    public Multi<String> greeting(@PathParam String name) {\n"
"        // TODO: create a Reactive Streams publisher or a Mutiny Multi\n"
"        return publisher;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:312
#, fuzzy
msgid "Now we just need to return our `Publisher` or `Multi`:"
msgstr "あとは、 `Publisher` か `Multi`."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:320
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import io.vertx.mutiny.core.Vertx;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:327
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import java.util.Date;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:330
#, no-wrap
msgid "@Path(\"/stream\")\n"
"public class StreamingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:342
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @Path(\"/{name}\")\n"
"    public Multi<String> greeting(@PathParam String name) {\n"
"        return vertx.periodicStream(2000).toMulti()\n"
"                .map(l -> String.format(\"Hello %s! (%s)%n\", name, new "
"Date()));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:346
#, fuzzy
msgid ""
"The server side is ready.  In order to see the result in the browser, we "
"need a web page."
msgstr "サーバー側の準備が整いました。ブラウザで結果を見るためにはWebページが必要です。"

#. type: Block title
#: upstream/_guides/vertx.adoc:348
#, no-wrap, fuzzy
msgid "META-INF/resources/streaming.html"
msgstr "META-INF/resources/streaming.html"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:361
#, no-wrap
msgid ""
"<!doctype html>\n"
"<html>\n"
"<head>\n"
"    <meta charset=\"utf-8\"/>\n"
"    <title>SSE with Vert.x - Quarkus</title>\n"
"    <script type=\"application/javascript\" src=\"streaming.js\"></script>\n"
"</head>\n"
"<body>\n"
"<div id=\"container\"></div>\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:365
#, fuzzy
msgid ""
"Our web page just has an empty `<div>` container.  The magic, as always, "
"lies in the Javascript code:"
msgstr ""
"私たちのウェブページには、空の `&amp;lt;div&amp;gt;` "
"コンテナがあります。いつものように、マジックはJavascriptのコードにあります。"

#. type: Block title
#: upstream/_guides/vertx.adoc:367
#, no-wrap, fuzzy
msgid "META-INF/resources/streaming.js"
msgstr "META-INF/resources/streaming.js"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:380
#, no-wrap
msgid ""
"if (!!window.EventSource) {\n"
"    var eventSource = new EventSource(\"/stream/Quarkus\");\n"
"    eventSource.onmessage = function (event) {\n"
"        var container = document.getElementById(\"container\");\n"
"        var paragraph = document.createElement(\"p\");\n"
"        paragraph.innerHTML = event.data;\n"
"        container.appendChild(paragraph);\n"
"    };\n"
"} else {\n"
"    window.alert(\"EventSource not available on this browser.\")\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:384
#, fuzzy
msgid ""
"Most browsers support SSE but some don't.  More about this in Mozilla's "
"https://developer.mozilla.org/en-US/docs/Web/API/"
"EventSource#Browser_compatibility[SSE browser-compatibility list]."
msgstr ""
"ほとんどのブラウザは SSE をサポートしていますが、一部のブラウザはサポートしていません。これについての詳細は、Mozilla の link:"
"https://developer.mozilla.org/en-US/docs/Web/API/"
"EventSource#Browser_compatibility[SSE ブラウザ互換性リスト]を参照してください。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:387
#, fuzzy
msgid ""
"Navigate to http://localhost:8080/streaming.html.  A new greeting should "
"show-up every 2 seconds."
msgstr "http://localhost:8080/streaming.html  に移動します。2秒ごとに新しい挨拶が表示されます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:391
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:13:55 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:393
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:13:57 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:395
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:13:59 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:397
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:14:01 CET 2020)\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:399
#, no-wrap
msgid "Hello Quarkus! (Wed Feb 12 17:14:03 CET 2020)\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/vertx.adoc:403
#, no-wrap, fuzzy
msgid "Using Vert.x JSON"
msgstr "Vert.x JSONの使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:407
#, fuzzy
msgid ""
"Vert.x API heavily relies on JSON, namely the `io.vertx.core.json."
"JsonObject` and `io.vertx.core.json.JsonArray` types.  They are both "
"supported as Quarkus web resource request and response bodies."
msgstr ""
"Vert.x APIはJSON、すなわち `io.vertx.core.json.JsonObject` 型と `io.vertx.core.json."
"JsonArray` "
"型に大きく依存しています。これらはいずれもQuarkusのウェブリソースのリクエストボディとレスポンスボディとしてサポートされています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:409
#, fuzzy
msgid "Consider these endpoints:"
msgstr "これらのエンドポイントを考えてみましょう。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:415
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"public class VertxJsonResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:421
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}/object\")\n"
"    public JsonObject jsonObject(@PathParam String name) {\n"
"        return new JsonObject().put(\"Hello\", name);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:428
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{name}/array\")\n"
"    public JsonArray jsonArray(@PathParam String name) {\n"
"        return new JsonArray().add(\"Hello\").add(name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:431
#, fuzzy
msgid ""
"In your browser, navigate to http://localhost:8080/hello/Quarkus/object. You "
"should see:"
msgstr "ブラウザで http://localhost:8080/hello/Quarkus/object  に移動します。表示されるはずです。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:435
#, no-wrap
msgid "{\"Hello\":\"Quarkus\"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:438
#, fuzzy
msgid "Then, navigate to http://localhost:8080/hello/Quarkus/array:"
msgstr "そして、 http://localhost:8080/hello/Quarkus/array  に移動します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:442
#, no-wrap
msgid "[\"Hello\",\"Quarkus\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:445
#, fuzzy
msgid ""
"Needless to say, this works equally well when the JSON content is a request "
"body or is wrapped in a `Uni`, `Multi`, `CompletionStage` or `Publisher`."
msgstr ""
"言うまでもなく、これはJSONコンテンツがリクエストボディであったり、 `Uni`, `Multi`, `CompletionStage`, , "
"`Publisher` でラップされている場合でも同様に動作します。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:446
#, no-wrap, fuzzy
msgid "Using Vert.x Clients"
msgstr "Vert.x クライアントの使用"

#. type: Plain text
#: upstream/_guides/vertx.adoc:450
#, fuzzy
msgid ""
"As you can inject a Vert.x instance, you can use Vert.x clients in a Quarkus "
"application.  This section gives an example with the `WebClient`."
msgstr ""
"Vert.xインスタンスを注入することができるので、QuarkusアプリケーションでVert."
"xクライアントを使用することができます。このセクションでは、 `WebClient`."

#. type: Title ===
#: upstream/_guides/vertx.adoc:451
#, no-wrap, fuzzy
msgid "Picking the right dependency"
msgstr "正しい依存関係の選択"

#. type: Plain text
#: upstream/_guides/vertx.adoc:454
#, fuzzy
msgid ""
"Depending on the API model you want to use you need to add the right "
"dependency to your `pom.xml` file:"
msgstr "使用したいAPIモデルに応じて、 `pom.xml` ファイルに適切な依存関係を追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:462
#, no-wrap
msgid ""
"<!-- bare API -->\n"
"<dependency>\n"
"  <groupId>io.vertx</groupId>\n"
"  <artifactId>vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:468
#, no-wrap
msgid ""
"<!-- Mutiny API -->\n"
"<dependency>\n"
"  <groupId>io.smallrye.reactive</groupId>\n"
"  <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:474
#, no-wrap
msgid ""
"<!-- Axle API -->\n"
"<dependency>\n"
"  <groupId>io.smallrye.reactive</groupId>\n"
"  <artifactId>smallrye-axle-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:480
#, no-wrap
msgid ""
"<!-- RX Java 2 API -->\n"
"<dependency>\n"
"  <groupId>io.vertx</groupId>\n"
"  <artifactId>vertx-rx-java2</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:483
#, fuzzy
msgid ""
"The `vertx-rx-java2` provides the RX Java 2 API for the whole Vert.x stack, "
"not only the web client."
msgstr ""
"`vertx-rx-java2` は Web クライアントだけでなく、Vert.x スタック全体の RX Java 2 API を提供しています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:485
#, fuzzy
msgid "In this guide, we are going to use the Mutiny API, so:"
msgstr "このガイドでは、Mutiny APIを使うことになっていますので。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:492
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.smallrye.reactive</groupId>\n"
"  <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:495
#, fuzzy
msgid "Now, create a new resource in your project with the following content:"
msgstr "では、以下の内容でプロジェクトに新しいリソースを作成します。"

#. type: Block title
#: upstream/_guides/vertx.adoc:497
#, no-wrap, fuzzy
msgid "src/main/java/org/acme/vertx/ResourceUsingWebClient.java"
msgstr "src/main/java/org/acme/vertx/ResourceUsingWebClient.java"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:508
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:511
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:516
#, no-wrap
msgid ""
"import io.vertx.mutiny.core.Vertx;\n"
"import io.vertx.mutiny.ext.web.client.WebClient;\n"
"import io.vertx.core.json.JsonObject;\n"
"import io.vertx.ext.web.client.WebClientOptions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:519
#, no-wrap
msgid "@Path(\"/fruit-data\")\n"
"public class ResourceUsingWebClient {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:524
#, no-wrap
msgid "    private WebClient client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:531
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void initialize() {\n"
"        this.client = WebClient.create(vertx,\n"
"                new WebClientOptions().setDefaultHost(\"fruityvice.com\")\n"
"                    .setDefaultPort(443).setSsl(true).setTrustAll(true));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:548
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    @Path(\"/{name}\")\n"
"    public Uni<JsonObject> getFruitData(@PathParam(\"name\") String name) {\n"
"        return client.get(\"/api/fruit/\" + name)\n"
"                .send()\n"
"                .onItem().transform(resp -> {\n"
"                    if (resp.statusCode() == 200) {\n"
"                        return resp.bodyAsJsonObject();\n"
"                    } else {\n"
"                        return new JsonObject()\n"
"                                .put(\"code\", resp.statusCode())\n"
"                                .put(\"message\", resp.bodyAsString());\n"
"                    }\n"
"                });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:556
#, fuzzy
msgid ""
"This resource creates a `WebClient` and upon request use this client to "
"invoke the _fruityvice_ API.  Depending on the result the response is "
"forwarded as it's received, or a new JSON object is created with the status "
"and body.  The `WebClient` is obviously asynchronous (and non-blocking), to "
"the endpoint returns a `Uni`."
msgstr ""
"このリソースは `WebClient` を作成し、リクエスト時にこのクライアントを使用して _fruityvice_API "
"を呼び出します。結果に応じて、レスポンスは受信したときに転送されるか、ステータスとボディを持つ新しいJSONオブジェクトが作成されます。 "
"`WebClient` は明らかに非同期（とノンブロッキング）で、エンドポイントに `Uni` を返します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:558
#, fuzzy
msgid "Run the application with:"
msgstr "でアプリケーションを実行します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:565
#, fuzzy
msgid ""
"And then, open a browser to: `http://localhost:8080/fruit-data/pear`. You "
"should get some details about pears."
msgstr ""
"そして、ブラウザを開いて `&lt;a href=\"http://localhost:8080/fruit-data/pear\" class="
"\"bare\"&gt;http://localhost:8080/fruit-data/pear&lt;/a&gt;`."
"あなたは、梨についてのいくつかの詳細を取得する必要があります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:569
#, fuzzy
msgid ""
"The application can also run as a native executable.  But, first, we need to "
"instruct Quarkus to enable _ssl_.  Open the `src/main/resources/application."
"properties` and add:"
msgstr ""
"アプリケーションはネイティブの実行ファイルとして実行することもできます。しかし、まず、Quarkusに "
"_sslを_有効にするように指示する必要があります。 `src/main/resources/application.properties` "
"を開いて、追加します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:573
#, no-wrap
msgid "quarkus.ssl.native=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:576
#, fuzzy
msgid "Then, create the native executable with:"
msgstr "そして、ネイティブの実行ファイルを"

#. type: Title ==
#: upstream/_guides/vertx.adoc:582
#, no-wrap, fuzzy
msgid "Deploying verticles"
msgstr "頂点の配置"

#. type: Plain text
#: upstream/_guides/vertx.adoc:587
#, fuzzy
msgid ""
"link:https://vertx.io/docs/vertx-core/java/#\\_verticles[Verticles] is \"a "
"simple, scalable, actor-like deployment and concurrency model\" provided by "
"_Vert.x_.  This model does not claim to be a strict actor-model "
"implementation, but it does share similarities especially with respect to "
"concurrency, scaling and deployment.  To use this model, you write and "
"_deploy_ verticles, communicating with each other by sending messages on the "
"event bus."
msgstr ""
"link:https://vertx.io/docs/vertx-core/java/#_verticles[Verticles]は _Vert.x_ "
"によって提供されている「シンプルでスケーラブルなアクターライクなデプロイメントと同時実行モデル」です。このモデルは厳密なアクターモデルの実装であるとは主張しませんが、特に同時実行、スケーリング、デプロイメントに関しては類似性を共有しています。このモデルを使用するには、イベントバス上でメッセージを送信することでお互いに通信しながら、 "
"頂点を書いて _展開し_ます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:590
#, fuzzy
msgid "You can deploy _verticles_ in Quarkus.  It supports:"
msgstr "Quarkusでバーティカル _を_展開することができます。サポートしています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:592
#, fuzzy
msgid ""
"_bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`"
msgstr "_裸の_頂点 - 拡張する Java クラス `io.vertx.core.AbstractVerticle`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:593
#, fuzzy
msgid ""
"_Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core."
"AbstractVerticle`"
msgstr ""
"_Mutiny_verticle - 拡張するJavaクラス `io.smallrye.mutiny.vertx.core."
"AbstractVerticle`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:595
#, fuzzy
msgid "To deploy verticles, use the regular Vert.x API:"
msgstr "頂点を展開するには、通常の Vert.x API を使用します。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:603
#, no-wrap
msgid ""
"// ...\n"
"vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n"
"vertx.deployVerticle(new MyVerticle(), ar -> { });\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:606
#, fuzzy
msgid ""
"You can also pass deployment options to configure the verticle as well as "
"set the number of instances."
msgstr "インスタンスの数を設定するだけでなく、デプロイメントオプションを渡してバーティクルを設定することもできます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:609
#, fuzzy
msgid ""
"Verticles are not _beans_ by default.  However, you can implement them as "
"_ApplicationScoped_ beans and get injection support:"
msgstr ""
"バーチクルはデフォルトでは _ビーンで_はありません。しかし、 "
"_ApplicationScoped_ビーンズとして実装し、インジェクションのサポートを得ることができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:613 upstream/_guides/vertx.adoc:641
#, no-wrap
msgid "package io.quarkus.vertx.verticles;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:617
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n"
"import org.eclipse.microprofile.config.inject.ConfigProperty;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:622
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyBeanVerticle extends AbstractVerticle {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:624
#, no-wrap
msgid "    @ConfigProperty(name = \"address\") String address;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:632
#, no-wrap
msgid ""
"    @Override\n"
"    public Uni<Void> asyncStart() {\n"
"        return vertx.eventBus().consumer(address)\n"
"                .handler(m -> m.replyAndForget(\"hello\"))\n"
"                .completionHandler();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:635
#, fuzzy
msgid ""
"You don't have to inject the `vertx` instance but instead leverage the "
"instance stored in the protected field of `AbstractVerticle`."
msgstr ""
"`vertx` インスタンスを注入する必要はなく、代わりに `AbstractVerticle` "
"の保護されたフィールドに保存されているインスタンスを活用します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:637
#, fuzzy
msgid "Then, deploy the verticle instance with:"
msgstr "そして、verticleインスタンスを使ってデプロイします。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:644
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:647
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:650
#, no-wrap
msgid "@ApplicationScoped\n"
"public class VerticleDeployer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vertx.adoc:655
#, no-wrap
msgid ""
"    public void init(@Observes StartupEvent e, Vertx vertx, MyBeanVerticle "
"verticle) {\n"
"         vertx.deployVerticle(verticle).await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:658
#, fuzzy
msgid "If you want to deploy every exposed `AbstractVerticle`, you can use:"
msgstr "もしあなたが公開された `AbstractVerticle` をすべてデプロイしたい場合、あなたは使用することができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:666
#, no-wrap
msgid ""
"public void init(@Observes StartupEvent e, Vertx vertx, "
"Instance<AbstractVerticle> verticles) {\n"
"    for (AbstractVerticle verticle : verticles) {\n"
"        vertx.deployVerticle(verticle).await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vertx.adoc:668
#, no-wrap, fuzzy
msgid "Listening to a Unix Domain Socket"
msgstr "Unix ドメインソケットのリスニング"

#. type: Plain text
#: upstream/_guides/vertx.adoc:674
#, fuzzy
msgid ""
"Listening on a unix domain socket allows us to dispense with the overhead of "
"TCP if the connection to the quarkus service is established from the same "
"host. This can happen if access to the service goes through a proxy which is "
"often the case if you're setting up a service mesh with a proxy like Envoy."
msgstr ""
"unix ドメインソケットでリスンすることで、同じホストから quarkus サービスへの接続が確立されている場合、TCP "
"のオーバーヘッドを省くことができます。これはサービスへのアクセスがプロキシを経由している場合に起こる可能性があり、Envoyのようなプロキシでサービスメッシュを設定している場合によく起こります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:676
#, fuzzy
msgid "This will only work on platforms that support <<native-transport>>."
msgstr ""
"これは、 link:#native-transport[[native-transport]]をサポートするプラットフォームでのみ動作します。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:679
#, fuzzy
msgid ""
"To setup please enable the appropriate <<native-transport>> and set the "
"following environment property:"
msgstr ""
"設定するには、適切な link:#native-transport[[native-"
"transport]を]有効にし、以下の環境プロパティを設定してください。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:683
#, no-wrap
msgid ""
"quarkus.http.domain-socket=/var/run/io.quarkus.app.socket\n"
"quarkus.http.domain-socket-enabled=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:687
#, fuzzy
msgid ""
"By itself this will not disable the tcp socket which by default will open on "
"`0.0.0.0:8080`. It can be explicitly disabled:"
msgstr ""
"これだけでは、デフォルトで `0.0.0.0:8080` で開かれる TCP ソケットを無効にすることはできません。明示的に無効にすることができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:690
#, no-wrap
msgid "quarkus.http.host-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:694
#, fuzzy
msgid ""
"These properties can be set through Java's `-D` command line parameter or on "
"`application.properties`."
msgstr "これらのプロパティは、Java の `-D` コマンドライン・パラメータまたは `application.properties`."

#. type: Title ==
#: upstream/_guides/vertx.adoc:695
#, no-wrap, fuzzy
msgid "Read only deployment environments"
msgstr "読み込み専用の展開環境"

#. type: Plain text
#: upstream/_guides/vertx.adoc:698
#, fuzzy
msgid ""
"In environments with read only file systems you may receive errors of the "
"form:"
msgstr "読み取り専用のファイルシステムを使用している環境では、このような形式のエラーが発生することがあります。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:702
#, no-wrap
msgid "java.lang.IllegalStateException: Failed to create cache dir\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:705
#, fuzzy
msgid ""
"Assuming `/tmp/` is writable this can be fixed by setting the `vertx."
"cacheDirBase` property to point to a directory in `/tmp/` for instance in "
"OpenShift by creating an environment variable `JAVA_OPTS` with the value `-"
"Dvertx.cacheDirBase=/tmp/vertx`."
msgstr ""
"`/tmp/` が書き込み可能であると仮定して、 `vertx.cacheDirBase` プロパティを設定して `/tmp/` "
"のディレクトリを指すように設定し、例えば OpenShift の場合は `JAVA_OPTS` に `-Dvertx.cacheDirBase=/tmp/"
"vertx` の値を持つ環境変数を作成することで修正できます。"

#. type: Title ==
#: upstream/_guides/vertx.adoc:707
#, no-wrap, fuzzy
msgid "Running behind a reverse proxy"
msgstr "リバースプロキシの背後での実行"

#. type: Plain text
#: upstream/_guides/vertx.adoc:713
#, fuzzy
msgid ""
"Quarkus could be accessed through proxies that additionally generate headers "
"(e.g. `X-Forwarded-Host`) to keep information from the client-facing side of "
"the proxy servers that is altered or lost when they are involved.  In those "
"scenarios, Quarkus can be configured to automatically update information "
"like protocol, host, port and URI reflecting the values in these headers."
msgstr ""
"Quarkusは、プロキシサーバーが関与したときに変更されたり失われたりする情報を、プロキシサーバーのクライアント側から保持するために、追加でヘッダー（例： "
"`X-Forwarded-Host` "
"）を生成するプロキシを介してアクセスすることができます。このようなシナリオでは、Quarkusは、これらのヘッダーの値を反映して、プロトコル、ホスト、ポート、URIなどの情報を自動的に更新するように設定することができます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:716
#, fuzzy
msgid ""
"Activating this feature makes the server exposed to several security issues "
"(i.e. information spoofing).  Consider activate it only when running behind "
"a reverse proxy."
msgstr ""
"この機能を有効にすると、サーバはいくつかのセキュリティ上の問題(情報の詐称など)にさらされることになります。リバースプロキシの後ろで実行している場合にのみ有効にすることを検討してください。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:718
#, fuzzy
msgid ""
"To setup this feature, please include the following lines in `src/main/"
"resources/application.properties`:"
msgstr "この機能を設定するには、 `src/main/resources/application.properties`."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:721
#, no-wrap
msgid "quarkus.http.proxy-address-forwarding=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:724
#, fuzzy
msgid ""
"To consider only de-facto standard header (`Forwarded` header), please "
"include the following lines in `src/main/resources/application.properties`:"
msgstr ""
"デファクトの標準ヘッダ( `Forwarded` ヘッダ)のみを考慮する場合は、 `src/main/resources/application."
"properties`."

#. type: delimited block -
#: upstream/_guides/vertx.adoc:727
#, no-wrap
msgid "quarkus.http.proxy.allow-forwarded=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:730
#, fuzzy
msgid ""
"To consider only non-standard headers, please include the following lines "
"instead in `src/main/resources/application.properties`:"
msgstr ""
"標準以外のヘッダのみを考慮するために、代わりに以下の行を `src/main/resources/application.properties` "
"に含めてください。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:736
#, no-wrap
msgid ""
"quarkus.http.proxy.proxy-address-forwarding=true\n"
"quarkus.http.proxy.enable-forwarded-host=true\n"
"quarkus.http.proxy.enable-forwarded-prefix=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:739
#, fuzzy
msgid ""
"Both configurations related to standard and non-standard headers can be "
"combined, although the standard headers configuration will have precedence."
msgstr "標準ヘッダと非標準ヘッダに関連する両方の設定を組み合わせることができますが、標準ヘッダの設定が優先されます。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:741
#, fuzzy
msgid "Supported forwarding address headers are:"
msgstr "サポートされている転送アドレスヘッダは以下の通りです。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:743
#, fuzzy
msgid "`Forwarded`"
msgstr "`Forwarded`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:744
#, fuzzy
msgid "`X-Forwarded-Proto`"
msgstr "`X-Forwarded-Proto`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:745
#, fuzzy
msgid "`X-Forwarded-Host`"
msgstr "`X-Forwarded-Host`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:746
#, fuzzy
msgid "`X-Forwarded-Port`"
msgstr "`X-Forwarded-Port`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:747
#, fuzzy
msgid "`X-Forwarded-Ssl`"
msgstr "`X-Forwarded-Ssl`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:748
#, fuzzy
msgid "`X-Forwarded-Prefix`"
msgstr "`X-Forwarded-Prefix`"

#. type: Plain text
#: upstream/_guides/vertx.adoc:753
#, fuzzy
msgid ""
"One can easily add a https://developer.mozilla.org/en-US/docs/Web/HTTP/"
"Headers/Set-Cookie/SameSite[SameSite] cookie property to any of the cookies "
"set by a Quarkus endpoint by listing a cookie name and a `SameSite` "
"attribute, for example:"
msgstr ""
"例えば、クッキー名と `SameSite` 属性をリストアップすることで、Quarkusエンドポイントで設定されたクッキーに link:https://"
"developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/"
"SameSite[SameSite]クッキープロパティを簡単に追加することができます。"

#. type: delimited block -
#: upstream/_guides/vertx.adoc:758
#, no-wrap
msgid ""
"quarkus.http.same-site-cookie.jwt.value=Lax\n"
"quarkus.http.same-site-cookie.session.value=Strict\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vertx.adoc:761
#, fuzzy
msgid ""
"Given this configuration, the `jwt` cookie will have a `SameSite=Lax` "
"attribute and the `session` cookie will have a `SameSite=Strict` attribute."
msgstr ""
"この設定を考えると、 `jwt` クッキーは `SameSite=Lax` 属性を持ち、 `session` クッキーは `SameSite="
"Strict` 属性を持つことになります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:765
#, fuzzy
msgid "There are many other facets of Quarkus using Vert.x underneath:"
msgstr "下にVert.xを使ったQuarkusの他の面もたくさんあります。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:769
#, fuzzy
msgid ""
"The event bus is the connecting tissue of Vert.x applications.  Quarkus "
"integrates it so different beans can interact with asynchronous messages.  "
"This part is covered in the link:reactive-event-bus[event bus documentation]."
""
msgstr ""
"イベントバスは、Vert."
"xアプリケーションの接続組織です。Quarkusはこれを統合して、異なるビーンが非同期メッセージと対話できるようにしています。この部分は、 link:"
"reactive-event-bus[イベントバスのドキュメント]でカバーされています。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:773
#, fuzzy
msgid ""
"Data streaming and Apache Kafka are an important part of modern systems.  "
"Quarkus integrates data streaming using Reactive Messaging.  More details on "
"link:kafka[Interacting with Kafka]."
msgstr ""
"データストリーミングとApache Kafkaは、現代のシステムの重要な部分です。Quarkusは、Reactive "
"Messagingを使用してデータストリーミングを統合しています。詳細は、 link:kafka[Kafkaとのインタラクション]を参照してください。"

#. type: Plain text
#: upstream/_guides/vertx.adoc:774
#, fuzzy
msgid ""
"Learn how to implement highly performant, low-overhead database applications "
"on Quarkus with the link:reactive-sql-clients[Reactive SQL Clients]."
msgstr ""
"link:reactive-sql-clients[Reactive "
"SQLクライアントを]使用して、Quarkus上に高パフォーマンスで低オーバーヘッドのデータベースアプリケーションを実装する方法をご紹介します。"

#. type: Plain text
#: upstream/_guides/quarkus-blaze-persistence.adoc:3
#, fuzzy
msgid ""
"icon:lock[title=Fixed at build time] Configuration property fixed at build "
"time - All other configuration properties are overridable at runtime"
msgstr ""
"<span class=\"icon\">lock]</span>ビルド時に設定プロパティを固定 - "
"その他の設定プロパティはすべて実行時にオーバーライド可能"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:13
#, no-wrap, fuzzy
msgid ""
"\n"
"h|[[quarkus-blaze-persistence_configuration]]link:#quarkus-blaze-"
"persistence_configuration[Configuration property]\n"
"\n"
"h|Type\n"
"h|Default\n"
"\n"
"a|icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus."
"blaze-persistence.template-eager-loading]]`link:#quarkus-blaze-"
"persistence_quarkus.blaze-persistence.template-eager-loading[quarkus.blaze-"
"persistence.template-eager-loading]`\n"
"\n"
msgstr ""
"h| link:[, id=quarkus-blaze-persistence_configuration] link:#quarkus-blaze-"
"persistence_configuration[設定プロパティ]"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:22
#, fuzzy
msgid ""
"A boolean flag to make it possible to prepare all view template caches on "
"startup. By default the eager loading of the view templates is disabled to "
"have a better startup performance. Valid values for this property are `true` "
"or `false`.  --|boolean | a|icon:lock[title=Fixed at build time] [[quarkus-"
"blaze-persistence_quarkus.blaze-persistence.default-batch-size]]`link:"
"#quarkus-blaze-persistence_quarkus.blaze-persistence.default-batch-"
"size[quarkus.blaze-persistence.default-batch-size]`"
msgstr ""
"起動時にすべてのビューテンプレートキャッシュを準備することを可能にするブーリアンフラグです。デフォルトでは、起動時のパフォーマンスを向上させるために、ビューテンプレートの熱心な読み込みは無効になっています。このプロパティの有効な値は "
"`true` または `false` です。--|boolean | a<span class=\"icon\">|[lock]</span>  "
"link:[, id=quarkus-blaze-persistence_quarkus.blaze-persistence.default-batch-"
"size] `&lt;a href=\"#quarkus-blaze-persistence_quarkus.blaze-persistence."
"default-batch-size\"&gt;quarkus.blaze-persistence.default-batch-size&lt;/"
"a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:31
#, fuzzy
msgid ""
"An integer value that defines the default batch size for entity view "
"attributes. By default the value is 1 and can be overridden either via `com."
"blazebit.persistence.view.BatchFetch#size()` or by setting this property via "
"`com.blazebit.persistence.view.EntityViewSetting#setProperty`.  --|int | "
"a|icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus."
"blaze-persistence.expect-batch-mode]]`link:#quarkus-blaze-"
"persistence_quarkus.blaze-persistence.expect-batch-mode[quarkus.blaze-"
"persistence.expect-batch-mode]`"
msgstr ""
"エンティティ ビュー属性のデフォルトのバッチ サイズを定義する整数値。デフォルトでは値は1で、 `com.blazebit.persistence."
"view.BatchFetch#size()` を通して、または `com.blazebit.persistence.view."
"EntityViewSetting#setProperty` を通してこのプロパティを設定することで上書きすることができます。--|int | "
"a<span class=\"icon\">|[lock]</span>  link:[, id=quarkus-blaze-"
"persistence_quarkus.blaze-persistence.expect-batch-mode] `&lt;a href="
"\"#quarkus-blaze-persistence_quarkus.blaze-persistence.expect-batch-"
"mode\"&gt;quarkus.blaze-persistence.expect-batch-mode&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:34
#, fuzzy
msgid ""
"A mode specifying if correlation value, view root or embedded view batching "
"is expected. By default the value is `values` and can be overridden by "
"setting this property via `com.blazebit.persistence.view."
"EntityViewSetting#setProperty`. Valid values are"
msgstr ""
"相関値、ビュールート、埋め込みビューのいずれかのバッチングが期待されるかどうかを指定するモードです。デフォルトでは、値は `values` であり、 "
"`com.blazebit.persistence.view.EntityViewSetting#setProperty` "
"でこのプロパティを設定することで上書きすることができます。有効な値は"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:35
#, fuzzy
msgid "`values`"
msgstr "`values`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:36
#, fuzzy
msgid "`view_roots`"
msgstr "`view_roots`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:43
#, fuzzy
msgid ""
"`embedding_views` --|string | a|icon:lock[title=Fixed at build time] "
"[[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.eager-"
"loading]]`link:#quarkus-blaze-persistence_quarkus.blaze-persistence.updater."
"eager-loading[quarkus.blaze-persistence.updater.eager-loading]`"
msgstr ""
"`embedding_views` --|string | a<span class=\"icon\">|[lock]</span>  link:[, "
"id=quarkus-blaze-persistence_quarkus.blaze-persistence.updater.eager-"
"loading] `&lt;a href=\"#quarkus-blaze-persistence_quarkus.blaze-persistence."
"updater.eager-loading\"&gt;quarkus.blaze-persistence.updater.eager-"
"loading&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:52
#, fuzzy
msgid ""
"A boolean flag to make it possible to prepare the entity view updater cache "
"on startup. By default the eager loading of entity view updates is disabled "
"to have a better startup performance. Valid values for this property are "
"`true` or `false`.  --|boolean | a|icon:lock[title=Fixed at build time] "
"[[quarkus-blaze-persistence_quarkus.blaze-persistence.updater.disallow-owned-"
"updatable-subview]]`link:#quarkus-blaze-persistence_quarkus.blaze-"
"persistence.updater.disallow-owned-updatable-subview[quarkus.blaze-"
"persistence.updater.disallow-owned-updatable-subview]`"
msgstr ""
"起動時にエンティティ ビューの更新キャッシュを準備することを可能にするブーリアン "
"フラグです。デフォルトでは、起動時のパフォーマンスを向上させるために、エンティティビュー更新の熱心な読み込みは無効になっています。このプロパティの有効な値は、 "
"`true` または `false`.--|boolean | a<span class=\"icon\">|[lock]</span>  link:"
"[, id=quarkus-blaze-persistence_quarkus.blaze-persistence.updater.disallow-"
"owned-updatable-subview] `&lt;a href=\"#quarkus-blaze-persistence_quarkus."
"blaze-persistence.updater.disallow-owned-updatable-subview\"&gt;quarkus."
"blaze-persistence.updater.disallow-owned-updatable-subview&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:61
#, fuzzy
msgid ""
"A boolean flag to make it possible to disable the strict validation that "
"disallows the use of an updatable entity view type for owned relationships. "
"By default the use is disallowed i.e. the default value is `true`, but since "
"there might be strange models out there, it possible to allow this. Valid "
"values for this property are `true` or `false`.  --|boolean | a|icon:"
"lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-"
"persistence.updater.strict-cascading-check]]`link:#quarkus-blaze-"
"persistence_quarkus.blaze-persistence.updater.strict-cascading-check[quarkus."
"blaze-persistence.updater.strict-cascading-check]`"
msgstr ""
"所有するリレーションシップに対して更新可能なエンティティ・ビュー・タイプの使用を禁止する厳密な検証を無効にするためのブール値フラグ。デフォルトでは、デフォルト値は "
"`true` となっていますが、奇妙なモデルがあるかもしれないので、これを許可することも可能です。このプロパティの有効な値は `true` または "
"`false` です。--|boolean | a<span class=\"icon\">|[lock]</span>  link:[, id="
"quarkus-blaze-persistence_quarkus.blaze-persistence.updater.strict-cascading-"
"check] `&lt;a href=\"#quarkus-blaze-persistence_quarkus.blaze-persistence."
"updater.strict-cascading-check\"&gt;quarkus.blaze-persistence.updater.strict-"
"cascading-check&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:70
#, fuzzy
msgid ""
"A boolean flag to make it possible to disable the strict cascading check "
"that disallows setting updatable or creatable entity views on non-cascading "
"attributes before being associated with a cascading attribute. When "
"disabled, it is possible, like in JPA, that the changes done to an updatable "
"entity view are not flushed when it is not associated with an attribute that "
"cascades updates. By default the use is enabled i.e. the default value is "
"`true`. Valid values for this property are `true` or `false`.  --|boolean | "
"a|icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus."
"blaze-persistence.updater.error-on-invalid-plural-setter]]`link:#quarkus-"
"blaze-persistence_quarkus.blaze-persistence.updater.error-on-invalid-plural-"
"setter[quarkus.blaze-persistence.updater.error-on-invalid-plural-setter]`"
msgstr ""
"カスケード属性に関連付けられる前に、カスケード属性に関連付けられていない属性上で更新可能なエンティティ・ビューや作成可能なエンティティ・ビューを設定できないようにする、厳密なカスケード・チェックを無効にすることができるようにするためのブール値フラグです。無効にすると、JPAのように、更新可能なエンティティビューがカスケード更新属性に関連付けられていない場合に、更新可能なエンティティビューに行われた変更がフラッシュされないようにすることができます。 "
"`true`デフォルトでは、この使用は有効になっています。このプロパティの有効な値は `true` または `false` です。--|boolean "
"| a<span class=\"icon\">|[lock]</span>  link:[, id=quarkus-blaze-"
"persistence_quarkus.blaze-persistence.updater.error-on-invalid-plural-"
"setter] `&lt;a href=\"#quarkus-blaze-persistence_quarkus.blaze-persistence."
"updater.error-on-invalid-plural-setter\"&gt;quarkus.blaze-persistence."
"updater.error-on-invalid-plural-setter&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:79
#, fuzzy
msgid ""
"A boolean flag that allows to switch from warnings to boot time validation "
"errors when invalid plural attribute setters are encountered while the "
"strict cascading check is enabled. When `true`, a boot time validation error "
"is thrown when encountering an invalid setter, otherwise just a warning. "
"This configuration has no effect when the strict cascading check is disabled."
" By default the use is disabled i.e. the default value is `false`. Valid "
"values for this property are `true` or `false`.  --|boolean | a|icon:"
"lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-"
"persistence.create-empty-flat-views]]`link:#quarkus-blaze-"
"persistence_quarkus.blaze-persistence.create-empty-flat-views[quarkus.blaze-"
"persistence.create-empty-flat-views]`"
msgstr ""
"厳格なカスケードチェックが有効になっている間に、無効な複数の属性セッターに遭遇した場合に、警告から起動時の検証エラーに切り替えることができるブール値フラグです。 "
"`true` "
"に設定すると、無効なセッターに遭遇した場合にはブート時の検証エラーが発生し、そうでない場合には警告のみが発生します。この設定は、厳密なカスケードチェックが無効になっている場合には何の効果もありません。デフォルトでは、使用は無効になっています。つまり、デフォルト値は "
"`false` です。このプロパティの有効な値は `true` または `false` です。--|boolean | a<span class="
"\"icon\">|[lock]</span>  link:[, id=quarkus-blaze-persistence_quarkus.blaze-"
"persistence.create-empty-flat-views] `&lt;a href=\"#quarkus-blaze-"
"persistence_quarkus.blaze-persistence.create-empty-flat-views\"&gt;quarkus."
"blaze-persistence.create-empty-flat-views&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:88
#, fuzzy
msgid ""
"A boolean flag that allows to specify if empty flat views should be created "
"by default if not specified via `EmptyFlatViewCreation`. By default the "
"creation of empty flat views is enabled i.e. the default value is `true`. "
"Valid values for this property are `true` or `false`.  --|boolean | a|icon:"
"lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus.blaze-"
"persistence.expression-cache-class]]`link:#quarkus-blaze-persistence_quarkus."
"blaze-persistence.expression-cache-class[quarkus.blaze-persistence."
"expression-cache-class]`"
msgstr ""
"`EmptyFlatViewCreation` で指定されていない場合、デフォルトで空のフラットビューを作成するかどうかを指定するブール値フラグです。 "
"`true`デフォルトでは、空のフラットビューの作成は有効になっています。このプロパティの有効な値は `true` または `false` です。--"
"|boolean | a<span class=\"icon\">|[lock]</span>  link:[, id=quarkus-blaze-"
"persistence_quarkus.blaze-persistence.expression-cache-class] `&lt;a href="
"\"#quarkus-blaze-persistence_quarkus.blaze-persistence.expression-cache-"
"class\"&gt;quarkus.blaze-persistence.expression-cache-class&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:97
#, fuzzy
msgid ""
"The full qualified expression cache implementation class name.  --|string | "
"a|icon:lock[title=Fixed at build time] [[quarkus-blaze-persistence_quarkus."
"blaze-persistence.inline-ctes]]`link:#quarkus-blaze-persistence_quarkus."
"blaze-persistence.inline-ctes[quarkus.blaze-persistence.inline-ctes]`"
msgstr ""
"完全修飾式キャッシュの実装クラス名。--|string | a<span class=\"icon\">|[lock]</span>  link:[, "
"id=quarkus-blaze-persistence_quarkus.blaze-persistence.inline-ctes] `&lt;a "
"href=\"#quarkus-blaze-persistence_quarkus.blaze-persistence.inline-"
"ctes\"&gt;quarkus.blaze-persistence.inline-ctes&lt;/a&gt;`"

#. type: Table
#: upstream/_guides/quarkus-blaze-persistence.adoc:103
#, fuzzy
msgid ""
"If set to true, the CTE queries are inlined by default. Valid values for "
"this property are `true`, `false` or `auto`. Default is `true` which will "
"always inline non-recursive CTEs. The `auto` configuration will only make "
"use of inlining if the JPA provider and DBMS dialect support/require it. The "
"property can be changed for a criteria builder before constructing a query.  "
"--|boolean |"
msgstr ""
"true に設定すると、CTE クエリはデフォルトでインライン化されます。このプロパティの有効な値は `true` 、 `false` または "
"`auto` です。デフォルトは `true` で、非再帰的な CTE を常にインライン化します。 `auto` の設定では、JPA プロバイダと "
"DBMS の方言がサポート/"
"要求している場合にのみインライン化を使用します。このプロパティは、クエリを構築する前にクライテリアビルダーで変更することができます。--|boolean"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/context-propagation.adoc:6
#, no-wrap, fuzzy
msgid "Context Propagation in Quarkus"
msgstr "Quarkusでのコンテキスト伝搬"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:15
#, no-wrap, fuzzy
msgid ""
"Traditional blocking code uses link:https://docs.oracle.com/en/java/javase/"
"11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`]\n"
" variables to store contextual objects in order to avoid\n"
"passing them as parameters everywhere. Many Quarkus extensions require those "
"contextual objects to operate\n"
"properly: link:rest-json[RESTEasy], link:cdi-reference[ArC] and link:"
"transaction[Transaction]\n"
"for example.\n"
msgstr ""
"従来のブロッキングコードでは  link:https://docs.oracle.com/en/java/javase/11/docs/api/java."
"base/java/lang/ThreadLocal."
"html[`ThreadLocal`]変数を使用してコンテキストオブジェクトを格納します。多くのQuarkus拡張機能は、適切に動作するためにこれらのコンテキストオブジェクトを必要とします。例えば、 "
"link:rest-json[RESTEasy]、 link:cdi-reference[ArC]、 link:"
"transaction[Transaction]などです。"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:20
#, fuzzy
msgid ""
"If you write reactive/async code, you have to cut your work into a pipeline "
"of code blocks that get executed \"later\", and in practice after the method "
"you defined them in have returned. As such, `try/finally` blocks as well as "
"`ThreadLocal` variables stop working, because your reactive code gets "
"executed in another thread, after the caller ran its `finally` block."
msgstr ""
"リアクティブ/非同期コードを書く場合、「後で」実行されるコードブロックのパイプラインに作業を切り "
"込まなければならず、実際には、定義したメソッドが返された後に実行されます。そのため、 `try/finally` ブロックや `ThreadLocal` "
"変数は動作しなくなります。なぜならば、呼び出し元が `finally` ブロックを実行した後に、リアクティブコードは別のスレッドで実行されるからです。"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:24
#, fuzzy
msgid ""
"link:https://github.com/eclipse/microprofile-context-"
"propagation[MicroProfile Context Propagation] was made to make those Quarkus "
"extensions work properly in reactive/async settings. It works by capturing "
"those contextual values that used to be in thread-locals, and restoring them "
"when your code is called."
msgstr ""
"link:https://github.com/eclipse/microprofile-context-"
"propagation[MicroProfile Context Propagation]は、リアクティブ/"
"非同期設定でQuarkus拡張機能が正しく動作するようにするために作られました。これは、スレッドローカルにあったコンテキスト値を取得し、コードが呼び出されたときにそれらを復元することで動作します。"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:29
#, fuzzy
msgid ""
"If you are using link:http://smallrye.io/smallrye-mutiny[Mutiny] (the "
"`quarkus-mutiny` extension), you just need to add the the `quarkus-smallrye-"
"context-propagation` extension to enable context propagation."
msgstr ""
"link:http://smallrye.io/smallrye-mutiny[Mutiny]( `quarkus-mutiny` の拡張子) "
"を使用している場合は、コンテキストの伝播を有効にするために `quarkus-smallrye-context-propagation` "
"の拡張子を追加するだけです。"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:31
#, fuzzy
msgid "In other words, add the following dependencies to your `pom.xml`:"
msgstr "つまり、以下の依存関係を `pom.xml` に追加します。"

#. type: delimited block -
#: upstream/_guides/context-propagation.adoc:50
#, no-wrap
msgid ""
"<dependencies>\n"
"    <!-- Mutiny and RestEasy support extensions if not already included -->\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-mutiny</artifactId>\n"
"    </dependency>\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-resteasy-mutiny</artifactId>\n"
"    </dependency>\n"
"    <!-- Context Propagation extension -->\n"
"    <dependency>\n"
"        <groupId>io.quarkus</groupId>\n"
"        <artifactId>quarkus-smallrye-context-propagation</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:53
#, fuzzy
msgid ""
"With this, you will get context propagation for ArC, RESTEasy and "
"transactions, if you are using them."
msgstr "これにより、ArC、RESTEasy、トランザクションを使用している場合は、コンテキストの伝播を得ることができます。"

#. type: Title ==
#: upstream/_guides/context-propagation.adoc:54
#, no-wrap, fuzzy
msgid "Usage example with Mutiny"
msgstr "反乱との使用例"

#. type: delimited block =
#: upstream/_guides/context-propagation.adoc:60
#, fuzzy
msgid ""
"This section uses Mutiny reactive types, if you're not familiar with them, "
"read the link:getting-started-reactive#mutiny[Getting Started with Reactive "
"guide] first."
msgstr ""
"このセクションでは、Mutinyの link:getting-started-reactive#mutiny[リアクティブタイプ]を使用しています。"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:65
#, fuzzy
msgid ""
"Let's write a REST endpoint that reads the next 3 items from a link:"
"kafka[Kafka topic], stores them in a database using link:hibernate-orm-"
"panache[Hibernate ORM with Panache] (all in the same transaction) before "
"returning them to the client, you can do it like this:"
msgstr ""
"link:kafka[Kafkaトピック]から次の3つのアイテムを読み込んで、 link:hibernate-orm-panache[Hibernate "
"ORM with Panacheを使っ]てデータベースに保存してからクライアントに返すRESTエンドポイントを書いてみましょう。"

#. type: delimited block -
#: upstream/_guides/context-propagation.adoc:71
#, no-wrap
msgid ""
"    // Get the prices stream\n"
"    @Inject\n"
"    @Channel(\"prices\") Publisher<Double> prices;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/context-propagation.adoc:92
#, no-wrap
msgid ""
"    @Transactional\n"
"    @GET\n"
"    @Path(\"/prices\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(MediaType.TEXT_PLAIN)\n"
"    public Publisher<Double> prices() {\n"
"        // get the next three prices from the price stream\n"
"        return Multi.createFrom().publisher(prices)\n"
"                .transform().byTakingFirstItems(3)\n"
"                .map(price -> {\n"
"                    // store each price before we send them\n"
"                    Price priceEntity = new Price();\n"
"                    priceEntity.value = price;\n"
"                    // here we are all in the same transaction\n"
"                    // thanks to context propagation\n"
"                    priceEntity.persist();\n"
"                    return price;\n"
"                    // the transaction is committed once the stream "
"completes\n"
"                });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:96
#, fuzzy
msgid ""
"Notice that thanks to Mutiny support for context propagation, this works out "
"of the box.  The 3 items are persisted using the same transaction and this "
"transaction is committed when the stream completes."
msgstr ""
"コンテキストの伝播のための Mutiny "
"サポートのおかげで、これは箱から出してすぐに動作することに注目してください。3つのアイテムは同じトランザクションを使用して保持され、このトランザクションはストリームが完了するとコミットされます。"

#. type: Title ==
#: upstream/_guides/context-propagation.adoc:97
#, no-wrap, fuzzy
msgid "Usage example for `CompletionStage`"
msgstr "使用例 `CompletionStage`"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:105
#, fuzzy
msgid ""
"If you are using link:https://docs.oracle.com/en/java/javase/11/docs/api/"
"java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`] you "
"need manual context propagation. You can do that by injecting a "
"`ThreadContext` or `ManagedExecutor` that will propagate every context. For "
"example, here we use the link:vertx[Vert.x Web Client] to get the list of "
"Star Wars people, then store them in the database using link:hibernate-orm-"
"panache[Hibernate ORM with Panache] (all in the same transaction) before "
"returning them to the client as JSON using link:rest-json[Jackson or JSON-B]:"
""
msgstr ""
"を使用している場合は  link:https://docs.oracle.com/en/java/javase/11/docs/api/java."
"base/java/util/concurrent/CompletionStage."
"html[`CompletionStage`]を使用するには、手動でコンテキストを伝播させる必要があります。 `ThreadContext` や "
"`ManagedExecutor` を注入することで、すべてのコンテキストを伝播させることができます。例えば、ここでは link:vertx[Vert."
"x Web Client]を使用してスターウォーズの人々のリストを取得し、 link:hibernate-orm-panache[Hibernate "
"ORM with Panache を]使用してデータベースに保存します (全て同じトランザクション内で) その後、 link:rest-"
"json[Jackson または JSON-B] を使用して JSON としてクライアントに返します。"

#. type: delimited block -
#: upstream/_guides/context-propagation.adoc:111
#, no-wrap
msgid ""
"    @Inject ThreadContext threadContext;\n"
"    @Inject ManagedExecutor managedExecutor;\n"
"    @Inject Vertx vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/context-propagation.adoc:138
#, no-wrap
msgid ""
"    @Transactional\n"
"    @GET\n"
"    @Path(\"/people\")\n"
"    public CompletionStage<List<Person>> people() throws SystemException {\n"
"        // Create a REST client to the Star Wars API\n"
"        WebClient client = WebClient.create(vertx,\n"
"                         new WebClientOptions()\n"
"                          .setDefaultHost(\"swapi.dev\")\n"
"                          .setDefaultPort(443)\n"
"                          .setSsl(true));\n"
"        // get the list of Star Wars people, with context capture\n"
"        return threadContext.withContextCapture(client.get(\"/api/people/\")."
"send())\n"
"                .thenApplyAsync(response -> {\n"
"                    JsonObject json = response.bodyAsJsonObject();\n"
"                    List<Person> persons = new ArrayList<>(json."
"getInteger(\"count\"));\n"
"                    // Store them in the DB\n"
"                    // Note that we're still in the same transaction as the "
"outer method\n"
"                    for (Object element : json.getJsonArray(\"results\")) {\n"
"                        Person person = new Person();\n"
"                        person.name = ((JsonObject) element)."
"getString(\"name\");\n"
"                        person.persist();\n"
"                        persons.add(person);\n"
"                    }\n"
"                    return persons;\n"
"                }, managedExecutor);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:142
#, fuzzy
msgid ""
"Using `ThreadContext` or `ManagedExecutor` you can wrap most useful "
"functional types and `CompletionStage` in order to get context propagated."
msgstr ""
"`ThreadContext` または `ManagedExecutor` を使用すると、ほとんどの有用な関数型と `CompletionStage` "
"をラップしてコンテキストを伝播させることができます。"

#. type: delimited block =
#: upstream/_guides/context-propagation.adoc:146
#, fuzzy
msgid "The injected `ManagedExecutor` uses the Quarkus thread pool."
msgstr "注入された `ManagedExecutor` は、Quarkus のスレッドプールを使用しています。"

#. type: Title ==
#: upstream/_guides/context-propagation.adoc:148
#, no-wrap, fuzzy
msgid "Adding support for RxJava2"
msgstr "RxJava2のサポートを追加"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:151
#, fuzzy
msgid "You need to include the following modules to get RxJava2 support:"
msgstr "RxJava2のサポートを受けるためには、以下のモジュールを含める必要があります。"

#. type: delimited block -
#: upstream/_guides/context-propagation.adoc:174
#, no-wrap
msgid ""
"<dependencies>\n"
"    <!-- Automatic context propagation for RxJava2 -->\n"
"    <dependency>\n"
"        <groupId>io.smallrye</groupId>\n"
"        <artifactId>smallrye-context-propagation-propagators-rxjava2</"
"artifactId>\n"
"    </dependency>\n"
"    <!-- \n"
"    Required if you want transactions extended to the end of methods "
"returning\n"
"    an RxJava2 type.\n"
"     -->\n"
"    <dependency>\n"
"        <groupId>io.smallrye.reactive</groupId>\n"
"        <artifactId>smallrye-reactive-converter-rxjava2</artifactId>\n"
"    </dependency>\n"
"    <!-- Required if you return RxJava2 types from your REST endpoints -->\n"
"    <dependency>\n"
"        <groupId>org.jboss.resteasy</groupId>\n"
"        <artifactId>resteasy-rxjava2</artifactId>\n"
"    </dependency>\n"
"</dependencies>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/context-propagation.adoc:176
#, no-wrap, fuzzy
msgid "Context Propagation for CDI"
msgstr "CDIのためのコンテキスト伝搬"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:180
#, fuzzy
msgid ""
"In terms of CDI, `@RequestScoped`, `@ApplicationScoped` and `@Singleton` "
"beans get propagated and are available in other threads.  `@Dependent` beans "
"as well as any custom scoped beans cannot be automatically propagated via "
"CDI Context Propagation."
msgstr ""
"CDI の観点からは、 `@RequestScoped`, `@ApplicationScoped`, `@Singleton`, "
"ビーンは伝播され、他のスレッドで利用可能です。 `@Dependent` ビーンやカスタムスコープされたビーンは、CDI "
"コンテキスト伝播を介して自動的に伝播されることはありません。"

#. type: Plain text
#: upstream/_guides/context-propagation.adoc:187
#, fuzzy
msgid ""
"`@ApplicationScoped` and `@Singleton` beans are always active scopes and as "
"such are easy to deal with - context propagation tasks can work with those "
"beans so long as the CDI container is running.  However, `@RequestScoped` "
"beans are a different story. They are only active for a short period of time "
"which can be bound either to HTTP request or some other request/task when "
"manually activated/deactivated.  In this case user must be aware that once "
"the original thread gets to an end of a request, it will terminate the "
"context, calling `@PreDestroy` on those beans and then clearing them from "
"the context.  Subsequent attempts to access those beans from other threads "
"can result in unexpected behaviour.  It is therefore recommended to make "
"sure all tasks using request scoped beans via context propagation are "
"performed in such a manner that they don't outlive the original request "
"duration."
msgstr ""
"`@ApplicationScoped` と `@Singleton` のビーンズは常にアクティブなスコープであり、そのため対処が簡単です - "
"コンテキスト伝播タスクは、CDI コンテナが動作している限り、これらのビーンズで動作します。しかし、 `@RequestScoped` "
"ビーンズは話が違います。手動で有効化/無効化すると、HTTP リクエストや他のリクエスト/"
"タスクにバインドされます。この場合、元のスレッドがリクエストの終了に到達すると、コンテキストを終了し、それらのビーンズで `@PreDestroy` "
"を呼び出し、コンテキストからクリアされることに注意しなければなりません。その後、他のスレッドからこれらのビーンズにアクセスしようとすると、予期せぬ動作をすることがあります。したがって、コンテキストの伝播を介してリクエストスコープされたビーンズを使用するすべてのタスクは、元のリクエストの持続時間を超えないような方法で実行されることを確認することが推奨されます。"

#. type: delimited block =
#: upstream/_guides/context-propagation.adoc:192
#, fuzzy
msgid ""
"Due to the above described behavior, it is recommended to avoid using "
"`@PreDestroy` on `@RequestScoped` beans when working with Context "
"Propagation in CDI."
msgstr ""
"上記で説明した動作のため、CDI で Context Propagation を使用する際には `@PreDestroy` を "
"`@RequestScoped` ビーンズで使用しないことをお勧めします。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-authorization.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Authorization of Web Endpoints"
msgstr "Quarkus - ウェブエンドポイントの認証"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:12
#, fuzzy
msgid ""
"Quarkus has an integrated pluggable web security layer. If security is "
"enabled all HTTP requests will have a permission check performed to make "
"sure they are allowed to continue."
msgstr ""
"Quarkusには、プラグイン可能なウェブセキュリティレイヤーが統合されています。セキュリティが有効になっている場合、すべてのHTTPリクエストは、継続が許可されているかどうかを確認するためのパーミッションチェックが実行されます。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:15
#, fuzzy
msgid ""
"Configuration authorization checks are executed before any annotation-based "
"authorization check is done, so both checks have to pass for a request to be "
"allowed."
msgstr ""
"設定認可チェックは、アノテーションベースの認可チェックが行われる前に実行されるので、リクエストが許可されるためには両方のチェックを通過しなければなりません。"

#. type: Title ==
#: upstream/_guides/security-authorization.adoc:16
#, no-wrap, fuzzy
msgid "Authorization using Configuration"
msgstr "設定を利用した認証"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:20
#, fuzzy
msgid ""
"The default implementation allows you to define permissions using config in "
"`application.properties`. An example config is shown below:"
msgstr ""
"デフォルトの実装では、 `application.properties` の config を使用してパーミッションを定義することができます。以下に "
"config の例を示します。"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:24
#, no-wrap
msgid ""
"quarkus.http.auth.policy.role-policy1.roles-allowed=user,admin               "
"       <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:27
#, no-wrap
msgid ""
"quarkus.http.auth.permission.roles1.paths=/roles-secured/*,/other/*,/api/*   "
"       <2>\n"
"quarkus.http.auth.permission.roles1.policy=role-policy1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:31
#, no-wrap
msgid ""
"quarkus.http.auth.permission.permit1.paths=/public/*                         "
"       <3>\n"
"quarkus.http.auth.permission.permit1.policy=permit\n"
"quarkus.http.auth.permission.permit1.methods=GET\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:34
#, no-wrap
msgid ""
"quarkus.http.auth.permission.deny1.paths=/forbidden                          "
"       <4>\n"
"quarkus.http.auth.permission.deny1.policy=deny\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:36
#, fuzzy
msgid ""
"This defines a role based policy that allows users with the `user` and "
"`admin` roles. This is referenced by later rules."
msgstr ""
"これは、 `user` と `admin` のロールを持つユーザーを許可するロールベースのポリシーを定義します。これは後のルールで参照されます。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:37
#, fuzzy
msgid ""
"This is a permission set that references the previously defined policy. "
"`roles1` is an arbitrary name, you can call the permission sets whatever you "
"want."
msgstr "`roles1` は任意の名前ですので、好きなようにパーミッションセットを呼び出すことができます。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:38
#, fuzzy
msgid ""
"This permission references the default `permit` built-in policy to allow "
"`GET` methods to `/public`. This is actually a no-op in this example, as "
"this request would have been allowed anyway."
msgstr ""
"このパーミッションはデフォルトの `permit` ビルトインポリシーを参照して、 `/public` への `GET` "
"メソッドを許可します。この例では、このリクエストはいずれにせよ許可されているはずなので、これは実際には実行されません。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:39
#, fuzzy
msgid ""
"This permission references the built-in `deny` policy for `/forbidden`. This "
"is an exact path match as it does not end with `*`."
msgstr ""
"このパーミッションは、 `/forbidden` のビルトイン `deny` ポリシーを参照します。これは `*` "
"で終わらないので、完全なパス一致です。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:43
#, fuzzy
msgid ""
"Permissions are defined in config using permission sets. These are "
"arbitrarily named permission grouping. Each permission set must specify a "
"policy that is used to control access. There are three built-in policies: "
"`deny`, `permit` and `authenticated`, which respectively permits all, denies "
"all and only allows authenticated users."
msgstr ""
"パーミッションはパーミッションセットを使用してconfigで定義されます。これらは任意の名前のパーミッショングループ化です。各パーミッションセットは、アクセスを制御するために使用されるポリシーを指定しなければなりません。 "
"`deny` 、 `permit` 、 `authenticated` の 3 "
"つのビルトインポリシーがあり、それぞれすべてを許可し、すべてを拒否し、認証されたユーザーのみを許可します。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:46
#, fuzzy
msgid ""
"It is also possible to define role based policies, as shown in the example. "
"These policies will only allow users with the specified roles to access the "
"resources."
msgstr ""
"例に示すように、ロールベースのポリシーを定義することも可能です。これらのポリシーは、指定されたロールを持つユーザーのみがリソースにアクセスできるようにします。"

#. type: Title ===
#: upstream/_guides/security-authorization.adoc:47
#, no-wrap, fuzzy
msgid "Matching on paths, methods"
msgstr "パス、メソッドのマッチング"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:51
#, fuzzy
msgid ""
"Permission sets can also specify paths and methods as a comma separated list."
" If a path ends with `*` then it is considered to be a wildcard match and "
"will match all sub paths, otherwise it is an exact match and will only match "
"that specific path:"
msgstr ""
"パーミッションセットでは、パスとメソッドをカンマ区切りのリストで指定することもできます。パスの末尾が `*` "
"である場合はワイルドカードマッチとみなされ、すべてのサブパスにマッチしますが、そうでない場合は完全一致となり、特定のパスにのみマッチします。"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:57
#, no-wrap
msgid ""
"quarkus.http.auth.permission.permit1.paths=/public/*,/css/*,/js/*,/robots."
"txt\n"
"quarkus.http.auth.permission.permit1.policy=permit\n"
"quarkus.http.auth.permission.permit1.methods=GET,HEAD\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-authorization.adoc:59
#, no-wrap, fuzzy
msgid "Matching path but not method"
msgstr "パスは一致するがメソッドは一致しない"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:63
#, fuzzy
msgid ""
"If a request would match one or more permission sets based on the path, but "
"does not match any due to method requirements then the request is rejected."
msgstr ""
"リクエストがパスに基づいて1つ以上のパーミッションセットにマッチするが、 メソッドの要件によりマッチしない場合、そのリクエストは拒否される。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:66
#, fuzzy
msgid ""
"Given the above permission set, `GET /public/foo` would match both the path "
"and method and thus be allowed, whereas `POST /public/foo` would match the "
"path but not the method and would thus be rejected."
msgstr ""
"上記のパーミッションセットを考えると、 `GET /public/foo` はパスとメソッドの両方にマッチするので許可されますが、 `POST /"
"public/foo` はパスにはマッチするがメソッドにはマッチしないので拒否されます。"

#. type: Title ===
#: upstream/_guides/security-authorization.adoc:67
#, no-wrap, fuzzy
msgid "Matching multiple paths: longest path wins"
msgstr "複数のパスのマッチング：一番長いパスの勝ち"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:71
#, fuzzy
msgid ""
"Matching is always done on a longest path wins basis, less specific "
"permission sets are not considered if a more specific one has been matched:"
msgstr ""
"マッチングは常に最長パスの勝ちに基づいて行われ、より特定のパーミッションセットがマッチしている場合には、より特定のパーミッションセットは考慮されません。"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:77
#: upstream/_guides/security-authorization.adoc:114
#, no-wrap
msgid ""
"quarkus.http.auth.permission.permit1.paths=/public/*\n"
"quarkus.http.auth.permission.permit1.policy=permit\n"
"quarkus.http.auth.permission.permit1.methods=GET,HEAD\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:80
#, no-wrap
msgid ""
"quarkus.http.auth.permission.deny1.paths=/public/forbidden-folder/*\n"
"quarkus.http.auth.permission.deny1.policy=deny\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:85
#, fuzzy
msgid ""
"Given the above permission set, `GET /public/forbidden-folder/foo` would "
"match both permission sets' paths, but because it matches the `deny1` "
"permission set's path on a longer match, `deny1` will be chosen and the "
"request will be rejected."
msgstr ""
"上記のパーミッションセットを考えると、 `GET /public/forbidden-folder/foo` "
"は両方のパーミッションセットのパスにマッチしますが、より長いマッチで `deny1` のパーミッションセットのパスにマッチするため、 `deny1` "
"が選択され、リクエストは拒否されます。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:87
#, fuzzy
msgid "[NOTE]"
msgstr ""

#. type: delimited block =
#: upstream/_guides/security-authorization.adoc:90
#, fuzzy
msgid ""
"Subpath permissions always win against the root path permissions as "
"explained above in the `deny1` versus `permit1` permission example.  Here is "
"another example showing a subpath permission allowing a public resource "
"access with the root path permission requiring the authorization:"
msgstr ""
"上記の `deny1` と `permit1` "
"のパーミッションの例で説明したように、サブパスパーミッションは常にルートパスパーミッションに対抗します。ここでは、サブパスパーミッションがパブリックリソースへのアクセスを許可し、ルートパスパーミッションが認可を必要としていることを示す別の例を示しています。"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:96
#, no-wrap
msgid ""
"quarkus.http.auth.policy.user-policy.roles-allowed=user\n"
"quarkus.http.auth.permission.roles.paths=/api/*\n"
"quarkus.http.auth.permission.roles.policy=user-policy\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:99
#, no-wrap
msgid ""
"quarkus.http.auth.permission.public.paths=/api/noauth/*\n"
"quarkus.http.auth.permission.public.policy=permit\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-authorization.adoc:102
#, no-wrap, fuzzy
msgid "Matching multiple paths: most specific method wins"
msgstr "複数のパスを一致させる：最も特定の方法が勝つ"

#. type: delimited block =
#: upstream/_guides/security-authorization.adoc:108
#, fuzzy
msgid ""
"If a path is registered with multiple permission sets then any permission "
"sets that specify a HTTP method will take precedence and permissions sets "
"without a method will not be considered (assuming of course the method "
"matches). In this instance, the permission sets without methods will only "
"come into effect if the request method does not match any of the sets with "
"method permissions."
msgstr ""
"パスが複数のパーミッションセットで登録されている場合、HTTP メソッドを指定するパーミッションセットが優先され、 "
"メソッドを持たないパーミッションセットは考慮されません "
"(もちろんメソッドがマッチすると仮定します)。この例では、メソッドを持たないパーミッションセットは、 "
"リクエストメソッドがメソッドパーミッションセットのどれにもマッチしない場合にのみ有効になります。"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:117
#, no-wrap
msgid ""
"quarkus.http.auth.permission.deny1.paths=/public/*\n"
"quarkus.http.auth.permission.deny1.policy=deny\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:123
#, fuzzy
msgid ""
"Given the above permission set, `GET /public/foo` would match both "
"permission sets' paths, but because it matches the `permit1` permission "
"set's explicit method, `permit1` will be chosen and the request will be "
"accepted. `PUT /public/foo` on the other hand, will not match the method "
"permissions of `permit1` and so `deny1` will be activated and reject the "
"request."
msgstr ""
"上記のパーミッションセットを考えると、 `GET /public/foo` は両方のパーミッションセットのパスにマッチしますが、 `permit1` "
"のパーミッションセットの明示的なメソッドにマッチするため、 `permit1` が選択され、リクエストが受け入れられます。一方、 `PUT /"
"public/foo` は `permit1` のメソッドパーミッションにマッチしないため、 `deny1` が有効化され、リクエストが拒否されます。"

#. type: Title ===
#: upstream/_guides/security-authorization.adoc:124
#, no-wrap, fuzzy
msgid "Matching multiple paths and methods: both win"
msgstr "複数のパスとメソッドのマッチング：両方の win"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:129
#, fuzzy
msgid ""
"If multiple permission sets specify the same path and method (or multiple "
"have no method) then both permissions have to allow access for the request "
"to proceed. Note that for this to happen both have to either have specified "
"the method, or have no method, method specific matches take precedence as "
"stated above:"
msgstr ""
"複数のパーミッションセットが同じパスとメソッドを指定している場合 "
"(あるいは複数のパーミッションセットがメソッドを持たない場合)、両方のパーミッションがリクエストを進めるためのアクセスを許可しなければなりません。これを実現するためには、両方ともメソッドを指定しているか、メソッドを持っていないかのどちらかでなければならないことに注意してください。"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:134
#, no-wrap
msgid ""
"quarkus.http.auth.policy.user-policy1.roles-allowed=user\n"
"quarkus.http.auth.policy.admin-policy1.roles-allowed=admin\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:137
#, no-wrap
msgid ""
"quarkus.http.auth.permission.roles1.paths=/api/*,/restricted/*\n"
"quarkus.http.auth.permission.roles1.policy=user-policy1\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:140
#, no-wrap
msgid ""
"quarkus.http.auth.permission.roles2.paths=/api/*,/admin/*\n"
"quarkus.http.auth.permission.roles2.policy=admin-policy1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:144
#, fuzzy
msgid ""
"Given the above permission set, `GET /api/foo` would match both permission "
"sets' paths, so would require both the `user` and `admin` roles."
msgstr ""
"上記のパーミッションセットを考えると、 `GET /api/foo` は両方のパーミッションセットのパスにマッチするので、 `user` と "
"`admin` の両方のロールが必要になります。"

#. type: Title ===
#: upstream/_guides/security-authorization.adoc:145
#, no-wrap, fuzzy
msgid "Configuration Properties to Deny access"
msgstr "アクセスを拒否する設定プロパティ"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:148
#, fuzzy
msgid ""
"There are two configuration settings that alter the RBAC Deny behavior:"
msgstr "RBAC Denyの動作を変更する2つの設定があります。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:151
#, fuzzy
msgid ""
"`quarkus.security.jaxrs.deny-unannotated-endpoints=true|false` - if set to "
"true, the access will be denied for all JAX-RS endpoints by default.  That "
"is if the security annotations do not define the access control. Defaults to "
"`false`."
msgstr ""
"`quarkus.security.jaxrs.deny-unannotated-endpoints=true|false` - true "
"に設定すると、デフォルトではすべての JAX-RS "
"エンドポイントに対してアクセスが拒否されます。つまり、セキュリティアノテーションでアクセス制御が定義されていない場合です。デフォルトは `false` "
"です。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:154
#, fuzzy
msgid ""
"`quarkus.security.deny-unannotated-members=true|false` - if set to true, the "
"access will be denied to all CDI methods and JAX-RS endpoints that do not "
"have security annotations but are defined in classes that contain methods "
"with security annotations. Defaults to `false`."
msgstr ""
"`quarkus.security.deny-unannotated-members=true|false` - true "
"に設定すると、セキュリティアノテーションを持たないが、セキュリティアノテーションを持つメソッドを含むクラスで定義されているすべての CDI "
"メソッドおよび JAX-RS エンドポイントへのアクセスが拒否されます。デフォルトは `false` です。"

#. type: Title ===
#: upstream/_guides/security-authorization.adoc:155
#, no-wrap, fuzzy
msgid "Disabling permissions "
msgstr "パーミッションを無効にする"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:158
#, fuzzy
msgid ""
"Permissions can be disabled at build time with an `enabled` property for "
"each declared permission, for example:"
msgstr "パーミッションは、ビルド時に `enabled` プロパティで宣言されたパーミッションごとに無効にすることができます。"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:165
#, no-wrap
msgid ""
"quarkus.http.auth.permission.permit1.enabled=false\n"
"quarkus.http.auth.permission.permit1.paths=/public/*,/css/*,/js/*,/robots."
"txt\n"
"quarkus.http.auth.permission.permit1.policy=permit\n"
"quarkus.http.auth.permission.permit1.methods=GET,HEAD\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:168
#, fuzzy
msgid ""
"and enabled at runtime with a system property or environment variable, for "
"example: `-Dquarkus.http.auth.permission.permit1.enabled=true`."
msgstr ""
"`-Dquarkus.http.auth.permission.permit1.enabled="
"true`で、実行時にシステム・プロパティや環境変数で有効にします。"

#. type: Title ==
#: upstream/_guides/security-authorization.adoc:170
#, no-wrap, fuzzy
msgid "Authorization using Annotations"
msgstr "アノテーションを使った認証"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:177
#, fuzzy
msgid ""
"Quarkus comes with built-in security to allow for Role-Based Access Control "
"(link:https://en.wikipedia.org/wiki/Role-based_access_control[RBAC])  based "
"on the common security annotations `@RolesAllowed`, `@DenyAll`, `@PermitAll` "
"on REST endpoints and CDI beans.  An example of an endpoint that makes use "
"of both JAX-RS and Common Security annotations to describe and secure its "
"endpoints is given in <<subject-example>>. Quarkus also provides the `io."
"quarkus.security.Authenticated` annotation that will permit any "
"authenticated user to access the resource (equivalent to "
"`@RolesAllowed(\"**\")`)."
msgstr ""
"Quarkusには、共通のセキュリティアノテーション `@RolesAllowed`, `@DenyAll`, `@PermitAll` "
"RESTエンドポイントとCDIビーンズに基づいた役割ベースのアクセス制御 link:https://en.wikipedia.org/wiki/Role-"
"based_access_control[（RBAC]）を可能にするためのビルトインセキュリティが搭載されています。JAX-RSとCommon "
"Securityアノテーションの両方を利用してエンドポイントを記述し、セキュリティを確保するエンドポイントの例は、 link:#subject-"
"example[[subject-example]]に記載されています。Quarkusはまた、認証済みのユーザーがリソースにアクセスすることを許可する "
"`io.quarkus.security.Authenticated` アノテーションも提供しています（ `@RolesAllowed(\"**\")` "
"と同等）。"

#. type: Block title
#: upstream/_guides/security-authorization.adoc:179
#, no-wrap, fuzzy
msgid "SubjectExposingResource Example"
msgstr "SubjectExposingResourceの例"

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:183
#, no-wrap
msgid "import java.security.Principal;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:191
#, no-wrap
msgid ""
"import javax.annotation.security.DenyAll;\n"
"import javax.annotation.security.PermitAll;\n"
"import javax.annotation.security.RolesAllowed;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.core.Context;\n"
"import javax.ws.rs.core.SecurityContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:194
#, no-wrap
msgid "@Path(\"subject\")\n"
"public class SubjectExposingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:203
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"secured\")\n"
"    @RolesAllowed(\"Tester\") <1>\n"
"    public String getSubjectSecured(@Context SecurityContext sec) {\n"
"        Principal user = sec.getUserPrincipal(); <2>\n"
"        String name = user != null ? user.getName() : \"anonymous\";\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:212
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"unsecured\")\n"
"    @PermitAll <3>\n"
"    public String getSubjectUnsecured(@Context SecurityContext sec) {\n"
"        Principal user = sec.getUserPrincipal(); <4>\n"
"        String name = user != null ? user.getName() : \"anonymous\";\n"
"        return name;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-authorization.adoc:222
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"denied\")\n"
"    @DenyAll <5>\n"
"    public String getSubjectDenied(@Context SecurityContext sec) {\n"
"        Principal user = sec.getUserPrincipal();\n"
"        String name = user != null ? user.getName() : \"anonymous\";\n"
"        return name;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:224
#, fuzzy
msgid ""
"This `/subject/secured` endpoint requires an authenticated user that has "
"been granted the role \"Tester\" through the use of the "
"`@RolesAllowed(\"Tester\")` annotation."
msgstr ""
"この `/subject/secured` エンドポイントには、 `@RolesAllowed(\"Tester\")` "
"アノテーションを使用して「Tester」という役割を付与された認証済みユーザが必要です。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:225
#, fuzzy
msgid ""
"The endpoint obtains the user principal from the JAX-RS `SecurityContext`. "
"This will be non-null for a secured endpoint."
msgstr ""
"エンドポイントは、JAX-RS `SecurityContext` からユーザー・プリンシパルを取得します。これは、保護されたエンドポイントの場合は非 "
"null になります。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:226
#, fuzzy
msgid ""
"The `/subject/unsecured` endpoint allows for unauthenticated access by "
"specifying the `@PermitAll` annotation."
msgstr ""
"`/subject/unsecured` エンドポイントでは、 `@PermitAll` "
"アノテーションを指定することで、認証されていないアクセスが可能になります。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:227
#, fuzzy
msgid ""
"This call to obtain the user principal will return null if the caller is "
"unauthenticated, non-null if the caller is authenticated."
msgstr ""
"ユーザプリンシパルを取得するためのこの呼び出しは、呼び出し元が認証されていない場合はnullを返し、呼び出し元が認証されている場合は非nullを返します。"

#. type: Plain text
#: upstream/_guides/security-authorization.adoc:228
#, fuzzy
msgid ""
"The `/subject/denied` endpoint disallows any access regardless of whether "
"the call is authenticated by specifying the `@DenyAll` annotation."
msgstr ""
"`/subject/denied` エンドポイントは、 `@DenyAll` "
"アノテーションを指定することで、呼が認証されているかどうかにかかわらず、あらゆるアクセスを禁止します。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi.adoc:6
#, no-wrap
msgid "Quarkus - Introduction to Contexts and Dependency Injection"
msgstr "Quarkus - コンテキストと依存性注入（CDI）の紹介"

#. type: Plain text
#: upstream/_guides/cdi.adoc:15
msgid ""
"In this guide we're going to describe the basic principles of the Quarkus "
"programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/"
"cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="
"\"_blank\"] specification."
msgstr ""
"このガイドでは、 http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and "
"Dependency Injection for Java 2.0, window="
"_blank]仕様に基づいたQuarkusプログラミングモデルの基本原理について説明します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:16
#, no-wrap
msgid "_Q: OK. Let's start simple. What is a bean?_"
msgstr "_Q：OK、簡単なことから始めましょう。Beanとは何ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:19
msgid ""
"A: Well, a bean is a _container-managed_ object that supports a set of basic "
"services, such as injection of dependencies, lifecycle callbacks and "
"interceptors."
msgstr ""
"A: そうですね、Beanは _コンテナ管理された_ "
"オブジェクトで、依存性の注入、ライフサイクルコールバック、インターセプターなどの基本的なサービスをサポートしています。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:20
#, no-wrap
msgid "_Q: Wait a minute. What does \"container-managed\" mean?_"
msgstr "_Q: ちょっと待ってください。コンテナ管理されている」とはどういう意味ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:26
msgid ""
"A: Simply put, you don't control the lifecycle of the object instance "
"directly.  Instead, you can affect the lifecycle through declarative means, "
"such as annotations, configuration, etc.  The container is the _environment_ "
"where your application runs.  It creates and destroys the instances of "
"beans, associates the instances with a designated context, and injects them "
"into other beans."
msgstr ""
"A: "
"簡単に言えば、オブジェクトインスタンスのライフサイクルを直接制御することはできません。その代わりに、アノテーションや設定などの宣言的な手段でライフサイクルに影響を与えることができます。コンテナはアプリケーションが動作する "
"_環境_ "
"です。コンテナは、Beanのインスタンスを作成したり破棄したり、指定されたコンテキストにインスタンスを関連付けたり、他のBeanズに注入したりします。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:27
#, no-wrap
msgid "_Q: What is it good for?_"
msgstr "_Ｑ：何に効くのですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:30
msgid ""
"A: An application developer can focus on the business logic rather than "
"finding out \"where and how\" to obtain a fully initialized component with "
"all of its dependencies."
msgstr ""
"A: "
"アプリケーション開発者は、すべての依存関係を持つ完全に初期化されたコンポーネントを取得するため、「どこでどのように」よりも、ビジネスロジックに集中することができます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:32
msgid ""
"You've probably heard of the _inversion of control_ (IoC) programming "
"principle. Dependency injection is one of the implementation techniques of "
"IoC."
msgstr ""
"_制御の反転_ （Inversion of Control, IoC "
"）というプログラミングの原理を聞いたことがあると思います。依存性注入はIoCの実装技術の一つです。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:33
#, no-wrap
msgid "_Q: What does a bean look like?_"
msgstr "_Q: Beanはどんな形をしていますか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:37
msgid ""
"A: There are several kinds of beans.  The most common ones are class-based "
"beans:"
msgstr "A: Beanにはいくつかの種類があります。最も一般的なのは、クラスベースのBeanです。"

#. type: Block title
#: upstream/_guides/cdi.adoc:38
#, no-wrap
msgid "Simple Bean Example"
msgstr "シンプルなBeanの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:44
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.enterprise.context.ApplicationScoped;\n"
"import org.eclipse.microprofile.metrics.annotation.Counted;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:47
#, no-wrap
msgid "@ApplicationScoped <1>\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:50
#, no-wrap
msgid "    @Inject\n"
"    Dictionary dictionary; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:56
#, no-wrap
msgid ""
"    @Counted  <3>\n"
"    String translate(String sentence) { \n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:58
msgid ""
"This is a scope annotation. It tells the container which context to "
"associate the bean instance with. In this particular case, a *single bean "
"instance* is created for the application and used by all other beans that "
"inject `Translator`."
msgstr ""
"これはスコープアノテーションです。これはコンテナに、Beanのインスタンスをどのコンテキストに関連付けるかを伝えます。この特定のケースでは、 "
"*単一のBeanインスタンス* がアプリケーション用に作成され、 `Translator`の注入を行う他の全てのBeanによって使用されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:59
msgid ""
"This is a field injection point. It tells the container that `Translator` "
"depends on the `Dictionary` bean. If there is no matching bean the build "
"fails."
msgstr ""
"これはフィールド注入ポイントです。 `Translator`  が `Dictionary`  "
"Beanに依存していることをコンテナに伝えます。マッチするBeanがない場合、ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:60
msgid ""
"This is an interceptor binding annotation. In this case, the annotation "
"comes from the MicroProfile Metrics. The relevant interceptor intercepts the "
"invocation and updates the relevant metrics. We will talk about "
"<<interceptors,interceptors>> later."
msgstr ""
"これはインターセプター結合アノテーションです。この場合、アノテーションは MicroProfile Metrics "
"から来ています。関連するインターセプターは呼び出しをインターセプトし、関連するメトリクスを更新します。 "
"<<interceptors,インターセプター>>については後述します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:61
#, no-wrap
msgid ""
"_Q: Nice. How does the dependency resolution work? I see no names or "
"identifiers._"
msgstr "_Q: いいですね。依存関係の解決方法を教えてください。名前や識別子が見当たらないのですが、どうすればいいですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:70
msgid ""
"A: That's a good question.  In CDI the process of matching a bean to an "
"injection point is *type-safe*.  Each bean declares a set of bean types.  In "
"our example above, the `Translator` bean has two bean types: `Translator` "
"and `java.lang.Object`.  Subsequently, a bean is assignable to an injection "
"point if the bean has a bean type that matches the _required type_ and has "
"all the _required qualifiers_.  We'll talk about qualifiers later.  For now, "
"it's enough to know that the bean above is assignable to an injection point "
"of type `Translator` and `java.lang.Object`."
msgstr ""
"A: いい質問ですね。CDIでは、Beanをインジェクションポイントにマッチングするプロセスは *タイプセーフ* "
"です。各Beanは、Beanタイプのセットを宣言します。上の例では、 `Translator`  Beanには、 `Translator`  と "
"`java.lang.Object`  の 2 つのBeanタイプがあります。その後、Beanが _必要な型_ にマッチするBean型を持ち、 "
"_必要な_ すべての _修飾子を_ "
"持っている場合、Beanはインジェクションポイントに代入可能です。この後、修飾子について説明します。今のところ、上記のBeanが "
"`Translator`  と `java.lang.Object`  のタイプのインジェクションポイントに代入可能であることを知っていれば十分です。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:71
#, no-wrap
msgid ""
"_Q: Hm, wait a minute. What happens if multiple beans declare the same "
"type?_"
msgstr "_Q: ふむ、ちょっと待ってください。複数の豆が同じ型を宣言した場合はどうなりますか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:77
msgid ""
"A: There is a simple rule: *exactly one bean must be assignable to an "
"injection point, otherwise the build fails*.  If none is assignable the "
"build fails with `UnsatisfiedResolutionException`.  If multiple are "
"assignable the build fails with `AmbiguousResolutionException`.  This is "
"very useful because your application fails fast whenever the container is "
"not able to find an unambiguous dependency for any injection point."
msgstr ""
"A: シンプルなルールがあります: "
"*1つのインジェクションポイントに正確に1つのBeanが割り当て可能でなければならない、そうでなければビルドは失敗します* "
"。割り当て可能なBeanが1つもない場合、 `UnsatisfiedResolutionException`  "
"でビルドは失敗します。複数のBeanが割り当て可能な場合、ビルドは `AmbiguousResolutionException`  "
"で失敗します。これは、コンテナがどのインジェクションポイントに対しても明確な依存関係を見つけることができない場合に、アプリケーションが高速に失敗するので、非常に便利です。"

#. type: delimited block =
#: upstream/_guides/cdi.adoc:81
msgid ""
"Your can use programmatic lookup via `javax.enterprise.inject.Instance` to "
"resolve ambiguities at runtime and even iterate over all beans implementing "
"a given type:"
msgstr ""
"`javax.enterprise.inject.Instance`  "
"を通じてプログラム的なルックアップを使用して、実行時に曖昧さを解決したり、指定された型を実装しているすべてのBeanを反復処理したりすることができます："

#. type: delimited block -
#: upstream/_guides/cdi.adoc:85
#, no-wrap
msgid "public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:88
#, no-wrap
msgid "    @Inject\n"
"    Instance<Dictionary> dictionaries; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:95
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      for (Dictionary dict : dictionaries) { <2>\n"
"         // ...\n"
"      }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:97
msgid ""
"This injection point will not result in an ambiguous dependency even if "
"there are multiple beans that implement the `Dictionary` type."
msgstr "このインジェクションポイントは、 `Dictionary`  型を実装した複数のBeanがあっても、曖昧な依存関係にはなりません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:98
msgid "`javax.enterprise.inject.Instance` extends `Iterable`."
msgstr "`javax.enterprise.inject.Instance` は `Iterable` を継承します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:100
#, no-wrap
msgid "_Q: Can I use setter and constructor injection?_"
msgstr "_Q: セッターやコンストラクタのインジェクションは使えますか？_"

#. type: delimited block =
#: upstream/_guides/cdi.adoc:105
msgid ""
"A: Yes, you can.  In fact, in CDI the \"setter injection\" is superseded by "
"more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#initializer_methods[initializer methods, window=\"_blank\"].  "
"Initializers may accept multiple parameters and don't have to follow the "
"JavaBean naming conventions."
msgstr ""
"A: はい、できます。実際、CDIでは「セッター注入」は、より強力な link:https://docs.jboss.org/cdi/spec/2.0/"
"cdi-spec.html#initializer_methods[イニシャライザメソッド, window="
"_blank]に取って代わられています。イニシャライザは複数のパラメータを受け入れることができ、JavaBeanの命名規則に従う必要はありません。"

#. type: Block title
#: upstream/_guides/cdi.adoc:106
#, no-wrap
msgid "Initialized and Constructor Injection Example"
msgstr "初期化とコンストラクタのインジェクション例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:111 upstream/_guides/cdi.adoc:306
#, no-wrap
msgid "@ApplicationScoped\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:113
#, no-wrap
msgid "    private final TranslatorHelper helper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:117
#, no-wrap
msgid ""
"    Translator(TranslatorHelper helper) { <1>\n"
"       this.helper = helper;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:123
#, no-wrap
msgid ""
"    @Inject <2>\n"
"    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n"
"      / ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:128
msgid ""
"This is a constructor injection.  In fact, this code would not work in "
"regular CDI implementations where a bean with a normal scope must always "
"declare a no-args constructor and the bean constructor must be annotated "
"with `@Inject`.  However, in Quarkus we detect the absence of no-args "
"constructor and \"add\" it directly in the bytecode.  It's also not "
"necessary to add `@Inject` if there is only one constructor present."
msgstr ""
"これはコンストラクタのインジェクションです。実際には、このコードは通常のCDI実装では動作しません。通常のスコープを持つBeanは常にno-"
"argsコンストラクタを宣言しなければならず、Beanのコンストラクタは `@Inject`  "
"でアノテーションされなければなりません。しかし、Quarkusでは、no-"
"argsコンストラクタが存在しないことを検出し、バイトコードに直接「追加」します。また、コンストラクタが1つしかない場合は、 `@Inject`  "
"を追加する必要はありません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:129
msgid "An initializer method must be annotated with `@Inject`."
msgstr "イニシャライザメソッドには `@Inject`  をアノテーションしなければなりません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:130
msgid ""
"An initializer may accept multiple parameters - each one is an injection "
"point."
msgstr "イニシャライザは複数のパラメータを受け付けることができ、それぞれがインジェクションポイントとなります。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:131
#, no-wrap
msgid "_Q: You talked about some qualifiers?_"
msgstr "_Q：修飾子の話もありましたね。_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:136
msgid ""
"A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, "
"window=\"_blank\"] are annotations that help the container to distinguish "
"beans that implement the same type.  As we already said a bean is assignable "
"to an injection point if it has all the required qualifiers.  If you declare "
"no qualifier at an injection point the `@Default` qualifier is assumed."
msgstr ""
"A link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[: 修飾子, "
"window="
"_blank]は、コンテナが同じ型を実装したBeanを区別するのに役立つアノテーションです。すでに述べたように、Beanは必要な修飾子をすべて持っていれば、インジェクションポイントに割り当てることができます。インジェクションポイントで修飾子を宣言しない場合は、 "
"`@Default`  の修飾子が想定されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:138
msgid ""
"A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and "
"annotated with the `@javax.inject.Qualifier` meta-annotation:"
msgstr ""
"Qualifier型は、 `@Retention(RUNTIME)`  として定義された Java アノテーションで、 `@javax.inject."
"Qualifier`  メタアノテーションでアノテーションされています。"

#. type: Block title
#: upstream/_guides/cdi.adoc:139
#, no-wrap
msgid "Qualifier Example"
msgstr "修飾子の例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:146
#, no-wrap
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface Superior {}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:149
msgid ""
"The qualifiers of a bean are declared by annotating the bean class or "
"producer method or field with the qualifier types:"
msgstr "Beanの修飾子は、Beanクラスやプロデューサのメソッドやフィールドに修飾子タイプをアノテーションすることで宣言されます。"

#. type: Block title
#: upstream/_guides/cdi.adoc:150
#, no-wrap
msgid "Bean With Custom Qualifier Example"
msgstr "カスタム修飾子を持つ Bean の例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:156
#, no-wrap
msgid ""
"@Superior <1>\n"
"@ApplicationScoped\n"
"public class SuperiorTranslator extends Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:161 upstream/_guides/cdi.adoc:210
#, no-wrap
msgid "    String translate(String sentence) { \n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:163
msgid ""
"`@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#defining_qualifier_types[qualifier annotation, window=\"_blank\"]."
msgstr ""
"`@Superior`  は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#defining_qualifier_types[修飾子アノテーション, window=_blank]です。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:167
msgid ""
"This bean would be assignable to `@Inject @Superior Translator` and `@Inject "
"@Superior SuperiorTranslator` but not to `@Inject Translator`.  The reason "
"is that `@Inject Translator` is automatically transformed to `@Inject "
"@Default Translator` during typesafe resolution.  And since our "
"`SuperiorTranslator` does not declare `@Default` only the original "
"`Translator` bean is assignable."
msgstr ""
"このBeanは `@Inject @Superior Translator`  と `@Inject @Superior "
"SuperiorTranslator`  には割り当てられますが、 `@Inject Translator`  には割り当てられません。その理由は、 "
"`@Inject Translator`  はタイプセーフ解決の際に自動的に `@Inject @Default Translator`  "
"に変換されるからです。また、私たちの `SuperiorTranslator`  は `@Default`  を宣言していないので、元の "
"`Translator`  Beanだけが代入可能です。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:168
#, no-wrap
msgid "_Q: Looks good. What is the bean scope?_"
msgstr "_Ｑ：良さそうですね。Beanスコープとは何ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:171
msgid ""
"The scope of a bean determines the lifecycle of its instances, i.e. when and "
"where an instance should be created and destroyed."
msgstr "Beanのスコープはインスタンスのライフサイクルを決定します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:173
msgid "Every bean has exactly one scope."
msgstr "すべての豆は、正確に1つのスコープを持っています。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:174
#, no-wrap
msgid "_Q: What scopes can I actually use in my Quarkus application?_"
msgstr "_Q: Quarkusアプリケーションで実際に使用できるスコープは何ですか？_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:177
msgid ""
"A: You can use all the built-in scopes mentioned by the specification except "
"for `javax.enterprise.context.ConversationScoped`."
msgstr ""
"A: `javax.enterprise.context.ConversationScoped`  "
"を除いて、仕様書に記載されているすべての組み込みスコープを使用できます。"

#. ----------------------
#. type: Table
#: upstream/_guides/cdi.adoc:187
#, no-wrap
msgid ""
"|Annotation   |Description   \n"
"|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is "
"used for the application and shared among all injection points. The instance "
"is created lazily, i.e. once a method is invoked upon the <<client_proxies, "
"client proxy>>. \n"
"|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no "
"client proxy is used. The instance is created when an injection point that "
"resolves to a @Singleton bean is being injected.\n"
"|`@javax.enterprise.context.RequestScoped`   | The bean instance is "
"associated with the current _request_ (usually an HTTP request). \n"
"|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. The "
"instances are not shared and every injection point spawns a new instance of "
"the dependent bean. The lifecycle of dependent bean is bound to the bean "
"injecting it - it will be created and destroyed along with the bean "
"injecting it.\n"
"|`@javax.enterprise.context.SessionScoped`   | This scope is backed by a "
"`javax.servlet.http.HttpSession` object. It's only available if the `quarkus-"
"undertow` extension is used.\n"
msgstr ""
"|Annotation   |Description   \n"
"|`@javax.enterprise.context.ApplicationScoped`   | "
"単一のBeanインスタンスがアプリケーションに使用され、すべてのインジェクションポイント間で共有されます。インスタンスは遅延して作成されます。つまり、<<client_proxies, "
"client proxy>>でメソッドが呼び出されると作成されます。\n"
"|`@javax.inject.Singleton`   | `@ApplicationScoped` "
"とクライアントプロキシが使用されないことを除いて、同じです。インスタンスは、@SingletonBeanに解決される注入ポイントが注入されているときに作成されます。\n"
"|`@javax.enterprise.context.RequestScoped`   | Beanインスタンスは現在の _リクエスト_ "
"と関連付けられます（通常HTTPリクエスト）。 \n"
"|`@javax.enterprise.context.Dependent`   | "
"これは疑似スコープです。インスタンスは共有されず、すべてのインジェクションポイントが依存Beanの新しいインスタンスを生成します。依存Beanのライフサイクルは、それを注入するBeanにバインドされています。これは、それを注入するBeanとともに作成および破棄されます。\n"
"|`@javax.enterprise.context.SessionScoped`   | このスコープは `javax.servlet.http."
"HttpSession` オブジェクトに支えられています。 `quarkus-undertow` エクステンションが使用されている場合のみ有効です。\n"

#. type: Plain text
#: upstream/_guides/cdi.adoc:190
msgid ""
"There can be other custom scopes provided by Quarkus extensions. For "
"example, `quarkus-narayana-jta` provides `javax.transaction."
"TransactionScoped`."
msgstr ""
"Quarkusの拡張機能によって提供される他のカスタムスコープもあります。例えば、 `quarkus-narayana-jta` は `javax."
"transaction.TransactionScoped` を提供します。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:192
#, no-wrap
msgid "_Q: I don't understand the concept of client proxies._"
msgstr "_Q: クライアントプロキシの概念がわかりません。_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:197
msgid ""
"Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#client_proxies[client proxies, window=\"_blank\"] could be hard to "
"grasp but they provide some useful functionality.  A client proxy is "
"basically an object that delegates all method invocations to a target bean "
"instance.  It's a container construct that implements `io.quarkus.arc."
"ClientProxy` and extends the bean class."
msgstr ""
"実際、 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#client_proxies[クライアントプロキシ, window="
"_blank]は理解するのが難しいかもしれませんが、いくつかの有用な機能を提供します。クライアントプロキシは基本的に、すべてのメソッド呼び出しをターゲットのBeanインスタンスに委譲するオブジェクトです。これは "
"`io.quarkus.arc.ClientProxy`  を実装し、Bean クラスを拡張したコンテナ構造体です。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:199
msgid ""
"Client proxies only delegate method invocations. So never read or write a "
"field of a normal scoped bean, otherwise you will work with non-contextual "
"or stale data."
msgstr ""
"クライアントプロキシはメソッドの呼び出しをデリゲートするだけです。そのため、通常のスコープされたBeanのフィールドを読み書きしてはいけません。"

#. type: Block title
#: upstream/_guides/cdi.adoc:200
#, no-wrap
msgid "Generated Client Proxy Example"
msgstr "生成されたクライアントプロキシの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:205
#, no-wrap
msgid "@ApplicationScoped\n"
"class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:213
#, no-wrap
msgid ""
"// The client proxy class is generated and looks like...\n"
"class Translator_ClientProxy extends Translator { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:221
#, no-wrap
msgid ""
"    String translate(String sentence) { \n"
"      // Find the correct translator instance...\n"
"      Translator translator = "
"getTranslatorInstanceFromTheApplicationContext();\n"
"      // And delegate the method invocation...\n"
"      return translator.translate(sentence);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:223
msgid ""
"The `Translator_ClientProxy` instance is always injected instead of a direct "
"reference to a https://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html#contextual_instance[contextual instance, window=\"_blank\"] of the "
"`Translator` bean."
msgstr ""
"`Translator_ClientProxy`  インスタンスは、 `Translator`  Beanの link:https://docs."
"jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[コンテキストインスタンス, "
"window=_blank]への直接参照の代わりに、常に注入されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:225
msgid "Client proxies allow for:"
msgstr "クライアントプロキシは、以下のことを可能にします。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:227
msgid ""
"Lazy instantiation - the instance is created once a method is invoked upon "
"the proxy."
msgstr "遅延インスタンス化 - メソッドがプロキシに呼び出されるとインスタンスが生成されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:228
msgid ""
"Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" "
"scope; i.e. you can inject a `@RequestScoped` bean into an "
"`@ApplicationScoped` bean."
msgstr ""
"「狭い」スコープのBeanを「広い」スコープのBeanに注入する機能、すなわち、 `@RequestScoped`  Beanを "
"`@ApplicationScoped`  Beanに注入することができます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:229
msgid ""
"Circular dependencies in the dependency graph. Having circular dependencies "
"is often an indication that a redesign should be considered, but sometimes "
"it's inevitable."
msgstr ""
"依存関係グラフの円形の依存関係。循環的な依存関係を持つことは、しばしば再設計を検討すべきであることを示していますが、時には避けられないこともあります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:230
msgid ""
"In rare cases it's practical to destroy the beans manually. A direct "
"injected reference would lead to a stale bean instance."
msgstr "まれなケースでは、手動でBeanを破棄するのが現実的です。直接参照を注入すると、古くなったBeanのインスタンスになってしまいます。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:232
#, no-wrap
msgid "_Q: OK. You said that there are several kinds of beans?_"
msgstr "_Q: なるほど、Beanは何種類かあるということですね。_"

#. type: Plain text
#: upstream/_guides/cdi.adoc:235
msgid "A: Yes. In general, we distinguish:"
msgstr "A: はい。一般的には区別しています。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:237
msgid "Class beans"
msgstr "クラスBean"

#. type: Plain text
#: upstream/_guides/cdi.adoc:238
msgid "Producer methods"
msgstr "プロデューサーメソッド"

#. type: Plain text
#: upstream/_guides/cdi.adoc:239
msgid "Producer fields"
msgstr "プロデューサーフィールド"

#. type: Plain text
#: upstream/_guides/cdi.adoc:242
msgid ""
"Synthetic beans are usually provided by extensions. Therefore, we are not "
"going to cover them in this guide."
msgstr "合成Beanは通常、エクステンションによって提供されます。そのため、このガイドではそれらを取り上げません。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:245
msgid ""
"Producer methods and fields are useful if you need additional control over "
"instantiation of a bean.  They are also useful when integrating third-party "
"libraries where you don't control the class source and may not add "
"additional annotations etc."
msgstr ""
"プロデューサ・メソッドとフィールドは、Beanのインスタンス化を追加で制御する必要がある場合に便利です。また、サードパーティのライブラリを統合する際に、クラスソースを制御できず、追加のアノテーションなどを追加できない場合にも便利です。"

#. type: Block title
#: upstream/_guides/cdi.adoc:246
#, no-wrap
msgid "Producers Example"
msgstr "プロデューサーの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:251
#, no-wrap
msgid "@ApplicationScoped\n"
"public class Producers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:254
#, no-wrap
msgid "    @Produces <1>\n"
"    double pi = Math.PI; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:264
#, no-wrap
msgid ""
"    @Produces <3>\n"
"    List<String> names() {\n"
"       List<String> names = new ArrayList<>();\n"
"       names.add(\"Andy\");\n"
"       names.add(\"Adalbert\");\n"
"       names.add(\"Joachim\");\n"
"       return names; <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:267
#, no-wrap
msgid "@ApplicationScoped\n"
"public class Consumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:270
#, no-wrap
msgid "   @Inject\n"
"   double pi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:273
#, no-wrap
msgid "   @Inject\n"
"   List<String> names;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:276
#, no-wrap
msgid "   // ...   \n"
"} \n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:281
msgid ""
"The container analyses the field annotations to build a bean metadata.  The "
"_type_ is used to build the set of bean types.  In this case, it will be "
"`double` and `java.lang.Object`.  No scope annotation is declared and so "
"it's defaulted to `@Dependent`."
msgstr ""
"コンテナは，フィールドアノテーションを分析して，Beanのメタデータを構築します。 _型_ "
"は，Beanの型の集合を構築するために使用されます。この場合、 `double`  と `java.lang.Object` ."
"スコープアノテーションは宣言されていないので、デフォルトは `@Dependent` になります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:282
msgid "The container will read this field when creating the bean instance."
msgstr "コンテナは、Beanのインスタンスを作成するときにこのフィールドを読みます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:286
msgid ""
"The container analyses the method annotations to build a bean metadata.  The "
"_return type_ is used to build the set of bean types.  In this case, it will "
"be `List<String>`, `Collection<String>`, `Iterable<String>` and `java.lang."
"Object`.  No scope annotation is declared and so it's defaulted to "
"`@Dependent`."
msgstr ""
"コンテナは，メソッドのアノテーションを解析して，Beanのメタデータを構築します。戻り値の _型_ "
"は、Bean型のセットを構築するために使用されます。この場合、 `List<String>` と `Collection<String>`、 "
"`Iterable<String>`、 `java.lang.Object` となります。スコープアノテーションは宣言されていないので、デフォルトは "
"`@Dependent`  となります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:287
msgid "The container will call this method when creating the bean instance."
msgstr "コンテナは、Beanのインスタンスを作成する際にこのメソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:291
msgid ""
"There's more about producers.  You can declare qualifiers, inject "
"dependencies into the producer methods parameters, etc.  You can read more "
"about producers for example in the https://docs.jboss.org/weld/reference/"
"latest/en-US/html/producermethods.html[Weld docs, window=\"_blank\"]."
msgstr ""
"プロデューサーについては他にもあります。修飾子を宣言したり、プロデューサーメソッドのパラメータに依存性を注入したりすることができます。プロデューサについては、例えば "
"link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods."
"html[Weld, window=_blank] のドキュメントを参照してください。"

#. type: Title ==
#: upstream/_guides/cdi.adoc:292
#, no-wrap
msgid "_Q: OK, injection looks cool. What other services are provided?_"
msgstr "_Q: OK、インジェクションはかっこいいですね。他にはどんなサービスがありますか？_"

#. type: Title ===
#: upstream/_guides/cdi.adoc:294
#, no-wrap
msgid "Lifecycle Callbacks"
msgstr "ライフサイクルコールバック"

#. type: Plain text
#: upstream/_guides/cdi.adoc:297
msgid ""
"A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` "
"callbacks:"
msgstr ""
"Beanクラスは、ライフサイクル `@PostConstruct`  と `@PreDestroy`  コールバックを宣言することができます。"

#. type: Block title
#: upstream/_guides/cdi.adoc:298
#, no-wrap
msgid "Lifecycle Callbacks Example"
msgstr "ライフサイクルコールバックの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:303
#, no-wrap
msgid ""
"import javax.annotation.PostConstruct;\n"
"import javax.annotation.PreDestroy;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:311
#, no-wrap
msgid "    @PostConstruct <1>\n"
"    void init() {\n"
"       // ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:317
#, no-wrap
msgid "    @PreDestroy <2>\n"
"    void destroy() {\n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:319
msgid ""
"This callback is invoked before the bean instance is put into service. It is "
"safe to perform some initialization here."
msgstr "このコールバックは、Beanインスタンスがサービスに投入される前に呼び出されます。ここでいくつかの初期化を行うのが安全です。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:320
msgid ""
"This callback is invoked before the bean instance is destroyed. It is safe "
"to perform some cleanup tasks here."
msgstr "このコールバックは、Beanインスタンスが破棄される前に呼び出されます。ここでいくつかのクリーンアップタスクを実行しても安全です。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:322
msgid ""
"It's a good practice to keep the logic in the callbacks \"without side "
"effects\", i.e. you should avoid calling other beans inside the callbacks."
msgstr "コールバック内のロジックを「副作用なし」に保つこと、つまり、コールバック内で他のBeanを呼び出すことは避けるべきです。"

#. type: Title ===
#: upstream/_guides/cdi.adoc:324
#, no-wrap
msgid "Interceptors"
msgstr "インターセプター"

#. type: Plain text
#: upstream/_guides/cdi.adoc:328
msgid ""
"Interceptors are used to separate cross-cutting concerns from business logic."
"  There is a separate specification - Java Interceptors - that defines the "
"basic programming model and semantics."
msgstr ""
"インターセプターは、横断的な問題をビジネス・ロジックから分離するために使用されます。基本的なプログラミングモデルとセマンティクスを定義した Java "
"Interceptors という別の仕様があります。"

#. type: Block title
#: upstream/_guides/cdi.adoc:329
#, no-wrap
msgid "Simple Interceptor Example"
msgstr "シンプルなインターセプターの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:334
#, no-wrap
msgid ""
"import javax.interceptor.Interceptor;\n"
"import javax.annotation.Priority;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:339
#, no-wrap
msgid ""
"@Logged <1>\n"
"@Priority(2020) <2>\n"
"@Interceptor <3>\n"
"public class LoggingInterceptor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:342
#, no-wrap
msgid "   @Inject <4>\n"
"   Logger logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:350
#, no-wrap
msgid ""
"   @AroundInvoke <5>\n"
"   Object logInvocation(InvocationContext context) {\n"
"      // ...log before\n"
"      Object ret = context.proceed(); <6>\n"
"      // ...log after\n"
"      return ret;\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:354
msgid ""
"This is an interceptor binding annotation that is used to bind our "
"interceptor to a bean. Simply annotate a bean class with `@Logged`."
msgstr ""
"これは、インターセプターをBeanにバインドするために使用されるインターセプターバインディングアノテーションです。Beanクラスに `@Logged`  "
"をアノテーションします。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:355
msgid ""
"`Priority` enables the interceptor and affects the interceptor ordering. "
"Interceptors with smaller priority values are called first."
msgstr ""
"`Priority`  はインターセプターを有効にし、インターセプターの順序に影響を与えます。優先度の値が小さいインターセプターが最初に呼び出されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:356
msgid "Marks an interceptor component."
msgstr "インターセプターコンポーネントをマークします。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:357
msgid "An interceptor instance may be the target of dependency injection."
msgstr "インターセプターインスタンスは、依存性注入の対象となる場合があります。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:358
msgid "`AroundInvoke` denotes a method that interposes on business methods."
msgstr "`AroundInvoke`  とは、ビジネスの方法に口出しする方法を指します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:359
msgid ""
"Proceed to the next interceptor in the interceptor chain or invoke the "
"intercepted business method."
msgstr "インターセプターチェーンの次のインターセプターに進むか、インターセプターされたビジネスメソッドを呼び出します。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:361
msgid ""
"Instances of interceptors are dependent objects of the bean instance they "
"intercept, i.e. a new interceptor instance is created for each intercepted "
"bean."
msgstr "インターセプタのインスタンスは、インターセプトするBeanのインスタンスに依存するオブジェクトです。"

#. type: Title ===
#: upstream/_guides/cdi.adoc:362
#, no-wrap
msgid "Events and Observers"
msgstr "イベントとオブザーバー"

#. type: Plain text
#: upstream/_guides/cdi.adoc:367
msgid ""
"Beans may also produce and consume events to interact in a completely "
"decoupled fashion.  Any Java object can serve as an event payload.  The "
"optional qualifiers act as topic selectors."
msgstr ""
"Beanは、完全に分離された方法で相互作用するために、イベントを生成したり消費したりすることもできます。任意の Java "
"オブジェクトをイベントのペイロードとして使用できます。オプションの修飾子は、トピックセレクタとして機能します。"

#. type: Block title
#: upstream/_guides/cdi.adoc:368
#, no-wrap
msgid "Simple Event Example"
msgstr "シンプルなイベントの例"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:375
#, no-wrap
msgid "class TaskCompleted {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:378
#, no-wrap
msgid "@ApplicationScoped\n"
"class ComplicatedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:381
#, no-wrap
msgid "   @Inject\n"
"   Event<TaskCompleted> event; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:386
#, no-wrap
msgid ""
"   void doSomething() {\n"
"      // ...\n"
"      event.fire(new TaskCompleted()); <2>\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:391
#, no-wrap
msgid "@ApplicationScoped\n"
"class Logger {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:395
#, no-wrap
msgid ""
"   void onTaskCompleted(@Observes TaskCompleted task) { <3>\n"
"      // ...log the task\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:399
msgid "`javax.enterprise.event.Event` is used to fire events."
msgstr "`javax.enterprise.event.Event`  は、イベントの火付けに使われています。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:400
msgid "Fire the event synchronously."
msgstr "イベントを同期的に発生させます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:401
msgid "This method is notified when a `TaskCompleted` event is fired."
msgstr "このメソッドは、 `TaskCompleted`  イベントが発生したときに通知されます。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:403
msgid ""
"For more info about events/observers visit https://docs.jboss.org/weld/"
"reference/latest/en-US/html/events.html[Weld docs, window=\"_blank\"]."
msgstr ""
"イベント/オブザーバーの詳細については、 link:https://docs.jboss.org/weld/reference/latest/en-US/"
"html/events.html[Weld docsを, window=_blank]をご覧ください。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:411
msgid ""
"In this guide, we've covered some of the basic topics of the Quarkus "
"programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/"
"cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="
"\"_blank\"] specification.  However, a full CDI implementation is not used "
"under the hood.  Quarkus only implements a subset of the CDI features - see "
"also <<cdi-reference.adoc#supported_features,the list of supported "
"features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.  "
"On the other hand, there are quite a few <<cdi-"
"reference#nonstandard_features,non-standard features>> and <<cdi-reference."
"adoc#build_time_apis,Quarkus-specific APIs>>.  We believe that our efforts "
"will drive the innovation of the CDI specification towards the build-time "
"oriented developer stacks in the future."
msgstr ""
"このガイドでは、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and "
"Dependency Injection for Java 2.0, window="
"_blank]仕様に基づいたQuarkusプログラミングモデルの基本的なトピックをいくつか取り上げました。ただし、CDIの完全な実装が使用されている訳ではありません。QuarkusはCDI "
"link:cdi-reference.html#supported_features[機能]のサブセットのみを実装しています。一方で、 link:cdi-"
"reference.html#nonstandard_features[非標準の機能]や link:cdi-reference."
"html#build_time_apis[Quarkus固有のAPI]もかなりの数があります。私たちの努力は、将来的にビルドタイム指向の開発者スタックに向けてCDI仕様の革新を推進するものと信じています。"

#. type: Plain text
#: upstream/_guides/cdi.adoc:413
msgid ""
"If you wish to learn more about Quarkus-specific features and limitations "
"there is a Quarkus link:cdi-reference[CDI Reference Guide].  We also "
"recommend you to read the http://docs.jboss.org/cdi/spec/2.0/cdi-spec."
"html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/"
"en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to "
"get acquainted with more complex topics."
msgstr ""
"Quarkus固有の機能や制限について詳しく知りたい場合は、Quarkus link:cdi-"
"reference[CDIリファレンスガイド]があります。また、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-"
"spec.html[CDIの仕様]や link:https://docs.jboss.org/weld/reference/latest/en-US/"
"html/[Weldのドキュメント]（WeldはCDIリファレンスインプリメンテーションです）を読んで、より複雑なトピックに精通することをお勧めします。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/vault-auth.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Working with HashiCorp Vault’s Authentication"
msgstr "Quarkus - HashiCorp Vaultの認証との連携"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:21
#, fuzzy
msgid "Working with Vault is typically a 2 step process:"
msgstr "Vaultでの作業は、通常、2つのステップのプロセスです。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:23
#, fuzzy
msgid "Logging in, which returns a client token"
msgstr "クライアントトークンを返すログイン"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:24
#, fuzzy
msgid ""
"Start using Vault using the client token, within the limits of what is "
"allowed by the policies associated with the token"
msgstr "クライアント トークンに関連付けられたポリシーで許可されている範囲内で、クライアント トークンを使用して Vault の使用を開始します。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:26
#, fuzzy
msgid ""
"There are several Vault authentication methods supported in Quarkus today, "
"namely:"
msgstr "現在QuarkusでサポートされているVault認証方法には、次のようなものがあります。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:28
#, fuzzy
msgid ""
"https://www.vaultproject.io/docs/auth/token[Token]: whenever you already "
"have a token"
msgstr ""
"トー link:https://www.vaultproject.io/docs/auth/token[クン]：すでにトークンを持っている場合"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:29
#, fuzzy
msgid ""
"https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with "
"a username and a password"
msgstr ""
"link:https://www.vaultproject.io/docs/auth/userpass[Userpass]: "
"ユーザ名とパスワードで認証します。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:31
#, fuzzy
msgid ""
"https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a "
"role id and a secret id (which can be seen as a _Userpass_ for automated "
"workflows - machines and services)"
msgstr ""
"link:https://www.vaultproject.io/docs/auth/approle[AppRole]: ロール ID と秘密の ID "
"で認証します (自動化されたワークフロー - マシンやサービスの _Userpass_として見ることができます)"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:32
#, fuzzy
msgid ""
"https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is "
"applicable to workloads deployed into Kubernetes"
msgstr ""
"Kubernetesにデプロイされたワークロードに適用される link:https://www.vaultproject.io/docs/auth/"
"kubernetes[Kubernetes]"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:34
#, fuzzy
msgid ""
"This guide aims at providing examples for each of those authentication "
"methods."
msgstr "本ガイドでは、これらの認証方法について、それぞれの例を提供することを目的としています。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:42
#, fuzzy
msgid "to complete the {base-guide}"
msgstr "ベースガイド}を完成させるために"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:43
#, fuzzy
msgid "roughly 30 minutes"
msgstr "ざっと30分"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:48
#, fuzzy
msgid ""
"For the Kubernetes authentication: A Kubernetes distribution to deploy the "
"Quarkus application (Minishift, K3s, Docker Desktop, …​)"
msgstr ""
"Kubernetes認証のために。QuarkusアプリケーションをデプロイするためのKubernetesディストリビューション（Minishift、K3s、Docker "
"Desktop、..."

#. type: Title ==
#: upstream/_guides/vault-auth.adoc:49
#, no-wrap, fuzzy
msgid "Token Authentication"
msgstr "トークン認証"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:52
#, fuzzy
msgid ""
"We assume there is a Vault container and a PostgreSQL container running from "
"the {base-guide}, and the root token is known."
msgstr ""
"ここでは、{base-guide}からVaultコンテナとPostgreSQLコンテナが動作しており、ルートトークンが既知であると仮定します。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:54
#, fuzzy
msgid ""
"First, create a new shell, `docker exec` into the container and set the root "
"token:"
msgstr "まず、コンテナに新しいシェル、 `docker exec` を作成し、ルートトークンを設定します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:58
#, no-wrap
msgid "docker exec -it dev-vault sh\n"
"/ # export VAULT_TOKEN={root-token}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:61
#, fuzzy
msgid "Create a token for the `vault-quickstart-policy` policy:"
msgstr "`vault-quickstart-policy` ポリシーのトークンを作成します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:73
#, no-wrap
msgid ""
"/ # vault token create -policy=vault-quickstart-policy\n"
"Key                  Value\n"
"---                  -----\n"
"token                {client-token}\n"
"token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n"
"token_duration       768h\n"
"token_renewable      true\n"
"token_policies       [\"default\" \"vault-quickstart-policy\"]\n"
"identity_policies    []\n"
"policies             [\"default\" \"vault-quickstart-policy\"]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:76
#, fuzzy
msgid "Now use the generated client token in the application configuration:"
msgstr "ここで、生成されたクライアントトークンをアプリケーション構成で使用します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:79
#, no-wrap
msgid "quarkus.vault.authentication.client-token={client-token}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:82
#, fuzzy
msgid "Compile and start the application:"
msgstr "コンパイルしてアプリケーションを起動します。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:89
#, fuzzy
msgid "Finally test the application endpoint:"
msgstr "最後にアプリケーションのエンドポイントをテストします。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:95 upstream/_guides/vault-auth.adoc:166
#, fuzzy
msgid "You should see: `{private-key}`."
msgstr "参照してください： `{private-key}`."

#. type: Title ===
#: upstream/_guides/vault-auth.adoc:96
#, no-wrap, fuzzy
msgid "Client Token using Response Wrapping"
msgstr "レスポンスラッピングを利用したクライアントトークン"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:102
#, fuzzy
msgid ""
"One drawback of this approach is that you expose a secret piece of "
"information (i.e. the token) that can give access to sensitive data in Vault."
" This requires ensuring that the application’s configuration stays secure at "
"all time.  If an intruder was to access the client token, it would be able "
"to start calling Vault on all endpoints permitted by the policy."
msgstr ""
"このアプローチの欠点の 1 つは、Vault "
"内の機密データへのアクセスを与えることができる秘密の情報（すなわちトークン）を公開してしまうことです。これは、アプリケーションの構成が常に安全な状態であることを保証する必要があります。侵入者がクライアント "
"トークンにアクセスすると、ポリシーによって許可されたすべてのエンドポイントで Vault を呼び出し始めることができるようになります。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:112
#, fuzzy
msgid ""
"This risk can be mitigated using an approach called https://www.vaultproject."
"io/docs/concepts/response-wrapping[Response Wrapping] (which used to be "
"known as _Cubbyhole Authentication_ in older versions of Vault). This "
"principle is simple: instead of configuring the client token itself, we hide "
"it inside a _Wrapping Token_, which we provide to the application. Upon "
"startup, the application will unwrap the _Wrapping Token_, and fetch the "
"real token from within. The additional level of security comes from the fact "
"that the _Wrapping Token_ is short lived (from a few seconds to a few "
"minutes; basically just enough to start and unwrap the token), and can be "
"unwrapped *only once*.  If the _Wrapping Token_ gets stolen and unwrapped, "
"we will notice immediately because the legitimate application will get an "
"error saying that the token is invalid."
msgstr ""
"このリスクは、 link:https://www.vaultproject.io/docs/concepts/response-"
"wrapping[Response Wrapping]（古いバージョンのVaultでは _Cubbyhole "
"Authentication_として知られていました）と呼ばれるアプローチを使用して軽減することができます。この原理は単純です。クライアント・トークン自体を設定する代わりに、アプリケーションに提供する "
"_ラッピング・トークン_の中にクライアント・トークンを隠します。起動時には、アプリケーションは "
"_ラッピング・トークン_を解除し、内部から本物のトークンを取得します。セキュリティの追加レベルは、 "
"_ラッピング・トークン_が短命（数秒から数分、基本的にはトークンを起動してアンラップするのに十分な時間）で、一 "
"*度*だけアンラップできるという事実から来ています。もし "
"_ラッピング・トークンが_盗まれてアンラップされた場合、正規のアプリケーションはトークンが無効であるというエラーを得るので、すぐに気づくでしょう。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:114
#, fuzzy
msgid ""
"With that in mind, let’s create a new token and wrap it inside a _Wrapping "
"Token_ with a TTL of 1 minute:"
msgstr "それを念頭に置いて、新しいトークンを作成して、TTLが1分の _Wrapping Token_の中に包んでみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:125
#, no-wrap
msgid ""
"/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n"
"Key                              Value\n"
"---                              -----\n"
"wrapping_token:                  {client-token-wrapping-token}\n"
"wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n"
"wrapping_token_ttl:              1m\n"
"wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n"
"wrapping_token_creation_path:    auth/token/create\n"
"wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:128
#, fuzzy
msgid "Now let’s use this wrapping token in the configuration:"
msgstr "では、このラッピングトークンを設定で使ってみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:131
#, no-wrap
msgid ""
"quarkus.vault.authentication.client-token-wrapping-token={client-token-"
"wrapping-token}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:134
#, fuzzy
msgid ""
"Compile and run the application *without the tests*, you should be able now "
"to curl the private key `{private-key}` as before."
msgstr ""
"コンパイルして *テストなしで*アプリケーションを実行すると、以前と同様に秘密鍵 `{private-key}` を curl "
"できるようになるはずです。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:136
#, fuzzy
msgid ""
"Stop the application, and execute tests with `./mvnw test`. They should fail "
"with the following error:"
msgstr "アプリケーションを停止し、 `./mvnw test` でテストを実行します。以下のエラーで失敗するはずです。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:140
#, no-wrap
msgid ""
"ERROR: Failed to start application\n"
"io.quarkus.vault.VaultException: wrapping token is not valid or does not "
"exist; this means that the token has already expired (if so you can increase "
"the TTL on the wrapping token) or has been consumed by somebody else "
"(potentially indicating that the wrapping token has been stolen)\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vault-auth.adoc:142
#, no-wrap, fuzzy
msgid "Userpass Authentication"
msgstr "ユーザーパス認証"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:146
#, fuzzy
msgid ""
"Normally the `userpass` auth method should already be enabled from the {base-"
"guide}. If not, execute the following commands now:"
msgstr ""
"通常、 `userpass` auth メソッドは {base-guide} "
"からすでに有効になっているはずです。有効になっていない場合は、以下のコマンドを実行してください。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:153
#, fuzzy
msgid ""
"And simply specify the username and password for this user in the "
"application configuration:"
msgstr "そして、アプリケーションの設定でこのユーザーのユーザー名とパスワードを指定するだけです。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:157
#, no-wrap
msgid ""
"quarkus.vault.authentication.userpass.username=bob\n"
"quarkus.vault.authentication.userpass.password=sinclair\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:160
#, fuzzy
msgid ""
"Test the application endpoint after compiling and starting the application "
"again:"
msgstr "コンパイルしてアプリケーションを再起動した後、アプリケーションのエンドポイントをテストします。"

#. type: delimited block =
#: upstream/_guides/vault-auth.adoc:172
#, fuzzy
msgid ""
"Userpass supports response wrapping as well for the `password` property, "
"although it is more unusual to use this approach as response wrapping "
"typically involves a technical workflow, which is better suited for "
"`approle`."
msgstr ""
"`approle`Userpass は `password` "
"プロパティに対してもレスポンスラッピングをサポートしていますが、このアプローチを使用するのは珍しいことです。"

#. type: Title ==
#: upstream/_guides/vault-auth.adoc:174
#, no-wrap, fuzzy
msgid "Approle Authentication"
msgstr "アプロール認証"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:177
#, fuzzy
msgid ""
"_Approle_ is an authentication method suited for technical workflows. It "
"relies on 2 pieces of information:"
msgstr "_Approleは_、技術的なワークフローに適した認証方法です。2つの情報に依存しています。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:179
#, fuzzy
msgid "role id can be compared to the user name in _Userpass_"
msgstr "ロールIDは _Userpass_のユーザー名と比較することができます。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:180
#, fuzzy
msgid "secret id plays the role of the `password`"
msgstr "の役割を果たすのがシークレットIDです。 `password`"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:183
#, fuzzy
msgid ""
"To set up _Approle_ you need to enable the `approle` auth method, create an "
"app role, and generate a role id and secret id:"
msgstr ""
"_Approle_を設定するには、 `approle` "
"authメソッドを有効にし、アプリロールを作成し、ロールIDとシークレットIDを生成する必要があります。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:187
#, no-wrap
msgid ""
"/ # vault auth enable approle\n"
"/ # vault write auth/approle/role/myapprole policies=vault-quickstart-"
"policy\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:192
#, no-wrap
msgid ""
"/ # vault read auth/approle/role/myapprole/role-id\n"
"Key        Value\n"
"---        -----\n"
"role_id    {role-id}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:198
#, no-wrap
msgid ""
"/ # vault write -f auth/approle/role/myapprole/secret-id\n"
"Key                   Value\n"
"---                   -----\n"
"secret_id             {secret-id}\n"
"secret_id_accessor    2acff656-d049-c4b3-a752-6125e69210ba\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:201
#, fuzzy
msgid "Add the appropriate properties:"
msgstr "適切なプロパティを追加します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:205
#, no-wrap
msgid ""
"quarkus.vault.authentication.app-role.role-id={role-id}\n"
"quarkus.vault.authentication.app-role.secret-id={secret-id}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:209
#, fuzzy
msgid ""
"After compiling and running the application you should be able to curl it on "
"the `private-key` endpoint to see the secret information `{private-key}` as "
"usual."
msgstr ""
"アプリケーションをコンパイルして実行すると、通常通り `private-key` エンドポイントで秘密の情報 `{private-key}` "
"を表示するためにそれをカールできるようになるはずです。"

#. type: Title ===
#: upstream/_guides/vault-auth.adoc:210
#, no-wrap, fuzzy
msgid "Approle using Response Wrapping"
msgstr "レスポンスラッピングを利用したアプロール"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:213
#, fuzzy
msgid ""
"Similarly to direct client token authentication, it is possible to wrap the "
"`secret-id`:"
msgstr "直接クライアントトークン認証と同様に、 `secret-id`."

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:223
#, no-wrap
msgid ""
"/ # vault write -wrap-ttl=60s -f auth/approle/role/myapprole/secret-id\n"
"Key                              Value\n"
"---                              -----\n"
"wrapping_token:                  {secret-id-wrapping-token}\n"
"wrapping_accessor:               u5EPZOnqyIJN8mT44od67WMS\n"
"wrapping_token_ttl:              1m\n"
"wrapping_token_creation_time:    2020-04-14 16:59:25.482352967 +0000 UTC\n"
"wrapping_token_creation_path:    auth/approle/role/myapprole/secret-id\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:226
#, fuzzy
msgid ""
"Replace the `secret-id` property with `secret-id-wrapping-token` in the "
"configuration:"
msgstr "設定で `secret-id` プロパティを `secret-id-wrapping-token` に置き換えます。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:229
#, no-wrap
msgid ""
"quarkus.vault.authentication.app-role.secret-id-wrapping-token={secret-id-"
"wrapping-token}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:233
#, fuzzy
msgid ""
"Finally, recompile the application without tests (otherwise you are going to "
"consume the wrapping token), launch it and curl the `private-key` endpoint. "
"As usual, you should see `{private-key}`."
msgstr ""
"最後に、テストなしでアプリケーションを再コンパイルし(そうしないとラッピングトークンを消費することになります)、アプリケーションを起動して "
"`private-key` のエンドポイントをカールします。いつものように、 `{private-key}`."

#. type: Title ==
#: upstream/_guides/vault-auth.adoc:234
#, no-wrap, fuzzy
msgid "Kubernetes Authentication"
msgstr "Kubernetes認証"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:238
#, fuzzy
msgid ""
"Vault provides an integration with Kubernetes to allow containers to "
"authenticate with Vault using their Kubernetes JWT token located in `/var/"
"run/secrets/kubernetes.io/serviceaccount`."
msgstr ""
"Vault は Kubernetes との統合を提供し、コンテナが `/var/run/secrets/kubernetes.io/"
"serviceaccount` にある Kubernetes JWT トークンを使用して Vault で認証できるようにします。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:241
#, fuzzy
msgid ""
"The setup is more involved than with the other auth methods because we need "
"to allow Vault to talk to the master API to be able to validate the JWT "
"token that the application will authenticate with."
msgstr ""
"アプリケーションが認証する JWT トークンを検証できるように Vault がマスター API "
"と通信できるようにする必要があるため、他の認証方法よりも設定が複雑になります。"

#. type: Title ===
#: upstream/_guides/vault-auth.adoc:242
#, no-wrap, fuzzy
msgid "auth-delegator"
msgstr "じかいだいし"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:246
#, fuzzy
msgid ""
"The first step involves creating a `vault-auth-sa` service account with "
"`auth-delegator` role that Vault will use to communicate with the master API."
""
msgstr ""
"最初のステップでは、Vault がマスター API との通信に使用する `auth-delegator` ロールを持つ `vault-auth-sa` "
"サービス アカウントを作成します。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:248
#, fuzzy
msgid "First create file `vault-auth-k8s.yml`:"
msgstr "最初にファイル `vault-auth-k8s.yml` を作成します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:255
#, no-wrap
msgid "apiVersion: v1\n"
"kind: ServiceAccount\n"
"metadata:\n"
"name: vault-auth-sa\n"
"---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:268
msgid ""
"kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: "
"name: vault-auth-delegator subjects: - kind: User name: vault-auth-sa "
"namespace: default roleRef: kind: ClusterRole name: system:auth-delegator "
"apiGroup: rbac.authorization.k8s.io"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:271
#, fuzzy
msgid "And apply it: `kubectl apply -f vault-auth-k8s.yml`."
msgstr "そして、それを適用します： `kubectl apply -f vault-auth-k8s.yml`."

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:274
#, fuzzy
msgid ""
"Once the objects are created, we need to capture the JWT token of this "
"service account, and grab the public certificate of the cluster:"
msgstr "オブジェクトを作成したら、このサービスアカウントのJWTトークンを取得し、クラスタの公開証明書を取得する必要があります。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:280
#, no-wrap
msgid ""
"secret_name=$(kubectl get sa vault-auth-sa -o json | jq -r '.secrets[0]."
"name')\n"
"token=$(kubectl get secret $secret_name -o json | jq -r '.data.token' | "
"base64 --decode)\n"
"echo token=$token\n"
"kubectl get secret $secret_name -o json | jq -r '.data.\"ca.crt\"' | base64 -"
"D > /tmp/ca.crt\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:286
#, fuzzy
msgid ""
"The next step requires to exec interactively with the root token into the "
"Vault container to configure the Kubernetes auth method:"
msgstr ""
"次のステップでは、Kubernetesの認証方法を設定するために、ルートトークンをVaultコンテナにインタラクティブに実行する必要があります。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:57
#, no-wrap
msgid "docker exec -it dev-vault sh\n"
"export VAULT_TOKEN={root-token}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:295
#, fuzzy
msgid ""
"Once inside the pod, set the token variable to the value that was just "
"printed in the console before, and recreate `ca.crt` with the same content "
"as `/tmp/ca.crt` outside the container. Finally use `kubectl config view` to "
"assess the url of your Kubernetes cluster:"
msgstr ""
"ポッド内に入ったら、トークン変数に先ほどコンソールに出力された値を設定し、コンテナ外の `/tmp/ca.crt` と同じ内容で `ca.crt` "
"を再作成します。最後に `kubectl config view` を使って Kubernetes クラスタの url を評価します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:300
#, no-wrap
msgid ""
"token=...       => set the value printed in the console just before\n"
"vi ca.crt       => copy/paste /tmp/ca.crt from outside the container\n"
"kubernetes_host => url from the kubectl config view (e.g. https://kubernetes."
"docker.internal:6443)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:303
#, fuzzy
msgid "Now we have all the information we need to configure Vault:"
msgstr "これで、Vaultの設定に必要な情報はすべて揃った。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:306
#, no-wrap
msgid "vault auth enable kubernetes\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:312
#, no-wrap
msgid ""
"# configure master API access from Vault\n"
"vault write auth/kubernetes/config \\\n"
"    token_reviewer_jwt=$token \\\n"
"    kubernetes_host=$kubernetes_host \\\n"
"    kubernetes_ca_cert=@ca.crt\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:319
#, no-wrap
msgid ""
"# create vault-quickstart-role role\n"
"vault write auth/kubernetes/role/vault-quickstart-role \\\n"
"    bound_service_account_names=vault-quickstart-sa \\\n"
"    bound_service_account_namespaces=default \\\n"
"    policies=vault-quickstart-policy \\\n"
"    ttl=1h\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/vault-auth.adoc:321
#, no-wrap, fuzzy
msgid "Deploy the application"
msgstr "アプリケーションのデプロイ"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:326
#, fuzzy
msgid ""
"Add the following properties to the application (and remove any other "
"authentication Vault property, plus replace `<host>` by the ip or name of "
"the local host that is running the Vault and PostgreSQL containers, such "
"that they will be accessible from the pod):"
msgstr ""
"アプリケーションに以下のプロパティを追加します（他の認証 Vault プロパティを削除し、 `&amp;lt;host&amp;gt;` を Vault "
"コンテナと PostgreSQL コンテナを実行しているローカルホストの ip または名前に置き換えて、ポッドからアクセスできるようにします）。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:334
#, no-wrap
msgid ""
"quarkus.vault.url=http://<host>:8200\n"
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=<your username>\n"
"quarkus.datasource.password=<your password>\n"
"quarkus.datasource.jdbc.url = jdbc:postgresql://<host>:5432/mydatabase\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:336
#, no-wrap
msgid "quarkus.vault.authentication.kubernetes.role=vault-quickstart-role\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:338
#, no-wrap
msgid "quarkus.log.category.\"io.quarkus.vault\".level=DEBUG\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:341
#, fuzzy
msgid "Now build the application:"
msgstr "今すぐアプリケーションを構築してください。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:345
#, no-wrap
msgid ""
"./mvnw package -DskipTests\n"
"docker build -f src/main/docker/Dockerfile.jvm -t quarkus/vault-quickstart-"
"jvm .\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:348
#, fuzzy
msgid "Create a `vault-quickstart-k8s.yml` file with:"
msgstr "で `vault-quickstart-k8s.yml` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:355
#, no-wrap
msgid ""
"apiVersion: v1\n"
"kind: ServiceAccount\n"
"metadata:\n"
"  name: vault-quickstart-sa\n"
"---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:381
#, no-wrap
msgid ""
"apiVersion: apps/v1\n"
"kind: Deployment\n"
"metadata:\n"
"  labels:\n"
"    app: vaultapp\n"
"  name: vaultapp\n"
"spec:\n"
"  replicas: 1\n"
"  selector:\n"
"    matchLabels:\n"
"      app: vaultapp\n"
"  template:\n"
"    metadata:\n"
"      labels:\n"
"        app: vaultapp\n"
"    spec:\n"
"      serviceAccountName: vault-quickstart-sa\n"
"      containers:\n"
"      - image: quarkus/vault-quickstart-jvm\n"
"        imagePullPolicy: Never\n"
"        name: vaultapp\n"
"        ports:\n"
"        - containerPort: 8080\n"
"          name: vaultport\n"
"          protocol: TCP\n"
"---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:396
#, no-wrap
msgid ""
"apiVersion: v1\n"
"kind: Service\n"
"metadata:\n"
"  name: vaultapp\n"
"  labels:\n"
"    app: vaultapp\n"
"spec:\n"
"  type: NodePort\n"
"  ports:\n"
"    - name: vault\n"
"      port: 8080\n"
"      nodePort: 30400\n"
"  selector:\n"
"    app: vaultapp\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:399
#, fuzzy
msgid "And apply it: `kubectl apply -f vault-quickstart-k8s.yml`."
msgstr "そして、それを適用します： `kubectl apply -f vault-quickstart-k8s.yml`."

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:401
#, fuzzy
msgid ""
"This will deploy the application, and make it available on port `30400` of "
"the Kubernetes host."
msgstr "これでアプリケーションがデプロイされ、Kubernetes ホストのポート `30400` で利用できるようになります。"

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:403
#, fuzzy
msgid "You can check that the application has started from the logs:"
msgstr "アプリが起動したかどうかはログから確認できます。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:408
#, no-wrap
msgid ""
"kubectl get pods\n"
"pod=$(kubectl get pod -l app=vaultapp -o json | jq -r '.items[0].metadata."
"name')\n"
"kubectl logs $pod\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:428
#, no-wrap
msgid ""
"exec java -Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss."
"logmanager.LogManager -XX:+UseParallelGC -XX:GCTimeRatio=4 -XX:"
"AdaptiveSizePolicyWeight=90 -XX:MinHeapFreeRatio=20 -XX:MaxHeapFreeRatio=40 -"
"XX:+ExitOnOutOfMemoryError -cp . -jar /deployments/app.jar\n"
"__  ____  __  _____   ___  __ ____  ______\n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\\n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n"
"2020-04-15 18:30:00,983 DEBUG [io.qua.vau.run.con.VaultConfigSource] (main) "
"loaded vault runtime config VaultRuntimeConfig{url=Optional[http://<host>:"
"8200], kubernetesAuthenticationRole=vault-quickstart-role, "
"kubernetesJwtTokenPath='/var/run/secrets/kubernetes.io/serviceaccount/"
"token', userpassUsername='', userpassPassword='***', appRoleRoleId='', "
"appRoleSecretId='***', appRoleSecretIdWrappingToken='***', clientToken=***, "
"clientTokenWrappingToken=***, renewGracePeriod=PT1H, cachePeriod=PT10M, "
"logConfidentialityLevel=MEDIUM, kvSecretEngineVersion=2, "
"kvSecretEngineMountPath='secret', tlsSkipVerify=false, tlsCaCert=Optional."
"empty, connectTimeout=PT5S, readTimeout=PT1S}\n"
"2020-04-15 18:30:00,985 DEBUG [io.qua.vau.run.con.VaultConfigSource] (main) "
"loaded vault buildtime config io.quarkus.vault.runtime.config."
"VaultBuildTimeConfig@4163f1cd\n"
"2020-04-15 18:30:01,310 DEBUG [io.qua.vau.run.cli.OkHttpClientFactory] "
"(main) create SSLSocketFactory with tls /var/run/secrets/kubernetes.io/"
"serviceaccount/ca.crt\n"
"2020-04-15 18:30:01,559 DEBUG [io.qua.vau.run.VaultAuthManager] (main) "
"authenticate with jwt at: /var/run/secrets/kubernetes.io/serviceaccount/"
"token => ***\n"
"2020-04-15 18:30:01,779 DEBUG [io.qua.vau.run.VaultAuthManager] (main) "
"created new login token: {clientToken: ***, renewable: true, leaseDuration: "
"3600s, valid_until: Wed Apr 15 19:30:01 GMT 2020}\n"
"2020-04-15 18:30:01,802 DEBUG [io.qua.vau.run.con.VaultConfigSource] (main) "
"loaded 1 properties from vault\n"
"2020-04-15 18:30:02,722 DEBUG [io.qua.vau.run.VaultAuthManager] "
"(Agroal_7305849841) extended login token: {clientToken: ***, renewable: "
"true, leaseDuration: 3600s, valid_until: Wed Apr 15 19:30:02 GMT 2020}\n"
"2020-04-15 18:30:03,274 INFO  [io.quarkus] (main) vault-quickstart 1.0-"
"SNAPSHOT (powered by Quarkus 999-SNAPSHOT) started in 4.255s. Listening on: "
"http://0.0.0.0:8080\n"
"2020-04-15 18:30:03,276 INFO  [io.quarkus] (main) Profile prod activated.\n"
"2020-04-15 18:30:03,276 INFO  [io.quarkus] (main) Installed features: "
"[agroal, cdi, hibernate-orm, jdbc-postgresql, narayana-jta, resteasy, "
"vault]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:431
#, fuzzy
msgid "Notice in particular the following log line:"
msgstr "特に以下のログ行に注目してください。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:434
#, no-wrap
msgid ""
"authenticate with jwt at: /var/run/secrets/kubernetes.io/serviceaccount/"
"token => ***\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:437
#, fuzzy
msgid ""
"Finally curl the `private-key` endpoint to make sure you can retrieve your "
"secret:"
msgstr "最後に `private-key` のエンドポイントをカールして、秘密を取得できることを確認します。"

#. type: delimited block -
#: upstream/_guides/vault-auth.adoc:440
#, no-wrap
msgid "curl http://localhost:30400/hello/private-key\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-auth.adoc:442
#, fuzzy
msgid "You should see `{private-key}`."
msgstr "`{private-key}` をご覧ください。"

#. type: Title =
#: upstream/_guides/faq.adoc:1
#, no-wrap, fuzzy
msgid "Quarkus - Frequently Asked Questions"
msgstr "Quarkus - よくある質問"

#. type: Title ==
#: upstream/_guides/faq.adoc:15
#, no-wrap, fuzzy
msgid "Native compilation"
msgstr "ネイティブコンパイル"

#. type: Labeled list
#: upstream/_guides/faq.adoc:17
#, no-wrap, fuzzy
msgid ""
"Native executable fails on macOS with `error: unknown type name 'uint8_t'`"
msgstr "で macOS でのネイティブ実行ファイルの失敗 `error: unknown type name 'uint8_t'`"

#. type: Plain text
#: upstream/_guides/faq.adoc:21
#, fuzzy
msgid ""
"Your macOS has the wrong `*.h` files compared to the OS and no gcc "
"compilation will work.  This can happen when you migrate from versions of "
"the OS.  See https://stackoverflow.com/questions/48029309/cannot-compile-any-"
"c-programs-error-unknown-type-name-uint8-t"
msgstr ""
"あなたのmacOSはOSと比較して `*.h` "
"ファイルが間違っていて、gccコンパイルが動作しません。これはOSのバージョンから移行したときに起こる可能性があります。 https://"
"stackoverflow.com/questions/48029309/cannot-compile-any-c-programs-error-"
"unknown-type-name-uint8-t 。"

#. type: Plain text
#: upstream/_guides/faq.adoc:23
#, fuzzy
msgid "The solution is to"
msgstr "解決策は、以下の通りです。"

#. type: Plain text
#: upstream/_guides/faq.adoc:25
#, fuzzy
msgid "`sudo mv /usr/local/include /usr/local/include.old`"
msgstr "`sudo mv /usr/local/include /usr/local/include.old`"

#. type: Plain text
#: upstream/_guides/faq.adoc:26
#, fuzzy
msgid "Reinstall XCode for good measure"
msgstr "念のためにXCodeを再インストールします。"

#. type: Plain text
#: upstream/_guides/faq.adoc:27
#, fuzzy
msgid "(optional?) `brew install llvm`"
msgstr "(オプション？) `brew install llvm`"

#. type: Plain text
#: upstream/_guides/faq.adoc:28
#, fuzzy
msgid "generally reinstall your brew dependencies with native compilation"
msgstr "一般的には、ネイティブコンパイルで brew の依存関係を再インストールします。"

#. type: Plain text
#: upstream/_guides/faq.adoc:29
#, fuzzy
msgid "The executable should work now."
msgstr "実行ファイルが動作するようになりました。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-jdbc.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using Security with JDBC"
msgstr "Quarkus - JDBCでセキュリティを使用する"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:11
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can use a database to "
"store your user identities."
msgstr "このガイドでは、Quarkusアプリケーションがデータベースを使用してユーザーIDを保存する方法を説明します。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:25
#, fuzzy
msgid ""
"In this example, we build a very simple microservice which offers three "
"endpoints:"
msgstr "この例では、3つのエンドポイントを提供する非常にシンプルなマイクロサービスを構築しています。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:27
#, fuzzy
msgid "`/api/public`"
msgstr "`/api/public`"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:28
#, fuzzy
msgid "`/api/users/me`"
msgstr "`/api/users/me`"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:29
#, fuzzy
msgid "`/api/admin`"
msgstr "`/api/admin`"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:33
#, fuzzy
msgid ""
"The `/api/public` endpoint can be accessed anonymously.  The `/api/admin` "
"endpoint is protected with RBAC (Role-Based Access Control) where only users "
"granted with the `admin` role can access. At this endpoint, we use the "
"`@RolesAllowed` annotation to declaratively enforce the access constraint.  "
"The `/api/users/me` endpoint is also protected with RBAC (Role-Based Access "
"Control) where only users granted with the `user` role can access. As a "
"response, it returns a JSON document with details about the user."
msgstr ""
"`/api/public` エンドポイントは匿名でアクセスできます。 `/api/admin` エンドポイントは RBAC (Role-Based "
"Access Control) で保護されており、 `admin` ロールで許可されたユーザーのみがアクセスできます。このエンドポイントでは、 "
"`@RolesAllowed` アノテーションを使用して、アクセス制約を宣言的に強制します。 `/api/users/me` エンドポイントも RBAC "
"(Role-Based Access Control) で保護されており、 `user` "
"ロールで付与されたユーザーのみがアクセスできます。レスポンスとして、ユーザーに関する詳細を含むJSONドキュメントを返します。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:42
#, fuzzy
msgid ""
"The solution is located in the `security-jdbc-quickstart` {quickstarts-tree-"
"url}/security-jdbc-quickstart[directory]."
msgstr ""
"ソリューションは `security-jdbc-quickstart` {quickstarts-tree-url}/security-jdbc-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:55
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=security-jdbc-quickstart \\\n"
"    -Dextensions=\"elytron-security-jdbc,jdbc-postgresql,resteasy\" \\\n"
"    -DnoExamples\n"
"cd security-jdbc-quickstart\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/security-jdbc.adoc:60
#, fuzzy
msgid ""
"Don't forget to add the database connector library of choice. Here we are "
"using PostgreSQL as identity store."
msgstr "選択したデータベースコネクタライブラリを追加することを忘れないでください。ここでは、PostgreSQLをIDストアとして使用しています。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:64
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `elytron-security-"
"jdbc` extension which is an https://docs.wildfly.org/17/"
"WildFly_Elytron_Security.html#jdbc-security-realm[`wildfly-elytron-realm-"
"jdbc`] adapter for Quarkus applications."
msgstr ""
"このコマンドはMavenプロジェクトを生成し、 `elytron-security-jdbc` 拡張モジュールをインポートします。  link:"
"https://docs.wildfly.org/17/WildFly_Elytron_Security.html#jdbc-security-"
"realm[`wildfly-elytron-realm-jdbc`]Quarkusアプリケーション用のアダプタです。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:67
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`elytron-security-jdbc` extension to your project by running the following "
"command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`elytron-security-jdbc` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:71
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"elytron-security-jdbc\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:81
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-elytron-security-jdbc</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kogito.adoc:114
#, no-wrap, fuzzy
msgid "Writing the application"
msgstr "アプリケーションの書き方"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:86
#, fuzzy
msgid ""
"Let's start by implementing the `/api/public` endpoint. As you can see from "
"the source code below, it is just a regular JAX-RS resource:"
msgstr ""
"まずは `/api/public` エンドポイントを実装してみましょう。下のソースコードを見ればわかるように、これは普通のJAX-RSリソースです。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:90
#: upstream/_guides/security-jdbc.adoc:115
#: upstream/_guides/security-jdbc.adoc:140
#, no-wrap
msgid "package org.acme.security.jdbc;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:96
#, no-wrap
msgid ""
"import javax.annotation.security.PermitAll;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:99
#, no-wrap
msgid "@Path(\"/api/public\")\n"
"public class PublicResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:107
#, no-wrap
msgid ""
"    @GET\n"
"    @PermitAll\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String publicResource() {\n"
"        return \"public\";\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:110
#, fuzzy
msgid ""
"The source code for the `/api/admin` endpoint is also very simple. The main "
"difference here is that we are using a `@RolesAllowed` annotation to make "
"sure that only users granted with the `admin` role can access the endpoint:"
msgstr ""
"`/api/admin` エンドポイントのソースコードも非常にシンプルです。ここでの主な違いは、 `admin` "
"ロールで付与されたユーザーだけがエンドポイントにアクセスできるように `@RolesAllowed` アノテーションを使用していることです。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:121
#, no-wrap
msgid ""
"import javax.annotation.security.RolesAllowed;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:124
#, no-wrap
msgid "@Path(\"/api/admin\")\n"
"public class AdminResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:132
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"admin\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String adminResource() {\n"
"         return \"admin\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:136
#, fuzzy
msgid ""
"Finally, let's consider the `/api/users/me` endpoint. As you can see from "
"the source code below, we are trusting only users with the `user` role.  We "
"are using `SecurityContext` to get access to the current authenticated "
"Principal and we return the user's name. This information is loaded from the "
"database."
msgstr ""
"最後に、 `/api/users/me` エンドポイントを考えてみましょう。下のソースコードを見ればわかるように、 `user` "
"の役割を持つユーザのみを信頼しています。現在認証されているプリンシパルへのアクセスを得るために `SecurityContext` "
"を使用しており、ユーザーの名前を返します。この情報はデータベースから読み込まれます。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:147
#, no-wrap
msgid ""
"import javax.annotation.security.RolesAllowed;\n"
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.core.Context;\n"
"import javax.ws.rs.core.SecurityContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:150
#, no-wrap
msgid "@Path(\"/api/users\")\n"
"public class UserResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:158
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"user\")\n"
"    @Path(\"/me\")\n"
"    public String me(@Context SecurityContext securityContext) {\n"
"        return securityContext.getUserPrincipal().getName();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-jdbc.adoc:160
#, no-wrap, fuzzy
msgid "Configuring the Application"
msgstr "アプリケーションの設定"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:163
#, fuzzy
msgid ""
"The `elytron-security-jdbc` extension requires at least one datasource to "
"access to your database."
msgstr "`elytron-security-jdbc` 拡張モジュールは、データベースにアクセスするために少なくとも一つのデータソースが必要です。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:170
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus\n"
"quarkus.datasource.password=quarkus\n"
"quarkus.datasource.jdbc.url=jdbc:postgresql:elytron-security-jdbc\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:173
#, fuzzy
msgid ""
"In our context, we are using PostgreSQL as identity store and we initialize "
"the database with users and roles."
msgstr "私たちのコンテキストでは、PostgreSQLをIDストアとして使用しており、ユーザとロールでデータベースを初期化しています。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:182
#, no-wrap
msgid ""
"CREATE TABLE test_user (\n"
"  id INT,\n"
"  username VARCHAR(255),\n"
"  password VARCHAR(255),\n"
"  role VARCHAR(255)\n"
");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:185
#, no-wrap
msgid ""
"INSERT INTO test_user (id, username, password, role) VALUES (1, 'admin', "
"'admin', 'admin');\n"
"INSERT INTO test_user (id, username, password, role) VALUES (2, "
"'user','user', 'user');\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/security-jdbc.adoc:191
#, fuzzy
msgid ""
"It is probably useless but we kindly remind you that you must not store "
"clear-text passwords in production environment ;-).  The `elytron-security-"
"jdbc` offers a built-in bcrypt password mapper."
msgstr ""
"おそらく役に立たないと思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください。) `elytron-security-"
"jdbc` は組み込みの bcrypt パスワードマッパーを提供しています。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:194
#, fuzzy
msgid "We can now configure the Elytron JDBC Realm."
msgstr "これで、Elytron JDBC Realmを設定することができます。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:203
#, no-wrap
msgid ""
"quarkus.security.jdbc.enabled=true\n"
"quarkus.security.jdbc.principal-query.sql=SELECT u.password, u.role FROM "
"test_user u WHERE u.username=? <1>\n"
"quarkus.security.jdbc.principal-query.clear-password-mapper.enabled=true <2>\n"
"quarkus.security.jdbc.principal-query.clear-password-mapper.password-index=1\n"
"quarkus.security.jdbc.principal-query.attribute-mappings.0.index=2 <3>\n"
"quarkus.security.jdbc.principal-query.attribute-mappings.0.to=groups\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:206
#, fuzzy
msgid ""
"The `elytron-security-jdbc` extension requires at least one principal query "
"to authenticate the user and its identity."
msgstr ""
"`elytron-security-jdbc` 拡張モジュールは、ユーザとその身元を認証するために、少なくとも一つの主な問い合わせを必要とします。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:208
#, fuzzy
msgid ""
"We define a parameterized SQL statement (with exactly 1 parameter) which "
"should return the user's password plus any additional information you want "
"to load."
msgstr "パラメータ化されたSQL文(正確には1つのパラメータ)を定義しています。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:209
#, fuzzy
msgid ""
"We configure the password mapper with the position of the password field in "
"the `SELECT` fields and other information like salt, hash encoding, etc."
msgstr "`SELECT` フィールドのパスワードフィールドの位置や、ソルト、ハッシュエンコードなどの情報を使って、パスワードマッパーを設定します。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:210
#, fuzzy
msgid ""
"We use `attribute-mappings` to bind the `SELECT` projection fields (ie. `u."
"role` here) to the target Principal representation attributes."
msgstr ""
"`attribute-mappings` を使用して、 `SELECT` の投影フィールド（例：ここでは `u.role` ）をターゲットの "
"Principal 表現属性にバインドしています。"

#. type: delimited block =
#: upstream/_guides/security-jdbc.adoc:214
#, fuzzy
msgid ""
"In the `principal-query` configuration all the `index` properties start at 1 "
"(rather than 0)."
msgstr "`principal-query` の設定では、 `index` のプロパティはすべて 1 から始まります (0 ではなく)。"

#. type: Title ==
#: upstream/_guides/kogito.adoc:271
#, no-wrap, fuzzy
msgid "Testing the Application"
msgstr "アプリケーションのテスト"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:220
#, fuzzy
msgid ""
"The application is now protected and the identities are provided by our "
"database.  The very first thing to check is to ensure the anonymous access "
"works."
msgstr ""
"アプリケーションが保護され、アイデンティティがデータベースから提供されるようになりました。非常に最初に確認すべきことは、匿名アクセスが機能することを確認することです。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:227
#, no-wrap
msgid ""
"$ curl -i -X GET http://localhost:8080/api/public\n"
"HTTP/1.1 200 OK\n"
"Content-Length: 6\n"
"Content-Type: text/plain;charset=UTF-8\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:229
#, no-wrap
msgid "public%\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:232
#, fuzzy
msgid "Now, let's try a to hit a protected resource anonymously."
msgstr "では、匿名で保護されたリソースを攻撃してみましょう。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:239
#, no-wrap
msgid ""
"$ curl -i -X GET http://localhost:8080/api/admin\n"
"HTTP/1.1 401 Unauthorized\n"
"Content-Length: 14\n"
"Content-Type: text/html;charset=UTF-8\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:241
#, no-wrap
msgid "Not authorized%\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:244
#, fuzzy
msgid "So far so good, now let's try with an allowed user."
msgstr "ここまでは順調ですが、今度は許可されたユーザーで試してみましょう。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:251
#, no-wrap
msgid ""
"$ curl -i -X GET -u admin:admin http://localhost:8080/api/admin\n"
"HTTP/1.1 200 OK\n"
"Content-Length: 5\n"
"Content-Type: text/plain;charset=UTF-8\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:253
#, no-wrap
msgid "admin%\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:256
#, fuzzy
msgid ""
"By providing the `admin:admin` credentials, the extension authenticated the "
"user and loaded their roles.  The `admin` user is authorized to access to "
"the protected resources."
msgstr ""
"`admin:admin` 資格情報を提供することで、拡張機能はユーザーを認証し、そのロールをロードしました。 `admin` "
"ユーザーは、保護されたリソースへのアクセスを許可されています。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:258
#, fuzzy
msgid ""
"The user `admin` should be forbidden to access a resource protected with "
"`@RolesAllowed(\"user\")` because it doesn't have this role."
msgstr ""
"ユーザー `admin` は、この役割を持っていないので、 `@RolesAllowed(\"user\")` "
"で保護されたリソースへのアクセスを禁止する必要があります。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:265
#, no-wrap
msgid ""
"$ curl -i -X GET -u admin:admin http://localhost:8080/api/users/me\n"
"HTTP/1.1 403 Forbidden\n"
"Content-Length: 34\n"
"Content-Type: text/html;charset=UTF-8\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:267
#, no-wrap
msgid "Forbidden%\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:270
#, fuzzy
msgid ""
"Finally, using the user `user` works and the security context contains the "
"principal details (username for instance)."
msgstr "最後に、ユーザ `user` を使用すると動作し、セキュリティコンテキストには主要な詳細（例えばユーザ名）が含まれています。"

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:277
#, no-wrap
msgid ""
"$ curl -i -X GET -u user:user http://localhost:8080/api/users/me\n"
"HTTP/1.1 200 OK\n"
"Content-Length: 4\n"
"Content-Type: text/plain;charset=UTF-8\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-jdbc.adoc:279
#, no-wrap
msgid "user%\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-jdbc.adoc:281
#, no-wrap, fuzzy
msgid "Advanced Configuration"
msgstr "高度な設定"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:284
#, fuzzy
msgid ""
"This guide only covered an easy use case, the extension offers multiple "
"datasources, multiple principal queries configuration as well as a bcrypt "
"password mapper."
msgstr ""
"このガイドでは、簡単な使用例のみを取り上げていますが、この拡張機能は複数のデータソース、複数のプリンシパルクエリの設定、および bcrypt "
"パスワードマッパーを提供しています。"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:291
#, fuzzy
msgid ""
"quarkus.datasource.db-kind=postgresql quarkus.datasource.username=quarkus "
"quarkus.datasource.password=quarkus quarkus.datasource.jdbc.url=jdbc:"
"postgresql:multiple-data-sources-users"
msgstr ""
"quarkus.datasource.db-kind=postgresql quarkus.datasource.username=quarkus "
"quarkus.datasource.password=quarkus quarkus.datasource.jdbc.url=jdbc:"
"postgresql:multiple-data-sources-users quarkus.datasource.jdbc.url=jdbc:"
"postgresql:複数データソースユーザ"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:296
#, fuzzy
msgid ""
"quarkus.datasource.permissions.db-kind=postgresql quarkus.datasource."
"permissions.username=quarkus quarkus.datasource.permissions.password=quarkus "
"quarkus.datasource.permissions.jdbc.url=jdbc:postgresql:multiple-data-"
"sources-permissions"
msgstr ""
"quarkus.datasource.permissions.db-kind=postgresql quarkus.datasource."
"permissions.username=quarkus quarkus.datasource.permissions.password=quarkus "
"quarkus.datasource.permissions.jdbc.url=jdbc:postgresql:multiple-data-"
"sources-permissions"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:301
#, fuzzy
msgid ""
"quarkus.security.jdbc.enabled=true quarkus.security.jdbc.principal-query.sql="
"SELECT u.password FROM test_user u WHERE u.username=? quarkus.security.jdbc."
"principal-query.clear-password-mapper.enabled=true quarkus.security.jdbc."
"principal-query.clear-password-mapper.password-index=1"
msgstr ""
"quarkus.security.jdbc.enabled=true quarkus.security.jdbc.principal-query.sql="
"SELECT u.password FROM test_user u WHERE u.username=? quarkus.security.jdbc."
"principal-query.clear-password-mapper.enabled=true quarkus.security.jdbc."
"principal-query.clear-password-mapper.password-index=1"

#. type: Plain text
#: upstream/_guides/security-jdbc.adoc:306
#, fuzzy
msgid ""
"quarkus.security.jdbc.principal-query.roles.sql=SELECT r.role_name FROM "
"test_role r, test_user_role ur WHERE ur.username=? AND ur.role_id = r.id "
"quarkus.security.jdbc.principal-query.roles.datasource=permissions quarkus."
"security.jdbc.principal-query.roles.attribute-mappings.0.index=1 quarkus."
"security.jdbc.principal-query.roles.attribute-mappings.0.to=groups"
msgstr ""
"quarkus.security.jdbc.principal-query.rolls.sql=SELECT r.role_name FROM "
"test_role r, test_user_role ur WHERE ur.username=?AND ur.role_id = r.id "
"quarkus.security.jdbc.principal-query.rolls.datasource=permissions quarkus."
"security.jdbc.principal-query.rolls.attribute-mappings.0.index=1 quarkus."
"security.jdbc.principal-query.rolls.attribute-mappings.0.to=groups"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/infinispan-embedded.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Infinispan Embedded"
msgstr "Quarkus - Infinispan Embedded"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:13
#, fuzzy
msgid ""
"Infinispan is an elastically scalable in-memory data store that you can "
"embed directly in your application."
msgstr "Infinispanは、アプリケーションに直接埋め込むことができる拡張性の高いインメモリデータストアです。"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:16
#, fuzzy
msgid ""
"Check out the link:https://infinispan.org/documentation/[Infinispan "
"documentation] to find out more about the Infinispan project."
msgstr ""
"Infinispanプロジェクトの詳細については、Infinispanの link:https://infinispan.org/"
"documentation/[ドキュメント]をご覧ください。"

#. type: Title ==
#: upstream/_guides/infinispan-embedded.adoc:19
#, no-wrap, fuzzy
msgid "Adding the Infinispan Embedded Extension"
msgstr "Infinispan 埋め込み拡張機能の追加"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:21
#, fuzzy
msgid ""
"After you set up your Quarkus project, run the following command from the "
"base directory:"
msgstr "Quarkusプロジェクトを設定したら、ベースディレクトリから以下のコマンドを実行します。"

#. type: delimited block -
#: upstream/_guides/infinispan-embedded.adoc:25
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"infinispan-embedded\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:28
#, fuzzy
msgid "The command adds the following dependency to your `pom.xml`:"
msgstr "このコマンドは、以下の依存関係を `pom.xml`."

#. type: delimited block -
#: upstream/_guides/infinispan-embedded.adoc:35
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-infinispan-embedded</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/infinispan-embedded.adoc:37
#, no-wrap, fuzzy
msgid "Feature Support"
msgstr "機能サポート"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:40
#, fuzzy
msgid ""
"The Infinispan embedded extension offers core caching functionality that "
"includes clustered caches, off-heap memory, data persistence, and "
"transactions."
msgstr ""
"Infinispan組み込み拡張機能は、クラスタ化キャッシュ、オフヒープメモリ、データ永続化、トランザクションを含むコアキャッシング機能を提供します。"

#. type: delimited block =
#: upstream/_guides/infinispan-embedded.adoc:45
#, fuzzy
msgid ""
"The Infinispan embedded extension does not currently support indexing "
"capabilities."
msgstr "Infinispan の組み込み拡張機能は、現在のところインデックス機能をサポートしていません。"

#. type: Title ===
#: upstream/_guides/infinispan-embedded.adoc:47
#, no-wrap, fuzzy
msgid "Transactions"
msgstr "取引"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:50
#, fuzzy
msgid ""
"Configure Infinispan caches for transactional operations with a specific "
"`TransactionManagerLookup`, as follows:"
msgstr ""
"Infinispan キャッシュを特定の `TransactionManagerLookup` "
"でトランザクション処理用に設定するには、以下のようにします。"

#. type: delimited block -
#: upstream/_guides/infinispan-embedded.adoc:56
#, no-wrap
msgid ""
"<local-cache name=\"quarkus-transaction\">\n"
"   <transaction transaction-manager-lookup=\"org.infinispan.transaction."
"lookup.JBossStandaloneJTAManagerLookup\"/>\n"
"</local-cache>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:59
#, fuzzy
msgid ""
"For more information, see the Quarkus link:transaction[Transaction Guide]."
msgstr "詳細については、Quarkus link:transaction[取引ガイド]を参照してください。"

#. type: Title ===
#: upstream/_guides/infinispan-embedded.adoc:60
#, no-wrap, fuzzy
msgid "Native Limitations"
msgstr "ネイティブの制限"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:62
#, fuzzy
msgid "When running Infinispan in native mode, some limitations apply:"
msgstr "ネイティブモードでInfinispanを実行する場合、いくつかの制限が適用されます。"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:64
#, fuzzy
msgid "JMX management is not supported."
msgstr "JMX管理には対応していません。"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:65
#, fuzzy
msgid "GraalVM does not allow native VM interfaces."
msgstr "GraalVMは、ネイティブVMインターフェースを許可していません。"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:66
#, fuzzy
msgid "`UDP`/`Multicast` is not supported."
msgstr "`UDP`/ `Multicast` はサポートされていません。"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:67
#, fuzzy
msgid ""
"You must use `TCP` transport and a non-UDP based membership protocol with "
"JGroups."
msgstr "JGroupsでは、 `TCP` トランスポートと非UDPベースのメンバーシッププロトコルを使用する必要があります。"

#. type: Title ==
#: upstream/_guides/infinispan-embedded.adoc:68
#, no-wrap, fuzzy
msgid "Injection (CDI)"
msgstr "射出(CDI)"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:71
#, fuzzy
msgid ""
"The Infinispan embedded extension provides injection capabilities so you do "
"not have to configure and start caches manually."
msgstr "Infinispan組み込み拡張機能はインジェクション機能を提供するので、手動でキャッシュを設定して起動する必要はありません。"

#. type: delimited block =
#: upstream/_guides/infinispan-embedded.adoc:75
#, fuzzy
msgid ""
"Additional injection functionality will be available in future versions."
msgstr "追加のインジェクション機能は、将来のバージョンで利用可能になる予定です。"

#. type: Labeled list
#: upstream/_guides/infinispan-embedded.adoc:77
#, no-wrap, fuzzy
msgid "`EmbeddedCacheManager`"
msgstr "`EmbeddedCacheManager`"

#. type: Plain text
#: upstream/_guides/infinispan-embedded.adoc:79
#, fuzzy
msgid "This is the main entry point to configure and obtain caches."
msgstr "キャッシュを設定したり取得したりするためのメインのエントリーポイントです。"

#. type: delimited block =
#: upstream/_guides/infinispan-embedded.adoc:88
#, fuzzy
msgid ""
"JMX elements are disabled during native runtime so you can use the same "
"configuration file in JVM and native modes."
msgstr "JMX要素はネイティブ実行時には無効化されるので、JVMとネイティブモードで同じ設定ファイルを使用することができます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-built-in-authentication.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Built-In Authentication Support"
msgstr "Quarkus - 組み込みの認証サポート"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:11
#, fuzzy
msgid ""
"This document describes the Quarkus built-in authentication mechanisms for "
"HTTP based FORM, BASIC and Mutual TLS authentication as well as the "
"proactive authentication."
msgstr ""
"このドキュメントでは、HTTPベースのFORM認証、BASIC認証、相互TLS認証、およびプロアクティブ認証のためのQuarkusの組み込み認証メカニズムについて説明します。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:13
#, no-wrap, fuzzy
msgid "Basic Authentication"
msgstr "基本認証"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:17
#, fuzzy
msgid ""
"To enable basic authentication set `quarkus.http.auth.basic=true`. You must "
"also have at least one extension installed that provides a username/password "
"based `IdentityProvider`, such as link:security-jdbc[Elytron JDBC]."
msgstr ""
"基本的な認証を有効にするには、 `quarkus.http.auth.basic=true` を設定します。また、ユーザー名/パスワードベースの "
"`IdentityProvider` を提供する拡張機能を少なくとも 1 つインストールしておく必要があります。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:19
#, fuzzy
msgid ""
"Please see link:security#identity-providers[Security Identity Providers] for "
"more information."
msgstr "詳細については、 link:security#identity-providers[セキュリティ ID プロバイダを]参照してください。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:21
#, fuzzy
msgid ""
"Please also see link:security-testing#configuring-user-"
"information[Configuring User Information in application.properties] section."
msgstr ""
"link:security-testing#configuring-user-information[application."
"properties]セクション link:security-testing#configuring-user-"
"information[のユーザー情報の設定]も参照してください。"

#. type: Title ==
#: upstream/_guides/security-built-in-authentication.adoc:23
#, no-wrap, fuzzy
msgid "Form Based Authentication"
msgstr "フォームベース認証"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:29
#, fuzzy
msgid ""
"Quarkus provides form based authentication that works in a similar manner to "
"traditional Servlet form based auth. Unlike traditional form authentication, "
"the authenticated user is not stored in an HTTP session, as Quarkus does not "
"provide clustered HTTP session support. Instead the authentication "
"information is stored in an encrypted cookie, which can be read by all "
"members of the cluster (provided they all share the same encryption key)."
msgstr ""
"Quarkusは、従来のサーブレットのフォームベースの認証と同様の方法で動作するフォームベースの認証を提供します。従来のフォーム認証とは異なり、Quarkusはクラスター化されたHTTPセッションをサポートしていないため、認証されたユーザーはHTTPセッションに保存されません。代わりに、認証情報は暗号化されたCookieに保存され、クラスターのすべてのメンバーが読み取ることができます（すべてのメンバーが同じ暗号化キーを共有している場合）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:35
#, fuzzy
msgid ""
"The encryption key can be set using the `quarkus.http.auth.session."
"encryption-key` property, and it must be at least 16 characters long. This "
"key is hashed using SHA-256 and the resulting digest is used as a key for "
"AES-256 encryption of the cookie value. This cookie contains an expiry time "
"as part of the encrypted value, so all nodes in the cluster must have their "
"clocks synchronized. At one minute intervals a new cookie will be generated "
"with an updated expiry time if the session is in use."
msgstr ""
"暗号化キーは `quarkus.http.auth.session.encryption-key` プロパティを使って設定でき、少なくとも 16 "
"文字の長さでなければなりません。このキーは SHA-256 を使ってハッシュ化され、その結果のダイジェストがクッキー値の AES-256 "
"暗号化のキーとして使用されます。このクッキーは暗号化された値の一部として有効期限を含んでいますので、クラスター内のすべての "
"ノードはクロックを同期させなければなりません。1 分間隔で、セッションが使用中であれば、更新された有効期限時間を持つ新しいクッキーが生成されます。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:37
#, fuzzy
msgid "The following properties can be used to configure form based auth:"
msgstr "以下のプロパティを使用して、フォームベースの認証を設定することができます。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:44
#, fuzzy
msgid ""
"Quarkus provides mTLS authentication so that you can authenticate users "
"based on their X.509 certificates."
msgstr "QuarkusはmTLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:46
#, fuzzy
msgid ""
"To use this authentication method, you should first enable SSL for your "
"application. For more details, check the link:http-reference#ssl[Supporting "
"secure connections with SSL] guide."
msgstr ""
"この認証方法を利用するには、まずアプリケーションでSSLを有効にする必要があります。詳細については、「 link:http-"
"reference#ssl[SSLによるセキュアな接続のサポート]」を参照してください。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:50
#, fuzzy
msgid ""
"Once your application is accepting secure connections, the next step is to "
"configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the "
"certificates that your application should trust as well as how your "
"application should ask for certificates when a client (e.g.: browser or "
"another service) tries to access one of its protected resources."
msgstr ""
"アプリケーションが安全な接続を受け入れたら、次のステップは、アプリケーションが信頼すべきすべての証明書を保持する `quarkus.http.ssl."
"certificate.trust-store-file` "
"を設定し、クライアント(ブラウザや他のサービスなど)が保護されたリソースの一つにアクセスしようとしたときに、アプリケーションがどのように証明書を要求するかを設定することです。"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:58
#, no-wrap
msgid ""
"quarkus.http.ssl.certificate.key-store-file=server-keystore.jks            "
"<1>\n"
"quarkus.http.ssl.certificate.key-store-password=the_key_store_secret\n"
"quarkus.http.ssl.certificate.trust-store-file=server-truststore.jks        "
"<2>\n"
"quarkus.http.ssl.certificate.trust-store-password=the_trust_store_secret\n"
"quarkus.http.ssl.client-auth=required                                      "
"<3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:61
#, no-wrap
msgid ""
"quarkus.http.auth.permission.default.paths=/*                              "
"<4>\n"
"quarkus.http.auth.permission.default.policy=authenticated\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:63
#, fuzzy
msgid "Configures a key store where the server's private key is located."
msgstr "サーバの秘密鍵が置かれている鍵ストアを設定します。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:64
#, fuzzy
msgid ""
"Configures a trust store from where the trusted certificates are going to be "
"loaded from."
msgstr "信頼された証明書がロードされる場所からトラストストアを構成します。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:67
#, fuzzy
msgid ""
"Defines that the server should *always* ask certificates from clients. You "
"can relax this behavior by using `REQUEST` so that the server should still "
"accept requests without a certificate. Useful when you are also supporting "
"authentication methods other than mTLS."
msgstr ""
"サーバが *常に*クライアントからの証明書を要求することを定義します。 `REQUEST` を使用することで、この動作を緩和することができます。mTLS "
"以外の認証方法もサポートしている場合に便利です。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:68
#, fuzzy
msgid ""
"Defines a policy where only authenticated users should have access to "
"resources from your application."
msgstr "認証されたユーザーのみがアプリケーションからリソースにアクセスできるようにするポリシーを定義します。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:71
#, fuzzy
msgid ""
"Once the incoming request matches a valid certificate in the truststore, "
"your application should be able to obtain the subject by just injecting a "
"`SecurityIdentity` as follows:"
msgstr ""
"受信したリクエストがトラストストアの有効な証明書と一致したら、アプリケーションは以下のように `SecurityIdentity` "
"を注入するだけでサブジェクトを取得できるようになるはずです。"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:73
#, no-wrap, fuzzy
msgid "Obtaining the subject"
msgstr "主語の取得"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:78
#, no-wrap
msgid "@Inject\n"
"SecurityIdentity identity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:84
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.TEXT_PLAIN)\n"
"public String hello() {\n"
"    return String.format(\"Hello, %s\", identity.getPrincipal().getName());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:87
#, fuzzy
msgid "You should also be able to get the certificate as follows:"
msgstr "また、以下のように証明書を取得できるようにしておきましょう。"

#. type: Block title
#: upstream/_guides/security-built-in-authentication.adoc:89
#, no-wrap, fuzzy
msgid "Obtaining the certificate"
msgstr "証明書の取得"

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:94
#, no-wrap
msgid ""
"import java.security.cert.X509Certificate;\n"
"import io.quarkus.security.credential.CertificateCredential;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-built-in-authentication.adoc:97
#, no-wrap
msgid ""
"CertificateCredential credential = identity."
"getCredential(CertificateCredential.class);\n"
"X509Certificate certificate = credential.getCertificate();\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:103
#, fuzzy
msgid ""
"The information from the client certificate can be used to enhance Quarkus "
"`SecurityIdentity`. For example, one can add new roles after checking a "
"client certificate subject name, etc.  Please see the link:security-"
"customization#security-identity-customization[SecurityIdentity "
"Customization] section for more information about customizing Quarkus "
"`SecurityIdentity`."
msgstr ""
"クライアント証明書からの情報は、Quarkusを強化するために使用することができます `SecurityIdentity` "
"。たとえば、クライアント証明書のサブジェクト名などを確認した後に、新しいロールを追加することができます。Quarkusのカスタマイズの詳細については、 "
"link:security-customization#security-identity-"
"customization[SecurityIdentity]のカスタマイズのセクションを参照してください `SecurityIdentity` 。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:109
#, fuzzy
msgid ""
"By default Quarkus does what we call proactive authentication. This means "
"that if an incoming request has a credential then that request will always "
"be authenticated (even if the target page does not require authentication)."
msgstr ""
"デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます（ターゲットページが認証を必要としない場合でも）。"

#. type: Plain text
#: upstream/_guides/security-built-in-authentication.adoc:112
#, fuzzy
msgid ""
"This means that requests with an invalid credential will always be rejected, "
"even for public pages. You can change this behavior and only authenticate "
"when required by setting `quarkus.http.auth.proactive=false`."
msgstr ""
"これは、公開ページであっても、無効なクレデンシャルを持つリクエストは常に拒否されることを意味します。この動作を変更して、 `quarkus.http."
"auth.proactive=false` を設定することで必要な場合のみ認証を行うことができます。"

#. type: delimited block =
#: upstream/_guides/status-include.adoc:4
#, fuzzy
msgid "This technology is considered {extension-status}."
msgstr "この技術は、{extension-status}と考えられています。"

#. type: delimited block =
#: upstream/_guides/status-include.adoc:9
#, fuzzy
msgid ""
"In _experimental_ mode, early feedback is requested to mature the idea.  "
"There is no guarantee of stability nor long term presence in the platform "
"until the solution matures.  Feedback is welcome on our https://groups."
"google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://"
"github.com/quarkusio/quarkus/issues[GitHub issue tracker]."
msgstr ""
"_実験_モードでは、アイデアを成熟させるために早期のフィードバックが求められます。ソリューションが成熟するまでの間、プラットフォームの安定性や長期的な存在を保証するものではありません。フィードバックは "
"link:https://groups.google.com/d/forum/quarkus-dev[メーリングリスト]や link:https://"
"github.com/quarkusio/quarkus/issues[GitHubのイシュートラッカー]で受け付けています。"

#. type: delimited block =
#: upstream/_guides/status-include.adoc:14
#, fuzzy
msgid ""
"In _preview_, backward compatibility and presence in the ecosystem is not "
"guaranteed.  Specific improvements might require to change configuration or "
"APIs and plans to become _stable_ are under way.  Feedback is welcome on our "
"https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in "
"our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker]."
msgstr ""
"_プレビュー_では、下位互換性やエコシステムでの存在は保証されていません。具体的な改善には設定や API の変更が必要になるかもしれませんが、 "
"_安定_版になるための計画は現在進行中です。フィードバックは link:https://groups.google.com/d/forum/"
"quarkus-dev[メーリングリスト]や link:https://github.com/quarkusio/quarkus/"
"issues[GitHub のイシュートラッカー]で受け付けています。"

#. type: delimited block =
#: upstream/_guides/status-include.adoc:17
#, fuzzy
msgid ""
"Being _stable_, backward compatibility and presence in the ecosystem are "
"taken very seriously."
msgstr "_安定している_こと、下位互換性があること、生態系の中に存在していることは、非常に深刻に受け止められています。"

#. type: delimited block =
#: upstream/_guides/status-include.adoc:20
#, fuzzy
msgid ""
"For a full list of possible extension statuses, check our https://quarkus.io/"
"faq/#extension-status[FAQ entry]."
msgstr ""
"可能な拡張ステータスの完全なリストについては、 link:https://quarkus.io/faq/#extension-"
"status[FAQの項目を]参照してください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/validation.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Validation with Hibernate Validator"
msgstr "Quarkus - Hibernate Validatorによる検証"

#. type: Plain text
#: upstream/_guides/validation.adoc:11
#, fuzzy
msgid "This guide covers how to use Hibernate Validator/Bean Validation for:"
msgstr "このガイドでは、Hibernate Validator/Bean Validation の使用方法について説明します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:13
#, fuzzy
msgid "validating the input/output of your REST services;"
msgstr "REST サービスの入出力を検証します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:14
#, fuzzy
msgid ""
"validating the parameters and return values of the methods of your business "
"services."
msgstr "ビジネスサービスのメソッドのパラメータと戻り値を検証します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:29
#, fuzzy
msgid ""
"The application built in this guide is quite simple. The user fills a form "
"on a web page.  The web page sends the form content to the `BookResource` as "
"JSON (using Ajax). The `BookResource` validates the user input and returns "
"the _result_ as JSON."
msgstr ""
"このガイドで構築されたアプリケーションは非常にシンプルです。ユーザーはウェブページ上でフォームを入力します。Web ページはフォームの内容を JSON "
"として `BookResource` に送信します (Ajax を使用)。 `BookResource` はユーザーの入力を検証し、 _結果を_JSON "
"として返します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:31
#, fuzzy
msgid "image:validation-guide-architecture.png[alt=Architecture]"
msgstr "image:validation-guide-architecture.png[alt=Architecture]"

#. type: Plain text
#: upstream/_guides/validation.adoc:40
#, fuzzy
msgid ""
"The solution is located in the `validation-quickstart` {quickstarts-tree-"
"url}/validation-quickstart[directory]."
msgstr ""
"ソリューションは `validation-quickstart` {quickstarts-tree-url}/validation-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:54
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=validation-quickstart \\\n"
"    -DclassName=\"org.acme.validation.BookResource\" \\\n"
"    -Dpath=\"/books\" \\\n"
"    -Dextensions=\"resteasy-jackson, hibernate-validator\"\n"
"cd validation-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:57
#, fuzzy
msgid ""
"This command generates a Maven structure importing the RESTEasy/JAX-RS, "
"Jackson and Hibernate Validator/Bean Validation extensions."
msgstr ""
"このコマンドは、RESTEasy/JAX-RS、Jackson、およびHibernate Validator/Bean "
"Validation拡張機能をインポートするMaven構造体を生成します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:60
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`hibernate-validator` extension to your project by running the following "
"command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`hibernate-validator` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:64
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"hibernate-validator\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:74
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-hibernate-validator</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/validation.adoc:76
#, no-wrap, fuzzy
msgid "Accessing the Validator"
msgstr "バリデータへのアクセス"

#. type: Plain text
#: upstream/_guides/validation.adoc:79
#, fuzzy
msgid ""
"Edit the `org.acme.validation.BookResource` class, and inject the "
"`Validator` object as follows:"
msgstr ""
"`org.acme.validation.BookResource` クラスを編集し、以下のように `Validator` オブジェクトを注入します。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:84
#, no-wrap
msgid "@Inject\n"
"Validator validator;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:87
#, fuzzy
msgid "The `Validator` allows checking constraints on a specific object."
msgstr "`Validator` では、特定のオブジェクトに対する制約をチェックすることができます。"

#. type: Title ==
#: upstream/_guides/validation.adoc:88
#, no-wrap, fuzzy
msgid "Constraints"
msgstr "制約"

#. type: Plain text
#: upstream/_guides/validation.adoc:92
#, fuzzy
msgid ""
"In this application, we are going to test an elementary object, but we "
"support complicated constraints and can validate graphs of objects.  Create "
"the `org.acme.validation.Book` class with the following content:"
msgstr ""
"今回のアプリケーションでは、素のオブジェクトをテストすることになりますが、複雑な制約にも対応しており、オブジェクトのグラフを検証することができます。以下の内容で "
"`org.acme.validation.Book` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:96 upstream/_guides/validation.adoc:213
#, no-wrap
msgid "package org.acme.validation;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:99
#, no-wrap
msgid ""
"import javax.validation.constraints.NotBlank;\n"
"import javax.validation.constraints.Min;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:101
#, no-wrap
msgid "public class Book {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:104
#, no-wrap
msgid ""
"    @NotBlank(message=\"Title may not be blank\")\n"
"    public String title;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:107
#, no-wrap
msgid ""
"    @NotBlank(message=\"Author may not be blank\")\n"
"    public String author;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:111
#, no-wrap
msgid ""
"    @Min(message=\"Author has been very lazy\", value=1)\n"
"    public double pages;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:115
#, fuzzy
msgid ""
"Constraints are added on fields, and when an object is validated, the values "
"are checked.  The getter and setter methods are also used for JSON mapping."
msgstr ""
"フィールドに制約を加え、オブジェクトが検証されると値がチェックされます。ゲッターメソッドとセッターメソッドはJSONマッピングにも使われています。"

#. type: Title ==
#: upstream/_guides/validation.adoc:116
#, no-wrap, fuzzy
msgid "JSON mapping and validation"
msgstr "JSONのマッピングと検証"

#. type: Plain text
#: upstream/_guides/validation.adoc:120
#, fuzzy
msgid "Back to the `BookResource` class.  Add the following method:"
msgstr "`BookResource` クラスに戻ります。以下のメソッドを追加します。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:133
#, no-wrap
msgid ""
"@Path(\"/manual-validation\")\n"
"@POST\n"
"public Result tryMeManualValidation(Book book) {\n"
"    Set<ConstraintViolation<Book>> violations = validator.validate(book);\n"
"    if (violations.isEmpty()) {\n"
"        return new Result(\"Book is valid! It was validated by manual "
"validation.\");\n"
"    } else {\n"
"        return new Result(violations);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:136
#, fuzzy
msgid ""
"Yes it does not compile, `Result` is missing, but we will add it very soon."
msgstr "はい、それはコンパイルされません。 `Result` がありませんが、私たちはすぐに追加します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:138
#, fuzzy
msgid ""
"The method parameter (`book`) is created from the JSON payload automatically."
""
msgstr "メソッドパラメータ( `book`)は、JSONペイロードから自動的に作成されます。"

#. type: Plain text
#: upstream/_guides/validation.adoc:143
#, fuzzy
msgid ""
"The method uses the `Validator` to check the payload.  It returns a set of "
"violations.  If this set is empty, it means the object is valid.  In case of "
"failures, the messages are concatenated and sent back to the browser."
msgstr ""
"このメソッドは `Validator` "
"を使用してペイロードをチェックします。これは違反のセットを返します。このセットが空の場合は、オブジェクトが有効であることを意味します。失敗した場合は、メッセージを連結してブラウザに送り返します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:145
#, fuzzy
msgid "Let's now create the `Result` class as an inner class:"
msgstr "それでは、 `Result` クラスをインナークラスとして作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:149
#, no-wrap
msgid "public static class Result {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:154
#, no-wrap
msgid ""
"    Result(String message) {\n"
"        this.success = true;\n"
"        this.message = message;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:161
#, no-wrap
msgid ""
"    Result(Set<? extends ConstraintViolation<?>> violations) {\n"
"        this.success = false;\n"
"        this.message = violations.stream()\n"
"             .map(cv -> cv.getMessage())\n"
"             .collect(Collectors.joining(\", \"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:164
#, no-wrap
msgid "    private String message;\n"
"    private boolean success;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:168
#, no-wrap
msgid "    public String getMessage() {\n"
"        return message;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:172
#, no-wrap
msgid "    public boolean isSuccess() {\n"
"        return success;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:178
#, fuzzy
msgid ""
"The class is very simple and only contains 2 fields and the associated "
"getters and setters.  Because we indicate that we produce JSON, the mapping "
"to JSON is made automatically."
msgstr ""
"このクラスは非常にシンプルで、2つのフィールドとそれに関連するゲッターとセッターを含んでいるだけです。JSONを生成することを示しているので、JSONへのマッピングは自動的に行われます。"

#. type: Title ==
#: upstream/_guides/validation.adoc:179
#, no-wrap, fuzzy
msgid "REST end point validation"
msgstr "ＲＥＳＴエンドポイント検証"

#. type: Plain text
#: upstream/_guides/validation.adoc:185
#, fuzzy
msgid ""
"While using the `Validator` manually might be useful for some advanced "
"usage, if you simply want to validate the parameters or the return value or "
"your REST end point, you can annotate it directly, either with constraints "
"(`@NotNull`, `@Digits`...)  or with `@Valid` (which will cascade the "
"validation to the bean)."
msgstr ""
"`Validator` "
"を手動で使用することは、高度な使用法には便利かもしれませんが、単にパラメータや戻り値、RESTエンドポイントを検証したい場合は、制約( "
"`@NotNull`, `@Digits`...)や `@Valid` "
"(ビーンに検証をカスケードします)を使用して直接アノテーションを行うことができます。"

#. type: Plain text
#: upstream/_guides/validation.adoc:187
#, fuzzy
msgid ""
"Let's create an end point validating the `Book` provided in the request:"
msgstr "リクエストで提供された `Book` を検証するエンドポイントを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:197
#, no-wrap
msgid ""
"@Path(\"/end-point-method-validation\")\n"
"@POST\n"
"@Produces(MediaType.APPLICATION_JSON)\n"
"@Consumes(MediaType.APPLICATION_JSON)\n"
"public Result tryMeEndPointMethodValidation(@Valid Book book) {\n"
"    return new Result(\"Book is valid! It was validated by end point method "
"validation.\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:200
#, fuzzy
msgid ""
"As you can see, we don't have to manually validate the provided `Book` "
"anymore as it is automatically validated."
msgstr "ご覧のように、提供された `Book` は自動的に検証されるので、もう手動で検証する必要はありません。"

#. type: Plain text
#: upstream/_guides/validation.adoc:203
#, fuzzy
msgid ""
"If a validation error is triggered, a violation report is generated and "
"serialized as JSON as our end point produces a JSON output.  It can be "
"extracted and manipulated to display a proper error message."
msgstr ""
"検証エラーが発生した場合、違反レポートが生成され、エンドポイントがJSON出力を生成するため、JSONとしてシリアライズされます。これを抽出して操作することで、適切なエラーメッセージを表示することができます。"

#. type: Title ==
#: upstream/_guides/validation.adoc:204
#, no-wrap, fuzzy
msgid "Service method validation"
msgstr "サービスメソッドの検証"

#. type: Plain text
#: upstream/_guides/validation.adoc:207
#, fuzzy
msgid ""
"It might not always be handy to have the validation rules declared at the "
"end point level as it could duplicate some business validation."
msgstr "エンドポイントレベルで宣言されたバリデーションルールは、ビジネスバリデーションと重複する可能性があるため、必ずしも便利とは限りません。"

#. type: Plain text
#: upstream/_guides/validation.adoc:209
#, fuzzy
msgid ""
"The best option is then to annotate a method of your business service with "
"your constraints (or in our particular case with `@Valid`):"
msgstr "最良の選択肢は、ビジネスサービスのメソッドに制約をアノテーションすることです（私たちの場合は `@Valid` ）。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:216
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.validation.Valid;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:219
#, no-wrap
msgid "@ApplicationScoped\n"
"public class BookService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:224
#, no-wrap
msgid ""
"    public void validateBook(@Valid Book book) {\n"
"        // your business logic here\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:227
#, fuzzy
msgid ""
"Calling the service in your rest end point triggers the `Book` validation "
"automatically:"
msgstr "残りのエンドポイントでサービスを呼び出すと、自動的に `Book` の検証が行われます。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:231
#, no-wrap
msgid "@Inject BookService bookService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:242
#, no-wrap
msgid ""
"@Path(\"/service-method-validation\")\n"
"@POST\n"
"public Result tryMeServiceMethodValidation(Book book) {\n"
"    try {\n"
"        bookService.validateBook(book);\n"
"        return new Result(\"Book is valid! It was validated by service "
"method validation.\");\n"
"    } catch (ConstraintViolationException e) {\n"
"        return new Result(e.getConstraintViolations());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:246
#, fuzzy
msgid ""
"Note that, if you want to push the validation errors to the frontend, you "
"have to catch the exception and push the information yourselves as they will "
"not be automatically pushed to the JSON output."
msgstr "検証エラーをフロントエンドにプッシュしたい場合は、例外をキャッチして自分で情報をプッシュしなければなりません。"

#. type: Plain text
#: upstream/_guides/validation.adoc:248
#, fuzzy
msgid ""
"Keep in mind that you usually don't want to expose to the public the "
"internals of your services"
msgstr "あなたは通常、あなたのサービスの内部を公開したくないことを覚えておいてください。"

#. type: Plain text
#: upstream/_guides/validation.adoc:249
#, fuzzy
msgid ""
"and especially not the validated value contained in the violation object."
msgstr "特に違反オブジェクトに含まれる検証済みの値ではありません。"

#. type: Title ==
#: upstream/_guides/validation.adoc:250
#, no-wrap, fuzzy
msgid "A frontend"
msgstr "フロントエンド"

#. type: Plain text
#: upstream/_guides/validation.adoc:255
#, fuzzy
msgid ""
"Now let's add the simple web page to interact with our `BookResource`.  "
"Quarkus automatically serves static resources contained in the `META-INF/"
"resources` directory.  In the `src/main/resources/META-INF/resources` "
"directory, replace the `index.html` file with the content from this "
"{quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/"
"resources/index.html[index.html] file in it."
msgstr ""
"それでは、 `BookResource`.Quarkusと対話するためのシンプルなウェブページを追加してみましょう。Quarkusは、 `META-"
"INF/resources` ディレクトリに含まれる静的リソースを自動的に提供します。 `src/main/resources/META-INF/"
"resources` ディレクトリで、 `index.html` ファイルをこの {quickstarts-blob-url}/validation-"
"quickstart/src/main/resources/META-INF/resources/index.html[index.html] "
"ファイルの内容に置き換えます。"

#. type: Plain text
#: upstream/_guides/validation.adoc:259
#, fuzzy
msgid "Now, let's see our application in action. Run it with:"
msgstr "では、実際にアプリケーションを見てみましょう。これを使って実行してみてください。"

#. type: Plain text
#: upstream/_guides/validation.adoc:266
#, fuzzy
msgid "Then, open your browser to http://localhost:8080/:"
msgstr "そして、ブラウザを開いて http://localhost:8080/ 。"

#. type: Plain text
#: upstream/_guides/validation.adoc:268
#, fuzzy
msgid "Enter the book details (valid or invalid)"
msgstr "書籍の詳細を入力してください（有効または無効"

#. type: Plain text
#: upstream/_guides/validation.adoc:269
#, fuzzy
msgid ""
"Click on the _Try me..._ buttons to check if your data is valid using one of "
"the methods we presented above."
msgstr "_Try me_...ボタンをクリックして、上記で紹介した方法のいずれかを使用してデータが有効かどうかを確認してください。"

#. type: Plain text
#: upstream/_guides/validation.adoc:271
#, fuzzy
msgid "image:validation-guide-screenshot.png[alt=Application]"
msgstr "image:validation-guide-screenshot.png[alt=Application]"

#. type: Plain text
#: upstream/_guides/validation.adoc:274
#, fuzzy
msgid ""
"As usual, the application can be packaged using `./mvnw clean package` and "
"executed using the `-runner.jar` file.  You can also build the native "
"executable using `./mvnw package -Pnative`."
msgstr ""
"いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` "
"ファイルを使って実行することができます。また、 `./mvnw package -Pnative` "
"を使用してネイティブの実行ファイルをビルドすることもできます。"

#. type: Title ===
#: upstream/_guides/validation.adoc:277
#, no-wrap, fuzzy
msgid "Hibernate Validator extension and CDI"
msgstr "Hibernate Validator 拡張機能と CDI"

#. type: Plain text
#: upstream/_guides/validation.adoc:280
#, fuzzy
msgid "The Hibernate Validator extension is tightly integrated with CDI."
msgstr "Hibernate ValidatorエクステンションはCDIと緊密に統合されています。"

#. type: Title ====
#: upstream/_guides/validation.adoc:281
#, no-wrap, fuzzy
msgid "Configuring the ValidatorFactory"
msgstr "ValidatorFactoryの設定"

#. type: Plain text
#: upstream/_guides/validation.adoc:284
#, fuzzy
msgid ""
"Sometimes, you might need to configure the behavior of the "
"`ValidatorFactory`, for instance to use a specific `ParameterNameProvider`."
msgstr ""
"時には、 `ValidatorFactory` の動作を設定する必要があるかもしれません , 例えば、特定の "
"`ParameterNameProvider` を使用するために ."

#. type: Plain text
#: upstream/_guides/validation.adoc:287
#, fuzzy
msgid ""
"While the `ValidatorFactory` is instantiated by Quarkus itself, you can very "
"easily tweak it by declaring replacement beans that will be injected in the "
"configuration."
msgstr ""
"`ValidatorFactory` は、Quarkus "
"自体によってインスタンス化されていますが、設定に注入される置換ビーンを宣言することで、非常に簡単に微調整することができます。"

#. type: Plain text
#: upstream/_guides/validation.adoc:289
#, fuzzy
msgid ""
"If you create a bean of the following types in your application, it will "
"automatically be injected into the `ValidatorFactory` configuration:"
msgstr "アプリケーションで以下のタイプのBeanを作成すると、自動的に `ValidatorFactory` の設定に注入されます。"

#. type: Plain text
#: upstream/_guides/validation.adoc:291
#, fuzzy
msgid "`javax.validation.ClockProvider`"
msgstr "`javax.validation.ClockProvider`"

#. type: Plain text
#: upstream/_guides/validation.adoc:292
#, fuzzy
msgid "`javax.validation.ConstraintValidator`"
msgstr "`javax.validation.ConstraintValidator`"

#. type: Plain text
#: upstream/_guides/validation.adoc:293
#, fuzzy
msgid "`javax.validation.ConstraintValidatorFactory`"
msgstr "`javax.validation.ConstraintValidatorFactory`"

#. type: Plain text
#: upstream/_guides/validation.adoc:294
#, fuzzy
msgid "`javax.validation.MessageInterpolator`"
msgstr "`javax.validation.MessageInterpolator`"

#. type: Plain text
#: upstream/_guides/validation.adoc:295
#, fuzzy
msgid "`javax.validation.ParameterNameProvider`"
msgstr "`javax.validation.ParameterNameProvider`"

#. type: Plain text
#: upstream/_guides/validation.adoc:296
#, fuzzy
msgid "`javax.validation.TraversableResolver`"
msgstr "`javax.validation.TraversableResolver`"

#. type: Plain text
#: upstream/_guides/validation.adoc:297
#, fuzzy
msgid ""
"`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`"
msgstr ""
"`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`"

#. type: Plain text
#: upstream/_guides/validation.adoc:298
#, fuzzy
msgid "`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`"
msgstr "`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`"

#. type: Plain text
#: upstream/_guides/validation.adoc:300
#, fuzzy
msgid "You don't have to wire anything."
msgstr "何も配線しなくても大丈夫です。"

#. type: delimited block =
#: upstream/_guides/validation.adoc:304
#, fuzzy
msgid "Obviously, for each listed type, you can declare only one bean."
msgstr "明らかに、リストされた各型に対して、1つのBeanだけを宣言することができます。"

#. type: delimited block =
#: upstream/_guides/validation.adoc:306
#, fuzzy
msgid "These beans should be declared as `@ApplicationScoped`."
msgstr "これらの豆は、 `@ApplicationScoped` として宣言する必要があります。"

#. type: Title ====
#: upstream/_guides/validation.adoc:308
#, no-wrap, fuzzy
msgid "Constraint validators as beans"
msgstr "ビーンズとしての制約バリデータ"

#. type: Plain text
#: upstream/_guides/validation.adoc:311
#, fuzzy
msgid "You can declare your constraint validators as CDI beans:"
msgstr "制約バリデータをCDIビーンとして宣言することができます。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:316
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyConstraintValidator implements "
"ConstraintValidator<MyConstraint, String> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:319
#, no-wrap
msgid "    @Inject\n"
"    MyService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:325
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean isValid(String value, ConstraintValidatorContext context) "
"{\n"
"        if (value == null) {\n"
"            return true;\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/validation.adoc:329
#, no-wrap
msgid "        return service.validate(value);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:333
#, fuzzy
msgid ""
"When initializing a constraint validator of a given type, Quarkus will check "
"if a bean of this type is available and, if so, it will use it instead of "
"instantiating one."
msgstr ""
"指定された型の制約バリデータを初期化する際に、Quarkusはこの型のBeanが利用可能かどうかをチェックし、利用可能な場合はインスタンスを作成する代わりにそれを使用します。"

#. type: Plain text
#: upstream/_guides/validation.adoc:335
#, fuzzy
msgid ""
"Thus, as demonstrated in our example, you can fully use injection in your "
"constraint validator beans."
msgstr "このように、例で示したように、制約バリデータビーンでインジェクションを完全に使用することができます。"

#. type: delimited block =
#: upstream/_guides/validation.adoc:339
#, fuzzy
msgid ""
"Except in very specific situations, it is recommended to make the said beans "
"`@ApplicationScoped`."
msgstr "非常に特定の状況を除いて、それは言った豆を作ることをお勧めします `@ApplicationScoped`."

#. type: Title ===
#: upstream/_guides/validation.adoc:341
#, no-wrap, fuzzy
msgid "Validation and localization"
msgstr "バリデーションとローカリゼーション"

#. type: Plain text
#: upstream/_guides/validation.adoc:344
#, fuzzy
msgid ""
"By default, constraint violation messages will be returned in the build "
"system locale."
msgstr "デフォルトでは、制約違反のメッセージはビルドシステムのロケールで返されます。"

#. type: Plain text
#: upstream/_guides/validation.adoc:346
#, fuzzy
msgid ""
"You can configure this behavior by adding the following configuration in "
"your `application.properties`:"
msgstr "この動作を設定するには、 `application.properties`."

#. type: delimited block -
#: upstream/_guides/validation.adoc:351
#, no-wrap
msgid "# The default locale to use\n"
"quarkus.default-locale=fr-FR\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/validation.adoc:355
#, fuzzy
msgid ""
"If you are using RESTEasy, in the context of a JAX-RS endpoint, Hibernate "
"Validator will automatically resolve the optimal locale to use from the "
"`Accept-Language` HTTP header, provided the supported locales have been "
"properly specified in the `application.properties`:"
msgstr ""
"`application.properties`RESTEasyを使用している場合、JAX-RSエンドポイントのコンテキストでは、 `Accept-"
"Language` HTTPヘッダから使用する最適なロケールをHibernate Validatorが自動的に解決します。"

#. type: delimited block -
#: upstream/_guides/validation.adoc:360
#, no-wrap
msgid ""
"# The list of all the supported locales\n"
"quarkus.locales=en-US,es-ES,fr-FR\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/validation.adoc:363
#, no-wrap, fuzzy
msgid "Hibernate Validator Configuration Reference"
msgstr "Hibernate Validator設定リファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/microprofile-metrics.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - MicroProfile Metrics"
msgstr "Quarkus - MicroProfile Metrics"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:12
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize the "
"MicroProfile Metrics specification through the SmallRye Metrics extension."
msgstr ""
"このガイドでは、QuarkusアプリケーションがSmallRye Metrics拡張機能を使用してMicroProfile "
"Metrics仕様を利用する方法を説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:15
#, fuzzy
msgid ""
"MicroProfile Metrics allows applications to gather various metrics and "
"statistics that provide insights into what is happening inside the "
"application."
msgstr ""
"MicroProfileメトリクスは、アプリケーションで様々なメトリクスや統計情報を収集して、アプリケーション内で何が起こっているかについての洞察を提供します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:19
#, fuzzy
msgid ""
"The metrics can be read remotely using JSON format or the OpenMetrics "
"format, so that they can be processed by additional tools such as "
"Prometheus, and stored for analysis and visualisation."
msgstr ""
"このように、JSON 形式または OpenMetrics 形式を使用してメトリクスをリモートで読み取ることができるため、Prometheus "
"などの追加ツールで処理したり、分析や可視化のために保存したりすることができます。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:23
#, fuzzy
msgid ""
"Apart from application-specific metrics, which are described in this guide, "
"you may also utilize built-in metrics exposed by various Quarkus extensions. "
"These are described in the guide for each particular extension that supports "
"built-in metrics."
msgstr ""
"このガイドで説明されているアプリケーション固有のメトリクスとは別に、Quarkusのさまざまな拡張機能によって公開されているビルトインメトリクスを利用することもできます。これらについては、ビルトインメトリクスをサポートしている各拡張機能のガイドで説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:26
#, fuzzy
msgid ""
"link:micrometer[Micrometer] is the recommended approach to metrics for "
"Quarkus.  Use the MicroProfile Metrics extension when it's required to "
"retain MicroProfile specification compatibility."
msgstr ""
"link:"
"micrometer[マイクロメーターは]、Quarkusのメトリクスへの推奨アプローチです。MicroProfile仕様の互換性を維持する必要がある場合は、MicroProfile "
"Metrics拡張機能を使用します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:40
#, fuzzy
msgid ""
"In this example, we build a very simple microservice which offers one REST "
"endpoint and that endpoint serves for determining whether a number is prime. "
"The implementation class is annotated with some metric annotations so that "
"while responding to user's requests, some metrics are gathered. The meaning "
"of each metric will be explained later."
msgstr ""
"この例では、1つのRESTエンドポイントを提供する非常にシンプルなマイクロサービスを構築し、そのエンドポイントは数値が素数であるかどうかを判断するのに役立ちます。実装クラスは、ユーザのリクエストに応答している間に、いくつかのメトリクスが収集されるように、いくつかのメトリックアノテーションでアノテーションされています。各メトリックの意味は後ほど説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:49
#, fuzzy
msgid ""
"The solution is located in the `microprofile-metrics-quickstart` "
"{quickstarts-tree-url}/microprofile-metrics-quickstart[directory]."
msgstr ""
"ソリューションは `microprofile-metrics-quickstart` {quickstarts-tree-url}/"
"microprofile-metrics-quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:61
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=microprofile-metrics-quickstart \\\n"
"    -Dextensions=\"smallrye-metrics\"\n"
"cd microprofile-metrics-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:64
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `smallrye-metrics` "
"extension which is an implementation of the MicroProfile Metrics "
"specification used in Quarkus."
msgstr ""
"このコマンドは、Quarkusで使用されているMicroProfile Metrics仕様の実装である `smallrye-metrics` "
"拡張子をインポートして、Mavenプロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:67
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-metrics` extension to your project by running the following "
"command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-metrics` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:71
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"smallrye-metrics\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:81
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-metrics</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:88
#, fuzzy
msgid ""
"The application consists of a single class that implements an algorithm for "
"checking whether a number is prime.  This algorithm is exposed over a REST "
"interface. Additionally, we need a few annotations to make sure that our "
"desired metrics are calculated over time and can be exported for manual "
"analysis or processing by additional tooling."
msgstr ""
"このアプリケーションは、数値が素数であるかどうかをチェックするアルゴリズムを実装した単一のクラスで構成されています。このアルゴリズムは、RESTインターフェースを介して公開されています。さらに、必要なメトリクスが時間の経過とともに計算され、手動分析や追加のツールによる処理のためにエクスポートできることを確認するために、いくつかのアノテーションが必要です。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:90
#, fuzzy
msgid "The metrics that we will gather are these:"
msgstr "集めようとしているメトリクスは、このようなものです。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:92
#: upstream/_guides/microprofile-metrics.adoc:210
#, fuzzy
msgid ""
"`performedChecks`: A counter which is increased by one each time the user "
"asks about a number."
msgstr "`performedChecks`: ユーザーが数字を尋ねるたびに1つ増えるカウンター。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:93
#: upstream/_guides/microprofile-metrics.adoc:211
#, fuzzy
msgid ""
"`highestPrimeNumberSoFar`: This is a gauge that stores the highest number "
"that was asked about by the user and which was determined to be prime."
msgstr "`highestPrimeNumberSoFar`: ユーザーから質問されて素数と判断された最高の数字を保存するゲージです。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:94
#, fuzzy
msgid ""
"`checksTimer`: This is a timer, therefore a compound metric that benchmarks "
"how much time the primality tests take. We will explain that one in more "
"details later."
msgstr ""
"`checksTimer`: "
"これはタイマーであり、したがって、プライマリテストにどれだけの時間がかかるかをベンチマークする複合的なメトリックです。これについては後ほど詳しく説明します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:96
#, fuzzy
msgid "The full source code looks like this:"
msgstr "完全なソースコードは以下のようになります。"

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:100
#, no-wrap
msgid "package org.acme.microprofile.metrics;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:106
#, no-wrap
msgid ""
"import org.eclipse.microprofile.metrics.MetricUnits;\n"
"import org.eclipse.microprofile.metrics.annotation.Counted;\n"
"import org.eclipse.microprofile.metrics.annotation.Gauge;\n"
"import org.eclipse.microprofile.metrics.annotation.Timed;\n"
"import org.jboss.resteasy.annotations.jaxrs.PathParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:114
#, no-wrap
msgid "@Path(\"/\")\n"
"public class PrimeNumberChecker {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:116
#, no-wrap
msgid "    private long highestPrimeNumberSoFar = 2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:145
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{number}\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    @Counted(name = \"performedChecks\", description = \"How many primality "
"checks have been performed.\")\n"
"    @Timed(name = \"checksTimer\", description = \"A measure of how long it "
"takes to perform the primality test.\", unit = MetricUnits.MILLISECONDS)\n"
"    public String checkIfPrime(@PathParam long number) {\n"
"        if (number < 1) {\n"
"            return \"Only natural numbers can be prime numbers.\";\n"
"        }\n"
"        if (number == 1) {\n"
"            return \"1 is not prime.\";\n"
"        }\n"
"        if (number == 2) {\n"
"                    return \"2 is prime.\";\n"
"        }\n"
"        if (number % 2 == 0) {\n"
"            return number + \" is not prime, it is divisible by 2.\";\n"
"        }\n"
"        for (int i = 3; i < Math.floor(Math.sqrt(number)) + 1; i = i + 2) {\n"
"            if (number % i == 0) {\n"
"                return number + \" is not prime, is divisible by \" + i + \"."
"\";\n"
"            }\n"
"        }\n"
"        if (number > highestPrimeNumberSoFar) {\n"
"            highestPrimeNumberSoFar = number;\n"
"        }\n"
"        return number + \" is prime.\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:150
#, no-wrap
msgid ""
"    @Gauge(name = \"highestPrimeNumberSoFar\", unit = MetricUnits.NONE, "
"description = \"Highest prime number so far.\")\n"
"    public Long highestPrimeNumberSoFar() {\n"
"        return highestPrimeNumberSoFar;\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/microprofile-metrics.adoc:154
#, no-wrap, fuzzy
msgid "Running and using the application"
msgstr "アプリケーションの実行と使用"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:157
#, fuzzy
msgid ""
"To run the microservice in dev mode, use `./mvnw clean compile quarkus:dev`"
msgstr "マイクロサービスをdevモードで実行するには、次のようにします。 `./mvnw clean compile quarkus:dev`"

#. type: Title ===
#: upstream/_guides/microprofile-metrics.adoc:158
#, no-wrap, fuzzy
msgid "Generate some values for the metrics"
msgstr "メトリクスの値を生成する"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:160
#, fuzzy
msgid "First, ask the endpoint whether some numbers are prime numbers."
msgstr "まず、ある数が素数であるかどうかを終点に問います。"

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:164
#, no-wrap
msgid "curl localhost:8080/350\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:167
#, fuzzy
msgid ""
"The application will respond that 350 is not a prime number because it can "
"be divided by 2."
msgstr "アプリでは、350は2で割れるので素数ではないと回答します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:169
#, fuzzy
msgid ""
"Now for some large prime number so that the test takes a bit more time:"
msgstr "さて、テストにもう少し時間がかかるように、いくつかの大きな素数のために。"

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:173
#, no-wrap
msgid "curl localhost:8080/629521085409773\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:177
#, fuzzy
msgid ""
"The application will respond that 629521085409773 is a prime number.  If you "
"want, try some more calls with numbers of your choice."
msgstr "アプリは629521085409773が素数であることを回答します。もしよろしければ、お好きな番号でもう何回か電話をかけてみてください。"

#. type: Title ===
#: upstream/_guides/microprofile-metrics.adoc:178
#, no-wrap, fuzzy
msgid "Review the generated metrics"
msgstr "生成されたメトリクスを確認する"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:181
#, fuzzy
msgid ""
"To view the metrics, execute `curl -H\"Accept: application/json\" localhost:"
"8080/metrics/application` You will receive a response such as:"
msgstr ""
"メトリクスを表示するには、 `curl -H\"Accept: application/json\" localhost:8080/metrics/"
"application` を実行すると、次のようなレスポンスが表示されます。"

#. type: delimited block -
#: upstream/_guides/microprofile-metrics.adoc:205
#, no-wrap
msgid ""
"{\n"
"  \"org.acme.microprofile.metrics.PrimeNumberChecker.checksTimer\" : {\n"
"    \"p50\": 217.231273,\n"
"    \"p75\": 217.231273,\n"
"    \"p95\": 217.231273,\n"
"    \"p98\": 217.231273,\n"
"    \"p99\": 217.231273,\n"
"    \"p999\": 217.231273,\n"
"    \"min\": 0.58961,\n"
"    \"mean\": 112.15909190834819,\n"
"    \"max\": 217.231273,\n"
"    \"stddev\": 108.2721053982776,\n"
"    \"count\": 2,\n"
"    \"meanRate\": 0.04943519091742238,\n"
"    \"oneMinRate\": 0.2232140583080189,\n"
"    \"fiveMinRate\": 0.3559527083952095,\n"
"    \"fifteenMinRate\": 0.38474303050928976\n"
"  },\n"
"  \"org.acme.microprofile.metrics.PrimeNumberChecker.performedChecks\" : 2,\n"
"  \"org.acme.microprofile.metrics.PrimeNumberChecker."
"highestPrimeNumberSoFar\" : 629521085409773\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:208
#, fuzzy
msgid "Let's explain the meaning of each metric:"
msgstr "それぞれのメトリックの意味を説明しましょう。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:212
#, fuzzy
msgid ""
"`checksTimer`: This is a timer, therefore a compound metric that benchmarks "
"how much time the primality tests take. All durations are measured in "
"milliseconds. It consists of these values:"
msgstr ""
"`checksTimer`: "
"これはタイマーであり、したがって、プライマリテストにどれだけの時間がかかるかをベンチマークする複合メトリックです。すべての持続時間はミリ秒単位で測定されます。これらの値で構成されています。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:213
#, fuzzy
msgid ""
"`min`: The shortest duration it took to perform a primality test, probably "
"it was performed for a small number."
msgstr "`min`: 原始性試験を行うのにかかった時間が最も短く、おそらく少数のために行われたのではないかと思います。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:214
#, fuzzy
msgid ""
"`max`: The longest duration, probably it was with a large prime number."
msgstr "`max`: 最長持続時間、たぶん大きな素数と一緒だった。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:215
#, fuzzy
msgid "`mean`: The mean value of the measured durations."
msgstr "`mean`: 測定された持続時間の平均値。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:216
#, fuzzy
msgid "`stddev`: The standard deviation."
msgstr "`stddev`: 標準偏差です。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:217
#, fuzzy
msgid ""
"`count`: The number of observations (so it will be the same value as "
"`performedChecks`)."
msgstr "`count`: オブザベーションの数（だから `performedChecks` と同じ値になります）。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:218
#, fuzzy
msgid ""
"`p50, p75, p95, p99, p999`: Percentiles of the durations. For example the "
"value in `p95` means that 95 % of the measurements were faster than this "
"duration."
msgstr ""
"`p50, p75, p95, p99, p999`: 持続時間のパーセンタイル。例えば、 `p95` "
"の値は、測定の95%がこの持続時間よりも速いことを意味します。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:219
#, fuzzy
msgid ""
"`meanRate, oneMinRate, fiveMinRate, fifteenMinRate`: Mean throughput and one-"
", five-, and fifteen-minute exponentially-weighted moving average throughput."
""
msgstr ""
"`meanRate, oneMinRate, fiveMinRate, fifteenMinRate`: 平均スループットと 1、5、および 15 "
"分間の指数関数的に加重された移動平均スループット。"

#. type: Plain text
#: upstream/_guides/microprofile-metrics.adoc:221
#, fuzzy
msgid ""
"If you prefer an OpenMetrics export rather than the JSON format, remove the "
"`-H\"Accept: application/json\"` argument from your command line."
msgstr ""
"JSON形式ではなくOpenMetricsのエクスポートを希望する場合は、コマンドラインから `-H\"Accept: application/"
"json\"` 引数を削除してください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/quartz.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Scheduling Periodic Tasks with Quartz"
msgstr "Quarkus - Quartzによる定期的なタスクのスケジューリング"

#. type: Plain text
#: upstream/_guides/quartz.adoc:13
#, fuzzy
msgid ""
"Modern applications often need to run specific tasks periodically.  In this "
"guide, you learn how to schedule periodic clustered tasks using the http://"
"www.quartz-scheduler.org/[Quartz] extension."
msgstr ""
"最近のアプリケーションでは、定期的に特定のタスクを実行する必要があることがよくあります。このガイドでは、 link:http://www.quartz-"
"scheduler.org/[Quartz]拡張機能を使用して定期的にクラスタ化されたタスクをスケジュールする方法を学びます。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:17
#, fuzzy
msgid ""
"If you only need to run in-memory scheduler use the link:"
"scheduler[Scheduler] extension."
msgstr "インメモリスケジューラを実行する必要がある場合は、 link:scheduler[Scheduler]拡張機能を使用してください。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:27
#, fuzzy
msgid "Docker and Docker Compose installed on your machine"
msgstr "マシンにインストールされているDockerとDocker Compose"

#. type: Plain text
#: upstream/_guides/quartz.adoc:31
#, fuzzy
msgid ""
"In this guide, we are going to expose one Rest API `tasks` to visualise the "
"list of tasks created by a Quartz job running every 10 seconds."
msgstr ""
"このガイドでは、10秒ごとに実行されるQuartzジョブによって作成されたタスクのリストを可視化するために、1つのRest API `tasks` "
"を公開します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:40
#, fuzzy
msgid ""
"The solution is located in the `quartz-quickstart` {quickstarts-tree-url}/"
"quartz-quickstart[directory]."
msgstr ""
"ソリューションは `quartz-quickstart` {quickstarts-tree-url}/quartz-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:54
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=quartz-quickstart \\\n"
"    -DclassName=\"org.acme.quartz.TaskResource\" \\\n"
"    -Dpath=\"/tasks\" \\\n"
"    -Dextensions=\"quartz,hibernate-orm-panache,flyway,resteasy-jackson,jdbc-"
"postgresql\"\n"
"cd quartz-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:63
#, fuzzy
msgid "an `org.acme.quartz.TaskResource` resource"
msgstr "`org.acme.quartz.TaskResource` リソース"

#. type: Plain text
#: upstream/_guides/quartz.adoc:66
#, fuzzy
msgid "The Maven project also imports the Quarkus Quartz extension."
msgstr "MavenプロジェクトはQuarkus Quartz拡張機能もインポートしています。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:69
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`quartz` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`quartz` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:73
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"quartz\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:83
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-quartz</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/quartz.adoc:88
#, fuzzy
msgid ""
"To use a JDBC store, the `quarkus-agroal` extension, which provides the "
"datasource support, is also required."
msgstr "JDBCストアを使用するには、データソースのサポートを提供する `quarkus-agroal` 拡張モジュールも必要です。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:90
#, no-wrap, fuzzy
msgid "Creating the Task Entity"
msgstr "タスクエンティティの作成"

#. type: Plain text
#: upstream/_guides/quartz.adoc:93
#, fuzzy
msgid ""
"In the `org.acme.quartz` package, create the `Task` class, with the "
"following content:"
msgstr "`org.acme.quartz` パッケージで、以下の内容の `Task` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:97 upstream/_guides/quartz.adoc:127
#: upstream/_guides/quartz.adoc:158 upstream/_guides/quartz.adoc:244
#: upstream/_guides/quartz.adoc:268
#, no-wrap
msgid "package org.acme.quartz;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:101
#, no-wrap
msgid ""
"import javax.persistence.Entity;\n"
"import java.time.Instant;\n"
"import javax.persistence.Table;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:103
#, no-wrap
msgid "import io.quarkus.hibernate.orm.panache.PanacheEntity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:108
#, no-wrap
msgid ""
"@Entity\n"
"@Table(name=\"TASKS\")\n"
"public class Task extends PanacheEntity { <1>\n"
"    public Instant createdAt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:112
#, no-wrap
msgid "    public Task() {\n"
"        createdAt = Instant.now();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:117
#, no-wrap
msgid ""
"    public Task(Instant time) {\n"
"        this.createdAt = time;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:119
#, fuzzy
msgid "Declare the entity using link:hibernate-orm-panache[Panache]"
msgstr "link:hibernate-orm-panache[Panache]を使用してエンティティを宣言する"

#. type: Plain text
#: upstream/_guides/quartz.adoc:123
#, fuzzy
msgid ""
"In the `org.acme.quartz` package, create the `TaskBean` class, with the "
"following content:"
msgstr "`org.acme.quartz` パッケージで、以下の内容の `TaskBean` クラスを作成します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:131
#, no-wrap
msgid "import javax.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:133
#, no-wrap
msgid "import io.quarkus.scheduler.Scheduled;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:136
#, no-wrap
msgid "@ApplicationScoped <1>\n"
"public class TaskBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:144
#, no-wrap
msgid ""
"    @Transactional\n"
"    @Scheduled(every = \"10s\") <2>\n"
"    void schedule() {\n"
"        Task task = new Task(); <3>\n"
"        task.persist(); <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:147
#, fuzzy
msgid ""
"Use the `@Scheduled` annotation to instruct Quarkus to run this method every "
"10 seconds."
msgstr "このメソッドを10秒ごとに実行するようにQuarkusに指示するには、 `@Scheduled` アノテーションを使用します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:148
#, fuzzy
msgid "Create a new `Task` with the current start time."
msgstr "現在の開始時刻で新しい `Task` を作成します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:149
#, fuzzy
msgid ""
"Persist the task in database using https://quarkus.io/guides/hibernate-orm-"
"panache[Panache]."
msgstr ""
"link:https://quarkus.io/guides/hibernate-orm-"
"panache[Panache]を使用してデータベースにタスクを持続させます。"

#. type: Title ===
#: upstream/_guides/quartz.adoc:150
#, no-wrap, fuzzy
msgid "Scheduling Jobs Programmatically"
msgstr "プログラムによるジョブのスケジューリング"

#. type: Plain text
#: upstream/_guides/quartz.adoc:154
#, fuzzy
msgid ""
"It is also possible to leverage the Quartz API directly.  You can inject the "
"underlying `org.quartz.Scheduler` in any bean:"
msgstr ""
"Quartz APIを直接活用することも可能です。どのBeanでも、その下にある `org.quartz.Scheduler` "
"を注入することができます。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:161
#, no-wrap
msgid "@ApplicationScoped\n"
"public class TaskBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:164
#, no-wrap
msgid "    @Inject\n"
"    org.quartz.Scheduler quartz; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:179
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent event) throws SchedulerException {\n"
"       JobDetail job = JobBuilder.newJob(MyJob.class)\n"
"                         .withIdentity(\"myJob\", \"myGroup\")\n"
"                         .build();\n"
"       Trigger trigger = TriggerBuilder.newTrigger()\n"
"                            .withIdentity(\"myTrigger\", \"myGroup\")\n"
"                            .startNow()\n"
"                            .withSchedule(\n"
"                               SimpleScheduleBuilder.simpleSchedule()\n"
"                                  .withIntervalInSeconds(10)\n"
"                                  .repeatForever())\n"
"                            .build();\n"
"       quartz.scheduleJob(job, trigger); <2>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:185
#, no-wrap
msgid ""
"    @Transactional\n"
"    void performTask() {\n"
"        Task task = new Task();\n"
"        task.persist();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:188
#, no-wrap
msgid ""
"    // A new instance of MyJob is created by Quartz for every job execution\n"
"    public static class MyJob implements Job {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:191
#, no-wrap
msgid "       @Inject\n"
"       TaskBean taskBean;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:195
#, no-wrap
msgid ""
"       public void execute(JobExecutionContext context) throws "
"JobExecutionException {\n"
"          taskBean.performTask(); <3>\n"
"       }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:200
#, fuzzy
msgid "Inject the underlying `org.quartz.Scheduler` instance."
msgstr "基礎となる `org.quartz.Scheduler` インスタンスを注入します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:201
#, fuzzy
msgid "Schedule a new job using the Quartz API."
msgstr "Quartz APIを使用して新しいジョブをスケジュールします。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:202
#, fuzzy
msgid ""
"Invoke the `TaskBean#performTask()` method from the job. Jobs are also link:"
"cdi[container-managed] beans if they belong to a link:cdi-reference[bean "
"archive]."
msgstr ""
"ジョブから `TaskBean#performTask()` メソッドを呼び出します。ジョブは、 link:cdi-"
"reference[ビーンアーカイブ]に属している場合、 link:cdi[コンテナ管理された]ビーンでもあります。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:204
#, fuzzy
msgid ""
"By default, the scheduler is not started unless a `@Scheduled` business "
"method is found. You may need to force the start of the scheduler for "
"\"pure\" programmatic scheduling. See also <<quartz-configuration-"
"reference>>."
msgstr ""
"デフォルトでは、 `@Scheduled` "
"ビジネスメソッドが見つからない限り、スケジューラは起動されません。純粋なプログラマティックスケジューリングを行うには、スケジューラを強制的に起動させる必要があるかもしれません。 "
"link:#quartz-configuration-reference[Quartz-configuration-"
"reference]]も参照してください。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:208
#, fuzzy
msgid ""
"Edit the `application.properties` file and add the below configuration:"
msgstr "`application.properties` ファイルを編集し、以下の設定を追加します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:213
#, no-wrap
msgid ""
"# Quartz configuration\n"
"quarkus.quartz.clustered=true <1>\n"
"quarkus.quartz.store-type=jdbc-cmt <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:219
#, no-wrap
msgid ""
"# Datasource configuration.\n"
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.username=quarkus_test\n"
"quarkus.datasource.password=quarkus_test\n"
"quarkus.datasource.jdbc.url=jdbc:postgresql://localhost/quarkus_test\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:224
#, no-wrap
msgid ""
"# Hibernate configuration\n"
"quarkus.hibernate-orm.database.generation=none\n"
"quarkus.hibernate-orm.log.sql=true\n"
"quarkus.hibernate-orm.sql-load-script=no-file\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:232
#, no-wrap
msgid ""
"# flyway configuration\n"
"quarkus.flyway.connect-retries=10\n"
"quarkus.flyway.table=flyway_quarkus_history\n"
"quarkus.flyway.migrate-at-start=true\n"
"quarkus.flyway.baseline-on-migrate=true\n"
"quarkus.flyway.baseline-version=1.0\n"
"quarkus.flyway.baseline-description=Quartz\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:235
#, fuzzy
msgid "Indicate that the scheduler will be run in clustered mode"
msgstr "スケジューラがクラスタモードで実行されることを示します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:236
#, fuzzy
msgid ""
"Use the database store to persist job related information so that they can "
"be shared between nodes"
msgstr "データベースストアを使用してジョブ関連情報を永続化し、ノード間で共有できるようにします。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:240
#, fuzzy
msgid "Edit the `TaskResource` class, and update the content to:"
msgstr "`TaskResource` クラスを編集して、内容を更新します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:254
#, no-wrap
msgid "@Path(\"/tasks\")\n"
"public class TaskResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:260
#, no-wrap
msgid ""
"    @GET\n"
"    public List<Task> listAll() {\n"
"        return Task.listAll(); <1>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:262
#, fuzzy
msgid "Retrieve the list of created tasks from the database"
msgstr "データベースから作成されたタスクのリストを取得します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:264
#, fuzzy
msgid ""
"We also need to update the tests. Edit the `TaskResourceTest` class to match:"
""
msgstr "テストも更新する必要があります。 `TaskResourceTest` クラスを一致するように編集します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:270
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:272
#, no-wrap
msgid "import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:274
#, no-wrap
msgid "import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:280
#, no-wrap
msgid "@QuarkusTest\n"
"public class TaskResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:291
#, no-wrap
msgid ""
"    @Test\n"
"    public void tasks() throws InterruptedException {\n"
"        Thread.sleep(1000); // wait at least a second to have the first task "
"created\n"
"        given()\n"
"                .when().get(\"/tasks\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(\"size()\", is(greaterThanOrEqualTo(1))); <1>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:293
#, fuzzy
msgid "Ensure that we have a `200` response and at least one task created"
msgstr "`200` のレスポンスと、少なくとも 1 つのタスクが作成されていることを確認してください。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:294
#, no-wrap, fuzzy
msgid "Creating Quartz Tables"
msgstr "石英テーブルの作成"

#. type: Plain text
#: upstream/_guides/quartz.adoc:298
#, fuzzy
msgid ""
"Add a SQL migration file named `src/main/resources/db/migration/V2.0."
"0\\__QuarkusQuartzTasks.sql` with the content copied from file with the "
"content from link:{quickstarts-blob-url}/quartz-quickstart/src/main/"
"resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql[V2.0."
"0__QuarkusQuartzTasks.sql]."
msgstr ""
"link:{quickstarts-blob-url}/quartz-quickstart/src/main/resources/db/"
"migration/V2.0.0__QuarkusQuartzTasks.sql[V2.0.0.0__QuarkusQuartzTasks."
"sql]からコピーした内容でファイルからコピーした内容で `src/main/resources/db/migration/V2.0."
"0__QuarkusQuartzTasks.sql` という名前のSQLマイグレーションファイルを追加します。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:299
#, no-wrap, fuzzy
msgid "Configuring the load balancer"
msgstr "ロードバランサーの設定"

#. type: Plain text
#: upstream/_guides/quartz.adoc:302
#, fuzzy
msgid ""
"In the root directory, create a `nginx.conf` file with the following content:"
""
msgstr "ルートディレクトリに、以下の内容の `nginx.conf` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:306
#, no-wrap
msgid "user  nginx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:310
#, no-wrap
msgid "events {\n"
"    worker_connections   1000;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:319
#, no-wrap
msgid ""
"http {\n"
"        server {\n"
"              listen 8080;\n"
"              location / {\n"
"                proxy_pass http://tasks:8080; <1>\n"
"              }\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:322
#, fuzzy
msgid "Route all traffic to our tasks application"
msgstr "すべてのトラフィックをタスクアプリケーションにルーティング"

#. type: Title ==
#: upstream/_guides/quartz.adoc:323
#, no-wrap, fuzzy
msgid "Setting Application Deployment"
msgstr "アプリケーション展開の設定"

#. type: Plain text
#: upstream/_guides/quartz.adoc:326
#, fuzzy
msgid ""
"In the root directory, create a `docker-compose.yml` file with the following "
"content:"
msgstr "ルートディレクトリに、以下の内容の `docker-compose.yml` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:330
#, no-wrap
msgid "version: '3'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:343
#, no-wrap
msgid ""
"services:\n"
"  tasks: <1>\n"
"    image: quarkus-quickstarts/quartz:1.0\n"
"    build:\n"
"      context: ./\n"
"      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}\n"
"    environment:\n"
"      QUARKUS_DATASOURCE_URL: jdbc:postgresql://postgres/quarkus_test\n"
"    networks:\n"
"      - tasks-network\n"
"    depends_on:\n"
"      - postgres\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:354
#, no-wrap
msgid ""
"  nginx: <2>\n"
"    image: nginx:1.17.6\n"
"    volumes:\n"
"      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n"
"    depends_on:\n"
"      - tasks\n"
"    ports:\n"
"      - 8080:8080\n"
"    networks:\n"
"      - tasks-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:366
#, no-wrap
msgid ""
"  postgres: <3>\n"
"    image: postgres:11.3\n"
"    container_name: quarkus_test\n"
"    environment:\n"
"      - POSTGRES_USER=quarkus_test\n"
"      - POSTGRES_PASSWORD=quarkus_test\n"
"      - POSTGRES_DB=quarkus_test\n"
"    ports:\n"
"      - 5432:5432\n"
"    networks:\n"
"      - tasks-network\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/quartz.adoc:370
#, no-wrap
msgid "networks:\n"
"  tasks-network:\n"
"    driver: bridge\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:373
#, fuzzy
msgid "Define the tasks service"
msgstr "タスクサービスの定義"

#. type: Plain text
#: upstream/_guides/quartz.adoc:374
#, fuzzy
msgid ""
"Define the nginx load balancer to route incoming traffic to an appropriate "
"node"
msgstr "受信トラフィックを適切なノードにルーティングするための nginx ロードバランサーを定義します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:375
#, fuzzy
msgid "Define the configuration to run the database"
msgstr "データベースを実行するための設定を定義します。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:376
#, no-wrap, fuzzy
msgid "Running the database"
msgstr "データベースの実行"

#. type: Plain text
#: upstream/_guides/quartz.adoc:379
#, fuzzy
msgid "In a separate terminal, run the below command:"
msgstr "別のターミナルで以下のコマンドを実行します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:383
#, no-wrap
msgid "docker-compose up postgres <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:386
#, fuzzy
msgid ""
"Start the database instance using the configuration options supplied in the "
"`docker-compose.yml` file"
msgstr "`docker-compose.yml` ファイルで提供されている設定オプションを使用してデータベースインスタンスを起動します。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:387
#, no-wrap, fuzzy
msgid "Run the application in Dev Mode"
msgstr "アプリケーションを開発モードで実行します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:391
#, fuzzy
msgid ""
"Run the application with: `./mvnw quarkus:dev`.  After a few seconds, open "
"another terminal and run `curl localhost:8080/tasks` to verify that we have "
"at least one task created."
msgstr ""
"`./mvnw quarkus:dev` でアプリケーションを実行します。数秒後、別のターミナルを開き、 `curl localhost:8080/"
"tasks` を実行して、少なくとも 1 つのタスクが作成されていることを確認します。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:395
#, no-wrap, fuzzy
msgid "Packaging the application and run several instances"
msgstr "アプリケーションのパッケージ化と複数のインスタンスの実行"

#. type: Plain text
#: upstream/_guides/quartz.adoc:398
#, fuzzy
msgid ""
"The application can be packaged using `./mvnw clean package`. Once the build "
"is successful, run the below command:"
msgstr ""
"アプリケーションは `./mvnw clean package` "
"を使用してパッケージ化することができます。ビルドが成功したら、以下のコマンドを実行します。"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:402
#, no-wrap
msgid "docker-compose up --scale tasks=2 --scale nginx=1 <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:405
#, fuzzy
msgid "Start two instances of the application and a load balancer"
msgstr "アプリケーションとロードバランサーの2つのインスタンスを起動する"

#. type: Plain text
#: upstream/_guides/quartz.adoc:407
#, fuzzy
msgid ""
"After a few seconds, in another terminal, run `curl localhost:8080/tasks` to "
"verify that tasks were only created at different instants and in an interval "
"of 10 seconds."
msgstr ""
"数秒後、別のターミナルで `curl localhost:8080/tasks` "
"を実行して、タスクが異なるインスタンスで、10秒の間隔でしか作成されていないことを確認します。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:409
#, fuzzy
msgid ""
"You can also generate the native executable with `./mvnw clean package -"
"Pnative`."
msgstr "`./mvnw clean package -Pnative` でネイティブの実行ファイルを生成することもできます。"

#. type: Title ==
#: upstream/_guides/quartz.adoc:411
#, no-wrap, fuzzy
msgid "Registering Plugin and Listeners"
msgstr "プラグインとリスナーの登録"

#. type: Plain text
#: upstream/_guides/quartz.adoc:414
#, fuzzy
msgid ""
"You can register `plugins`, `job-listeners` and `trigger-listeners` through "
"Quarkus configuration."
msgstr ""
"Quarkusの設定から、 `plugins` 、 `job-listeners` 、 `trigger-listeners` "
"を登録することができます。"

#. type: Plain text
#: upstream/_guides/quartz.adoc:416
#, fuzzy
msgid ""
"The example below registers the plugin `org.quartz.plugins.history."
"LoggingJobHistoryPlugin` named as `jobHistory` with the property "
"`jobSuccessMessage` defined as `Job [{1}.{0}] execution complete and reports:"
" {8}`"
msgstr ""
"以下の例では、 `org.quartz.plugins.history.LoggingJobHistoryPlugin` という名前のプラグインを "
"`jobHistory` として登録し、プロパティ `jobSuccessMessage` を `Job [{1}.{0}] execution "
"complete and reports: {8}`"

#. type: delimited block -
#: upstream/_guides/quartz.adoc:421
#, no-wrap
msgid ""
"quarkus.quartz.plugins.jobHistory.class=org.quartz.plugins.history."
"LoggingJobHistoryPlugin\n"
"quarkus.quartz.plugins.jobHistory.properties.jobSuccessMessage=Job [{1}.{0}] "
"execution complete and reports: {8}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/quartz.adoc:424
#, fuzzy
msgid ""
"You can also register a listener programmatically with an injected `org."
"quartz.Scheduler`:"
msgstr "リスナーをプログラムで登録するには、 `org.quartz.Scheduler`."

#. type: delimited block -
#: upstream/_guides/quartz.adoc:433
#, no-wrap
msgid ""
"public class MyListenerManager {\n"
"    void onStart(@Observes StartupEvent event, org.quartz.Scheduler "
"scheduler) throws SchedulerException {\n"
"        scheduler.getListenerManager().addJobListener(new MyJogListener());\n"
"        scheduler.getListenerManager().addTriggerListener(new "
"MyTriggerListener());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/quartz.adoc:436
#, no-wrap, fuzzy
msgid "Quartz Configuration Reference"
msgstr "クォーツ構成リファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/grpc-getting-started.adoc:6
#, no-wrap, fuzzy
msgid "Getting Started with gRPC"
msgstr "gRPCを始めるには"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:12
#, fuzzy
msgid ""
"This page explains how to start using gRPC in your Quarkus application.  "
"While this page describes how to configure it with Maven, it is also "
"possible to use Gradle."
msgstr ""
"このページでは、QuarkusアプリケーションでgRPCを使い始める方法を説明します。このページではMavenでの設定方法を説明していますが、Gradleを使用することも可能です。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:15
#, fuzzy
msgid ""
"Let's imagine you have a regular Quarkus project, generated from the https://"
"code.quarkus.io[Quarkus project generator].  The default configuration is "
"enough, but you can also select some extensions if you want."
msgstr ""
"ここでは、Quark link:https://code.quarkus."
"io[usプロジェクトジェネレータ]から生成された通常のQuarkusプロジェクトを想像してみましょう。デフォルトの設定で十分ですが、必要に応じていくつかの拡張機能を選択することもできます。"

#. type: Title ==
#: upstream/_guides/grpc-getting-started.adoc:16
#, no-wrap, fuzzy
msgid "Configuring your project"
msgstr "プロジェクトの設定"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:19
#, fuzzy
msgid ""
"Edit the `pom.xml` file to add the Quarkus gRPC extension dependency (just "
"under `<dependencies>`):"
msgstr ""
"`pom.xml` ファイルを編集して、Quarkus gRPC拡張子の依存関係を追加します（ "
"`&amp;lt;dependencies&amp;gt;` のすぐ下）。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:26
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-grpc</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:30
#, fuzzy
msgid ""
"Make sure you have `generate-code` goal of `quarkus-maven-plugin` enabled in "
"your `pom.xml`.  If you wish to generate code from different `proto` files "
"for tests, also add the `generate-code-tests` goal:"
msgstr ""
"`pom.xml` で `generate-code` ゴールの `quarkus-maven-plugin` "
"が有効になっていることを確認してください。テスト用に異なる `proto` ファイルからコードを生成したい場合は、 `generate-code-"
"tests` ゴールも追加してください。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:50
#, no-wrap
msgid ""
"<build>\n"
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>io.quarkus</groupId>\n"
"            <artifactId>quarkus-maven-plugin</artifactId>\n"
"            <executions>\n"
"                <execution>\n"
"                    <goals>\n"
"                        <goal>generate-code</goal>\n"
"                        <goal>generate-code-tests</goal>\n"
"                        <goal>build</goal>\n"
"                    </goals>\n"
"                </execution>\n"
"            </executions>\n"
"        </plugin>\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:54
#, fuzzy
msgid ""
"With this configuration, you can put your service and message definitions in "
"the `src/main/proto` directory.  `quarkus-maven-plugin` will generate Java "
"files from your `proto` files."
msgstr ""
"この設定では、サービスとメッセージの定義を `src/main/proto` ディレクトリに置くことができます。 `quarkus-maven-"
"plugin` は、 `proto` ファイルから Java ファイルを生成します。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:56
#, fuzzy
msgid ""
"Alternatively to using the `generate-code` goal of the `quarkus-maven-"
"plugin`, you can use `protobuf-maven-plugin` to generate these files, more "
"in <<Generating Java files from proto with protobuf-maven-plugin>>"
msgstr ""
"`quarkus-maven-plugin`の `generate-code` ゴールを使用する代わりに、 `protobuf-maven-"
"plugin` を使用してこれらのファイルを生成する link:#Generating Java files from proto with "
"protobuf-maven-plugin[こと]ができます。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:59
#, fuzzy
msgid ""
"Let's start with a simple _Hello_ service.  Create the `src/main/proto/"
"helloworld.proto` file with the following content:"
msgstr ""
"まずは簡単な _Hello_サービスから始めてみましょう。以下の内容の `src/main/proto/helloworld.proto` "
"ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:63
#, no-wrap
msgid "syntax = \"proto3\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:67
#, no-wrap
msgid ""
"option java_multiple_files = true;\n"
"option java_package = \"io.quarkus.example\";\n"
"option java_outer_classname = \"HelloWorldProto\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:69
#, no-wrap
msgid "package helloworld;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:75
#, no-wrap
msgid ""
"// The greeting service definition.\n"
"service Greeter {\n"
"    // Sends a greeting\n"
"    rpc SayHello (HelloRequest) returns (HelloReply) {}\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:80
#, no-wrap
msgid ""
"// The request message containing the user's name.\n"
"message HelloRequest {\n"
"    string name = 1;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:85
#, no-wrap
msgid ""
"// The response message containing the greetings\n"
"message HelloReply {\n"
"    string message = 1;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:88
#, fuzzy
msgid ""
"This `proto` file defines a simple service interface with a single method "
"(`SayHello`), and the exchanged messages (`HelloRequest` containing the name "
"and `HelloReply` containing the greeting message)."
msgstr ""
"この `proto` ファイルは、単一のメソッド ( `SayHello`) と交換されたメッセージ (名前を含む `HelloRequest` "
"と挨拶メッセージを含む `HelloReply` ) を持つシンプルなサービスインターフェースを定義しています。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:91
#, fuzzy
msgid ""
"Before coding, we need to generate the classes used to implement and consume "
"gRPC services.  In a terminal, run:"
msgstr "コーディングの前に、gRPCサービスを実装して消費するためのクラスを生成する必要があります。ターミナルで、実行します。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:95
#, no-wrap
msgid "$ mvn compile\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:98
#, fuzzy
msgid ""
"Once generated, you can look at the `target/generated-sources/grpc` "
"directory:"
msgstr "生成されると、 `target/generated-sources/grpc` ディレクトリを見ることができます。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:112
#, no-wrap
msgid ""
"target/generated-sources/grpc\n"
"└── io\n"
"    └── quarkus\n"
"        └── example\n"
"            ├── GreeterGrpc.java\n"
"            ├── HelloReply.java\n"
"            ├── HelloReplyOrBuilder.java\n"
"            ├── HelloRequest.java\n"
"            ├── HelloRequestOrBuilder.java\n"
"            ├── HelloWorldProto.java\n"
"            └── MutinyGreeterGrpc.java\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:115
#, fuzzy
msgid "These are the classes we are going to use."
msgstr "これから使う授業です。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:117
#, fuzzy
msgid ""
"Every time you update the `proto` files, you need to re-generate the classes "
"(using `mvn compile`)."
msgstr "`proto` ファイルを更新するたびに、クラスを再生成する必要があります ( `mvn compile` を使用して)。"

#. type: Title ===
#: upstream/_guides/grpc-getting-started.adoc:118
#, no-wrap, fuzzy
msgid "`proto` files with imports"
msgstr "`proto` ファイルのインポート"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:122
#, fuzzy
msgid ""
"Protocol Buffers specification provides a way to import `proto` files.  The "
"Quarkus code generation mechanism lets you control the scope of dependencies "
"to scan for possible imports by setting the `quarkus.generate-code.grpc.scan-"
"for-imports` property to one of the following:"
msgstr ""
"Protocol Buffers仕様では、 `proto` ファイルをインポートする方法を提供しています。Quarkusのコード生成メカニズムでは、 "
"`quarkus.generate-code.grpc.scan-for-imports` "
"プロパティを以下のいずれかに設定することで、インポートの可能性をスキャンするための依存関係の範囲を制御することができます。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:124
#, fuzzy
msgid "`all` - scan all the dependencies"
msgstr "`all` - すべての依存関係をスキャンする"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:125
#, fuzzy
msgid ""
"`none` - don't scan the dependencies, use only what is defined in the `src/"
"main/proto` or `src/test/proto`"
msgstr "`none` - 依存関係をスキャンしないで、 `src/main/proto` または `src/test/proto`"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:126
#, fuzzy
msgid ""
"`groupId1:artifactId1,groupId2:artifactId2` - scan only the dependencies "
"with group id and artifact id in the list."
msgstr ""
"`groupId1:artifactId1,groupId2:artifactId2` - "
"リスト内のグループIDとアーティファクトIDを持つ依存関係のみをスキャンします。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:129
#, fuzzy
msgid ""
"If not specified, the property is set to `com.google.protobuf:protobuf-java`."
"  To override it, set the `quarkus.generate-code.grpc.scan-for-imports` "
"property in your pom.xml (or gradle.properties) to the desired value, e.g."
msgstr ""
"指定されていない場合、このプロパティは `com.google.protobuf:protobuf-java` "
"に設定されます。これを上書きするには、pom.xml (または gradle.properties) の `quarkus.generate-code."
"grpc.scan-for-imports` プロパティを希望の値に設定します。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:135
#, no-wrap
msgid ""
"<properties>\n"
"  <quarkus.generate-code.grpc.scan-for-imports>all</quarkus.generate-code."
"grpc.scan-for-imports>\n"
"</properties>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/grpc-getting-started.adoc:137
#, no-wrap, fuzzy
msgid "Implementing a gRPC service"
msgstr "gRPCサービスの実装"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:140
#, fuzzy
msgid ""
"Now that we have the generated classes let's implement our _hello_ service."
msgstr "生成されたクラスができたので、 _hello_サービスを実装してみましょう。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:142
#, fuzzy
msgid ""
"With Quarkus, implementing a service requires to _extend_ the generated "
"service base implementation and expose it as a `@Singleton` CDI bean."
msgstr ""
"Quarkusでは、サービスを実装するには、生成されたサービスベースの実装を _拡張し_、 `@Singleton` CDI "
"Beanとして公開する必要があります。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:144
#, fuzzy
msgid ""
"Don't use `@ApplicationScoped` as the gRPC service implementation cannot be "
"proxied."
msgstr "gRPCサービスの実装はプロキシできないので、 `@ApplicationScoped` を使用しないでください。"

#. type: Title ===
#: upstream/_guides/grpc-getting-started.adoc:145
#, no-wrap, fuzzy
msgid "Implementing a service"
msgstr "サービスの実装"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:148
#, fuzzy
msgid ""
"Create the `src/main/java/org/acme/HelloService.java` file with the "
"following content:"
msgstr "以下の内容の `src/main/java/org/acme/HelloService.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1044
#: upstream/_guides/qute-reference.adoc:1204
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:157
#, no-wrap
msgid ""
"import io.grpc.stub.StreamObserver;\n"
"import io.quarkus.example.GreeterGrpc;\n"
"import io.quarkus.example.HelloReply;\n"
"import io.quarkus.example.HelloRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:159
#: upstream/_guides/grpc-getting-started.adoc:193
#, no-wrap
msgid "import javax.inject.Singleton;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:162
#, no-wrap
msgid ""
"@Singleton                                                                   "
"                 // <1>\n"
"public class HelloService extends GreeterGrpc.GreeterImplBase {              "
"                 // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:171
#, no-wrap
msgid ""
"    @Override\n"
"    public void sayHello(HelloRequest request, StreamObserver<HelloReply> "
"responseObserver) { // <3>\n"
"        String name = request.getName();\n"
"        String message = \"Hello \" + name;\n"
"        responseObserver.onNext(HelloReply.newBuilder().setMessage(message)."
"build());         // <4>\n"
"        responseObserver.onCompleted();                                      "
"                 // <5>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:174
#, fuzzy
msgid "Expose your implementation as bean."
msgstr "実装をBeanとして公開します。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:175
#, fuzzy
msgid "Extends the `ImplBase` class. This is a generated class."
msgstr "`ImplBase` クラスを拡張します。生成されたクラスです。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:176
#, fuzzy
msgid ""
"Implement the methods defined in the service definition (here we have a "
"single method)."
msgstr "サービス定義で定義されたメソッドを実装します（ここでは1つのメソッドを使用しています）。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:177
#, fuzzy
msgid "Build and send the response."
msgstr "レスポンスを構築して送信します。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:178
#, fuzzy
msgid "Close the response."
msgstr "レスポンスを閉じる。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:182
#, fuzzy
msgid ""
"Quarkus also provides an additional model with Mutiny, a Reactive "
"Programming API integrated in Quarkus.  Learn more about Mutiny on the link:"
"getting-started-reactive#mutiny[Getting Started with Reactive guide].  A "
"Mutiny implementation of this service would be:"
msgstr ""
"Quarkusは、Quarkusに統合されたReactive Programming "
"APIであるMutinyを使用した追加モデルも提供しています。Mutinyの詳細については、 link:getting-started-"
"reactive#mutiny[Getting Started with "
"Reactiveガイド]を参照してください。このサービスのMutinyの実装は次のようになります。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:191
#, no-wrap
msgid ""
"import io.quarkus.example.HelloReply;\n"
"import io.quarkus.example.HelloRequest;\n"
"import io.quarkus.example.MutinyGreeterGrpc;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:196
#, no-wrap
msgid ""
"@Singleton\n"
"public class ReactiveHelloService extends MutinyGreeterGrpc.GreeterImplBase "
"{\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:204
#, no-wrap
msgid ""
"    @Override\n"
"    public Uni<HelloReply> sayHello(HelloRequest request) {\n"
"        return Uni.createFrom().item(() ->\n"
"                HelloReply.newBuilder().setMessage(\"Hello \" + request."
"getName()).build()\n"
"        );\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:207
#, fuzzy
msgid "The main differences are the following:"
msgstr "主な違いは以下の通りです。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:209
#, fuzzy
msgid ""
"it extends the `ImplBase` from `MutinyGreeterGrpc` instead of `GreeterGrpc`"
msgstr "の代わりに `MutinyGreeterGrpc` から `ImplBase` を拡張します。 `GreeterGrpc`"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:210
#, fuzzy
msgid "the signature of the method is using Mutiny types"
msgstr "メソッドのシグネチャは Mutiny 型を使用しています。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:215
#, fuzzy
msgid ""
"If your service implementation logic is blocking (use blocking I/O for "
"example), annotate your method with `@Blocking`.  The `io.smallrye.common."
"annotation.Blocking` annotation instructs the framework to invoke the "
"annotated method on a worker thread instead of the I/O thread (event-loop)."
msgstr ""
"サービスの実装ロジックがブロッキングされている場合 (例えば、ブロッキング I/O を使用している場合)、メソッドに `@Blocking` "
"をアノテーションします。 `io.smallrye.common.annotation.Blocking` アノテーションは、I/O スレッド "
"(イベントループ) の代わりにワーカースレッドでアノテーションされたメソッドを呼び出すようにフレームワークに指示します。"

#. type: Title ===
#: upstream/_guides/grpc-getting-started.adoc:216
#, no-wrap, fuzzy
msgid "The gRPC server"
msgstr "gRPCサーバ"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:220
#, fuzzy
msgid ""
"The services are _served_ by a _server_.  Available services (_CDI beans_) "
"are automatically registered and exposed."
msgstr "サービスは _サーバ_によって _提供される_。利用可能なサービス _（CDI豆_）は自動的に登録され、公開されます。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:222
#, fuzzy
msgid ""
"By default, the server is exposed on `localhost:9000`, and uses _plain-text_ "
"(so no TLS)."
msgstr ""
"デフォルトでは、サーバは `localhost:9000` で公開されており、 _プレーンテキストを_使用します（そのため TLS は使用しません）。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:224
#, fuzzy
msgid "Run the application using: `mvn quarkus:dev`."
msgstr "`mvn quarkus:dev` を使用してアプリケーションを実行します。"

#. type: Title ==
#: upstream/_guides/grpc-getting-started.adoc:225
#, no-wrap, fuzzy
msgid "Consuming a gRPC service"
msgstr "gRPCサービスを消費する"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:229
#, fuzzy
msgid ""
"In this section, we are going to consume the service we expose.  To "
"simplify, we are going to consume the service from the same application, "
"which in the real world, does not make sense."
msgstr ""
"ここでは、公開しているサービスを消費することにします。簡単に言うと、同じアプリケーションからサービスを消費することになりますが、これは現実の世界では意味がありません。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:231
#, fuzzy
msgid ""
"Open the existing `org.acme.ExampleResource` class, and edit the content to "
"become:"
msgstr "既存の `org.acme.ExampleResource` クラスを開き、内容を編集してなります。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:239
#, no-wrap
msgid ""
"import io.quarkus.example.GreeterGrpc;\n"
"import io.quarkus.example.HelloRequest;\n"
"import io.quarkus.grpc.runtime.annotations.GrpcService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:941
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.PathParam;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:253
#, no-wrap
msgid ""
"    @Inject\n"
"    @GrpcService(\"hello\")                     // <1>\n"
"    GreeterGrpc.GreeterBlockingStub client;   // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:266
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{name}\")\n"
"    public String hello(@PathParam(\"name\") String name) {\n"
"        return client.sayHello(HelloRequest.newBuilder().setName(name)."
"build()).getMessage();  // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:269
#, fuzzy
msgid ""
"Inject the service and configure its name. This name is used in the "
"application configuration."
msgstr "サービスを注入し、その名前を設定します。この名前は、アプリケーションの設定で使用されます。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:270
#, fuzzy
msgid "Use the _blocking_ stub (also a generated class)."
msgstr "_ブロッキング_スタブ（生成されたクラスでもあります）を使用します。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:271
#, fuzzy
msgid "Invoke the service."
msgstr "サービスを起動します。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:274
#, fuzzy
msgid ""
"We need to configure the application to indicate where the `hello` service "
"is found.  In the `src/main/resources/application.properties` file, add the "
"following property:"
msgstr ""
"`hello` サービスがどこにあるかを示すようにアプリケーションを構成する必要があります。 `src/main/resources/"
"application.properties` ファイルで、以下のプロパティを追加します。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:278
#, no-wrap
msgid "quarkus.grpc.clients.hello.host=localhost\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:281
#, fuzzy
msgid ""
"`hello` is the name of the service used in the `@GrpcService` annotation."
msgstr "`hello` は `@GrpcService` アノテーションで使用されるサービスの名前です。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:282
#, fuzzy
msgid "`host` configures the service host (here it's localhost)."
msgstr "`host` はサービスホストを設定します (ここでは localhost)。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:284
#, fuzzy
msgid ""
"Then, open http://localhost:8080/hello/quarkus in a browser, and you should "
"get `Hello quarkus`!"
msgstr "そして、ブラウザで http://localhost:8080/hello/quarkus を開くと、 `Hello quarkus`!"

#. type: Title ==
#: upstream/_guides/grpc-getting-started.adoc:285
#, no-wrap, fuzzy
msgid "Packaging the application"
msgstr "アプリケーションのパッケージング"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:289
#, fuzzy
msgid ""
"Like any other Quarkus applications, you can package it with: `mvn package`. "
" You can also package the application into a native executable with: `mvn "
"package -Pnative`."
msgstr ""
"他のQuarkusアプリケーションと同様に、 `mvn package` "
"でパッケージ化することができます。また、アプリケーションをネイティブの実行ファイルにパッケージ化することもできます: `mvn package -"
"Pnative`."

#. type: Title ==
#: upstream/_guides/grpc-getting-started.adoc:290
#, no-wrap, fuzzy
msgid "Generating Java files from proto with protobuf-maven-plugin"
msgstr "protoからprotobuf-maven-pluginでJavaファイルを生成する"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:294
#, fuzzy
msgid ""
"Alternatively to using Quarkus code generation to generate stubs for `proto` "
"files, you can also use `protobuf-maven-plugin`."
msgstr "Quarkusコード生成を使用して `proto` ファイルのスタブを生成する代わりに、 `protobuf-maven-plugin`."

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:296
#, fuzzy
msgid ""
"To do it, first define the 2 following properties in the `<properties>` "
"section:"
msgstr "そのためには、まず `&amp;lt;properties&amp;gt;` セクションで以下の 2 つのプロパティを定義します。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:301
#, no-wrap
msgid ""
"<grpc.version>{grpc-version}</grpc.version>\n"
"<protoc.version>{protoc-version}</protoc.version>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:304
#, fuzzy
msgid "They configure the gRPC version and the `protoc` version."
msgstr "gRPC のバージョンと `protoc` のバージョンを設定します。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:306
#, fuzzy
msgid ""
"Then, add to the `build` section the `os-maven-plugin` extension and the "
"`protobuf-maven-plugin` configuration."
msgstr ""
"そして、 `build` セクションに `os-maven-plugin` の拡張子と `protobuf-maven-plugin` "
"の設定を追加します。"

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:317
#, no-wrap
msgid ""
"<build>\n"
"    <extensions>\n"
"        <extension>\n"
"            <groupId>kr.motd.maven</groupId>\n"
"            <artifactId>os-maven-plugin</artifactId>\n"
"            <version>${os-maven-plugin-version}</version>\n"
"        </extension>\n"
"    </extensions>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:354
#, no-wrap
msgid ""
"    <plugins>\n"
"        <plugin>\n"
"            <groupId>org.xolstice.maven.plugins</groupId>\n"
"            <artifactId>protobuf-maven-plugin</artifactId>      // <1>\n"
"            <version>${protobuf-maven-plugin-version}</version>\n"
"            <configuration>\n"
"                <protocArtifact>com.google.protobuf:protoc:${protoc.version}:"
"exe:${os.detected.classifier}</protocArtifact> // <2>\n"
"                <pluginId>grpc-java</pluginId>\n"
"                <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:"
"exe:${os.detected.classifier}</pluginArtifact>\n"
"                <protocPlugins>\n"
"                    <protocPlugin>\n"
"                        <id>quarkus-grpc-protoc-plugin</id>\n"
"                        <groupId>io.quarkus</groupId>\n"
"                        <artifactId>quarkus-grpc-protoc-plugin</artifactId>\n"
"                        <version>{quarkus-version}</version>\n"
"                        <mainClass>io.quarkus.grpc.protoc.plugin."
"MutinyGrpcGenerator</mainClass>\n"
"                    </protocPlugin>\n"
"                </protocPlugins>\n"
"            </configuration>\n"
"            <executions>\n"
"                <execution>\n"
"                    <id>compile</id>\n"
"                    <goals>\n"
"                        <goal>compile</goal>\n"
"                        <goal>compile-custom</goal>\n"
"                    </goals>\n"
"                </execution>\n"
"                <execution>\n"
"                    <id>test-compile</id>\n"
"                    <goals>\n"
"                        <goal>test-compile</goal>\n"
"                        <goal>test-compile-custom</goal>\n"
"                    </goals>\n"
"                </execution>\n"
"            </executions>\n"
"        </plugin>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/grpc-getting-started.adoc:358
#, no-wrap
msgid "        <!-- ... -->\n"
"    </plugins>\n"
"</build>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:361
#, fuzzy
msgid ""
"The `protobuf-maven-plugin` that generates stub classes from your gRPC "
"service definition (`proto` files)."
msgstr "gRPCサービス定義からスタブクラスを生成する `protobuf-maven-plugin` ( `proto` ファイル)。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:363
#, fuzzy
msgid ""
"The class generation uses a tool named `protoc`, which is OS-specific.  "
"That's why we use the `os-maven-plugin` to target the executable compatible "
"with the operating system."
msgstr ""
"クラス生成には、OS固有の `protoc` というツールを使用しています。そのため、OSと互換性のある実行ファイルを対象に `os-maven-"
"plugin` を使用しています。"

#. type: Plain text
#: upstream/_guides/grpc-getting-started.adoc:364
#, fuzzy
msgid ""
"This configuration instructs the `protobuf-maven-plugin` to generate the "
"default gRPC classes and classes using Mutiny to fit with the Quarkus "
"development experience."
msgstr ""
"この設定は、Quarkusの開発経験に合わせてMutinyを使用してデフォルトのgRPCクラスとクラスを生成するように、 `protobuf-maven-"
"plugin` に指示します。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/azure-functions-http.adoc:6
#, no-wrap, fuzzy
msgid ""
"Quarkus - Azure Functions (Serverless) with RESTEasy, Undertow, or Vert.x "
"Web"
msgstr ""
"Quarkus - RESTEasy、Undertow、またはVert.x Webを使用したAzure Functions (サーバーレス)"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:13
#, fuzzy
msgid ""
"The `quarkus-azure-functions-http` extension allows you to write "
"microservices with RESTEasy (JAX-RS), Undertow (servlet), Vert.x Web, or "
"link:funqy-http[Funqy HTTP] and make these microservices deployable to the "
"Azure Functions runtime."
msgstr ""
"`quarkus-azure-functions-http` 拡張機能を使うと、RESTEasy (JAX-RS)、Undertow "
"(サーブレット)、Vert.x Web、または link:funqy-http[Funqy "
"HTTPを]使ってマイクロサービスを書き、これらのマイクロサービスをAzure Functionsランタイムにデプロイできるようにすることができます。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:15
#, fuzzy
msgid ""
"One azure function deployment can represent any number of JAX-RS, servlet, "
"Vert.x Web, or link:funqy-http[Funqy HTTP] endpoints."
msgstr ""
"1 つの azure 機能デプロイメントでは、JAX-RS、サーブレット、Vert.x Web、または link:funqy-http[Funqy "
"HTTP]エンドポイントを任意の数だけ表現できます。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:24
#, fuzzy
msgid "JDK 1.8 (Azure requires JDK 1.8)"
msgstr "JDK 1.8 (AzureにはJDK 1.8が必要)"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:26
#, fuzzy
msgid "https://azure.microsoft.com[An Azure Account].  Free accounts work."
msgstr "link:https://azure.microsoft.com[Azureのアカウント]。無料アカウントの仕事。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:27
#, fuzzy
msgid ""
"https://docs.microsoft.com/en-us/cli/azure/install-azure-cli[Azure CLI "
"Installed]"
msgstr ""
"link:https://docs.microsoft.com/en-us/cli/azure/install-azure-cli[Azure "
"CLIがインストールされている]"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:33
#, fuzzy
msgid ""
"This guide walks you through running a Maven Archetype to generate a sample "
"project that contains three http endpoints written with JAX-RS APIs, Servlet "
"APIs, Vert.x Web, or link:funqy-http[Funqy HTTP] APIs.  After building, you "
"will then be able to deploy to Azure."
msgstr ""
"このガイドでは、JAX-RS API、Servlet API、Vert.x Web、または link:funqy-http[Funqy "
"HTTP]APIで記述された3つのHTTPエンドポイントを含むサンプルプロジェクトを生成するために、Maven "
"Archetypeを実行する方法を説明します。ビルド後、Azureにデプロイできるようになります。"

#. type: Title ==
#: upstream/_guides/azure-functions-http.adoc:34
#, no-wrap, fuzzy
msgid "Creating the Maven Deployment Project"
msgstr "Maven デプロイメントプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:37
#, fuzzy
msgid ""
"Create the azure maven project for your Quarkus application using our Maven "
"Archetype."
msgstr "Maven Archetypeを使用して、Quarkusアプリケーション用のazure mavenプロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/azure-functions-http.adoc:45
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"    -DarchetypeGroupId=io.quarkus \\\n"
"    -DarchetypeArtifactId=quarkus-azure-functions-http-archetype \\\n"
"    -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:48
#, fuzzy
msgid ""
"Running this command will run maven in interactive mode and it will ask you "
"to fill in some build properties:"
msgstr "このコマンドを実行すると、インタラクティブモードでmavenが実行され、いくつかのビルドプロパティの入力を求められます。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:50
#, fuzzy
msgid ""
"`groupId` - The maven groupId of this generated project.  Type in `org.acme`."
""
msgstr "`groupId` - この生成されたプロジェクトの maven グループ ID。 `org.acme` と入力します。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:51
#, fuzzy
msgid ""
"`artifactId` - The maven artifactId of this generated project. Type in "
"`quarkus-demo`"
msgstr "`artifactId` - この生成されたプロジェクトの maven artifactId。を入力します。 `quarkus-demo`"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:52
#, fuzzy
msgid "`version` - Version of this generated project."
msgstr "`version` - この生成されたプロジェクトのバージョン。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:53
#, fuzzy
msgid "`package` - defaults to `groupId`"
msgstr "`package` - デフォルトは `groupId`"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:54
#, fuzzy
msgid ""
"`appName` - Use the default value.  This is the application name in Azure.  "
"It must be a unique subdomain name under `*.azurewebsites.net`. Otherwise "
"deploying to Azure will fail."
msgstr ""
"`appName` - 既定値を使用します。これは、Azure でのアプリケーション名です。 `*.azurewebsites.net` "
"以下の一意のサブドメイン名である必要があります。そうしないと、Azure へのデプロイに失敗します。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:55
#, fuzzy
msgid "`appRegion` - Defaults to `westus`.  Dependent on your azure region."
msgstr "`appRegion` - デフォルトは `westus` です。お使いの azure リージョンに依存します。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:56
#, fuzzy
msgid ""
"`function` - Use the default which is `quarkus`.  Name of your azure "
"function. Can be anything you want."
msgstr "`function` - デフォルトの `quarkus` を使用してください。あなたの azure 関数の名前。何でも構いません。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:57
#, fuzzy
msgid "`resourceGroup` - Use the default value.  Any value is fine though."
msgstr "`resourceGroup` - デフォルト値を使用してください。どんな値でも構いません。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:59
#, fuzzy
msgid ""
"The values above are defined as properties in the generated `pom.xml` file."
msgstr "上記の値は、生成された `pom.xml` ファイルのプロパティとして定義されています。"

#. type: Title ==
#: upstream/_guides/azure-functions-http.adoc:60
#, no-wrap, fuzzy
msgid "Login to Azure"
msgstr "Azureへのログイン"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:63
#, fuzzy
msgid "If you don't login to Azure you won't be able to deploy."
msgstr "Azureにログインしないとデプロイできません。"

#. type: delimited block -
#: upstream/_guides/azure-functions-http.adoc:67
#, no-wrap
msgid "az login\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/azure-functions-http.adoc:69
#, no-wrap, fuzzy
msgid "Build and Deploy to Azure"
msgstr "Azureへのビルドとデプロイ"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:74
#, fuzzy
msgid ""
"The `pom.xml` you generated in the previous step pulls in the `azure-"
"functions-maven-plugin`.  Running maven install generates config files and a "
"staging directory required by the `azure-functions-maven-plugin`.  Here's "
"how to execute it."
msgstr ""
"前のステップで生成した `pom.xml` は、 `azure-functions-maven-plugin`.maven install "
"を実行すると、設定ファイルと `azure-functions-maven-plugin` "
"によって必要とされるステージングディレクトリが生成されます。実行方法は以下の通りです。"

#. type: delimited block -
#: upstream/_guides/azure-functions-http.adoc:78
#, no-wrap
msgid "./mvnw clean install azure-functions:deploy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:82
#, fuzzy
msgid ""
"If you haven't already created your function up at azure, the will build an "
"uber-jar, package it, create the function at Azure, and deploy it."
msgstr ""
"あなたがまだ Azure で機能を作成していない場合は、uber-jar をビルドしてパッケージ化し、Azure で機能を作成してデプロイします。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:84
#, fuzzy
msgid ""
"If deployment is a success, the azure plugin will tell you the base URL to "
"access your function."
msgstr "デプロイが成功した場合、azure プラグインは機能にアクセスするためのベース URL を教えてくれます。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:86
#, fuzzy
msgid "i.e."
msgstr "輒"

#. type: delimited block -
#: upstream/_guides/azure-functions-http.adoc:89
#, no-wrap
msgid ""
"Successfully deployed the artifact to https://quarkus-demo-123451234."
"azurewebsites.net\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:92
#, fuzzy
msgid "The URL to access the service would be"
msgstr "サービスにアクセスするためのURLは"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:97
#, fuzzy
msgid ""
"https://{appName}.azurewebsites.net/api/hello https://{appName}."
"azurewebsites.net/api/servlet/hello https://{appName}.azurewebsites.net/api/"
"vertx/hello https://{appName}.azurewebsites.net/api/funqyHello"
msgstr ""
"https://{appName}.azurewebsites.net/api/ https://{appName}.azurewebsites.net/"
"api/hello   https://{appName}.azurewebsites.net/api/servlet/hello hello "
"https://{appName}.azurewebsites.net/api/ https://{appName}.azurewebsites.net/"
"api/vertx/hello   https://{appName}.azurewebsites.net/api/funqyHello"

#. type: Title ==
#: upstream/_guides/azure-functions-http.adoc:98
#, no-wrap, fuzzy
msgid "Extension maven dependencies"
msgstr "拡張mavenの依存関係"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:103
#, fuzzy
msgid ""
"The sample project includes the RESTEasy, Undertow, Vert.x Web, link:funqy-"
"http[Funqy HTTP] extensions.  If you are only using one of those APIs (i.e. "
"jax-rs only), respectively remove the maven dependency `quarkus-resteasy`, "
"`quarkus-undertow`, `quarkus-funqy-http`, and/or `quarkus-vertx-web`."
msgstr ""
"サンプルプロジェクトには、RESTEasy、Undertow、Vert.x Web、 link:funqy-http[Funqy "
"HTTP]拡張機能が含まれています。これらのAPIの1つだけを使用している場合(つまりjax-"
"rsのみ)は、それぞれmavenの依存関係を削除してください `quarkus-resteasy`, `quarkus-undertow`, "
"`quarkus-funqy-http`, , および/または `quarkus-vertx-web`."

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:106
#, fuzzy
msgid ""
"You must include the `quarkus-azure-functions-http` extension as this is a "
"generic bridge between the Azure Functions runtime and the HTTP framework "
"you are writing your microservices in."
msgstr ""
"これは、Azure Functions ランタイムとマイクロサービスを書いている HTTP フレームワークの間の一般的なブリッジなので、 "
"`quarkus-azure-functions-http` 拡張モジュールを含める必要があります。"

#. type: Title ==
#: upstream/_guides/azure-functions-http.adoc:107
#, no-wrap, fuzzy
msgid "Azure Deployment Descriptors"
msgstr "Azureデプロイメント記述子"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:111
#, fuzzy
msgid ""
"Templates for Azure Functions deployment descriptors (`host.json`, `function."
"json`) are within the `azure-config` directory.  Edit them as you need to.  "
"Rerun the build when you are ready."
msgstr ""
"Azure Functions 配置記述子のテンプレート ( `host.json`, `function.json`) は、 `azure-"
"config` ディレクトリ内にあります。必要に応じて編集してください。準備ができたらビルドを再実行します。"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:114
#, no-wrap, fuzzy
msgid ""
"*NOTE*: If you change the `function.json` `path` attribute or if you add a "
"`routePrefix`,\n"
"your jax-rs endpoints won't route correctly.  See <<config-azure-paths>> for "
"more information.\n"
msgstr ""
"*注*: `function.json` `path` 属性を変更したり、 `routePrefix` を追加したりすると、jax-rs "
"エンドポイントは正しくルーティングされません。詳細は link:#config-azure-paths[[config-azure-paths] "
"を]参照してください。"

#. type: Title ==
#: upstream/_guides/azure-functions-http.adoc:117
#, no-wrap, fuzzy
msgid "Configuring Root Paths"
msgstr "ルートパスの設定"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:122
#, fuzzy
msgid ""
"The default route prefix for an Azure Function is `/api`.  All of your JAX-"
"RS, Servlet, Vert.x Web, and link:funqy-http[Funqy HTTP] endpoints must "
"explicitly take this into account.  In the generated project this is handled "
"by the `quarkus.http.root-path` switch in `application.properties`"
msgstr ""
"Azure Function のデフォルトのルートプレフィックスは `/api` です。すべてのJAX-RS、サーブレット、Vert.x Web、および "
"link:funqy-http[Funqy HTTP]エンドポイントは、これを明示的に考慮しなければなりません。 `quarkus.http.root-"
"path` 生成されたプロジェクトでは、これは `application.properties`"

#. type: Plain text
#: upstream/_guides/azure-functions-http.adoc:125
#, fuzzy
msgid ""
"If you modify the `path` or add a `routePrefix` within the `azure-config/"
"function.json` deployment descriptor, your code or configuration must also "
"reflect any prefixes you specify for your path."
msgstr ""
"`path` を変更したり、 `azure-config/function.json` 配置記述子内に `routePrefix` "
"を追加したりする場合、コードや設定にはパスに指定した接頭辞も反映させる必要があります。"

#. type: Title =
#: upstream/_guides/0-glossary.adoc:1
#, no-wrap, fuzzy
msgid "Glossary"
msgstr "用語集"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:7
#, fuzzy
msgid ""
"This is a collection of preferred term in the documentation and website.  "
"Please stay within these terms for consistency."
msgstr "ドキュメントやウェブサイトで好まれる用語を集めたものです。一貫性を保つために、これらの用語の範囲内にとどめてください。"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:8
#, no-wrap, fuzzy
msgid "* Live coding"
msgstr "<li> <p>ライブコーディング</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:9
#, fuzzy
msgid "for our `quarkus:dev` capability"
msgstr "`quarkus:dev` の機能について"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:9
#, no-wrap, fuzzy
msgid "* GraalVM native image"
msgstr "<li> <p>GraalVMネイティブイメージ</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:10
#, fuzzy
msgid "preferred term for the VM creating native executable. No space."
msgstr "ネイティブ実行ファイルを作成するVMの好ましい用語。スペースはありません。"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:10
#, no-wrap, fuzzy
msgid "* Substrate VM"
msgstr "<li> <p>基板 VM</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:11
#, fuzzy
msgid "non-preferred. Exclude."
msgstr "非優先。除外します。"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:11
#, no-wrap, fuzzy
msgid "* Native Executable"
msgstr "<li> <p>ネイティブ実行可能</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:12
#, fuzzy
msgid "the executable that is compiled to native 1s and 0s"
msgstr "ネイティブの1と0にコンパイルされた実行ファイル"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:12
#, no-wrap, fuzzy
msgid "* Docker image"
msgstr "<li> <p>ドッカーイメージ</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:13
#, fuzzy
msgid ""
"for the actual `Dockerfile` definition and when the tool chain is involved"
msgstr "実際の `Dockerfile` の定義と、ツールチェーンが関与している場合は"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:13
#, no-wrap, fuzzy
msgid "* Container"
msgstr "<li> <p>コンテナ</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:14
#, fuzzy
msgid "when we discuss Quarkus running in... containers"
msgstr "コンテナ内でのQuarkusの実行について議論するとき"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:14
#, no-wrap, fuzzy
msgid "* Supersonic Subatomic Java"
msgstr "<li> <p>超音速素粒子Java</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:15
#, fuzzy
msgid "our tagline"
msgstr "当社のキャッチフレーズ"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:15
#, no-wrap, fuzzy
msgid "* Kubernetes Native Java"
msgstr "<li> <p>Kubernetes ネイティブJava</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:16
#, fuzzy
msgid "our preferred tagline to say that we rock for containers"
msgstr "私たちはコンテナのためにロックしていることを言うために私たちの好ましいキャッチフレーズ"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:16
#, no-wrap, fuzzy
msgid "* Developer Joy"
msgstr "<li> <p>開発者の喜び</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:17
#, fuzzy
msgid ""
"for everything going from live reload to the opinionated layer to a single "
"config file"
msgstr "ライブリロードからオピニオン層へのリロードから単一のコンフィグファイルへの移行まで、すべてのことに対応しています。"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:17
#, no-wrap, fuzzy
msgid "* Unify Imperative and Reactive"
msgstr "<li> <p>インペラティブとリアクティブの統一</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:18
#, fuzzy
msgid "imperative and reactive. 'Nuff said."
msgstr "命令的で反応的な言うまでもありません"

#. type: Labeled list
#: upstream/_guides/0-glossary.adoc:18
#, no-wrap, fuzzy
msgid "* Best of breed frameworks and standards"
msgstr "<li> <p>ベスト・オブ・ブリードのフレームワークとスタンダード</p> </li>"

#. type: Plain text
#: upstream/_guides/0-glossary.adoc:18
#, fuzzy
msgid "when we explain our stack"
msgstr "スタックを説明するときに"

#. type: Title =
#: upstream/_guides/README.adoc:1
#, no-wrap, fuzzy
msgid "How to Create Quarkus Documentation"
msgstr "Quarkusのドキュメントを作成する方法"

#. type: Plain text
#: upstream/_guides/README.adoc:5
#, fuzzy
msgid ""
"This guide describes the asciidoc format and conventions that Quarkus has "
"adopted."
msgstr "このガイドでは、Quarkusが採用しているアスキードックのフォーマットと規約について説明します。"

#. type: Plain text
#: upstream/_guides/README.adoc:9
#, fuzzy
msgid ""
"The following links provide background on the general conventions and "
"Asciidoc syntax."
msgstr "以下のリンクは、一般的な規約と Asciidoc 構文の背景を提供します。"

#. type: Plain text
#: upstream/_guides/README.adoc:11
#, fuzzy
msgid ""
"https://redhat-documentation.github.io/asciidoc-markup-conventions/[AsciiDoc "
"Mark-up Quick Reference for Documentation]"
msgstr ""
"link:https://redhat-documentation.github.io/asciidoc-markup-conventions/"
"[ドキュメントのためのAsciiDocマークアップクイックリファレンス]"

#. type: Plain text
#: upstream/_guides/README.adoc:12
#, fuzzy
msgid "http://asciidoctor.org/docs/user-manual/[Asciidoctor User Manual]"
msgstr "link:http://asciidoctor.org/docs/user-manual/[アサイードクターユーザーマニュアル]"

#. type: Plain text
#: upstream/_guides/README.adoc:13
#, fuzzy
msgid ""
"http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/[AsciiDoc Syntax "
"Quick Reference]"
msgstr ""
"link:http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/[AsciiDoc "
"構文クイックリファレンス]"

#. type: Title ==
#: upstream/_guides/README.adoc:14
#, no-wrap, fuzzy
msgid "Variables for Use in Documents"
msgstr "ドキュメントで使用する変数"

#. type: Plain text
#: upstream/_guides/README.adoc:19
#, fuzzy
msgid ""
"The following variables externalize key information that can change over "
"time, and so references to such information should be done by using the "
"variable inside of {} curly brackets. The complete list of externalized "
"variables for use is given in the following table:"
msgstr ""
"以下の変数は、時間の経過とともに変化する可能性のあるキー情報を外部化していますので、そのような情報への参照は "
"{}中括弧内の変数を使用して行う必要があります。使用する外部化された変数の完全なリストを以下の表に示します。"

#. type: Block title
#: upstream/_guides/README.adoc:20
#, no-wrap, fuzzy
msgid "Variables"
msgstr "変数"

#. type: Table
#: upstream/_guides/README.adoc:49
#, no-wrap, fuzzy
msgid ""
"|Property Name|Value|Description\n"
"|\\{quarkus-version}|{quarkus-version}|The current version of the project.\n"
"|\\{quarkus-home-url}|{quarkus-home-url}| The location of the project home "
"page.\n"
"|\\{quarkus-site-getting-started}|{quarkus-site-getting-started}| The "
"location of the getting started page.\n"
"\n"
"|\\{quarkus-org-url}|{quarkus-org-url}| The location of the project github "
"organization.\n"
"|\\{quarkus-base-url}|{quarkus-base-url}| Quarkus GitHub URL common base "
"prefix.\n"
"|\\{quarkus-clone-url}|{quarkus-clone-url}| Quarkus URL for git clone "
"referenced by the documentation.\n"
"|\\{quarkus-archive-url}|{quarkus-archive-url}| Quarkus URL to master source "
"archive.\n"
"|\\{quarkus-blob-url}|{quarkus-blob-url}| Quarkus URL to master blob source "
"tree; used for referencing source files.\n"
"|\\{quarkus-tree-url}|{quarkus-tree-url}| Quarkus URL to master source tree "
"root; used for referencing directories.\n"
"|\\{quarkus-issues-url}|{quarkus-issues-url}| Quarkus URL to the issues page."
"\n"
"|\\{quarkus-images-url}|{quarkus-images-url}| Quarkus URL to set of "
"container images delivered for Quarkus.\n"
"\n"
"|\\{quarkus-chat-url}|{quarkus-chat-url} | URL of our chat.\n"
"|\\{quarkus-mailing-list-subscription-email}|{quarkus-mailing-list-"
"subscription-email} | Email used to subscribe to our mailing list.\n"
"|\\{quarkus-mailing-list-index}|{quarkus-mailing-list-index} | Mailing list "
"index page.\n"
"\n"
"|\\{quickstarts-base-url}|{quickstarts-base-url}| Quickstarts URL common "
"base prefix.\n"
"|\\{quickstarts-clone-url}|{quickstarts-clone-url}| Quickstarts URL for git "
"clone referenced by the documentation.\n"
"|\\{quickstarts-archive-url}|{quickstarts-archive-url}| Quickstarts URL to "
"master source archive.\n"
"|\\{quickstarts-blob-url}|{quickstarts-blob-url}| Quickstarts URL to master "
"blob source tree; used for referencing source files.\n"
"|\\{quickstarts-tree-url}|{quickstarts-tree-url}| Quickstarts URL to master "
"source tree root; used for referencing directories.\n"
"\n"
"|\\{graalvm-version}|{graalvm-version}| Recommended GraalVM version to use.\n"
"|\\{graalvm-flavor}|{graalvm-flavor}| The full flavor of GraaVM to use e.g. "
"`19.3.1-java11`. Make sure to use a `java11` version.\n"
msgstr ""
"|プロパティ名|Value|Description |{quarkus-version}|{quarkus-"
"version}|プロジェクトの現在のバージョン。|{quarkus-home-url}|{quarkus-home-"
"url}|プロジェクトのホームページの場所。|{quarkus-site-getting-started}|{quarkus-site-getting-"
"started}| 開始ページの場所。"

#. type: Plain text
#: upstream/_guides/topic/container-first.adoc:4
#, no-wrap, fuzzy
msgid "layout: vision\n"
"permalink: /vision/container-first\n"
"---\n"
msgstr "layout: vision パーマリンク。/vision/container-first ---."

#. type: Title =
#: upstream/_guides/topic/container-first.adoc:7
#, no-wrap, fuzzy
msgid "{project-name} - Container First"
msgstr "プロジェクト名} - コンテナファースト"

#. type: Plain text
#: upstream/_guides/topic/container-first.adoc:12
#, fuzzy
msgid ""
"From the outset {project-name} has been designed around a container first "
"philosophy.  What this means in real terms is that {project-name} is "
"optimised for low memory usage and fast startup times in the following ways:"
msgstr ""
"最初から {project-name} はコンテナファーストの哲学に基づいて設計されています。これが実際に意味することは、{project-name} "
"は以下の方法でメモリ使用量を抑え、起動時間を短縮するように最適化されているということです。"

#. type: Labeled list
#: upstream/_guides/topic/container-first.adoc:13
#, no-wrap, fuzzy
msgid "First Class Support for Graal/SubstrateVM"
msgstr "Graal/SubstrateVMのファーストクラスサポート"

#. type: Plain text
#: upstream/_guides/topic/container-first.adoc:18
#, fuzzy
msgid ""
"Substrate support has been an important part of the design for {project-"
"name} from the beginning.  When an application is compiled down to a native "
"image it starts much faster and can run with a much smaller heap than a "
"standard JVM. {project-name} are all tested in Substrate, and can run "
"without the `-H:+ReportUnsupportedElementsAtRuntime` flag."
msgstr ""
"サブストレートのサポートは、最初から{project-"
"name}の設計の重要な部分でした。アプリケーションがネイティブイメージにコンパイルされると、標準的なJVMよりもはるかに高速に起動し、より小さなヒープで実行することができます。project-"
"name} はすべて Substrate でテストされており、 `-H:+ReportUnsupportedElementsAtRuntime` "
"フラグなしで実行することができます。"

#. type: Labeled list
#: upstream/_guides/topic/container-first.adoc:19
#, no-wrap, fuzzy
msgid "Build Time Metadata Processing"
msgstr "ビルドタイムメタデータ処理"

#. type: Plain text
#: upstream/_guides/topic/container-first.adoc:25
#, fuzzy
msgid ""
"As much processing as possible is done at build time, so your application "
"will only contain the classes that are actually needed at runtime. In a "
"traditional model all the classes required to perform the initial "
"application deployment hang around for the life of the application, even "
"though they are only used once. With {project-name} they are not even loaded "
"into the production JVM. This results in less memory usage, and also faster "
"startup time as all metadata processing has already been done."
msgstr ""
"可能な限り多くの処理はビルド時に行われるので、アプリケーションは実行時に実際に必要とされるクラスだけを含みます。従来のモデルでは、最初のアプリケーションのデプロイメントを実行するために必要なすべてのクラスは、一度しか使用されないにもかかわらず、アプリケーションの寿命の間、ぶら下がっています。project-"
"name}では、それらのクラスは本番環境のJVMにロードされません。その結果、メモリ使用量が少なくなり、すべてのメタデータ処理がすでに行われているため、起動時間も速くなります。"

#. type: Labeled list
#: upstream/_guides/topic/container-first.adoc:26
#, no-wrap, fuzzy
msgid "Reduction in Reflection Usage"
msgstr "リフレクション使用量の削減"

#. type: Plain text
#: upstream/_guides/topic/container-first.adoc:28
#, fuzzy
msgid ""
"As much as possible {project-name} tries to avoid reflection, reducing "
"startup time and memory usage."
msgstr "project-name}は可能な限り反射を避け、起動時間とメモリ使用量を減らすようにしています。"

#. type: Labeled list
#: upstream/_guides/topic/container-first.adoc:29
#, no-wrap, fuzzy
msgid "Native Image Pre Boot"
msgstr "ネイティブイメージのプリブート"

#. type: Plain text
#: upstream/_guides/topic/container-first.adoc:32
#, fuzzy
msgid ""
"When running in a native image {project-name} pre-boots as much of the "
"framework as possible during the native image build process. This means that "
"the resulting native image has already run most of the startup code and "
"serialized the result into the executable, resulting in even faster startup."
msgstr ""
"ネイティブイメージで{project-"
"name}を実行する場合、ネイティブイメージのビルドプロセスの間に、フレームワークの可能な限りの部分をプリブートします。これは、結果として得られるネイティブイメージがすでにほとんどのスタートアップコードを実行し、その結果を実行ファイルにシリアライズしていることを意味し、より高速なスタートアップを実現します。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:4
#, no-wrap, fuzzy
msgid "layout: community\n"
"permalink: /community/\n"
"---\n"
msgstr "layout: community パーマリンク。/community/ ---."

#. type: Title =
#: upstream/_guides/topic/community.adoc:6
#, no-wrap, fuzzy
msgid "{project-name} - Community"
msgstr "プロジェクト名} - コミュニティ"

#. type: Title ==
#: upstream/_guides/topic/community.adoc:8
#, no-wrap, fuzzy
msgid "Getting help"
msgstr "助けを求める"

#. type: Title ===
#: upstream/_guides/topic/community.adoc:10
#, no-wrap, fuzzy
msgid "Documentation"
msgstr "ドキュメント"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:14
#, fuzzy
msgid ""
"We have a lot of documentation, be sure to check link:{quarkus-site-getting-"
"started}[our getting started] page and all our link:/guides/[guides].  + "
"Also check out our link:/faq[FAQ] section and https://www.youtube.com/"
"playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO[Quarkus Tips Playlist]."
msgstr ""
"多くのドキュメントがありますので、 link:{quarkus-site-getting-started}[スタート]ページやすべての link:/"
"guides/[ガイドを]ご確認ください。+ また、 link:/faq[FAQ]セクションと link:https://www.youtube.com/"
"playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO[Quarkus Tipsプレイリスト]もご覧ください。"

#. type: Title ===
#: upstream/_guides/topic/community.adoc:15
#, no-wrap, fuzzy
msgid "Discussions"
msgstr "ディスカッション"

#. type: Labeled list
#: upstream/_guides/topic/community.adoc:17
#, no-wrap, fuzzy
msgid "Stack Overflow"
msgstr "スタックオーバーフロー"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:20
#, fuzzy
msgid ""
"Ask your questions on https://stackoverflow.com/questions/tagged/"
"quarkus[Stack Overflow]. + After the documentation, probably the best place "
"to look for answers. We actively monitor the https://stackoverflow.com/"
"questions/tagged/quarkus[quarkus tag]."
msgstr ""
"link:https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow] "
"で質問をしてみましょう。+ ドキュメントの後に、おそらく答えを探すのに最適な場所です。 link:https://stackoverflow.com/"
"questions/tagged/quarkus[quarkusタグを]積極的に監視しています。"

#. type: Labeled list
#: upstream/_guides/topic/community.adoc:21
#, no-wrap, fuzzy
msgid "Mailing list"
msgstr "メーリングリスト"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:23
#, fuzzy
msgid ""
"You can also ask questions on our mailing list. Join the Google group via "
"email {quarkus-mailing-list-subscription-email} or by visiting the Google "
"Groups page {quarkus-mailing-list-index}."
msgstr ""
"また、メーリングリストで質問をすることもできます。Google グループに参加するには、電子メール {quarkus-mailing-list-"
"subcription-email} または Google グループページ {quarkus-mailing-list-index} "
"から参加してください。"

#. type: Labeled list
#: upstream/_guides/topic/community.adoc:24
#, no-wrap, fuzzy
msgid "Live chat on Zulip"
msgstr "Zulipのライブチャット"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:27
#, fuzzy
msgid ""
"If you prefer live chat with the developers, we have a {quarkus-chat-"
"url}[Zulip chat] where we all hang out."
msgstr "開発者とのライブチャットがお好きな方は、{quarkus-chat-url}[Zulip chat]をご利用ください。"

#. type: Title ==
#: upstream/_guides/topic/community.adoc:28
#, no-wrap, fuzzy
msgid "Publications"
msgstr "出版物"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:31
#, fuzzy
msgid ""
"We are actively collection interesting blogs, articles, videos and other "
"interesting publications. You can find those on link:{quarkus-site-"
"publications}[Publications] page."
msgstr ""
"私たちは積極的に面白いブログ、記事、ビデオ、その他の興味深い出版物を収集しています。あなたは、 link:{quarkus-site-"
"publications}[出版物の]ページでそれらを見つけることができます。"

#. type: Title ==
#: upstream/_guides/topic/community.adoc:32
#, no-wrap, fuzzy
msgid "An Open Project"
msgstr "オープンプロジェクト"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:35
#, fuzzy
msgid ""
"{project-name} is an Open Source project licensed under the https://www."
"apache.org/licenses/LICENSE-2.0[Apache License version 2.0]. First and "
"foremost, it is an open community where contributions, ideas and discussions "
"are done in the open and welcome contributors. Let's join forces in building "
"the future of Java applications."
msgstr ""
"プロジェクト名}は link:https://www.apache.org/licenses/LICENSE-2.0[Apacheライセンスバージョン2."
"0]でライセンスされたオープンソースプロジェクトです。何よりもまず何よりも、貢献やアイデア、議論がオープンに行われ、貢献者を歓迎するオープンコミュニティです。力を合わせて、Javaアプリケーションの未来を築いていきましょう。"

#. type: Title ==
#: upstream/_guides/topic/community.adoc:36
#, no-wrap, fuzzy
msgid "Code and issue tracker"
msgstr "コードとイシュートラッカー"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:39
#, fuzzy
msgid ""
"The source code is hosted on {quarkus-base-url}[GitHub]. If you need to "
"report a bug or request a new feature, look for a similar one on our "
"{quarkus-issues-url}[github issues tracker]. If you don’t find any, create a "
"new issue."
msgstr ""
"ソースコードは{quarkus-base-url}[GitHub]でホストされています。バグの報告や新機能のリクエストが必要な場合は、{quarkus-"
"issues-url}[github issues tracker] で同様のものを探してください。もし見つからなければ、新しい課題を作成してください。"

#. type: Title ==
#: upstream/_guides/topic/community.adoc:41
#, no-wrap, fuzzy
msgid "Contributing"
msgstr "貢献"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:44
#, fuzzy
msgid "There are a lot of ways to contribute to {project-name} development:"
msgstr "プロジェクト名}の開発に貢献する方法はたくさんあります。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:46
#, fuzzy
msgid "Writing documentation and quickstarts,"
msgstr "ドキュメントを書いたり、クイックスタートをしたり。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:47
#, fuzzy
msgid "{quarkus-issues-url}[Fixing bugs or even just opening an issue],"
msgstr "{quarkus-issues-url}[バグを修正したり、問題を開くだけでも構いません]。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:48
#, fuzzy
msgid "Writing new extensions."
msgstr "新しい拡張機能を書く。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:50
#, fuzzy
msgid ""
"If you are an extension developer or want to contribute to {project-name} "
"development, join our mailing list either:"
msgstr "もしあなたが拡張機能の開発者であったり、{project-name}の開発に貢献したい場合は、私たちのメーリングリストに参加してください。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:52
#, fuzzy
msgid "by emailing {quarkus-mailing-list-subscription-email}"
msgstr "メールで{quarkus-mailing-list-subscription-email}を送信してください。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:53
#, fuzzy
msgid "by visiting the Google Groups page {quarkus-mailing-list-index}"
msgstr "Googleグループのページ{quarkus-mailing-list-index}にアクセスしてください。"

#. type: Plain text
#: upstream/_guides/topic/community.adoc:54
#, fuzzy
msgid ""
"Make sure you visit our extensive link:{quarkus-writing-extensions-"
"guide}[extension developer guide]."
msgstr "当社の広範な link:{quarkus-writing-extensions-guide}[拡張機能開発者ガイドを]必ずご覧ください。"

#. type: Plain text
#: upstream/_guides/topic/publications.adoc:4
#, no-wrap, fuzzy
msgid "layout: publications\n"
"permalink: /publications/\n"
"---\n"
msgstr "layout: publications permalink./出版物/ ---."

#. type: Title =
#: upstream/_guides/topic/publications.adoc:6
#, no-wrap, fuzzy
msgid "{project-name} - Publications"
msgstr "プロジェクト名} - 出版物"

#. type: Plain text
#: upstream/_guides/topic/publications.adoc:9
#, fuzzy
msgid ""
"Below is a list of articles, blogs, podcast and other tidbits published "
"online around {project-name}."
msgstr "以下は、{project-name}周辺でオンラインで公開されている記事、ブログ、ポッドキャスト、その他の豆知識のリストです。"

#. type: Plain text
#: upstream/_guides/topic/publications.adoc:10
#, fuzzy
msgid ""
"If you believe we are missing an article, blog or video https://github.com/"
"quarkusio/quarkusio.github.io[submit an issue]."
msgstr ""
"記事、ブログ、ビデオが不足していると思われる場合は、 link:https://github.com/quarkusio/quarkusio."
"github.io[問題を提出して]ください。"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:4
#, no-wrap, fuzzy
msgid "layout: vision\n"
"permalink: /vision/developer-joy\n"
"---\n"
msgstr "layout: vision permalink./vision/developer-joy ---."

#. type: Title =
#: upstream/_guides/topic/developer-joy.adoc:7
#, no-wrap, fuzzy
msgid "{project-name} - Developer Joy"
msgstr "プロジェクト名} - Developer Joy"

#. type: Title ==
#: upstream/_guides/topic/developer-joy.adoc:9
#, no-wrap, fuzzy
msgid "Beyond simply working, we're aiming for Joy"
msgstr "単純に働くことを超えて、Joyを目指す"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:12
#, fuzzy
msgid ""
"{project-name} is not just about being great for writing Web Applications or "
"Micro-Services. We're focusing on more than the feature set: we make sure "
"that every feature works well, simply, with little to no configuration, in "
"the most intuitive way possible. It should be trivial to develop simple "
"things, and easy to develop the more complex ones."
msgstr ""
"project-"
"name}は、単にWebアプリケーションやマイクロサービスを書くために優れているということだけではありません。私たちが重視しているのは機能セットだけではありません:"
" 私たちは、可能な限り直感的な方法で、ほとんど設定をせずに、シンプルに、すべての機能がうまく動作するようにしています。シンプルなものを開発するのは簡単で、複雑なものを開発するのは簡単でなければなりません。"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:14
#, fuzzy
msgid ""
"We've looked for the most useful extensions, we've made sure they all work "
"together, that every use-case is covered, that out-of-the-box configuration "
"is the most sensible, that every error helps you to resolve it. More than "
"productivity: using {project-name} should be enjoyable."
msgstr ""
"私たちは最も有用な拡張機能を探し、それらがすべて一緒に動作し、すべてのユースケースがカバーされていること、箱から出してすぐに使える設定が最も賢明であること、すべてのエラーが解決に役立つことを確認しました。生産性以上のもの:"
" {project-name} を使うことは楽しいものでなければなりません。"

#. type: Title ===
#: upstream/_guides/topic/developer-joy.adoc:15
#, no-wrap, fuzzy
msgid "Unified configuration"
msgstr "統一された設定"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:18
#, fuzzy
msgid ""
"Gone are the days of a thousand configuration files and formats. We're "
"aiming for cohesion, so a single configuration file is all it takes for "
"{project-name} applications to configure every single extension. Not only "
"that, but we've made sure that every configurable option has the most useful "
"and sensible defaults so you can get started with no configuration "
"whatsoever."
msgstr ""
"何千もの設定ファイルやフォーマットの時代は終わりました。私たちは一貫性を目指しているので、{project-"
"name}アプリケーションがすべての拡張機能を設定するために必要なのは、単一の設定ファイルだけです。それだけでなく、すべての設定可能なオプションには、最も便利で賢明なデフォルト値が設定されていることを確認していますので、何も設定しなくても始めることができます。"

#. type: Title ===
#: upstream/_guides/topic/developer-joy.adoc:19
#, no-wrap, fuzzy
msgid "Live Coding"
msgstr "ライブコーディング"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:23
#, fuzzy
msgid ""
"One of the major productivity problems that face most Java developers is "
"traditional Java development workflow. For most web developers this will "
"generally be:"
msgstr ""
"ほとんどのJava開発者が直面する主要な生産性の問題の1つは、従来のJava開発ワークフローです。ほとんどのウェブ開発者にとって、これは一般的には"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:25
#, fuzzy
msgid "_Write Code_ -> _Compile_ -> _Deploy_ -> _Refresh Browser_ -> _Repeat_"
msgstr "_コードを書く_→ _コンパイル_→ _デプロイ_→ _ブラウザを更新_→ _繰り返し_"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:29
#, fuzzy
msgid ""
"This can be a major drain on productivity, as the compile + redeploy cycle "
"can often take up to a minute or more. {project-name} aims to solve this "
"problem with its _Live Coding_ feature. When running in development mode the "
"workflow is simply:"
msgstr ""
"これは、コンパイルと再デプロイのサイクルが1分以上かかることが多く、生産性を大きく低下させる可能性があります。project-name}は、 "
"_ライブコーディング_機能でこの問題を解決しようとしています。開発モードで実行している場合、ワークフローは単純です。"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:31
#, fuzzy
msgid "_Write Code_ -> _Refresh Browser_ -> _Repeat_"
msgstr "_コードを書く_→ _ブラウザを更新_→ _繰り返し_"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:34
#, fuzzy
msgid ""
"This will work out of the box, with no special setup required. This works "
"for Java file, application config, and static resources."
msgstr ""
"これは、特別な設定を必要とせず、箱から出してすぐに動作します。これはJavaファイル、アプリケーション設定、静的リソースに対して動作します。"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:43
#, fuzzy
msgid ""
"When you run `mvn compile quarkus:dev` {project-name} will launch in "
"development mode. When it receives a HTTP request it will hold the request, "
"and check to see if any application source files have been changed. If they "
"have it will transparently compile the changed files, redeploy the "
"application with the changed files, and then the HTTP request will continue "
"to the redeployed application. {project-name} redeploys are much faster than "
"a traditional app server, so for all but the largest applications this "
"should take well under a second."
msgstr ""
"`mvn compile quarkus:dev` {project-name} を実行すると、開発モードで起動します。HTTP "
"リクエストを受信すると、リクエストを保持し、アプリケーションのソースファイルが変更されたかどうかをチェックします。もし変更されていれば、変更されたファイルを透過的にコンパイルし、変更されたファイルでアプリケーションを再デプロイし、再デプロイされたアプリケーションへの "
"HTTP リクエストを続けます。project-name} "
"の再デプロイは、従来のアプリサーバよりもはるかに高速なので、大規模なアプリケーションを除くすべてのアプリケーションでは、1秒以下で完了するはずです。"

#. type: Title ===
#: upstream/_guides/topic/developer-joy.adoc:45
#, no-wrap, fuzzy
msgid "Works on all the things"
msgstr "すべてのことに取り組む"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:48
#, fuzzy
msgid ""
"There's nothing worse than getting different results when running your "
"application or tests under Maven, Gradle, or the IDE. Whatever your "
"workflow, {project-name} applications or tests are trivial to run in any "
"environment, so pick your favorite tool and we make sure you get the same "
"results as easily as possible."
msgstr ""
"Maven、Gradle、IDEでアプリケーションやテストを実行したときに、異なる結果を得ることほど悪いことはありません。ワークフローがどのようなものであれ、{project-"
"name}アプリケーションやテストはどのような環境でも簡単に実行できます。"

#. type: Title ===
#: upstream/_guides/topic/developer-joy.adoc:49
#, no-wrap, fuzzy
msgid "Opinionated"
msgstr "ご意見番"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:52
#, fuzzy
msgid ""
"We get it: there are a thousand ways to write the same code. Every company "
"has traditions about how a project should be structured, and that can be "
"fine. But it makes it really hard to write simple documentation, to onboard "
"new developers, and to make things simple."
msgstr ""
"同じコードを書く方法は何千通りもあります。どの会社にもプロジェクトの構造化についての伝統があり、それはそれでいいのです。しかし、簡単なドキュメントを書いたり、新しい開発者を迎え入れたり、物事をシンプルにするのは本当に難しいことです。"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:54
#, fuzzy
msgid ""
"{project-name} will focus on what we feel is the simplest and most useful "
"way to use any given feature. We will work hard to trim that particular "
"feature to its most useful essence, and to document it thoroughly, in an "
"intuitive manner. That's analysing up-front how to best use that feature and "
"helping you avoid that analysis, through our experience, and guiding you in "
"what we think is the best way to do things. That's taking an opinion on how "
"you should do things and voicing it."
msgstr ""
"project-"
"name}は、与えられた機能を使用するための最もシンプルで最も有用な方法と思われるものに焦点を当てます。私たちは、その特定の機能を最も有用な本質に落とし込み、直観的な方法で徹底的に文書化するように努力します。これは、その機能をどのように使うのが一番良いかを前もって分析し、私たちの経験から、そのような分析を避けるためのお手伝いをし、私たちが考える最善の方法をお客様にご案内することです。これは、物事をどのように行うべきかについて意見を述べ、それを表明することです。"

#. type: Plain text
#: upstream/_guides/topic/developer-joy.adoc:55
#, fuzzy
msgid ""
"Perhaps you'll disagree with our opinion, or you'll have a much more complex "
"use-case that will not be solved by our recommended way, but that's fine. "
"Don't worry: we will not prevent you from more advanced usage on the "
"features we provide or the frameworks we integrate."
msgstr ""
"おそらくあなたは私たちの意見に同意しないかもしれませんし、私たちの推奨する方法では解決できない複雑なユースケースを抱えているかもしれませんが、それは構いません。ご心配なく:"
" 私たちが提供する機能や私たちが統合しているフレームワークのより高度な利用を妨げることはありません。"

#. type: Title =
#: upstream/_guides/topic/architecture.adoc:2
#, no-wrap, fuzzy
msgid "{project-name} - Architecture"
msgstr "プロジェクト名} - 建築"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:5
#, fuzzy
msgid "image::images/architecture-phases.png"
msgstr "image::images/architecture-phases.png"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:9
#, fuzzy
msgid ""
"{project-name} has an architecture that does as much processing as possible "
"at build time. Annotations and other descriptors are processed as early as "
"possible, and then {project-name} will generate bytecode based on this "
"information. This results in lower memory usage and faster startup speeds at "
"runtime."
msgstr ""
"{project-"
"name}は、ビルド時に可能な限り多くの処理を行うアーキテクチャを持っています。アノテーションやその他の記述子はできるだけ早い段階で処理され、{project-"
"name}はこの情報に基づいてバイトコードを生成します。その結果、メモリ使用量が少なくなり、実行時の起動速度が速くなります。"

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:10
#, no-wrap, fuzzy
msgid "Application Architecture"
msgstr "アプリケーションアーキテクチャ"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:14
#, fuzzy
msgid ""
"This means that a {project-name} based application will go through a few "
"different distinct phases, each of which can potentially be executed in a "
"different JVM. These phases are:"
msgstr ""
"これは、{project-"
"name}ベースのアプリケーションがいくつかの異なるフェーズを経て、それぞれが異なるJVMで実行される可能性があることを意味します。これらのフェーズは以下の通りです。"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:22
#, fuzzy
msgid ""
"This involves processing all the metadata that is present in the application "
"and its libraries, such as annotations, descriptors etc, and processing this "
"information to create bytecode that is executable at runtime. This generated "
"bytecode will directly start the runtime services that were represented by "
"the metadata. For example if your application contains a `@WebServlet` "
"annotation this phase will output the bytecode required to start Undertow "
"and register this Servlet.  The end result of this phase is a runnable "
"application that should be equivalent to manually wiring up the runtime "
"services you require, without any of the deployment time code present."
msgstr ""
"これには、アノテーションやディスクリプタなどのアプリケーションやそのライブラリに存在するすべてのメタデータを処理し、この情報を処理して実行時に実行可能なバイトコードを生成することが含まれます。この生成されたバイトコードは、メタデータによって表現されたランタイムサービスを直接起動します。例えば、アプリケーションに "
"`@WebServlet` アノテーションが含まれている場合、このフェーズは Undertow "
"を起動してこのサーブレットを登録するために必要なバイトコードを出力します。このフェーズの最終的な結果は、デプロイ時のコードを一切使用せずに、必要なランタイムサービスを手動で配線するのと同等の実行可能なアプリケーションとなります。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:23
#, no-wrap, fuzzy
msgid "JVM Startup"
msgstr "JVMスタートアップ"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:29
#, fuzzy
msgid ""
"When running as a normal JVM application the bytecode generated in the "
"augmentation phase will be executed to start the runtime services needed by "
"the application. In production mode this will generally be in a different "
"JVM instance, which means that none of the classes needed by the "
"augmentation phase will be loaded at runtime, resulting in a smaller memory "
"footprint and faster startup time. In development mode this will be the same "
"JVM, allowing for the application to be quickly restarted when changes are "
"made."
msgstr ""
"通常のJVMアプリケーションとして実行している場合、拡張フェーズで生成されたバイトコードは、アプリケーションが必要とするランタイムサービスを開始するために実行されます。本番モードでは、これは通常、別のJVMインスタンスで実行されます。これは、拡張フェーズで必要とされるクラスが実行時にロードされないことを意味し、その結果、メモリフットプリントが小さくなり、起動時間が速くなります。開発モードでは、これは同じJVMになり、変更が加えられたときにアプリケーションを迅速に再起動することができます。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:30
#, no-wrap, fuzzy
msgid "Native Image Build"
msgstr "ネイティブイメージのビルド"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:38
#, fuzzy
msgid ""
"When building a native image with SubstrateVM any code that is part of a "
"static initializer is run as part of the native image build process, and the "
"results are directly stored in memory. {project-name} takes advantage of "
"this by generating some of the startup code in static initializer blocks, so "
"they are run as part of the image build process rather than on image startup."
" This has multiple advantages, as the image build is a standard JVM it is "
"still possible to use JVM features such as reflection and dynamic proxy "
"generation that do not work out of the box on Substrate. As most of the "
"startup is done in this phase the native image will start even faster, as it "
"effectively contains a serialized image of an already started application."
msgstr ""
"SubstrateVMでネイティブイメージをビルドする際、静的イニシャライザの一部であるコードは、ネイティブイメージのビルドプロセスの一部として実行され、その結果は直接メモリに保存されます。project-"
"name}は、スタートアップコードの一部を静的イニシャライザブロックに生成することで、この利点を利用しているため、イメージの起動時ではなく、イメージのビルドプロセスの一部として実行されます。これには複数の利点があります。イメージビルドが標準のJVMであるため、 "
"Substrate上では動作しないリフレクションや動的プロキシ生成などのJVM機能を使用することができます。ほとんどの起動はこのフェーズで行われるので、すでに起動しているアプリケーションのシリアライズされたイメージを効果的に含んでいるため、ネイティブイメージの起動はさらに速くなります。"

#. type: Labeled list
#: upstream/_guides/topic/architecture.adoc:39
#, no-wrap, fuzzy
msgid "Native Image Start"
msgstr "ネイティブイメージの開始"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:42
#, fuzzy
msgid ""
"As most of the work has been done in the image build the actual native image "
"startup will generally only contain tasks that can't be done in advance, "
"such as opening sockets and connecting to databases."
msgstr ""
"ほとんどの作業はイメージのビルドで行われているので、実際のネイティブイメージの起動には、ソケットを開いたりデータベースに接続したりといった、事前にできないタスクしか含まれていないのが一般的です。"

#. type: Title ==
#: upstream/_guides/topic/architecture.adoc:43
#, no-wrap, fuzzy
msgid "Extension Architecture"
msgstr "拡張アーキテクチャ"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:50
#, fuzzy
msgid ""
"As a result of this architecture every extension will provide two artifacts, "
"one that handles build time processing (the `-deployment` artifacts), and "
"another `-runtime` artifact that contains the classes needed at runtime. "
"Only the runtime artifact will end up in the final application. The end "
"result of the deployment process is some generated bytecode that can "
"directly start any runtime services required by the application (but don't "
"worry, you don't have to know anything about bytecode to write a {project-"
"name} extension)."
msgstr ""
"1つはビルド時の処理を処理するもの( `-deployment` アーティファクト)で、もう1つは実行時に必要なクラスを含む `-runtime` "
"アーティファクトです。実行時の成果物だけが最終的なアプリケーションになります。デプロイ処理の最終的な結果は、アプリケーションが必要とする任意のランタイムサービスを直接起動することができる、生成されたバイトコードです "
"(ただし、バイトコードについて何も知らなくても {project-name} 拡張モジュールを書くことができますので、ご心配なく)。"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:56
#, fuzzy
msgid ""
"{project-name} uses a novel technique for writing bytecode that we are "
"calling _Bytecode Recording_. Basically at augment time extensions can "
"inject instances of classes that contain the runtime logic to start "
"services, and invoke these instances as if they were directly starting the "
"service. These injected instances are actually proxies, that override all "
"the public methods and record exactly which invocations have been made, what "
"the parameters are, and the order they were made in. They then generate "
"bytecode to perform this exact same sequence of invocations when the "
"application starts up."
msgstr ""
"project-name}では、バイト "
"_コード_を書くための新しい技術を使用しています。基本的には、拡張機能はサービスを開始するためのランタイムロジックを含むクラスのインスタンスを注入し、あたかもサービスを直接開始するかのようにインスタンスを呼び出すことができます。これらのインスタンスは実際にはプロキシで、すべてのパブリックメソッドをオーバーライドして、どの呼び出しが行われたか、パラメータは何か、どの順番で行われたかを正確に記録します。そして、アプリケーションが起動したときに、全く同じシーケンスの呼び出しを実行するバイトコードを生成します。"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:60
#, fuzzy
msgid ""
"This means that from the point of view of an extension developer it looks "
"like they are making invocations that directly start the application, when "
"in fact they are recording bytecode that will be used to start the "
"application later."
msgstr ""
"これは、拡張機能の開発者の視点から見ると、アプリケーションを直接起動する呼び出しをしているように見えますが、実際には後でアプリケーションを起動するために使用されるバイトコードを記録していることを意味します。"

#. type: Plain text
#: upstream/_guides/topic/architecture.adoc:62
#, fuzzy
msgid ""
"The `-deployment` artifacts work by defining `@BuildStep` methods, that "
"produce and consume `BuildItem` instances, and can also record bytecode if "
"required."
msgstr ""
"`-deployment` アーティファクトは `@BuildStep` メソッドを定義することで動作し、 `BuildItem` "
"インスタンスを生成して消費し、必要に応じてバイトコードを記録することもできます。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:4
#, no-wrap, fuzzy
msgid "layout: vision\n"
"permalink: /vision/continuum\n"
"---\n"
msgstr "layout: vision パーマリンク。/vision/continuum ---."

#. type: Title =
#: upstream/_guides/topic/continuum.adoc:7
#, no-wrap, fuzzy
msgid "The Imperative and Reactive Continuum"
msgstr "強迫的なものと反応的なものの連続体"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:15
#, fuzzy
msgid ""
"For years, the client-server architecture has been the de-facto standard to "
"build applications.  But a major shift happened.  The _one model rules them "
"all_ age is over.  A new range of applications and architecture styles has "
"emerged and impacts how code is written and how applications are deployed "
"and executed.  HTTP microservices, reactive applications, message-driven "
"microservices and serverless are now central players in modern systems."
msgstr ""
"何年もの間、クライアント・サーバ・アーキテクチャは、アプリケーションを構築するための事実上の標準でした。しかし、大きな変化が起こりました。1 "
"_つのモデルがすべての_時代を支配していた時代は終わりました。新しい範囲のアプリケーションとアーキテクチャのスタイルが登場し、コードの書き方やアプリケーションの展開と実行の仕方に影響を与えています。HTTP "
"マイクロサービス、リアクティブアプリケーション、メッセージ駆動型マイクロサービス、サーバーレスは、現在のシステムの中心的な役割を果たしています。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:18
#, fuzzy
msgid ""
"Quarkus has been designed with this new world in mind, and provides first-"
"class support for these different paradigms.  Quarkus development model "
"morphs to adapt itself to the type of application you are developing."
msgstr ""
"Quarkusは、この新しい世界を念頭に置いて設計されており、これらの異なるパラダイムに対してファーストクラスのサポートを提供しています。Quarkusの開発モデルは、開発中のアプリケーションの種類に合わせて変化します。"

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:19
#, no-wrap, fuzzy
msgid "HTTP microservices"
msgstr "HTTPマイクロサービス"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:24
#, fuzzy
msgid ""
"Let’s start with the basic: HTTP microservices.  In this context, you need "
"to develop an HTTP endpoint, often called REST or CRUD.  You process "
"incoming HTTP requests, and to do so you often need to rely on others "
"services, such as databases, or another HTTP service."
msgstr ""
"まずは基本中の基本、HTTPマイクロサービスから始めましょう。この文脈では、HTTP エンドポイントを開発する必要があり、しばしば REST や "
"CRUD "
"と呼ばれます。あなたは受信したHTTPリクエストを処理しますが、そのためにはデータベースなどの他のサービスや別のHTTPサービスに依存する必要があることが多いです。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:27
#, fuzzy
msgid ""
"For this type of application, Quarkus relies on well-known standards such as "
"JAX-RS, JPA and MicroProfile Rest Client.  Let's take a very simple "
"application handling _fruits_. The code would be something like:"
msgstr ""
"このタイプのアプリケーションのために、QuarkusはJAX-RS、JPA、MicroProfile Rest "
"Clientなどのよく知られた標準に依存しています。 _果物を_扱う非常にシンプルなアプリケーションを見てみましょう。コードは次のようになります。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:34
#, no-wrap
msgid ""
"@Path(\"fruits\")\n"
"@Produces(\"application/json\")\n"
"@Consumes(\"application/json\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:37
#, no-wrap
msgid "    @Inject\n"
"    EntityManager entityManager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:43
#, no-wrap
msgid ""
"    @GET\n"
"    public List<Fruit> get() {\n"
"        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit."
"class)\n"
"              .getResultList();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:53
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    public Fruit getSingle(@PathParam Integer id) {\n"
"        Fruit entity = entityManager.find(Fruit.class, id);\n"
"        if (entity == null) {\n"
"            throw new WebApplicationException(\"Fruit with id of \" + id + "
"\" does not exist.\", 404);\n"
"        }\n"
"        return entity;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:60
#, no-wrap
msgid ""
"    @POST\n"
"    @Transactional\n"
"    public Response create(Fruit fruit) {\n"
"        if (fruit.getId() != null) {\n"
"            throw new WebApplicationException(\"Id was invalidly set on "
"request.\", 422);\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:64
#, no-wrap
msgid ""
"        entityManager.persist(fruit);\n"
"        return Response.ok(fruit).status(201).build();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:67
#, no-wrap
msgid "    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:72
#, fuzzy
msgid ""
"If you are a Java EE or Spring user, this development model should look "
"familiar.  You expose a _resource_ containing methods annotated with `@GET`, "
"`@POST`... to handle the different requests.  The _path_ is specified using "
"the `@Path` annotation."
msgstr ""
"Java EEやSpringのユーザーであれば、この開発モデルは見覚えがあるはずです。さまざまなリクエストを処理するために `@GET`, "
"`@POST`... でアノテーションされたメソッドを含む _リソース_を公開しています。 _パスは_ `@Path` "
"アノテーションを使って指定します。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:75
#, fuzzy
msgid ""
"JPA users will recognize the `EntityManager` used to access the database.  "
"Finally, methods requiring a transaction are simply annotated with "
"`@Transactional`."
msgstr ""
"JPAユーザーは、データベースへのアクセスに使用された `EntityManager` を認識します。最後に、トランザクションを必要とするメソッドには "
"`@Transactional`."

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:79
#, fuzzy
msgid ""
"Let's now imagine you need to access another HTTP endpoint.  You can use a "
"HTTP client directly, this is nothing more than repeating boilerplate code.  "
"Quarkus provides a way to call HTTP endpoint easily using the MicroProfile "
"Rest Client API."
msgstr ""
"ここで、別の HTTP "
"エンドポイントにアクセスする必要があることを想像してみましょう。HTTPクライアントを直接使用することができますが、これは定型文のコードを繰り返すだけです。Quarkusは、MicroProfile "
"Rest Client APIを使用してHTTPエンドポイントを簡単に呼び出す方法を提供しています。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:81
#, fuzzy
msgid "First declare your service as follows:"
msgstr "まずは以下のようにサービスを宣言しましょう。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:87
#, no-wrap
msgid "@Path(\"/v2\")\n"
"@RegisterRestClient\n"
"public interface CountriesService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:93
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/name/{name}\")\n"
"    @Produces(\"application/json\")\n"
"    Set<Country> getByName(@PathParam(\"name\") String name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:96
#, fuzzy
msgid ""
"For each call you are intending to do, add a method and use annotations to "
"describe the behavior."
msgstr "意図している各呼び出しについて、メソッドを追加し、動作を記述するためにアノテーションを使用します。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:98
#, fuzzy
msgid "Then, in your resource, just use the `CountriesService`:"
msgstr "そして、リソースの中で `CountriesService`."

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:103
#, no-wrap
msgid "@Path(\"/country\")\n"
"public class CountriesResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:107
#, no-wrap
msgid "    @Inject\n"
"    @RestClient\n"
"    CountriesService countriesService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:115
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/name/{name}\")\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public Set<Country> name(@PathParam(\"name\") String name) {\n"
"        return countriesService.getByName(name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:120
#, fuzzy
msgid ""
"But you may be wondering where the URL is configured as it's not in the code."
"  Remember, it must not be hard-coded because the url likely depends on the "
"environment.  The URL is configured in the application configuration:"
msgstr ""
"しかし、コードの中にはないので、URLがどこに設定されているのか気になるかもしれません。URLは環境に依存している可能性が高いので、ハードコード化してはいけないことを覚えておいてください。URLはアプリケーションの設定で設定されています。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:125
#, no-wrap
msgid ""
"# the format is interface-name/mp-rest/url=the-service-url\n"
"org.acme.restclient.CountriesService/mp-rest/url=https://restcountries.eu/"
"rest\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:128
#, fuzzy
msgid ""
"The url can now be updated during the deployment or at launch time using "
"system properties or environment variables."
msgstr "システムのプロパティや環境変数を使用して、デプロイ時や起動時にURLを更新できるようになりました。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:133
#, fuzzy
msgid ""
"Application requirements have changed drastically over the last few years.  "
"For any application to succeed in the era of cloud computing, big data or "
"IoT, going reactive is increasingly becoming the architecture style to "
"follow."
msgstr ""
"アプリケーションの要件は、ここ数年で大きく変化しています。クラウド コンピューティング、ビッグ データ、IoT "
"の時代に成功するためには、リアクティブなアーキテクチャを採用することがますます重要になってきています。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:137
#, fuzzy
msgid ""
"Today’s users embrace applications that have milliseconds of response time, "
"100% uptime, lower latency, push data instead of pull, higher throughput and "
"elasticity.  However, these features are nearly impossible to achieve by "
"using _yesterday’s software architecture_ without a huge investment in "
"resources, infrastructure and tooling.  The world changed and having dozen "
"of servers, long response time (> 500 ms), downtime due to maintenance or "
"waterfalls of failures does not meet the expected user experience."
msgstr ""
"今日のユーザーは、ミリ秒単位の応答時間、100%のアップタイム、低いレイテンシー、プルではなくプッシュデータ、より高いスループットと弾力性を持つアプリケーションを採用しています。しかし、これらの機能は、リソース、インフラストラクチャ、ツールへの莫大な投資なしでは、 "
"_昨日のソフトウェアアーキテクチャ_を使用して達成することはほぼ不可能です。世界は変わり、何十台ものサーバーを持ち、長い応答時間（＞500ms）、メンテナンスによるダウンタイム、障害の滝のような状況では、期待されるユーザー体験を満たすことはできません。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:140
#, fuzzy
msgid ""
"Quarkus stands with you on your path to reactive.  First, you can implement "
"asynchronous HTTP endpoint as follows:"
msgstr "Quarkusは、お客様のリアクティブへの道筋をサポートします。まず、以下のように非同期HTTPエンドポイントを実装します。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:148
#, no-wrap
msgid ""
"@GET\n"
"@Path(\"/greeting/{name}\")\n"
"public CompletionStage<String> greetings(@PathParam(\"name\") String name) {\n"
"    return reactiveService.getAsyncGreetings(name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:152
#, fuzzy
msgid ""
"Method actions can compose asynchronous operations and complete the result "
"when everything is done without blocking threads.  This greatly improves "
"resource consumption and elasticity."
msgstr ""
"メソッドアクションは、スレッドをブロックすることなく、すべてが行われたときに非同期操作を構成し、結果を完了させることができます。これにより、リソース消費と弾力性が大幅に向上します。"

#.  TODO Async rest client, but does not seem to be working.
#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:157
#, fuzzy
msgid ""
"But, what about streams? Generating a _server-sent event_ response with "
"Quarkus is just as simple:"
msgstr "しかし、ストリームについてはどうでしょうか？Quarkusを使用して _サーバーから送信されたイベント_レスポンスを生成するのは簡単です。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:166
#, no-wrap
msgid ""
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@GET\n"
"@Path(\"/neo\")\n"
"public Publisher<String> stream() {\n"
"    return service.getStream();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:170
#, fuzzy
msgid ""
"This method returns a Reactive Streams `Publisher`.  To provide this stream, "
"you can either use https://github.com/ReactiveX/RxJava[Rx Java 2] or https://"
"www.smallrye.io/smallrye-reactive-streams-operators/[MicroProfile Reactive "
"Streams Operators]:"
msgstr ""
"このメソッドは、Reactive Streams `Publisher` を返します。このストリームを提供するために、 link:https://"
"github.com/ReactiveX/RxJava[Rx Java 2]または link:https://www.smallrye.io/"
"smallrye-reactive-streams-operators/[MicroProfile Reactive Streams "
"演算子を]使用することができます。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:181
#, no-wrap
msgid ""
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"@GET\n"
"@Path(\"/neo\")\n"
"public Publisher<String> stream() {\n"
"    return ReactiveStreams.of(\"a\", \"b\", \"c\")\n"
"           .map(String::toUpperCase)\n"
"           .buildRs();\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:183
#, no-wrap, fuzzy
msgid "Message-driven microservices"
msgstr "メッセージ駆動型マイクロサービス"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:187
#, fuzzy
msgid ""
"However, HTTP characteristics prohibit implementing https://www."
"reactivemanifesto.org/[reactive systems], where all the components interact "
"using asynchronous messages passing.  But no worries, Quarkus is perfectly "
"suited to implement message-driven microservices and reactive systems."
msgstr ""
"しかし、HTTPの特性上、すべてのコンポーネントが非同期メッセージの通過を使用して相互作用する link:https://www."
"reactivemanifesto.org/"
"[リアクティブシステムを]実装することはできません。しかし心配はいりません。Quarkusは、メッセージ駆動型のマイクロサービスやリアクティブシステムの実装に完全に適しています。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:189
#, fuzzy
msgid ""
"First, you can consume messages from various brokers such as AMQP or Kafka, "
"and process these messages smoothly:"
msgstr "まず、AMQPやKafkaなどの各種ブローカーからのメッセージを消費し、スムーズに処理することができます。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:194
#, no-wrap
msgid "@ApplicationScoped\n"
"public class HealthDataProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:201
#, no-wrap
msgid ""
"  @Incoming(\"health\")\n"
"  @Outgoing(\"heartbeat\")\n"
"  public double filtered(Health health) {\n"
"    return health.getHeartbeat();\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:206
#, fuzzy
msgid ""
"The `@Incoming` and `@Outgoing` annotations are part of https://www.smallrye."
"io/smallrye-reactive-messaging[Reactive Messaging].  They are used to "
"express from which _stream_ you are consuming and to which stream you are "
"sending.  Thanks to Reactive Messaging you can consume and send messages "
"from and to different brokers and transports such as HTTP, Kafka, or http://"
"camel.apache.org[Apache Camel]."
msgstr ""
"`@Incoming` および `@Outgoing` アノテーションは、 link:https://www.smallrye.io/smallrye-"
"reactive-messaging[Reactive Messaging] の一部です。これは、どの "
"_ストリーム_からどのストリームにメッセージを消費し、どのストリームにメッセージを送信しているかを表現するために使用されます。Reactive "
"Messaging のおかげで、HTTP、Kafka、 link:http://camel.apache.org[Apache Camel] "
"などの異なるブローカーやトランスポートとの間でメッセージを消費したり、送信したりすることができます。"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:209
#, fuzzy
msgid ""
"Sometimes you need more than just handling messages one by one.  You can "
"also express your message processing logic using reactive programming as "
"illustrated in the following snippet:"
msgstr ""
"メッセージを一つずつ処理するだけでは不十分な場合もあります。次のスニペットに示すように、リアクティブプログラミングを使ってメッセージ処理ロジックを表現することもできます。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:222
#, no-wrap
msgid ""
"@Incoming(\"health\")\n"
"@Outgoing(\"output\")\n"
"public Publisher<KafkaMessage<String, JsonObject>> "
"filterState(Flowable<MqttMessage> input) {\n"
"    return input\n"
"      .map(message -> Buffer.buffer(message.getPayload()).toJsonObject())\n"
"      .map(json -> json.getJsonObject(\"state\"))\n"
"      .distinctUntilChanged(json -> json.getString(\"state\")) // Filter on "
"the \"State\" key of the json object.\n"
"      .doOnNext(json -> LOGGER.info(\"Forwarding new state '{}' to Kafka\", "
"json.encode()))\n"
"      .map(json -> KafkaMessage.of(\"state\", \"neo\", json));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:225
#, fuzzy
msgid ""
"Stream-based manipulation can either use Rx Java 2 (as in the previous "
"snippet) or MicroProfile Reactive Streams Operators."
msgstr ""
"ストリームベースの操作には、Rx Java 2 (前のスニペットのように) または MicroProfile Reactive Streams "
"Operators を使用することができます。"

#. type: Title ==
#: upstream/_guides/topic/continuum.adoc:226
#, no-wrap, fuzzy
msgid "Functions as a Service and Serverless"
msgstr "サービスとしての機能とサーバーレス"

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:230
#, fuzzy
msgid ""
"Thanks to their stellar startup time and low memory usage, you can implement "
"functions using Quarkus to be used in serverless environments.  If you are "
"using AWS Lambda, your Quarkus function looks like:"
msgstr ""
"驚異的な起動時間と低いメモリ使用量のおかげで、Quarkusを使用してサーバーレス環境で使用する関数を実装することができます。AWS "
"Lambdaを使用している場合、Quarkusの関数は次のようになります。"

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:234
#, no-wrap
msgid ""
"public class HelloLambda implements RequestHandler<HelloRequest, String> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:237
#, no-wrap
msgid "    @Inject\n"
"    HelloGreeter greeter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/topic/continuum.adoc:243
#, no-wrap
msgid ""
"    @Override\n"
"    public String handleRequest(HelloRequest request, Context context) {\n"
"        return greeter.greet(request.firstName, request.lastName);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/topic/continuum.adoc:245
#, fuzzy
msgid ""
"You can use any of the Quarkus features in your function and benefit from "
"the fast startup and low memory utilization. With Quarkus, you can embrace "
"this new world without having to change your programming language."
msgstr ""
"Quarkusの機能のいずれかを関数で使用することができ、高速な起動と低メモリ使用率の恩恵を受けることができます。Quarkusを使用すると、プログラミング言語を変更することなく、この新しい世界を受け入れることができます。"

#. type: Plain text
#: upstream/_guides/topic/standards.adoc:4
#, no-wrap
msgid "layout: vision\n"
"permalink: /vision/standards\n"
"---\n"
msgstr "layout: vision\n"
"permalink: /vision/standards\n"
"---\n"

#. type: Title =
#: upstream/_guides/topic/standards.adoc:7
#, no-wrap
msgid "{project-name} - Our View on Standards"
msgstr "{project-name} - 規格に関する我々の見解"

#. type: Plain text
#: upstream/_guides/topic/standards.adoc:13
#, fuzzy
msgid ""
"Let's go to the quark of things.  We don't want you to spend hours learning "
"new technologies.  Instead, the {project-name} programming model builds on "
"top of proven standards.  Be it official standards such as Eclipse "
"MicroProfile or leading frameworks in a specific domain such as Eclipse Vert."
"x."
msgstr ""
"物質のクオークに行きましょう。私達は、あなたが新しい技術を習得するのに何時間も費やして欲しくありません。代わりに、 {project-name} "
"プログラミングモデルは実証済の標準の上に構築されています。Eclipse MicroProfileのような公式の標準や、Eclipse Vert."
"xのような特定のドメインにおけるリーディングフレームワークを使用します。"

#. type: Plain text
#: upstream/_guides/topic/standards.adoc:19
msgid ""
"Our dependency injection solution is based on CDI.  You can use JAX-RS "
"annotations to define the REST endpoints.  You can use JPA annotations to "
"map your persistent entities and JTA annotations to declare the transaction "
"boundaries.  You can use Eclipse MicroProfile to configure and monitor your "
"application.  You can use Vert.x, Apache Camel and we support much more."
msgstr ""
"我々の依存性注入ソリューションはCDIに基づいています。 JAX-RS アノテーションを使用して REST エンドポイントを定義できます。 JPA "
"アノテーションを使用して、永続エンティティーをマップし、 JTA アノテーションを使用してトランザクション境界を宣言することができます。 Eclipse "
"MicroProfileを使用して、アプリケーションを構成およびモニターできます。 Vert.x、Apache "
"Camelを使用することが出来、そして更に多くをサポートしています。"

#. type: Plain text
#: upstream/_guides/topic/standards.adoc:23
msgid ""
"Since we're not limited to standards we can go beyond and extend your "
"possibilities.  Of course, {project-name} is not a passive consumer.  Our "
"goal is to improve and innovate the technologies we use and contribute back "
"to the open source projects and standards we rely on."
msgstr ""
"我々は標準に限定されない為、あなたの可能性を広げることが可能です。 もちろん、{project-name} は受動的な消費者ではありません。 "
"私たちのゴールは、使用する技術を改善、革新し、私たちが頼りにしているオープンソースプロジェクトと標準に貢献することです。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/qute.adoc:6
#, no-wrap, fuzzy
msgid "Qute Templating Engine"
msgstr "クートテンプレーティングエンジン"

#. type: Plain text
#: upstream/_guides/qute.adoc:17
#, fuzzy
msgid ""
"Qute is a templating engine designed specifically to meet the Quarkus needs. "
" The usage of reflection is minimized to reduce the size of native images.  "
"The API combines both the imperative and the non-blocking reactive style of "
"coding.  In the development mode, all files located in `src/main/resources/"
"templates` are watched for changes and modifications are immediately visible."
"  Furthermore, we try to detect most of the template problems at build time. "
" In this guide, you will learn how to easily render templates in your "
"application."
msgstr ""
"Quteは、Quarkusのニーズを満たすために特別に設計されたテンプレートエンジンです。ネイティブ画像のサイズを小さくするために、リフレクションの使用は最小限に抑えられています。APIは、コーディングの命令型と非ブロッキング反応型の両方のスタイルを組み合わせています。開発モードでは、 "
"`src/main/resources/templates` "
"にあるすべてのファイルが変更のために監視され、変更はすぐに表示されます。さらに、ビルド時にテンプレートの問題のほとんどを検出するようにしています。このガイドでは、アプリケーションでテンプレートを簡単にレンダリングする方法を学びます。"

#. type: Title ==
#: upstream/_guides/qute.adoc:20
#, no-wrap, fuzzy
msgid "Hello World with JAX-RS"
msgstr "JAX-RSでハローワールド"

#. type: Plain text
#: upstream/_guides/qute.adoc:24
#, fuzzy
msgid ""
"If you want to use Qute in your JAX-RS application, you need to add the "
"`quarkus-resteasy-qute` extension first.  In your `pom.xml` file, add:"
msgstr ""
"JAX-RSアプリケーションでQuteを使用する場合は、まず `quarkus-resteasy-qute` の拡張子を追加する必要があります。 "
"`pom.xml` ファイルに追加します。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1267
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-qute</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:34 upstream/_guides/qute.adoc:98
#, fuzzy
msgid "We'll start with a very simple template:"
msgstr "まずはとてもシンプルなテンプレートから。"

#. type: Block title
#: upstream/_guides/qute.adoc:35
#, no-wrap, fuzzy
msgid "hello.txt"
msgstr "ハローテキスト"

#. type: delimited block -
#: upstream/_guides/qute.adoc:39 upstream/_guides/qute.adoc:103
#, no-wrap
msgid "Hello {name}! <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:40
#, fuzzy
msgid ""
"`{name}` is a value expression that is evaluated when the template is "
"rendered."
msgstr "`{name}` は、テンプレートがレンダリングされたときに評価される値の式です。"

#. type: Plain text
#: upstream/_guides/qute.adoc:43
#, fuzzy
msgid ""
"By default, all files located in the `src/main/resources/templates` "
"directory and its subdirectories are registered as templates. Templates are "
"validated during startup and watched for changes in the development mode."
msgstr ""
"デフォルトでは、 `src/main/resources/templates` "
"ディレクトリとそのサブディレクトリにあるすべてのファイルがテンプレートとして登録されます。テンプレートは起動時に検証され、開発モードでの変更を監視します。"

#. type: Plain text
#: upstream/_guides/qute.adoc:45
#, fuzzy
msgid "Now let's inject the \"compiled\" template in the resource class."
msgstr "では、リソースクラスに「コンパイル済み」テンプレートを注入してみましょう。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:987
#: upstream/_guides/qute-reference.adoc:1272
#, no-wrap, fuzzy
msgid "HelloResource.java"
msgstr "HelloResource.java"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:934
#: upstream/_guides/qute-reference.adoc:972
#: upstream/_guides/qute-reference.adoc:991
#: upstream/_guides/qute-reference.adoc:1276
#, no-wrap
msgid "package org.acme.quarkus.sample;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1281
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.QueryParam;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1284
#, no-wrap
msgid ""
"import io.quarkus.qute.TemplateInstance;\n"
"import io.quarkus.qute.Template;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1000
#: upstream/_guides/qute-reference.adoc:1287
#, no-wrap
msgid "@Path(\"hello\")\n"
"public class HelloResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1290
#, no-wrap
msgid "    @Inject\n"
"    Template hello; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1297
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public TemplateInstance get(@QueryParam(\"name\") String name) {\n"
"        return hello.data(\"name\", name); <2> <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1299
#, fuzzy
msgid ""
"If there is no `@ResourcePath` qualifier provided, the field name is used to "
"locate the template. In this particular case, we're injecting a template "
"with path `templates/hello.txt`."
msgstr ""
"`@ResourcePath` "
"の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この特定のケースでは、パスが `templates/"
"hello.txt` であるテンプレートを注入しています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1300
#, fuzzy
msgid ""
"`Template.data()` returns a new template instance that can be customized "
"before the actual rendering is triggered. In this case, we put the name "
"value under the key `name`. The data map is accessible during rendering."
msgstr ""
"`Template.data()` "
"は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` "
"の下に置きます。データマップはレンダリング中にアクセス可能です。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1301
#, fuzzy
msgid ""
"Note that we don't trigger the rendering - this is done automatically by a "
"special `ContainerResponseFilter` implementation."
msgstr ""
"レンダリングをトリガーしないことに注意してください - これは特別な `ContainerResponseFilter` "
"の実装によって自動的に行われます。"

#. type: Plain text
#: upstream/_guides/qute.adoc:77
#, fuzzy
msgid "If your application is running, you can request the endpoint:"
msgstr "アプリケーションが動作している場合は、エンドポイントを要求することができます。"

#. type: delimited block -
#: upstream/_guides/qute.adoc:82
#, no-wrap
msgid "$ curl -w \"\\n\" http://localhost:8080/hello?name=Martin\n"
"Hello Martin!\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/qute.adoc:84
#, no-wrap, fuzzy
msgid "Type-safe templates"
msgstr "タイプセーフテンプレート"

#. type: Plain text
#: upstream/_guides/qute.adoc:87
#, fuzzy
msgid ""
"There's an alternate way to declare your templates in your Java code, which "
"relies on the following convention:"
msgstr "Java コードでテンプレートを宣言する別の方法がありますが、これは以下の規約に依存しています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:926
#, fuzzy
msgid ""
"Organise your template files in the `/src/main/resources/templates` "
"directory, by grouping them into one directory per resource class. So, if "
"your `ItemResource` class references two templates `hello` and `goodbye`, "
"place them at `/src/main/resources/templates/ItemResource/hello.txt` and `/"
"src/main/resources/templates/ItemResource/goodbye.txt`. Grouping templates "
"per resource class makes it easier to navigate to them."
msgstr ""
"テンプレートファイルを `/src/main/resources/templates` ディレクトリに整理し、リソースクラスごとに 1 "
"つのディレクトリにグループ化します。つまり、 `ItemResource` クラスが `hello` と `goodbye` の 2 "
"つのテンプレートを参照している場合は、 `/src/main/resources/templates/ItemResource/hello.txt` と "
"`/src/main/resources/templates/ItemResource/goodbye.txt` "
"に配置します。リソースクラスごとにテンプレートをグループ化することで、テンプレートへのナビゲートが容易になります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:927
#, fuzzy
msgid ""
"In each of your resource class, declare a `@CheckedTemplate static class "
"Template {}` class within your resource class."
msgstr ""
"各リソースクラスで、リソースクラス内で `@CheckedTemplate static class Template {}` クラスを宣言します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:928
#, fuzzy
msgid ""
"Declare one `public static native TemplateInstance method();` per template "
"file for your resource."
msgstr ""
"リ ソ ース のテ ン プ レー ト フ ァ イ ルごとに `public static native TemplateInstance "
"method();` を 1 つずつ宣言 し ます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:929
#, fuzzy
msgid "Use those static methods to build your template instances."
msgstr "テンプレートインスタンスを構築するには、これらの静的メソッドを使用します。"

#. type: Plain text
#: upstream/_guides/qute.adoc:96
#, fuzzy
msgid "Here's the previous example, rewritten using this style:"
msgstr "先ほどの例を、このスタイルで書き換えてみました。"

#. type: Block title
#: upstream/_guides/qute.adoc:99
#, no-wrap, fuzzy
msgid "HelloResource/hello.txt"
msgstr "HelloResource/hello.txt"

#. type: Plain text
#: upstream/_guides/qute.adoc:107
#, fuzzy
msgid "Now let's declare and use those templates in the resource class."
msgstr "では、これらのテンプレートをリソースクラスで宣言して使ってみましょう。"

#. type: delimited block -
#: upstream/_guides/qute.adoc:120
#, no-wrap
msgid ""
"import io.quarkus.qute.TemplateInstance;\n"
"import io.quarkus.qute.api.CheckedTemplate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:128
#, no-wrap
msgid ""
"    @CheckedTemplate\n"
"    public static class Templates {\n"
"        public static native TemplateInstance hello(); <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:135
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public TemplateInstance get(@QueryParam(\"name\") String name) {\n"
"        return Templates.hello().data(\"name\", name); <2> <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:137
#, fuzzy
msgid ""
"This declares a template with path `templates/HelloResource/hello.txt`."
msgstr "これは、パス `templates/HelloResource/hello.txt` のテンプレートを宣言します。"

#. type: Plain text
#: upstream/_guides/qute.adoc:138
#, fuzzy
msgid ""
"`Templates.hello()` returns a new template instance that can be customized "
"before the actual rendering is triggered. In this case, we put the name "
"value under the key `name`. The data map is accessible during rendering."
msgstr ""
"`Templates.hello()` "
"は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` "
"の下に置きます。データマップはレンダリング中にアクセス可能です。"

#. type: Plain text
#: upstream/_guides/qute.adoc:141
#, fuzzy
msgid ""
"Once you have declared a `@CheckedTemplate` class, we will check that all "
"its methods point to existing templates, so if you try to use a template "
"from your Java code and you forgot to add it, we will let you know at build "
"time :)"
msgstr ""
"`@CheckedTemplate` クラスを宣言したら、すべてのメソッドが既存のテンプレートを指しているかどうかをチェックしますので、もし Java "
"コードからテンプレートを使おうとして追加するのを忘れてしまった場合は、ビルド時にお知らせします :)"

#. type: Plain text
#: upstream/_guides/qute.adoc:143
#, fuzzy
msgid ""
"Keep in mind this style of declaration allows you to reference templates "
"declared in other resources too:"
msgstr "このスタイルの宣言では、他のリソースで宣言されたテンプレートも参照できることを覚えておいてください。"

#. type: delimited block -
#: upstream/_guides/qute.adoc:155
#, no-wrap
msgid "import io.quarkus.qute.TemplateInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:158
#, no-wrap
msgid "@Path(\"goodbye\")\n"
"public class GoodbyeResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:165
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public TemplateInstance get(@QueryParam(\"name\") String name) {\n"
"        return HelloResource.Templates.hello().data(\"name\", name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/qute.adoc:167
#, no-wrap, fuzzy
msgid "Top-level type-safe templates"
msgstr "トップレベルのタイプセーフテンプレート"

#. type: Plain text
#: upstream/_guides/qute.adoc:171
#, fuzzy
msgid ""
"Naturally, if you want to declare templates at the top-level, directly in `/"
"src/main/resources/templates/hello.txt`, for example, you can declare them "
"in a toplevel (non-nested) `Templates` class:"
msgstr ""
"当然のことながら、トップレベルでテンプレートを宣言したい場合、例えば `/src/main/resources/templates/hello.txt` "
"で直接宣言したい場合は、トップレベル（非入れ子）の `Templates` クラスで宣言することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:945
#: upstream/_guides/qute-reference.adoc:976
#, no-wrap
msgid ""
"import io.quarkus.qute.TemplateInstance;\n"
"import io.quarkus.qute.Template;\n"
"import io.quarkus.qute.api.CheckedTemplate;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:185
#, no-wrap
msgid ""
"@CheckedTemplate\n"
"public class Templates {\n"
"    public static native TemplateInstance hello(); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:187
#, fuzzy
msgid "This declares a template with path `templates/hello.txt`."
msgstr "これは、パス `templates/hello.txt` のテンプレートを宣言します。"

#. type: Title ==
#: upstream/_guides/qute.adoc:189
#, no-wrap, fuzzy
msgid "Template Parameter Declarations "
msgstr "テンプレートパラメータ宣言"

#. type: Plain text
#: upstream/_guides/qute.adoc:192
#, fuzzy
msgid ""
"If you declare a *parameter declaration* in a template then Qute attempts to "
"validate all expressions that reference this parameter and if an incorrect "
"expression is found the build fails."
msgstr ""
"テンプレートで "
"*パラメータ宣言を*宣言した場合、Quteはこのパラメータを参照するすべての式の検証を試み、間違った式が見つかった場合はビルドが失敗します。"

#. type: Plain text
#: upstream/_guides/qute.adoc:194
#, fuzzy
msgid "Let's suppose we have a simple class like this:"
msgstr "このようなシンプルなクラスがあったとしましょう。"

#. type: Block title
#: upstream/_guides/qute.adoc:195
#, no-wrap, fuzzy
msgid "Item.java"
msgstr "アイテム.java"

#. type: delimited block -
#: upstream/_guides/qute.adoc:202
#, no-wrap
msgid ""
"public class Item {\n"
"    public String name;\n"
"    public BigDecimal price;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:205
#, fuzzy
msgid ""
"And we'd like to render a simple HTML page that contains the item name and "
"price."
msgstr "そして、商品名と価格が記載されたシンプルなHTMLページをレンダリングしたいと思います。"

#. type: Plain text
#: upstream/_guides/qute.adoc:207 upstream/_guides/qute.adoc:268
#, fuzzy
msgid "Let's start again with the template:"
msgstr "改めてテンプレートから始めてみましょう。"

#. type: Block title
#: upstream/_guides/qute.adoc:208
#, no-wrap, fuzzy
msgid "ItemResource/item.html"
msgstr "ItemResource/item.html"

#. type: delimited block -
#: upstream/_guides/qute.adoc:222
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>{item.name}</title> <1>\n"
"</head>\n"
"<body>\n"
"    <h1>{item.name}</h1>\n"
"    <div>Price: {item.price}</div> <2> \n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:224 upstream/_guides/qute.adoc:287
#, fuzzy
msgid ""
"This expression is validated. Try to change the expression to `{item."
"nonSense}` and the build should fail."
msgstr "この式は検証済みです。式を `{item.nonSense}` に変更するとビルドに失敗します。"

#. type: Plain text
#: upstream/_guides/qute.adoc:225
#, fuzzy
msgid "This is also validated."
msgstr "これも検証されています。"

#. type: Plain text
#: upstream/_guides/qute.adoc:227
#, fuzzy
msgid "Finally, let's create a resource class with type-safe templates:"
msgstr "最後に、タイプセーフなテンプレートを使ってリソースクラスを作ってみましょう。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:930
#, no-wrap, fuzzy
msgid "ItemResource.java"
msgstr "アイテムリソース.java"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:948
#, no-wrap
msgid "@Path(\"item\")\n"
"public class ItemResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:251
#, no-wrap
msgid ""
"    @CheckedTemplate\n"
"    public static class Templates {\n"
"        public static native TemplateInstance item(Item item); <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:259
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    @Produces(MediaType.TEXT_HTML)\n"
"    public TemplateInstance get(@PathParam(\"id\") Integer id) {\n"
"        return Templates.item(service.findItem(id)); <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:963
#, fuzzy
msgid ""
"Declare a method that gives us a `TemplateInstance` for `templates/"
"ItemResource/item.html` and declare its `Item item` parameter so we can "
"validate the template."
msgstr ""
"`templates/ItemResource/item.html` に `TemplateInstance` を与えるメソッドを宣言し、その "
"`Item item` パラメータを宣言することで、テンプレートを検証することができます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:965
#, fuzzy
msgid "Make the `Item` object accessible in the template."
msgstr "テンプレート内で `Item` オブジェクトにアクセスできるようにします。"

#. type: Title ===
#: upstream/_guides/qute.adoc:263
#, no-wrap, fuzzy
msgid "Template parameter declaration inside the template itself"
msgstr "テンプレート内部のテンプレートパラメータ宣言"

#. type: Plain text
#: upstream/_guides/qute.adoc:266
#, fuzzy
msgid ""
"Alternatively, you can declare your template parameters in the template file "
"itself."
msgstr "あるいは、テンプレートファイル自体でテンプレートパラメータを宣言することもできます。"

#. type: Block title
#: upstream/_guides/qute.adoc:269
#, no-wrap, fuzzy
msgid "item.html"
msgstr "アイテム.html"

#. type: delimited block -
#: upstream/_guides/qute.adoc:284
#, no-wrap
msgid ""
"{@org.acme.Item item} <1>\n"
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>{item.name}</title> <2>\n"
"</head>\n"
"<body>\n"
"    <h1>{item.name}</h1>\n"
"    <div>Price: {item.price}</div> \n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:286
#, fuzzy
msgid ""
"Optional parameter declaration. Qute attempts to validate all expressions "
"that reference the parameter `item`."
msgstr "オプションのパラメータ宣言。Qute は、パラメータを参照するすべての式の検証を試みます `item`."

#. type: Plain text
#: upstream/_guides/qute.adoc:289
#, fuzzy
msgid "Finally, let's create a resource class."
msgstr "最後に、リソースクラスを作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/qute.adoc:310
#, no-wrap
msgid "    @Inject\n"
"    ItemService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1314
#, no-wrap
msgid "    @Inject\n"
"    Template item; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:321
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    @Produces(MediaType.TEXT_HTML)\n"
"    public TemplateInstance get(@PathParam(\"id\") Integer id) {\n"
"        return item.data(\"item\", service.findItem(id)); <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:323
#, fuzzy
msgid "Inject the template with path `templates/item.html`."
msgstr "テンプレートのパスを `templates/item.html` にインジェクトします。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:1010
#, no-wrap, fuzzy
msgid "Template Extension Methods"
msgstr "テンプレートの拡張方法"

#. type: Plain text
#: upstream/_guides/qute.adoc:328
#, no-wrap, fuzzy
msgid ""
"*Template extension methods* are used to extend the set of accessible "
"properties of data objects.\n"
msgstr "*テンプレート拡張メソッドは*、データオブジェクトのアクセス可能なプロパティのセットを拡張するために使用されます。"

#. type: Plain text
#: upstream/_guides/qute.adoc:332
#, fuzzy
msgid ""
"Sometimes, you're not in control of the classes that you want to use in your "
"template, and you cannot add methods to them. Template extension methods "
"allows you to declare new method for those classes that will be available "
"from your templates just as if they belonged to the target class."
msgstr ""
"時には、テンプレートで使用したいクラスをコントロールできず、メソッドを追加できないことがあります。テンプレート拡張メソッドを使うと、テンプレートから利用できるようになるクラスのメソッドを、あたかもターゲットクラスに属しているかのように宣言することができます。"

#. type: Plain text
#: upstream/_guides/qute.adoc:337
#, fuzzy
msgid ""
"Let's keep extending on our simple HTML page that contains the item name, "
"price and add a discounted price.  The discounted price is sometimes called "
"a \"computed property\".  We will implement a template extension method to "
"render this property easily.  Let's update our template:"
msgstr ""
"アイテム名、価格、値引き価格を含むシンプルなHTMLページを拡張していきましょう。値引き価格は「計算されたプロパティ」と呼ばれることがあります。このプロパティを簡単にレンダリングするためのテンプレート拡張メソッドを実装します。テンプレートを更新してみましょう。"

#. type: Block title
#: upstream/_guides/qute.adoc:338
#, no-wrap, fuzzy
msgid "HelloResource/item.html"
msgstr "HelloResource/item.html"

#. type: delimited block -
#: upstream/_guides/qute.adoc:355
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>{item.name}</title>\n"
"</head>\n"
"<body>\n"
"    <h1>{item.name}</h1>\n"
"    <div>Price: {item.price}</div> \n"
"    {#if item.price > 100} <1>\n"
"    <div>Discounted Price: {item.discountedPrice}</div> <2>\n"
"    {/if}\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:357
#, fuzzy
msgid "`if` is a basic control flow section."
msgstr "`if` は、基本的な制御フローの部分です。"

#. type: Plain text
#: upstream/_guides/qute.adoc:358
#, fuzzy
msgid ""
"This expression is also validated against the `Item` class and obviously "
"there is no such property declared. However, there is a template extension "
"method declared on the `TemplateExtensions` class - see below."
msgstr ""
"この式は `Item` クラスに対しても検証されており、明らかにそのようなプロパティは宣言されていません。しかし、 "
"`TemplateExtensions` クラスで宣言されたテンプレート拡張メソッドがあります - 以下を参照してください。"

#. type: Plain text
#: upstream/_guides/qute.adoc:360
#, fuzzy
msgid "Finally, let's create a class where we put all our extension methods:"
msgstr "最後に、すべての拡張メソッドを置くクラスを作りましょう。"

#. type: Block title
#: upstream/_guides/qute.adoc:361
#, no-wrap, fuzzy
msgid "TemplateExtensions.java"
msgstr "TemplateExtensions.java"

#. type: delimited block -
#: upstream/_guides/qute.adoc:367
#, no-wrap
msgid "import io.quarkus.qute.TemplateExtension;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:370
#, no-wrap
msgid "@TemplateExtension\n"
"public class TemplateExtensions {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:375
#, no-wrap
msgid ""
"    public static BigDecimal discountedPrice(Item item) { <1>\n"
"        return item.price.multiply(new BigDecimal(\"0.9\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:377
#, fuzzy
msgid ""
"A static template extension method can be used to add \"computed "
"properties\" to a data class. The class of the first parameter is used to "
"match the base object and the method name is used to match the property name."
""
msgstr ""
"静的テンプレート拡張メソッドを使用して、データクラスに「計算されたプロパティ」を追加することができます。最初のパラメータのクラスはベースオブジェクトと一致するように使用され、メソッド名はプロパティ名と一致するように使用されます。"

#. type: Plain text
#: upstream/_guides/qute.adoc:380
#, fuzzy
msgid ""
"you can place template extension methods in every class if you annotate them "
"with `@TemplateExtension` but we advise to keep them either grouped by "
"target type, or in a single `TemplateExtensions` class by convention."
msgstr ""
"テンプレート拡張メソッドは、 `@TemplateExtension` "
"でアノテーションを付ければ、すべてのクラスに配置することができますが、規約上、ターゲットタイプでグループ化するか、 "
"`TemplateExtensions` クラスにまとめておくことをお勧めします。"

#. type: Title ==
#: upstream/_guides/qute.adoc:381
#, no-wrap, fuzzy
msgid "Rendering Periodic Reports"
msgstr "定期レポートの表示"

#. type: Plain text
#: upstream/_guides/qute.adoc:386
#, fuzzy
msgid ""
"Templating engine could be also very useful when rendering periodic reports. "
" You'll need to add the `quarkus-scheduler` and `quarkus-qute` extensions "
"first.  In your `pom.xml` file, add:"
msgstr ""
"テンプレーティングエンジンは、定期的なレポートをレンダリングする際にも非常に便利かもしれません。最初に `quarkus-scheduler` と "
"`quarkus-qute` の拡張子を追加する必要があります。 `pom.xml` ファイルに追加します。"

#. type: delimited block -
#: upstream/_guides/qute.adoc:397
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-qute</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-scheduler</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:400
#, fuzzy
msgid ""
"Let's suppose the have a `SampleService` bean whose `get()` method returns a "
"list of samples."
msgstr "`SampleService` ビーンがあり、その `get()` メソッドがサンプルのリストを返すとしましょう。"

#. type: Block title
#: upstream/_guides/qute.adoc:401
#, no-wrap, fuzzy
msgid "Sample.java"
msgstr "Sample.java"

#. type: delimited block -
#: upstream/_guides/qute.adoc:409
#, no-wrap
msgid ""
"public class Sample {\n"
"    public boolean valid;\n"
"    public String name;\n"
"    public String data;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:412
#, fuzzy
msgid "The template is simple:"
msgstr "テンプレートはシンプルなものを使用しています。"

#. type: Block title
#: upstream/_guides/qute.adoc:413
#, no-wrap, fuzzy
msgid "report.html"
msgstr "報告書.html"

#. type: delimited block -
#: upstream/_guides/qute.adoc:436
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>Report {now}</title>\n"
"</head>\n"
"<body>\n"
"    <h1>Report {now}</h1>\n"
"    {#for sample in samples} <1>\n"
"      <h2>{sample.name ?: 'Unknown'}</h2> <2>\n"
"      <p>\n"
"      {#if sample.valid}\n"
"        {sample.data}\n"
"      {#else}\n"
"        <strong>Invalid sample found</strong>.\n"
"      {/if}\n"
"      </p>\n"
"    {/for}\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:438
#, fuzzy
msgid ""
"The loop section makes it possible to iterate over iterables, maps and "
"streams."
msgstr "ループセクションでは、イテレーション、マップ、ストリームの反復処理が可能になります。"

#. type: Plain text
#: upstream/_guides/qute.adoc:439
#, fuzzy
msgid ""
"This value expression is using the https://en.wikipedia.org/wiki/"
"Elvis_operator[elvis operator] - if the name is null the default value is "
"used."
msgstr ""
"この値式は link:https://en.wikipedia.org/wiki/Elvis_operator[elvis 演算子を]使用します - "
"名前が NULL の場合はデフォルト値が使用されます。"

#. type: Block title
#: upstream/_guides/qute.adoc:441
#, no-wrap, fuzzy
msgid "ReportGenerator.java"
msgstr "ReportGenerator.java"

#. type: delimited block -
#: upstream/_guides/qute.adoc:446
#, no-wrap
msgid "import javax.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:450
#, no-wrap
msgid ""
"import io.quarkus.qute.Template;\n"
"import io.quarkus.qute.api.ResourcePath;\n"
"import io.quarkus.scheduler.Scheduled;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:452
#, no-wrap
msgid "public class ReportGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:455
#, no-wrap
msgid "    @Inject\n"
"    SampleService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:458
#, no-wrap
msgid "    @ResourcePath(\"reports/v1/report_01\") <1>\n"
"    Template report;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute.adoc:468
#, no-wrap
msgid ""
"    @Scheduled(cron=\"0 30 * * * ?\") <2>\n"
"    void generate() {\n"
"        String result = report\n"
"            .data(\"samples\", service.get())\n"
"            .data(\"now\", java.time.LocalDateTime.now())\n"
"            .render(); <3>\n"
"        // Write the result somewhere...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:470
#, fuzzy
msgid ""
"In this case, we use the `@ResourcePath` qualifier to specify the template "
"path: `templates/reports/v1/report_01.html`."
msgstr ""
"この場合、 `@ResourcePath` の修飾子を使用してテンプレートのパスを指定します: `templates/reports/v1/"
"report_01.html`."

#. type: Plain text
#: upstream/_guides/qute.adoc:471
#, fuzzy
msgid ""
"Use the `@Scheduled` annotation to instruct Quarkus to execute this method "
"on the half hour. For more information see the link:scheduler[Scheduler] "
"guide."
msgstr ""
"`@Scheduled` アノテーションを使用して、Quarkusにこのメソッドを30分に実行するよう指示します。詳細については、 link:"
"scheduler[スケジューラーガイド]を参照してください。"

#. type: Plain text
#: upstream/_guides/qute.adoc:472
#, fuzzy
msgid ""
"The `TemplateInstance.render()` method triggers rendering. Note that this "
"method blocks the current thread."
msgstr ""
"`TemplateInstance.render()` "
"メソッドはレンダリングをトリガします。このメソッドは現在のスレッドをブロックすることに注意してください。"

#. type: Title ==
#: upstream/_guides/qute.adoc:473
#, no-wrap, fuzzy
msgid "Reactive and Asynchronous APIs"
msgstr "リアクティブAPIと非同期API"

#. type: Plain text
#: upstream/_guides/qute.adoc:476
#, fuzzy
msgid ""
"Templates can be rendered as a `CompletionStage<String>` (completed with the "
"rendered output asynchronously) or as `Publisher<String>` containing the "
"rendered chunks:"
msgstr ""
"テンプレートは、 `CompletionStage&amp;lt;String&amp;gt;` "
"（非同期にレンダリングされた出力で完了）としてレンダリングすることも、レンダリングされたチャンクを含む "
"`Publisher&amp;lt;String&amp;gt;` としてレンダリングすることもできます。"

#. type: delimited block -
#: upstream/_guides/qute.adoc:481
#, no-wrap
msgid ""
"CompletionStage<String> async = template.data(\"name\", \"neo\")."
"renderAsync();\n"
"Publisher<String> publisher = template.data(\"name\", \"neo\")."
"publisher();\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:486
#, fuzzy
msgid ""
"In the case of a `Publisher`, the template is rendered chunk by chunk "
"following the requests from the subscriber.  The rendering is not started "
"until a subscriber requests it.  The returned `Publisher` is an instance of "
"`io.smallrye.mutiny.Multi`."
msgstr ""
"`Publisher` "
"の場合、テンプレートは購読者からのリクエストに応じてチャンクごとにレンダリングされます。レンダリングは、サブスクライバがリクエストするまで開始されません。返された "
"`Publisher` は `io.smallrye.mutiny.Multi`."

#. type: Plain text
#: upstream/_guides/qute.adoc:488
#, fuzzy
msgid ""
"It is possible to create an instance of `io.smallrye.mutiny.Uni` as follows:"
msgstr "以下のように、 `io.smallrye.mutiny.Uni` のインスタンスを作成することができます。"

#. type: delimited block -
#: upstream/_guides/qute.adoc:492
#, no-wrap
msgid ""
"Uni<String> uni = Uni.createFrom().completionStage(() -> template."
"data(\"name\", \"neo\").renderAsync());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute.adoc:495
#, fuzzy
msgid ""
"In this case, the rendering only starts once the subscriber requests it."
msgstr "この場合、サブスクライバーが要求した場合にのみレンダリングが開始されます。"

#. type: Title ==
#: upstream/_guides/qute.adoc:496
#, no-wrap, fuzzy
msgid "Qute Reference Guide"
msgstr "キュートリファレンスガイド"

#. type: Plain text
#: upstream/_guides/qute.adoc:499
#, fuzzy
msgid ""
"To learn more about Qute, please refer to the link:qute-reference[Qute "
"reference guide]."
msgstr "Quteについて詳しく知りたい方は、Q link:qute-reference[ute参考ガイドを参考]にしてください。"

#. type: Title ==
#: upstream/_guides/qute.adoc:501
#, no-wrap, fuzzy
msgid "Qute Configuration Reference"
msgstr "Qute設定リファレンス"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/qute-reference.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Qute Reference Guide"
msgstr "クォークス - キューテのリファレンスガイド"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:24
#, fuzzy
msgid ""
"Qute is a templating engine designed specifically to meet the Quarkus needs. "
" The usage of reflection is minimized to reduce the size of native images.  "
"The API combines both the imperative and the non-blocking reactive style of "
"coding.  In the development mode, all files located in the `src/main/"
"resources/templates` folder are watched for changes and modifications are "
"immediately visible in your application.  Furthermore, Qute attempts to "
"detect most of the template problems at build time and fail fast.  In this "
"guide, you will find an <<hello_world_example,introductory example>>, the "
"description of the <<core_features,core features>> and "
"<<quarkus_integration,Quarkus integration>> details."
msgstr ""
"Quteは、Quarkusのニーズを満たすために特別に設計されたテンプレートエンジンです。ネイティブ画像のサイズを小さくするために、リフレクションの使用は最小限に抑えられています。APIは、コーディングの命令型と非ブロッキング反応型の両方のスタイルを組み合わせています。開発モードでは、 "
"`src/main/resources/templates` "
"フォルダにあるすべてのファイルが変更されているかどうかが監視され、変更があった場合はすぐにアプリケーションに表示されます。さらに、Quteはビルド時にテンプレートの問題のほとんどを検出しようとし、高速に失敗します。このガイドでは、導入 "
"link:#hello_world_example[例]、 link:#core_features[コア機能の]説明、 link:"
"#quarkus_integration[Quarkusの統合の]詳細について説明しています。"

#. type: Title ==
#: upstream/_guides/qute-reference.adoc:26
#, no-wrap, fuzzy
msgid "Hello World Example"
msgstr "ハローワールドの例"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:31
#, fuzzy
msgid ""
"In this example, we'd like to demonstrate the basic workflow when working "
"with Qute templates.  Let's start with a simple hello world example.  We "
"will always need some *template contents*:"
msgstr ""
"この例では、Quteのテンプレートを扱う際の基本的なワークフローをデモしたいと思います。まず、簡単なhello worldの例から始めましょう。 "
"*テンプレートの内容*は必ず必要になります。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:32
#, no-wrap, fuzzy
msgid "hello.html"
msgstr "hello.html"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:38
#, no-wrap
msgid "<html>\n"
"  <p>Hello {name}! <1>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:43
#, fuzzy
msgid ""
"Then, we will need to parse the contents into a *template definition* Java "
"object.  A template definition is an instance of `io.quarkus.qute.Template`."
msgstr ""
"そして、その内容を *テンプレート定義*Javaオブジェクトにパースする必要があります。テンプレート定義は、 `io.quarkus.qute."
"Template`."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:47
#, fuzzy
msgid ""
"If using Qute \"standalone\" you'll need to create an instance of `io."
"quarkus.qute.Engine` first.  The `Engine` represents a central point for "
"template management with dedicated configuration.  Let's use the convenient "
"builder:"
msgstr ""
"Quteを\"スタンドアロン\"で使用する場合は、まず `io.quarkus.qute.Engine` のインスタンスを作成する必要があります。 "
"`Engine` は、専用の設定でテンプレートを管理するための一元的なポイントを表しています。便利なビルダーを使ってみましょう。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:51
#, no-wrap
msgid "Engine engine = Engine.builder().addDefaults().build();\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:54
#, fuzzy
msgid ""
"In Quarkus, there is a preconfigured `Engine` available for injection - see "
"<<quarkus_integration>>."
msgstr ""
"Quarkusでは、あらかじめ設定された `Engine` がインジェクション用に利用可能です link:#quarkus_integration[- "
"[quarkus_integration] を]参照してください。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:56
#, fuzzy
msgid ""
"Once we have an `Engine` instance we could parse the template contents:"
msgstr "`Engine` のインスタンスがあれば、テンプレートの内容を解析することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:60
#, no-wrap
msgid "Template helloTemplate = engine.parse(helloHtmlContent);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:63
#, fuzzy
msgid ""
"In Quarkus, you can simply inject the template definition. The template is "
"automatically parsed and cached - see <<quarkus_integration>>."
msgstr ""
"Quarkusでは、テンプレートの定義を単純に注入することができます。テンプレートは自動的に解析され、キャッシュされます link:"
"#quarkus_integration[- [quarkus_integration]を]参照してください。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:65
#, fuzzy
msgid ""
"Finally, we will create a *template instance*, set the data and render the "
"output:"
msgstr "最後に *テンプレートインスタンスを*作成し、データを設定して出力をレンダリングします。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:70
#, no-wrap
msgid ""
"// Renders <html><p>Hello Jim!</p></html>\n"
"helloTemplate.data(\"name\", \"Jim\").render(); <1> \n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:72
#, fuzzy
msgid ""
"`Template.data(String, Object)` is a convenient method that creates a "
"template instance and sets the data in one step."
msgstr ""
"`Template.data(String, Object)` は、テンプレートのインスタンスを作成してデータを設定するだけの便利なメソッドです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:74
#, fuzzy
msgid "So the workflow is simple:"
msgstr "なので、仕事の流れは簡単です。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:76
#, fuzzy
msgid "Create template contents (`hello.html`),"
msgstr "テンプレートコンテンツを作成する ( `hello.html`)。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:77
#, fuzzy
msgid "Parse template definition (`io.quarkus.qute.Template`),"
msgstr "テンプレートの定義を解析する ( `io.quarkus.qute.Template`)。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:78
#, fuzzy
msgid "Create template instance (`io.quarkus.qute.TemplateInstance`),"
msgstr "テンプレートインスタンスを作成します ( `io.quarkus.qute.TemplateInstance`)。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:79
#, fuzzy
msgid "Render output."
msgstr "出力をレンダリングします。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:81
#, fuzzy
msgid ""
"The `Engine` is able to cache the definitions so that it's not necessary to "
"parse the contents again and again. In Quarkus, the caching is done "
"automatically."
msgstr ""
"`Engine` は定義をキャッシュすることができるので、何度も内容をパースする必要がありません。Quarkusでは、キャッシュは自動的に行われます。"

#. type: Title ==
#: upstream/_guides/qute-reference.adoc:83
#, no-wrap, fuzzy
msgid "Core Features"
msgstr "コア機能"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:85
#, no-wrap, fuzzy
msgid "Basic Building Blocks"
msgstr "基本的なビルディングブロック"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:88
#, fuzzy
msgid ""
"The dynamic parts of a template include comments, expressions, sections and "
"unparsed character data."
msgstr "テンプレートの動的な部分には、コメント、式、セクション、パースされていない文字データなどがあります。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:89
#, no-wrap, fuzzy
msgid "Comments "
msgstr "コメント"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:93
#, fuzzy
msgid ""
"A comment starts with `{!` and ends with `!}`, e.g. `{! This is a comment "
"!}`.  It could be multi-line and may contain expressions and sections: `{! "
"{#if true} !}`.  Of course, the content of a comment is completely ignored."
msgstr ""
"`{! This is a comment !}`コメントは `{!` で始まり `!}` "
"で終わる。コメントは複数行で、表現やセクションを含むことができます: `{! {#if true} !}`."
"もちろん、コメントの内容は完全に無視されます。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:95
#: upstream/_guides/qute-reference.adoc:213
#, no-wrap, fuzzy
msgid "Expressions"
msgstr "表現方法"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:100
#, fuzzy
msgid ""
"An <<expressions,expression>> outputs an evaluated value.  It consists of "
"one or more parts.  A part may represent simple properties: `{foo}`, `{item."
"name}` or virtual methods: `{item.get(name)}`, `{name ?: 'John'}`.  An "
"expression may start with a namespace: `{inject:colors}`."
msgstr ""
"link:#expressions[式は]評価された値を出力します。式は 1 "
"つ以上の部分から構成されています。部分は単純なプロパティを表すことができます: `{foo}`, `{item.name}` "
"または仮想メソッドを表すことができます: `{item.get(name)}`, `{name ?: 'John'}`."
"式は、名前空間で始まることがあります: `{inject:colors}`."

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:102
#: upstream/_guides/qute-reference.adoc:443
#, no-wrap, fuzzy
msgid "Sections"
msgstr "セクション"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:107
#, fuzzy
msgid ""
"A <<sections,section>> may contain text, expressions and nested sections: "
"`{#if foo}{foo.name}{/if}`.  The name in the closing tag is optional: `{#if "
"active}ACTIVE!{/}`.  It can be empty: `{#myTag image=true /}`.  A section "
"may declare nested section blocks: `{#if item.valid} Valid. {#else} Invalid. "
"{/if}` and decide which block to render."
msgstr ""
"1 つのセ ク シ ョ link:#sections[ン]はテキス ト ・ 式 ・ 入れ子に し たセ ク シ ョ ン を含む こ と がで き ます "
"： `{#if foo}{foo.name}{/if}`.クロージングタグの名前はオプションです: `{#if active}ACTIVE!{/}`."
"空にすることもできます: `{#myTag image=true /}`.セクションは、入れ子になったセクションブロックを宣言することができます: "
"`{#if item.valid} Valid. {#else} Invalid. {/if}` そして、どのブロックをレンダリングするかを決定します。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:108
#, no-wrap, fuzzy
msgid "Unparsed Character Data"
msgstr "未解析文字データ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:111
#, fuzzy
msgid ""
"It is used to mark the content that should be rendered but not parsed.  It "
"starts with `{|` and ends with `|}`: `{| <script>if(true){alert('Qute is "
"cute!')};</script> |}`, and could be multi-line."
msgstr ""
"これは、レンダリングされるべきだが解析されないコンテンツをマークするために使用されます。 `{|` で始まり `|}`: `{| "
"&amp;lt;script&amp;gt;if(true){alert('Qute is cute!')};&amp;lt;/"
"script&amp;gt; |}` で終わります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:113
#, fuzzy
msgid ""
"Previously, unparsed character data had to start with `{[` and end with `]}`."
" This syntax is still supported but we encourage users to switch to the new "
"syntax to avoid some common collisions with constructs from other languages."
msgstr ""
"以前は、アンパースされた文字データは `{[` で始まり `]}` "
"で終わる必要がありました。この構文はまだサポートされていますが、他の言語の構文とのよくある衝突を避けるために、新しい構文に切り替えることをお勧めします。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:115
#, no-wrap, fuzzy
msgid "Identifiers and Tags"
msgstr "識別子とタグ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:120
#, fuzzy
msgid ""
"Identifiers are used in expressions and section tags.  A valid identifier is "
"a sequence of non-whitespace characters.  However, users are encouraged to "
"only use valid Java identifiers in expressions."
msgstr ""
"識別子は、式やセクションタグで使用されます。有効な識別子は、空白文字以外の文字列です。ただし、式の中では有効な Java "
"識別子のみを使用することが推奨されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:122
#, fuzzy
msgid ""
"You can use bracket notation if you need to specify an identifier that "
"contains a dot, e.g. `{map['my.key']}`."
msgstr "`{map['my.key']}`ドットを含む識別子を指定する必要がある場合は、大括弧表記を使用することができます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:126
#, fuzzy
msgid ""
"When parsing a template document the parser identifies all _tags_.  A tag "
"starts and ends with a curly bracket, e.g. `{foo}`.  The content of a tag "
"must start with:"
msgstr ""
"テンプレート文書を解析する際、パーサはすべての _タグを_識別します。 `{foo}`タグは中括弧で始まり、中括弧で終わります。タグの内容は"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:128
#, fuzzy
msgid "a digit, or"
msgstr "すうじ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:129
#, fuzzy
msgid "an alphabet character, or"
msgstr "アルファベットもじ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:130
#, fuzzy
msgid "underscore, or"
msgstr "アンダースコア"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:131
#, fuzzy
msgid "a built-in command: `#`, `!`, `@`, `/`."
msgstr "組み込みコマンド: `#`, `!`, `@`, `/`."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:133
#, fuzzy
msgid ""
"If it does not start with any of the above it is ignored by the parser."
msgstr "上記のいずれかで始まらない場合は、パーサによって無視されます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:134
#, no-wrap, fuzzy
msgid "Tag Examples"
msgstr "タグの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:146
#, no-wrap
msgid ""
"<html>\n"
"   <body>\n"
"   {_foo.bar}   <1>\n"
"   {! comment !}<2>\n"
"   {  foo}      <3>\n"
"   {{foo}}      <4>\n"
"   {\"foo\":true} <5>\n"
"   </body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:148
#, fuzzy
msgid "Parsed: an expression that starts with underscore."
msgstr "解析済み: アンダースコアで始まる式。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:149
#, fuzzy
msgid "Parsed: a comment"
msgstr "解析済み: コメント"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:150
#, fuzzy
msgid "Ignored: starts with whitespace."
msgstr "無視されている: 空白で始まります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:151
#, fuzzy
msgid "Ignored: starts with `{`."
msgstr "無視されている: `{` で始まる ."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:152
#, fuzzy
msgid "Ignored: starts with `\"`."
msgstr "無視されている: `\"` で始まる ."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:154
#, fuzzy
msgid ""
"It is also possible to use escape sequences `\\{` and `\\}` to insert "
"delimiters in the text. In fact, an escape sequence is usually only needed "
"for the start delimiter, ie. `\\\\{foo}` will be rendered as `{foo}` (no "
"parsing/evaluation will happen)."
msgstr ""
"エスケープシーケンス `\\{` や `\\}` を使ってテキストにデリミタを挿入することも可能です。 `\\{foo}` `{foo}` "
"実際には、エスケープシーケンスは通常、開始デリミタのためにのみ必要とされます。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:155
#, no-wrap, fuzzy
msgid "Removing Standalone Lines From the Template"
msgstr "テンプレートから独立した行を削除する"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:161
#, fuzzy
msgid ""
"By default, the parser removes standalone lines from the template output.  A "
"*standalone line* is a line that contains at least one section tag (e.g. "
"`{#each}` and `{/each}`), parameter declaration (e.g. `{@org.acme.Foo foo}`) "
"or comment but no expression and no non-whitespace character.  In other "
"words, a line that contains no section tag or a parameter declaration is "
"*not* a standalone line.  Likewise, a line that contains an _expression_ or "
"a _non-whitespace character_ is *not* a standalone line."
msgstr ""
"デフォルトでは、パーサはテンプレート出力からスタンドアロン行を削除します。スタンドアロン *行*とは、少なくとも1つのセクションタグ（例： "
"`{#each}` や `{/each}` ）、パラメータ宣言（例： `{@org.acme.Foo foo}` "
"）、コメントを含むが、式を含まず、空白以外の文字を含まない行のことです。言い換えれば、セクションタグやパラメータ宣言を含まない行は、独立した行ではあり "
"*ません*。同様に、 _式_や _空白以外の文字を_含む行もスタンドアロン行ではあり *ません*。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:162
#, no-wrap, fuzzy
msgid "Template Example"
msgstr "テンプレート例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:175
#, no-wrap
msgid ""
"<html>\n"
"  <body>\n"
"     <ul>\n"
"     {#for item in items} <1>\n"
"       <li>{item.name} {#if item.active}{item.price}{/if}</li>  <2>\n"
"                          <3>\n"
"     {/for}               <4>\n"
"     </ul>\n"
"   <body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:177
#, fuzzy
msgid "This is a standalone line and will be removed."
msgstr "これは単独回線なので削除されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:178
#, fuzzy
msgid ""
"Not a standalone line - contains an expression and non-whitespace characters"
msgstr "スタンドアロン行ではない - 式と非空白文字を含む"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:179
#, fuzzy
msgid "Not a standalone line - contains no section tag/parameter declaration"
msgstr "独立した行ではない - セクションタグ/パラメータ宣言を含まない"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:180
#, fuzzy
msgid "This is a standalone line."
msgstr "これは独立したラインです。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:181
#, no-wrap, fuzzy
msgid "Default Output"
msgstr "デフォルト出力"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:188
#, no-wrap
msgid "<html>\n"
"  <body>\n"
"     <ul>\n"
"       <li>Foo 100</li>  \n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:192
#: upstream/_guides/qute-reference.adoc:210
#, no-wrap
msgid "     </ul>\n"
"   <body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:196
#, fuzzy
msgid ""
"In Quarkus, the default behavior can be disabled by setting the property "
"`quarkus.qute.remove-standalone-lines` to `false`.  In this case, all "
"whitespace characters from a standalone line will be printed to the output."
msgstr ""
"Quarkusでは、プロパティ（ `quarkus.qute.remove-standalone-lines` ）を `false` "
"に設定することで、デフォルトの動作を無効にすることができます。この場合、スタンドアロン行のすべての空白文字が出力に出力されます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:197
#, no-wrap, fuzzy
msgid "Output with `quarkus.qute.remove-standalone-lines=false`"
msgstr "との出力 `quarkus.qute.remove-standalone-lines=false`"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:203
#, no-wrap
msgid "<html>\n"
"  <body>\n"
"     <ul>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:205
#, no-wrap
msgid "       <li>Foo 100</li>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:220
#, fuzzy
msgid ""
"An expression outputs a value.  It consists of one or more parts separated "
"by dot (dot notation) or square brackets (bracket notation).  In the `object."
"property` (dot notation) syntax, the `property` must be a "
"<<identifiers,valid identifier>>.  In the `object[property_name]` (bracket "
"notation) syntax, the `property_name` has to be a non-null <<literals, "
"literal>> value.  An expression could start with an optional namespace "
"followed by a colon (`:`)."
msgstr ""
"式は値を出力します。これは、ドット(ドット表記)または角括弧(カッコ表記)で区切られた1つ以上の部分から構成されています。 `object."
"property` (ドット表記) 構文では、 `property` は link:#identifiers[有効な識別子]である必要があります。 "
"`object[property_name]` (括弧表記) 構文では、 `property_name` は非 null link:"
"#literals[リテラル]値である必要があります。式は、オプションの名前空間とコロン ( `:`) で始まることができます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:221
#, no-wrap, fuzzy
msgid "Expressions Example"
msgstr "式の例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:228
#, no-wrap
msgid "{name} <1>\n"
"{item.name} <2>\n"
"{item['name']} <3>\n"
"{global:colors} <4> \n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:230
#, fuzzy
msgid "no namespace, one part: `name`"
msgstr "名前空間がない、1つの部分 `name`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:231
#, fuzzy
msgid "no namespace, two parts: `item`, `name`"
msgstr "名前空間なし、2つの部分: `item`. `name`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:232
#, fuzzy
msgid "equivalent to `{item.name}` but using the bracket notation"
msgstr "`{item.name}` と同等ですが、括弧表記を使用しています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:233
#, fuzzy
msgid "namespace `global`, one part: `colors`"
msgstr "namespace `global`, 一部分。 `colors`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:237
#, fuzzy
msgid ""
"A part of an expression could be a _virtual method_ in which case the name "
"can be followed by a list of comma-separated parameters in parentheses.  A "
"parameter of a virtual method can be either a nested expression or a "
"<<literals, literal>> value.  We call it \"virtual\" because it does not "
"have to be backed by a real Java method."
msgstr ""
"式の一部は "
"_仮想メソッド_である可能性があり、その場合は名前の後に括弧内のコンマで区切られたパラメータのリストを付けることができます。仮想メソッドのパラメータは、入れ子になった式か "
"link:#literals[リテラル]値のどちらかになります。これを「仮想」と呼ぶのは、実際のJavaメソッドに裏打ちされている必要がないからです。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:238
#, no-wrap, fuzzy
msgid "Virtual Methods Example"
msgstr "仮想メソッドの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:243
#, no-wrap
msgid "{item.getLabels(1)} <1>\n"
"{name or 'John'} <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:245
#, fuzzy
msgid ""
"no namespace, two parts - `item`, `getLabels(1)`, the second part is a "
"virtual method with name `getLabels` and params `1`"
msgstr ""
"名前空間がなく、2つの部分 - `item`, `getLabels(1)`, 2番目の部分は、名前 `getLabels` と params "
"を持つ仮想メソッドです。 `1`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:246
#, fuzzy
msgid ""
"infix notation that can be used for virtual methods with single parameter, "
"translated to `name.or('John')`; no namespace, two parts - `name`, "
"`or('John')`"
msgstr ""
"単一のパラメータを持つ仮想メソッドに使用できる infix 記法、 `name.or('John')` に翻訳されています; 名前空間なし、2 つの部分 "
"- `name`. `or('John')`"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:248
#, no-wrap, fuzzy
msgid "Supported Literals"
msgstr "サポートされているリテラル"

#. type: Table
#: upstream/_guides/qute-reference.adoc:274
#, no-wrap, fuzzy
msgid ""
"|Literal |Examples\n"
"\n"
"|boolean \n"
"|`true`, `false`\n"
"\n"
"|null \n"
"|`null`\n"
"\n"
"|string \n"
"|`'value'`, `\"string\"`\n"
"\n"
"|integer \n"
"|`1`, `-5`\n"
"\n"
"|long\n"
"|`1l`, `-5L`\n"
"\n"
"|double\n"
"|`1D`, `-5d`\n"
"\n"
"|float\n"
"|`1f`, `-5F`\n"
"\n"
msgstr "|リテラル｜例文"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:276
#, no-wrap, fuzzy
msgid "Resolution"
msgstr "決議"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:283
#, fuzzy
msgid ""
"The first part of the expression is always resolved against the "
"<<current_context_object, current context object>>.  If no result is found "
"for the first part it's resolved against the parent context object (if "
"available).  For an expression that starts with a namespace the current "
"context object is found using all the available ``NamespaceResolver``s.  For "
"an expression that does not start with a namespace the current context "
"object is *derived from the position* of the tag.  All other parts of an "
"expression are resolved using all ``ValueResolver``s against the result of "
"the previous resolution."
msgstr ""
"式の最初の部分は、常に link:"
"#current_context_object[現在のコンテキストオブジェクト]に対して解決されます。最初の部分で結果が見つからない場合は、親コンテキストオブジェクト "
"(利用可能な場合) に対して解決されます。名前空間で始まる式の場合、現在のコンテキストオブジェクトは、利用可能なすべての "
"`NamespaceResolver`s を使用して検出されます。名前空間で始まらない式の場合、現在のコンテキストオブジェクトはタグの "
"*位置から派生し*ます。式の他のすべての部分は、前の解決結果に対してすべての `ValueResolver`s を使用して解決されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:289
#, fuzzy
msgid ""
"For example, expression `{name}` has no namespace and single part - `name`.  "
"The \"name\" will be resolved using all available value resolvers against "
"the current context object.  However, the expression `{global:colors}` has "
"the namespace `global` and single part - `colors`.  First, all available "
"``NamespaceResolver``s will be used to find the current context object.  And "
"afterwards value resolvers will be used to resolve \"colors\" against the "
"context object found."
msgstr ""
"例えば、式 `{name}` には名前空間がなく、単一の部分 - `name`."
"名前」は、現在のコンテキスト・オブジェクトに対して利用可能なすべての値リゾルバを使用して解決されます。しかし、式 `{global:colors}` "
"には、名前空間 `global` と単一部分 - `colors` があります。まず、現在のコンテキストオブジェクトを見つけるために、利用可能なすべての "
"`NamespaceResolver`s "
"が使用されます。その後、見つかったコンテキストオブジェクトに対して\"colors\"を解決するために値リゾルバが使用されます。"

#. type: delimited block =
#: upstream/_guides/qute-reference.adoc:294
#, fuzzy
msgid ""
"Data passed to the template instance are always accessible using the `data` "
"namespace.  This could be useful to access data for which the key is "
"overridden:"
msgstr ""
"テンプレート・インスタンスに渡されたデータは、常に `data` "
"名前空間を使用してアクセスできます。これは、キーがオーバーライドされているデータにアクセスするのに便利かもしれません。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:309
#, no-wrap
msgid ""
"<html>\n"
"{item.name} <1>\n"
"<ul>\n"
"{#for item in item.getDerivedItems()} <2>\n"
"  <li>\n"
"  {item.name} <3> \n"
"  is derived from\n"
"  {data:item.name} <4>\n"
"  </li>\n"
"{/for}\n"
"</ul>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:311
#, fuzzy
msgid "`item` is passed to the template instance as a data object."
msgstr "`item` はデータオブジェクトとしてテンプレートインスタンスに渡されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:312
#, fuzzy
msgid "Iterate over the list of derived items."
msgstr "派生アイテムのリストを繰り返し処理します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:313
#, fuzzy
msgid "`item` is an alias for the iterated element."
msgstr "`item` は反復要素のエイリアスです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:314
#, fuzzy
msgid "Use the `data` namespace to access the `item` data object."
msgstr "`data` ネームスペースを使用して、 `item` データ・オブジェクトにアクセスします。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:318
#, no-wrap, fuzzy
msgid "Current Context"
msgstr "現在の状況"

#. type: delimited block =
#: upstream/_guides/qute-reference.adoc:324
#, fuzzy
msgid ""
"If an expression does not specify a namespace the _current context object_ "
"is derived from the position of the tag.  By default, the current context "
"object represents the data passed to the template instance.  However, "
"sections may change the current context object.  A typical example is the "
"`with` section that could be used to set the current context object in order "
"to simplify the template structure:"
msgstr ""
"デフォルトでは、現在のコンテキスト・オブジェクトはテンプレート・インスタンスに渡されたデータを表します。しかし、セクションは現在のコンテキストオブジェクトを変更することができます。典型的な例は "
"`with` セクションで、テンプレート構造を単純化するためにカレントコンテキストオブジェクトを設定するために使用することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:331
#, no-wrap
msgid "{#with item}\n"
"  <h1>{name}</h1>  <1>\n"
"  <p>{description}</p>\n"
"{/with}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:333
#, fuzzy
msgid "`name` is resolved against the `item`."
msgstr "`name` は `item` に対して解決されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:335
#, fuzzy
msgid ""
"Another built-in section that modifies the current context object is `let`/"
"`set`:"
msgstr "現在のコンテキストオブジェクトを変更する別の組み込みセクションは、 `let`/ `set`."

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:341
#, no-wrap
msgid ""
"{#let myParent=order.item.parent myPrice=order.price} <1>\n"
"  <h1>{myParent.name}</h1>\n"
"  <p>Price: {myPrice}</p>\n"
"{/let}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:343
#, fuzzy
msgid ""
"The current context object inside the section is the map of resolved "
"parameters."
msgstr "セクション内の現在のコンテキストオブジェクトは、解決されたパラメータのマップです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:345
#, fuzzy
msgid "The current context can be accessed via the implicit binding `this`."
msgstr "現在のコンテキストは、暗黙のバインディング `this` を通してアクセスできます。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:346
#, no-wrap, fuzzy
msgid "Built-in Operators"
msgstr "作り付けのオペレータ"

#. type: Table
#: upstream/_guides/qute-reference.adoc:366
#, no-wrap, fuzzy
msgid ""
"|Operator |Description\t|Examples\n"
"\n"
"|Elvis \n"
"|Outputs the default value if the previous part cannot be resolved or "
"resolves to `null`.\n"
"|`{person.name ?: 'John'}`, `{person.name or 'John'}`\n"
"\n"
"|Ternary \n"
"|Shorthand for if-then-else statement. Unlike in <<if_section>> nested "
"operators are not supported.\n"
"|`{item.isActive ? item.name : 'Inactive item'}` outputs the value of `item."
"name` if `item.isActive` resolves to `true`.\n"
"\n"
"|Logical AND \n"
"|Outputs `true` if both parts are not `falsy` as described in the "
"<<if_section>>. The parameter is only evaluated if needed.\n"
"|`{person.isActive && person.hasStyle}`\n"
"\n"
"|Logical OR \n"
"|Outputs `true` if any of the parts is not `falsy` as described in the "
"<<if_section>>. The parameter is only evaluated if needed.\n"
"|`{person.isActive \\|\\| person.hasStyle}`\n"
msgstr "|操作子｜操作子｜説明｜例"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:369
#, fuzzy
msgid ""
"The condition in a ternary operator evaluates to `true` if the value is not "
"considered `falsy` as described in the <<if_section>>."
msgstr ""
"三項演算子の条件は、 link:#if_section[[if_section]]で説明したように、値が `falsy` とみなされない場合は "
"`true` と評価されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:371
#, fuzzy
msgid ""
"In fact, the operators are implemented as \"virtual methods\" that consume "
"one parameter and can be used with infix notation, i.e. `{person.name or "
"'John'}` is translated to `{person.name.or('John')}`."
msgstr ""
"`{person.name or 'John'}` `{person.name."
"or('John')}`実際には、演算子は1つのパラメータを消費する「仮想メソッド」として実装されており、infix記法で使用することができます。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:372
#, no-wrap, fuzzy
msgid "Character Escapes"
msgstr "キャラクターエスケープ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:375
#, fuzzy
msgid ""
"For HTML and XML templates the `'`, `\"`, `<`, `>`, `&` characters are "
"escaped by default if a template variant is set."
msgstr ""
"HTML と XML テンプレートの場合、 `'`, `\"`, `&amp;lt;`, `&amp;gt;`, `&amp;amp;` "
"の文字は、テンプレートバリアントが設定されている場合はデフォルトでエスケープされます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:377
#, fuzzy
msgid ""
"In Quarkus, a variant is set automatically for templates located in the `src/"
"main/resources/templates`. By default, the `java.net."
"URLConnection#getFileNameMap()` is used to determine the content type of a "
"template file. The additional map of suffixes to content types can be set "
"via `quarkus.qute.content-types`."
msgstr ""
"Quarkusでは、 `src/main/resources/templates` "
"にあるテンプレートに対してバリアントが自動的に設定されます。デフォルトでは、テンプレートファイルのコンテンツタイプを決定するために `java.net."
"URLConnection#getFileNameMap()` が使用されます。コンテンツタイプへのサフィックスの追加マップは、 `quarkus."
"qute.content-types` を通じて設定できます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:379
#, fuzzy
msgid "If you need to render the unescaped value:"
msgstr "エスケープされていない値をレンダリングする必要がある場合。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:381
#, fuzzy
msgid ""
"Use the `raw` or `safe` properties implemented as extension methods of the "
"`java.lang.Object`,"
msgstr "`java.lang.Object` の拡張メソッドとして実装されている `raw` または `safe` プロパティを使用します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:382
#, fuzzy
msgid "Wrap the `String` value in a `io.quarkus.qute.RawString`."
msgstr "`String` の値を `io.quarkus.qute.RawString`."

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:389
#, no-wrap
msgid "<html>\n"
"<h1>{title}</h1> <1>\n"
"{paragraph.raw} <2>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:391
#, fuzzy
msgid ""
"`title` that resolves to `Expressions & Escapes` will be rendered as "
"`Expressions &amp;amp; Escapes`"
msgstr ""
"`title` が `Expressions &amp;amp; Escapes` に解決した場合は、以下のように表示されます。 "
"`Expressions &amp;amp;amp; Escapes`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:392
#, fuzzy
msgid ""
"`paragraph` that resolves to `<p>My text!</p>` will be rendered as `<p>My "
"text!</p>`"
msgstr ""
"`paragraph` が `&amp;lt;p&amp;gt;My text!&amp;lt;/p&amp;gt;` "
"に解決した場合は、以下のように表示されます。 `&amp;lt;p&amp;gt;My text!&amp;lt;/p&amp;gt;`"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:393
#, no-wrap, fuzzy
msgid "Virtual Methods"
msgstr "バーチャルメソッド"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:399
#, fuzzy
msgid ""
"A virtual method is a *part of an expression* that looks like a regular Java "
"method invocation.  It's called \"virtual\" because it does not have to "
"match the actual method of a Java class.  In fact, like normal properties a "
"virtual method is also handled by a value resolver.  The only difference is "
"that for virtual methods a value resolver consumes parameters that are also "
"expressions."
msgstr ""
"仮想メソッドとは、通常のJavaメソッド呼び出しのように見える "
"*式の一部*です。Javaクラスの実際のメソッドと一致する必要がないため、「仮想」と呼ばれています。実際には、通常のプロパティと同様に、仮想メソッドも値リゾルバによって処理されます。唯一の違いは、仮想メソッドの場合、値リゾルバが式でもあるパラメータを消費することです。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:400
#, no-wrap, fuzzy
msgid "Virtual Method Example"
msgstr "仮想メソッドの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:406
#, no-wrap
msgid "<html>\n"
"<h1>{item.buildName(item.name,5)}</h1> <1>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:408
#, no-wrap, fuzzy
msgid ""
"`buildName(item.name,5)` represents a virtual method with name `buildName` "
"and two parameters: `item.name` and `5` . The virtual method could be "
"evaluated by a value resolver generated for the following Java class:   \n"
msgstr ""
"`buildName(item.name,5)` は、名前 `buildName` と 2 つのパラメータ `item.name` と `5` "
"を持つ仮想メソッドを表します。この仮想メソッドは、以下の Java クラス用に生成された値リゾルバによって評価されます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:416
#, no-wrap
msgid ""
"class Item {\n"
"   String buildName(String name, int age) {\n"
"      return name + \":\" + age;\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:419
#, fuzzy
msgid ""
"Virtual methods are usually evaluated by value resolvers generated for "
"<<template_extension_methods,@TemplateExtension methods>>, "
"<<template_data,@TemplateData>> or classes used in "
"<<typesafe_expressions,parameter declarations>>. However, a custom value "
"resolver that is not backed by any Java class/method can be registered as "
"well."
msgstr ""
"仮想メソッドは通常、 link:#template_extension_methods[@TemplateExtensionメソッド]、 link:"
"#template_data[@TemplateData]、または link:"
"#typesafe_expressions[パラメータ宣言]で使用されるクラスのために生成された値リゾルバによって評価されます。しかし、Javaのクラス/"
"メソッドではバックアップされていないカスタムの値リゾルバも登録できます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:421
#, fuzzy
msgid ""
"A virtual method with single parameter can be called using the infix "
"notation:"
msgstr "単一のパラメータを持つ仮想メソッドは infix 記法を使用して呼び出すことができます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:422
#, no-wrap, fuzzy
msgid "Infix Notation Example"
msgstr "インフィックス表記例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:428
#, no-wrap
msgid "<html>\n"
"<p>{item.price or 5}</p>  <1>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:430
#, fuzzy
msgid "`item.price or 5` is translated to `item.price.or(5)`."
msgstr "`item.price or 5` は `item.price.or(5)` に翻訳されています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:432
#, fuzzy
msgid "Virtual method parameters can be \"nested\" virtual method invocations."
msgstr "仮想メソッドのパラメータは、仮想メソッドの呼び出しを「入れ子にする」ことができます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:433
#, no-wrap, fuzzy
msgid "Nested Virtual Method Example"
msgstr "入れ子になった仮想メソッドの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:439
#, no-wrap
msgid ""
"<html>\n"
"<p>{item.subtractPrice(item.calculateDiscount(10))}</p>  <1>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:441
#, fuzzy
msgid ""
"`item.calculateDiscount(10)` is evaluated first and then passed as an "
"argument to `item.subtractPrice()`."
msgstr ""
"`item.calculateDiscount(10)` は最初に評価され、その後 `item.subtractPrice()` "
"への引数として渡されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:446
#, fuzzy
msgid "A section:"
msgstr "セクション。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:448
#, fuzzy
msgid "has a start tag"
msgstr "はスタートタグを持っています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:449
#, fuzzy
msgid ""
"starts with `#`, followed by the name of the section such as `{#if}` and "
"`{#each}`,"
msgstr "は、 `#` で始まり、 `{#if}` や `{#each}` などのセクションの名前が続きます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:450
#, fuzzy
msgid "may be empty"
msgstr "空くかもしれない"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:451
#, fuzzy
msgid "tag ends with `/`, ie. `{#emptySection /}`"
msgstr "タグは `/` で終わります。 `{#emptySection /}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:452
#, fuzzy
msgid "may contain other expression, sections, etc."
msgstr "は、他の表現、セクションなどを含む場合があります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:453
#, fuzzy
msgid ""
"the end tag starts with `/` and contains the name of the section (optional): "
"`{#if foo}Foo!{/if}` or `{#if foo}Foo!{/}`,"
msgstr ""
"エンドタグは `/` で始まり、セクションの名前（オプション）を含みます： `{#if foo}Foo!{/if}` または `{#if "
"foo}Foo!{/}`."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:460
#, fuzzy
msgid ""
"The start tag can also define parameters.  The parameters have optional "
"names.  A section may contain several content *blocks*.  The \"main\" block "
"is always present.  Additional/nested blocks also start with `#` and can "
"have parameters too - `{#else if item.isActive}`.  A section helper that "
"defines the logic of a section can \"execute\" any of the blocks and "
"evaluate the parameters."
msgstr ""
"startタグはパラメータを定義することもできます。パラメータにはオプションの名前を付けます。1つのセクションには、いくつかのコンテンツ "
"*ブロックを*含めることができます。main\" ブロックは常に存在します。追加/入れ子になったブロックも `#` "
"で始まり、パラメータを持つことができます - `{#else if item.isActive}`."
"セクションのロジックを定義するセクションヘルパーは、任意のブロックを「実行」し、パラメータを評価することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:470
#, no-wrap
msgid ""
"{#if item.name is 'sword'}\n"
"  It's a sword!\n"
"{#else if item.name is 'shield'}\n"
"  It's a shield!\n"
"{#else}\n"
"  Item is neither a sword nor a shield.\n"
"{/if}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:472
#, no-wrap, fuzzy
msgid "Loop Section"
msgstr "ループ部"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:477
#, fuzzy
msgid ""
"The loop section makes it possible to iterate over an instance of "
"`Iterable`, `Map` 's entry set, `Stream` and an Integer.  It has two flavors."
"  The first one is using the `each` name alias."
msgstr ""
"ループセクションでは、 `Iterable`, `Map` のエントリセット、 `Stream` "
"と整数のインスタンスを反復処理することができます。ループには2つの機能があります。最初のものは `each` という名前のエイリアスを使用しています。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:483
#, no-wrap
msgid "{#each items}\n"
"  {it.name} <1>\n"
"{/each}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:485
#, fuzzy
msgid ""
"`it` is an implicit alias. `name` is resolved against the current iteration "
"element."
msgstr "`it` は暗黙のエイリアスです。 `name` は現在の反復要素に対して解決されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:487
#, fuzzy
msgid ""
"The other form is using the `for` name alias and can specify the alias used "
"to reference the iteration element:"
msgstr "もう一つの形式は、 `for` 名前のエイリアスを使用しており、反復要素を参照するために使用されるエイリアスを指定することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:493
#, no-wrap
msgid "{#for item in items}\n"
"  {item.name}\n"
"{/for}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:496
#, fuzzy
msgid "It's also possible to access the iteration metadata inside the loop:"
msgstr "ループ内の反復メタデータにアクセスすることも可能です。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:502
#, no-wrap
msgid "{#each items}\n"
"  {count}. {it.name} <1>\n"
"{/each}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:504
#, fuzzy
msgid ""
"`count` represents one-based index. Metadata also include zero-based "
"`index`, `hasNext`, `odd`, `even`."
msgstr ""
"`count` はワンベースのインデックスを表しています。メタデータには、ゼロベースの `index`, `hasNext`, `odd`, "
"`even`."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:506
#, fuzzy
msgid ""
"The `for` statement also works with integers, starting from 1. In the "
"example below, considering that `total = 3`:"
msgstr "`for` 文は、1 から始まる整数でも動作します。 以下の例では、 `total = 3`."

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:512
#, no-wrap
msgid "{#for i in total}\n"
"  {i}:\n"
"{/for}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:515
#, fuzzy
msgid "The output will be:"
msgstr "出力されます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:519
#, no-wrap
msgid "1:2:3:\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:522
#, no-wrap, fuzzy
msgid "If Section"
msgstr "セクション"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:527
#, fuzzy
msgid ""
"The `if` section represents a basic control flow section.  The simplest "
"possible version accepts a single parameter and renders the content if the "
"condition is evaluated to `true`.  A condition without an operator evaluates "
"to `true` if the value is not considered `falsy`, i.e. if the value is not "
"`null`, `false`, an empty collection, an empty map, an empty array, an empty "
"string/char sequence or a number equal to zero."
msgstr ""
"`if` セクションは、基本的な制御フローセクションを表しています。最も単純なバージョンでは、単一のパラメータを受け取り、条件が `true` "
"と評価された場合にコンテンツをレンダリングします。 `falsy`つまり、値が `null` 、 `false` "
"、空のコレクション、空のマップ、空の配列、空の文字列/文字列シーケンス、またはゼロに等しい数ではない場合、 `true` と評価されます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:533
#, no-wrap
msgid "{#if item.active}\n"
"  This item is active.\n"
"{/if}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:536
#, fuzzy
msgid "You can also use the following operators in a condition:"
msgstr "条件で以下の演算子を使うこともできます。"

#. type: Table
#: upstream/_guides/qute-reference.adoc:576
#, no-wrap, fuzzy
msgid ""
"|Operator |Aliases |Precedence (higher wins)\n"
"\n"
"|logical complement \n"
"|`!` \n"
"| 4\n"
"\n"
"|greater than \n"
"|`gt`, `>`\n"
"| 3\n"
"\n"
"|greater than or equal to\n"
"|`ge`, `>=`\n"
"| 3\n"
"\n"
"|less than \n"
"|`lt`, `<`\n"
"| 3\n"
"\n"
"|less than or equal to\n"
"|`le`, `\\<=`\n"
"| 3\n"
"\n"
"|equals \n"
"|`eq`, `==`, `is` \n"
"| 2\n"
"\n"
"|not equals \n"
"|`ne`, `!=`\n"
"| 2\n"
"\n"
"|logical AND (short-circuiting)\n"
"|`&&`, `and`\n"
"| 1\n"
"\n"
"|logical OR (short-circuiting)\n"
"|`\\|\\|`, `or`\n"
"| 1\n"
"\n"
msgstr "|オペレーター｜アライアス｜先行(上位入賞)"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:578
#, no-wrap, fuzzy
msgid "A simple operator example"
msgstr "簡単な演算子の例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:584
#, no-wrap
msgid "{#if item.age > 10}\n"
"  This item is very old.\n"
"{/if}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:587
#, fuzzy
msgid "Multiple conditions are also supported."
msgstr "複数の条件にも対応しています。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:588
#, no-wrap, fuzzy
msgid "Multiple conditions example"
msgstr "複数条件の例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:594
#, no-wrap
msgid ""
"{#if item.age > 10 && item.price > 500}\n"
"  This item is very old and expensive.\n"
"{/if}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:597
#, fuzzy
msgid "Precedence rules can be overridden by parentheses."
msgstr "優先順位の規則は、カッコで上書きすることができます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:598
#, no-wrap, fuzzy
msgid "Parentheses example"
msgstr "括弧の例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:604
#, no-wrap
msgid ""
"{#if (item.age > 10 || item.price > 500) && user.loggedIn}\n"
"  User must be logged in and item age must be > 10 or price must be > 500.\n"
"{/if}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:608
#, fuzzy
msgid "You can also add any number of `else` blocks:"
msgstr "また、 `else` ブロックを何個でも追加することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:620
#, no-wrap
msgid ""
"{#if item.age > 10}\n"
"  This item is very old.\n"
"{#else if item.age > 5}\n"
"  This item is quite old.\n"
"{#else if item.age > 2}\n"
"  This item is old.\n"
"{#else}\n"
"  This item is not old at all!\n"
"{/if}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:623
#, no-wrap, fuzzy
msgid "With Section"
msgstr "セクションと"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:627
#, fuzzy
msgid ""
"This section can be used to set the current context object.  This could be "
"useful to simplify the template structure:"
msgstr ""
"このセクションは、現在のコンテキストオブジェクトを設定するために使用することができます。これはテンプレート構造を単純化するのに便利かもしれません。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:634
#, no-wrap
msgid ""
"{#with item.parent}\n"
"  <h1>{name}</h1>  <1>\n"
"  <p>{description}</p> <2>\n"
"{/with}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:636
#, fuzzy
msgid "The `name` will be resolved against the `item.parent`."
msgstr "`name` に対し、 `item.parent`."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:637
#, fuzzy
msgid "The `description` will be also resolved against the `item.parent`."
msgstr "`description` も `item.parent`.に対して解決されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:639
#, fuzzy
msgid ""
"This section might also come in handy when we'd like to avoid multiple "
"expensive invocations:"
msgstr "このセクションは、複数の高価な呼び出しを避けたいときにも便利かもしれません。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:649
#, no-wrap
msgid ""
"{#with item.callExpensiveLogicToGetTheValue(1,'foo',bazinga)}\n"
"  {#if this is \"fun\"} <1>\n"
"    <h1>Yay!</h1>\n"
"  {#else}\n"
"    <h1>{this} is not fun at all!</h1>\n"
"  {/if}\n"
"{/with}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:651
#, fuzzy
msgid ""
"`this` is the result of `item."
"callExpensiveLogicToGetTheValue(1,'foo',bazinga)`. The method is only "
"invoked once even though the result may be used in multiple expressions."
msgstr ""
"`this` は `item.callExpensiveLogicToGetTheValue(1,'foo',bazinga)` "
"の結果です。結果が複数の式で使用されても、このメソッドは一度しか呼び出されません。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:652
#, no-wrap, fuzzy
msgid "Let/Set Section"
msgstr "レット/セットセクション"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:655
#, fuzzy
msgid "This section allows you to define named local variables:"
msgstr "このセクションでは、名前付きローカル変数を定義することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:660
#, no-wrap
msgid "{#let myParent=order.item.parent}\n"
"  <h1>{myParent.name}</h1>\n"
"{/let}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:663
#, fuzzy
msgid "The section tag is also registered under the `set` alias:"
msgstr "セクションタグも `set` の別名で登録されています。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:670
#, no-wrap
msgid ""
"{#set myParent=item.parent price=item.price}\n"
"  <h1>{myParent.name}</h1>\n"
"  <p>Price: {price}\n"
"{/set}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:674
#, no-wrap, fuzzy
msgid "Include Section"
msgstr "セクションを含む"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:677
#, fuzzy
msgid ""
"This section can be used to include another template and possibly override "
"some parts of the template (template inheritance)."
msgstr "このセクションでは、別のテンプレートをインクルードしたり、テンプレートの一部をオーバーライドすることができます（テンプレートの継承）。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:678
#, no-wrap, fuzzy
msgid "Simple Example"
msgstr "簡単な例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:690
#, no-wrap
msgid ""
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>Simple Include</title>\n"
"</head>\n"
"<body>\n"
"  {#include foo limit=10 /} <1><2>\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:692
#, fuzzy
msgid ""
"Include a template with id `foo`. The included template can reference data "
"from the current context."
msgstr ""
"id `foo` でテンプレートをインクルードします。インクルードされたテンプレートは、現在のコンテキストからデータを参照することができます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:693
#, fuzzy
msgid ""
"It's also possible to define optional parameters that can be used in the "
"included template."
msgstr "また、付属のテンプレートで使用できるオプションのパラメータを定義することも可能です。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:695
#, fuzzy
msgid "Template inheritance makes it possible to reuse template layouts."
msgstr "テンプレート継承により、テンプレートレイアウトの再利用が可能になります。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:696
#, no-wrap, fuzzy
msgid "Template \"base\""
msgstr "テンプレート「ベース"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:708
#, no-wrap
msgid ""
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>{#insert title}Default Title{/}</title> <1>\n"
"</head>\n"
"<body>\n"
"  {#insert body}No body!{/} <2>\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:710
#, fuzzy
msgid ""
"`insert` sections are used to specify parts that could be overridden by a "
"template that includes the given template."
msgstr "`insert` セクションは、与えられたテンプレートを含むテンプレートでオーバーライドできる部分を指定するために使われます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:711
#, fuzzy
msgid ""
"An `insert` section may define the default content that is rendered if not "
"overridden."
msgstr "`insert` セクションは、オーバーライドされない場合にレンダリングされるデフォルトのコンテンツを定義することができます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:712
#, no-wrap, fuzzy
msgid "Template \"detail\""
msgstr "テンプレート「詳細"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:723
#, no-wrap
msgid ""
"{#include base} <1>\n"
"  {#title}My Title{/title} <2>\n"
"  {#body}\n"
"    <div>\n"
"      My body.\n"
"    </div>\n"
"  {/body}\n"
"{/include}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:725
#, fuzzy
msgid "`include` section is used to specify the extended template."
msgstr "`include` セクションは、拡張テンプレートを指定するために使用されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:726
#, fuzzy
msgid "Nested blocks are used to specify the parts that should be overridden."
msgstr "入れ子になったブロックは、オーバーライドする部分を指定するために使用されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:728
#, fuzzy
msgid "Section blocks can also define an optional end tag - `{/title}`."
msgstr "セクションブロックはオプションのエンドタグを定義することもできます - `{/title}`."

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:730
#, no-wrap, fuzzy
msgid "User-defined Tags"
msgstr "ユーザー定義タグ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:734
#, fuzzy
msgid ""
"User-defined tags can be used to include a template and optionally pass some "
"parameters.  Let's suppose we have a template called `itemDetail.html`:"
msgstr ""
"ユーザー定義タグは、テンプレートをインクルードし、オプションでいくつかのパラメータを渡すために使用することができます。 `itemDetail."
"html` というテンプレートがあるとします。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:741
#, no-wrap
msgid "{#if showImage} <1>\n"
"  {it.image} <2>\n"
"  {nested-content} <3>\n"
"{/if}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:743
#, fuzzy
msgid "`showImage` is a named parameter."
msgstr "`showImage` は名前付きパラメータです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:744
#, fuzzy
msgid ""
"`it` is a special key that is replaced with the first unnamed param of the "
"tag."
msgstr "`it` は、タグの最初の名前のないパラメータに置き換えられる特別なキーです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:745
#, fuzzy
msgid ""
"(optional) `nested-content` is a special key that will be replaced by the "
"content of the tag."
msgstr "(オプション) `nested-content` は、タグの内容に置き換えられる特別なキーです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:747
#, fuzzy
msgid ""
"Now if we register this template under the name `itemDetail.html` and if we "
"add a `UserTagSectionHelper` to the engine:"
msgstr ""
"さて、このテンプレートを `itemDetail.html` という名前で登録し、エンジンに `UserTagSectionHelper` "
"を追加した場合。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:753
#, no-wrap
msgid ""
"Engine engine = Engine.builder()\n"
"                   .addSectionHelper(new UserTagSectionHelper."
"Factory(\"itemDetail\",\"itemDetail.html\"))\n"
"                   .build();\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:756
#, fuzzy
msgid ""
"In Quarkus, all files from the `src/main/resources/templates/tags` are "
"registered and monitored automatically!"
msgstr ""
"Quarkusでは、 `src/main/resources/templates/tags` からのファイルはすべて登録され、自動的に監視されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:758
#, fuzzy
msgid "We can include the tag like this:"
msgstr "こんな感じでタグを入れていきます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:770
#, no-wrap
msgid ""
"<ul>\n"
"{#for item in items}\n"
"  <li>\n"
"  {#itemDetail item showImage=true} <1>\n"
"    = <b>{item.name}</b> <2>\n"
"  {/itemDetail}\n"
"  </li>\n"
"{/for}\n"
"</ul>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:772
#, fuzzy
msgid ""
"`item` is resolved to an iteration element and can be referenced using the "
"`it` key in the tag template."
msgstr "`item` は反復要素に解決され、タグテンプレートの `it` キーを使用して参照することができます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:773
#, fuzzy
msgid ""
"Tag content injected using the `nested-content` key in the tag template."
msgstr "タグテンプレートの `nested-content` キーを使用して注入されたタグコンテンツ。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:774
#, no-wrap, fuzzy
msgid "Engine Configuration"
msgstr "エンジン構成"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:776
#, no-wrap, fuzzy
msgid "Template Locator"
msgstr "テンプレートロケーター"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:780
#, fuzzy
msgid ""
"Manual registration is sometimes handy but it's also possible to register a "
"template locator using `EngineBuilder.addLocator(Function<String, "
"Optional<Reader>>)`.  This locator is used whenever the `Engine."
"getTemplate()` method is called and the engine has no template for a given "
"id stored in the cache."
msgstr ""
"手動登録が便利な場合もありますが、 `EngineBuilder.addLocator(Function&amp;lt;String, "
"Optional&amp;lt;Reader&amp;gt;&amp;gt;)` "
"を使用してテンプレートロケータを登録することも可能です。このロケータは、 `Engine.getTemplate()` "
"メソッドが呼び出され、エンジンがキャッシュに保存されている指定された id のテンプレートを持っていない場合に使用されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:782
#, fuzzy
msgid ""
"In Quarkus, all templates from the `src/main/resources/templates` are "
"located automatically."
msgstr "Quarkusでは、 `src/main/resources/templates` からのテンプレートはすべて自動的に配置されています。"

#. type: Title ==
#: upstream/_guides/qute-reference.adoc:784
#, no-wrap, fuzzy
msgid "Quarkus Integration"
msgstr "Quarkusの統合"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:787
#, fuzzy
msgid ""
"If you want to use Qute in your Quarkus application add the following "
"dependency to your project:"
msgstr "QuarkusアプリケーションでQuteを使用する場合は、以下の依存関係をプロジェクトに追加してください。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:794
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-qute</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:798
#, fuzzy
msgid ""
"In Quarkus, a preconfigured engine instance is provided and available for "
"injection - a bean with scope `@ApplicationScoped`, bean type `io.quarkus."
"qute.Engine` and qualifier `@Default` is registered automatically.  "
"Moreover, all templates located in the `src/main/resources/templates` "
"directory are validated and can be easily injected."
msgstr ""
"`@ApplicationScoped` `io.quarkus.qute.Engine` `@Default` "
"Quarkusでは、事前に設定されたエンジンインスタンスが提供され、インジェクションに利用できます。さらに、 `src/main/resources/"
"templates` ディレクトリにあるすべてのテンプレートが検証され、簡単にインジェクションすることができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:804
#, no-wrap
msgid ""
"import io.quarkus.qute.Engine;\n"
"import io.quarkus.qute.Template;\n"
"import io.quarkus.qute.api.ResourcePath;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:806
#, no-wrap
msgid "class MyBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:809
#, no-wrap
msgid "    @Inject \n"
"    Template items; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:812
#, no-wrap
msgid "    @ResourcePath(\"detail/items2_v1.html\") <2>\n"
"    Template items2;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:816
#, no-wrap
msgid "    @Inject\n"
"    Engine engine; <3>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:818
#, fuzzy
msgid ""
"If there is no `ResourcePath` qualifier provided, the field name is used to "
"locate the template. In this particular case, the container will attempt to "
"locate a template with path `src/main/resources/templates/items.html`."
msgstr ""
"`ResourcePath` "
"の修飾子が与えられていない場合は、フィールド名がテンプレートの位置を特定するために使われます。この特定のケースでは、コンテナはパス `src/main/"
"resources/templates/items.html` でテンプレートを見つけようとします。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:819
#, fuzzy
msgid ""
"The `ResourcePath` qualifier instructs the container to inject a template "
"from a path relative from `src/main/resources/templates`. In this case, the "
"full path is `src/main/resources/templates/detail/items2_v1.html`."
msgstr ""
"`ResourcePath` 修飾子は、 `src/main/resources/templates` "
"からの相対パスからテンプレートを注入するようにコンテナに指示します。この場合のフルパスは `src/main/resources/templates/"
"detail/items2_v1.html` です。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:820
#, fuzzy
msgid "Inject the configured `Engine` instance."
msgstr "構成された `Engine` インスタンスを注入します。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:821
#, no-wrap, fuzzy
msgid "Template Variants"
msgstr "テンプレートのバリエーション"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:825
#, fuzzy
msgid ""
"Sometimes it's useful to render a specific variant of the template based on "
"the content negotiation.  This can be done by setting a special attribute "
"via `TemplateInstance.setAttribute()`:"
msgstr ""
"コンテンツネゴシエーションに基づいてテンプレートの特定のバリアントをレンダリングすることが有用な場合があります。これは "
"`TemplateInstance.setAttribute()` を通じて特別な属性を設定することで行うことができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:832
#, no-wrap
msgid "    @Inject\n"
"    Template items; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:835
#, no-wrap
msgid "    @Inject\n"
"    ItemManager manager;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:840
#, no-wrap
msgid ""
"    String renderItems() {\n"
"       return items.data(\"items\",manager.findItems())."
"setAttribute(TemplateInstance.SELECTED_VARIANT, new Variant(Locale."
"getDefault(),\"text/html\",\"UTF-8\")).render();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:843
#, fuzzy
msgid ""
"When using `quarkus-resteasy-qute` the content negotiation is performed "
"automatically. See <<resteasy_integration>>."
msgstr ""
"`quarkus-resteasy-qute` を使用している場合、コンテンツネゴシエーションは自動的に行われます。 link:"
"#resteasy_integration[resteasy_integration]]を参照してください。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:844
#, no-wrap, fuzzy
msgid "Injecting Beans Directly In Templates"
msgstr "テンプレートに直接Beansを注入する"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:847
#, fuzzy
msgid ""
"A CDI bean annotated with `@Named` can be referenced in any template through "
"the `inject` namespace:"
msgstr ""
"`@Named` でアノテーションされた CDI ビーンは、 `inject` 名前空間を通して、どのテンプレートでも参照することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:851
#, no-wrap
msgid "{inject:foo.price} <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:853
#, fuzzy
msgid ""
"First, a bean with name `foo` is found and then used as the base object."
msgstr "まず、 `foo` という名前のビーンを見つけ、それをベースオブジェクトとして使用します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:856
#, fuzzy
msgid ""
"All expressions using the `inject` namespace are validated during build.  "
"For the expression `inject:foo.price` the implementation class of the "
"injected bean must either have the `price` property (e.g. a `getPrice()` "
"method) or a matching <<template_extension_methods,template extension "
"method>> must exist."
msgstr ""
"`inject` 名前空間を使用するすべての式は、ビルド時に検証されます。式 `inject:foo.price` "
"については、注入されたビーンの実装クラスが `price` プロパティ ( `getPrice()` メソッドなど) を持っているか、一致する link:"
"#template_extension_methods[テンプレート拡張メソッド]が存在していなければなりません。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:858
#, fuzzy
msgid ""
"A `ValueResolver` is also generated for all beans annotated with `@Named` so "
"that it's possible to access its properties without reflection."
msgstr ""
"`@Named` でアノテーションされたすべての豆に対して `ValueResolver` "
"も生成され、そのプロパティに反射なしでアクセスできるようになります。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:860
#, no-wrap, fuzzy
msgid "Type-safe Expressions"
msgstr "型安全な式"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:865
#, fuzzy
msgid ""
"Template expressions can be optionally type-safe.  Which means that an "
"expression is validated against the existing Java types and template "
"extension methods.  If an invalid/incorrect expression is found then the "
"build fails."
msgstr ""
"テンプレート式は、オプションでタイプセーフにすることができます。これは、式が既存のJavaの型とテンプレート拡張メソッドに対して検証されることを意味します。無効な/"
"不正確な式が見つかった場合、ビルドは失敗します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:867
#, fuzzy
msgid ""
"For example, if there is an expression `item.name` where `item` maps to `org."
"acme.Item` then `Item` must have a property `name` or a matching template "
"extension method must exist."
msgstr ""
"例えば、 `item.name` という式があり、 `item` が `org.acme.Item` にマップされている場合、 `Item` には "
"`name` というプロパティがあるか、一致するテンプレート拡張メソッドが存在しなければなりません。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:870
#, fuzzy
msgid ""
"An optional _parameter declaration_ is used to bind a Java type to "
"expressions whose first part matches the parameter name.  Parameter "
"declarations are specified directly in a template."
msgstr ""
"オプションの _パラメータ宣言_は、最初の部分がパラメータ名と一致する式に Java "
"型をバインドするために使用されます。パラメータ宣言はテンプレートで直接指定します。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:871
#, no-wrap, fuzzy
msgid "Parameter Declaration Example"
msgstr "パラメータ宣言の例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:886
#, no-wrap
msgid ""
"{@org.acme.Foo foo} <1>\n"
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>Qute Hello</title>\n"
"</head>\n"
"<body>\n"
"  <h1>{title}</h1> <2>\n"
"  Hello {foo.message.toLowerCase}! <3> <4>\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:888
#, fuzzy
msgid "Parameter declaration - maps `foo` to `org.acme.Foo`."
msgstr "パラメータ宣言 - `foo` を `org.acme.Foo` にマップします。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:889
#, fuzzy
msgid "Not validated - not matching a param declaration."
msgstr "検証されていません - param 宣言にマッチしません。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:890
#, fuzzy
msgid ""
"This expression is validated. `org.acme.Foo` must have a property `message` "
"or a matching template extension method must exist."
msgstr "`org.acme.Foo` はプロパティ `message` を持つか、一致するテンプレート拡張メソッドが存在しなければなりません。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:891
#, fuzzy
msgid ""
"Likewise, the Java type of the object resolved from `foo.message` must have "
"a property `toLowerCase` or a matching template extension method must exist."
msgstr ""
"同様に、 `foo.message` から解決されたオブジェクトの Java 型は、プロパティ `toLowerCase` "
"を持つか、一致するテンプレート拡張メソッドが存在しなければなりません。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:893
#, fuzzy
msgid ""
"A value resolver is automatically generated for all types used in parameter "
"declarations so that it's possible to access its properties without "
"reflection."
msgstr "パラメータ宣言で使用されるすべての型に対して値リゾルバが自動的に生成され、そのプロパティに反射なしでアクセスできるようになります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:895
#, fuzzy
msgid ""
"Method parameters of <<typesafe_templates,type-safe templates>> are "
"automatically turned into parameter declarations."
msgstr "link:#typesafe_templates[タイプセーフテンプレート]のメソッドパラメータは、自動的にパラメータ宣言に変換されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:897
#, fuzzy
msgid ""
"Note that sections can override names that would otherwise match a parameter "
"declaration:"
msgstr "セクションは、パラメータ宣言にマッチする名前をオーバーライドできることに注意してください。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:914
#, no-wrap
msgid ""
"{@org.acme.Foo foo}\n"
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"<meta charset=\"UTF-8\">\n"
"<title>Qute Hello</title>\n"
"</head>\n"
"<body>\n"
"  <h1>{foo.message}</h1> <1>\n"
"  {#for foo in baz.foos}\n"
"    <p>Hello {foo.message}!</p> <2>\n"
"  {/for}\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:916
#, fuzzy
msgid "Validated against `org.acme.Foo`."
msgstr "`org.acme.Foo` に対して検証されています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:917
#, fuzzy
msgid "Not validated - `foo` is overridden in the loop section."
msgstr "検証されていません - `foo` はループセクションでオーバーライドされています。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:919
#, no-wrap, fuzzy
msgid "Type-safe Templates"
msgstr "タイプセーフテンプレート"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:922
#, fuzzy
msgid ""
"You can also declare your templates in your Java code.  If using "
"<<resteasy_integration,templates in JAX-RS resources>>, you can rely on the "
"following convention:"
msgstr ""
"また、Java コードでテンプレートを宣言することもできます。 link:#resteasy_integration[JAX-"
"RSリソースでテンプレートを]使用する場合は、以下の規約に従うことができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:953
#, no-wrap
msgid ""
"    @CheckedTemplate\n"
"    public static class Templates {\n"
"        public static native TemplateInstance item(Item item); <1> <2>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:961
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"{id}\")\n"
"    @Produces(MediaType.TEXT_HTML)\n"
"    public TemplateInstance get(@PathParam(\"id\") Integer id) {\n"
"        return Templates.item(service.findItem(id)); <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:964
#, fuzzy
msgid ""
"The `item` parameter is automatically turned into a "
"<<typesafe_expressions,parameter declaration>> and so all expressions that "
"reference this name will be validated."
msgstr ""
"`item` パラメータは自動的に link:"
"#typesafe_expressions[パラメータ宣言]に変換されるので、この名前を参照するすべての式が検証されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:967
#, fuzzy
msgid ""
"You can also declare a top-level Java class annotated with "
"`@CheckedTemplate`:"
msgstr "また、 `@CheckedTemplate` でアノテーションされたトップレベルの Java クラスを宣言することもできます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:968
#, no-wrap, fuzzy
msgid "Top-level checked templates"
msgstr "トップレベルのチェック済みテンプレート"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:981
#, no-wrap
msgid ""
"@CheckedTemplate\n"
"public class Templates {\n"
"    public static native TemplateInstance hello(String name); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:983
#, fuzzy
msgid ""
"This declares a template with path `templates/hello.txt`. The `name` "
"parameter is automatically turned into a <<typesafe_expressions,parameter "
"declaration>> and so all expressions that reference this name will be "
"validated."
msgstr ""
"これは、パス `templates/hello.txt` を持つテンプレートを宣言します。 `name` パラメータは自動的に link:"
"#typesafe_expressions[パラメータ宣言]に変換されるので、この名前を参照するすべての式が検証されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:986
#, fuzzy
msgid ""
"Then declare one `public static native TemplateInstance method();` per "
"template file.  Use those static methods to build your template instances:"
msgstr ""
"そして、テンプレートファイルごとに `public static native TemplateInstance method();` "
"を宣言します。これらの静的メソッドを使用してテンプレートインスタンスを構築します。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:997
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.QueryParam;\n"
"import io.quarkus.qute.TemplateInstance;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1007
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public TemplateInstance get(@QueryParam(\"name\") String name) {\n"
"        return Templates.hello(name);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1014
#, fuzzy
msgid ""
"Extension methods can be used to extend the data classes with new "
"functionality (to extend the set of accessible properties and methods) or to "
"resolve expressions for a specific <<namespace_extension_methods,namespace>>."
"  For example, it is possible to add _computed properties_ and _virtual "
"methods_."
msgstr ""
"拡張メソッドは、データクラスを新しい機能で拡張するため（アクセス可能なプロパティとメソッドのセットを拡張するため）、または特定の link:"
"#namespace_extension_methods[名前空間の]ための式を解決するために使用することができます。例えば、 "
"_計算されたプロパティ_や _仮想メソッドを_追加することができます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1019
#, fuzzy
msgid ""
"A value resolver is automatically generated for a method annotated with "
"`@TemplateExtension`.  If a class is annotated with `@TemplateExtension` "
"then a value resolver is generated for every _non-private static method_ "
"declared on the class.  Method-level annotations override the behavior "
"defined on the class.  Methods that do not meet the following requirements "
"are ignored."
msgstr ""
"値リゾルバは、 `@TemplateExtension` でアノテーションされたメソッドに対して自動的に生成されます。クラスが "
"`@TemplateExtension` でアノテーションされている場合は、そのクラスで宣言されている "
"_非プライベート・スタティック・メソッド_ごとに値リゾルバが生成されます。メソッドレベルのアノテーションは、クラスで定義された動作をオーバーライドします。以下の要件を満たさないメソッドは無視されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1021
#, fuzzy
msgid "A template extension method:"
msgstr "テンプレートの拡張方法です。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1023
#, fuzzy
msgid "must not be `private`"
msgstr "まじか `private`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1024
#, fuzzy
msgid "must be static,"
msgstr "は静的でなければなりません。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1025
#, fuzzy
msgid "must not return `void`,"
msgstr "`void` を返してはいけません。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1026
#, fuzzy
msgid "must accept at least one parameter, unless the namespace is specified."
msgstr "は、名前空間が指定されていない限り、少なくとも1つのパラメータを受け付ける必要があります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1029
#, fuzzy
msgid ""
"The class of the first parameter is used to match the base object unless the "
"namespace is specified.  In such case, the namespace is used to match an "
"expression."
msgstr ""
"名前空間が指定されていない限り、最初のパラメータのクラスがベース・オブジェクトにマッチするように使用されます。その場合、名前空間は式にマッチするように使用されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1036
#, fuzzy
msgid ""
"The method name is used to match the property name by default.  However, it "
"is possible to specify the matching name with "
"`TemplateExtension#matchName()`.  A special constant - "
"`TemplateExtension#ANY` - may be used to specify that the extension method "
"matches any name.  It is also possible to match the name against a regular "
"expression specified in `TemplateExtension#matchRegex()`.  In both cases, a "
"string method parameter is used to pass the property name.  If both "
"`matchName()` and `matchRegex()` are set the regular expression is used for "
"matching."
msgstr ""
"メソッド名は、デフォルトではプロパティ名とのマッチングに使用されます。ただし、一致する名前を "
"`TemplateExtension#matchName()` で指定することは可能です。特別な定数 `TemplateExtension#ANY` "
"を使用して、拡張メソッドが任意の名前にマッチすることを指定することができます。また、 `TemplateExtension#matchRegex()` "
"で指定された正規表現に対して名前を一致させることも可能です。どちらの場合も、文字列メソッド・パラメータを使用してプロパティ名を渡します。 "
"`matchName()` と `matchRegex()` の両方が設定されている場合は、正規表現がマッチングに使用されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1039
#, fuzzy
msgid ""
"If a namespace is specified the method must declare at least one parameter "
"and the first parameter must be a string.  If no namespace is specified the "
"method must declare at least two parameters and the second parameter must be "
"a string."
msgstr ""
"名前空間を指定する場合、メソッドは少なくとも 1 "
"つのパラメータを宣言し、最初のパラメータは文字列である必要があります。名前空間を指定しない場合は、少なくとも 2 つのパラメータを宣言し、2 "
"番目のパラメータは文字列である必要があります。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:1040
#, no-wrap, fuzzy
msgid "Extension Method Example"
msgstr "拡張メソッドの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1046
#, no-wrap
msgid "class Item {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1048
#: upstream/_guides/qute-reference.adoc:1209
#: upstream/_guides/qute-reference.adoc:1240
#, no-wrap
msgid "    public final BigDecimal price;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1053
#: upstream/_guides/qute-reference.adoc:1245
#, no-wrap
msgid ""
"    public Item(BigDecimal price) {\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1056
#, no-wrap
msgid "@TemplateExtension\n"
"class MyExtensions {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1061
#, no-wrap
msgid ""
"    static BigDecimal discountedPrice(Item item) { <1>\n"
"        return item.getPrice().multiply(new BigDecimal(\"0.9\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1063
#, fuzzy
msgid ""
"This method matches an expression with base object of the type `Item.class` "
"and the `discountedPrice` property name."
msgstr ""
"このメソッドは、 `Item.class` 型のベース・オブジェクトと `discountedPrice` プロパティ名を持つ式にマッチします。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1065
#, fuzzy
msgid ""
"This template extension method makes it possible to render the following "
"template:"
msgstr "このテンプレート拡張メソッドを使うと、以下のようなテンプレートをレンダリングすることができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1069
#, no-wrap
msgid "{item.discountedPrice} <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1071
#, fuzzy
msgid "`item` is resolved to an instance of `org.acme.Item`."
msgstr "`item` は `org.acme.Item` のインスタンスに解決されます。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:1072
#, no-wrap, fuzzy
msgid "Method Parameters"
msgstr "メソッドパラメータ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1077
#, fuzzy
msgid ""
"An extension method may accept multiple parameters.  If no namespace is "
"specified the first parameter is always used to pass the base object, i.e. "
"`org.acme.Item` in the first example.  Other parameters are resolved when "
"rendering the template and passed to the extension method."
msgstr ""
"拡張メソッドは複数のパラメータを受け取ることができます。 `org.acme.Item` "
"名前空間が指定されていない場合、最初のパラメータは常にベースオブジェクトを渡すために使用されます。他のパラメータはテンプレートをレンダリングする際に解決され、拡張メソッドに渡されます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:1078
#, no-wrap, fuzzy
msgid "Multiple Parameters Example"
msgstr "複数のパラメータの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1083
#, no-wrap
msgid "@TemplateExtension\n"
"class BigDecimalExtensions {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1088
#, no-wrap
msgid ""
"    static BigDecimal scale(BigDecimal val, int scale, RoundingMode mode) { "
"<1>\n"
"        return val.setScale(scale, mode);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1090
#, fuzzy
msgid ""
"This method matches an expression with base object of the type `BigDecimal."
"class`, with the `scale` virtual method name and two virtual method "
"parameters."
msgstr ""
"このメソッドは、 `BigDecimal.class` 型の基底オブジェクトと、 `scale` の仮想メソッド名と 2 "
"つの仮想メソッドパラメータを持つ式にマッチします。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1094
#, no-wrap
msgid "{item.discountedPrice.scale(2,mode)} <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1096
#, fuzzy
msgid "`item.discountedPrice` is resolved to an instance of `BigDecimal`."
msgstr "`item.discountedPrice` は `BigDecimal` のインスタンスに解決されます。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:1098
#, no-wrap, fuzzy
msgid "Namespace Extension Methods"
msgstr "名前空間拡張メソッド"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1103
#, fuzzy
msgid ""
"If `TemplateExtension#namespace()` is specified then the extension method is "
"used to resolve expressions with the given <<expressions,namespace>>.  "
"Template extension methods that share the same namespace are grouped in one "
"resolver ordered by `TemplateExtension#priority()`.  The first matching "
"extension method is used to resolve an expression."
msgstr ""
"`TemplateExtension#namespace()` が指定された場合、その拡張メソッドは、指定された link:"
"#expressions[名前空間]を持つ式を解決するために使用されます。同じ名前空間を共有するテンプレート拡張メソッドは、 "
"`TemplateExtension#priority()` で順に 1 "
"つのリゾルバにグループ化されます。最初に一致する拡張メソッドが式の解決に使用されます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:1104
#, no-wrap, fuzzy
msgid "Namespace Extension Method Example"
msgstr "名前空間拡張メソッドの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1109
#, no-wrap
msgid ""
"@TemplateExtension(namespace = \"str\")\n"
"public static class StringExtensions {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1113
#, no-wrap
msgid ""
"   static String format(String fmt, Object... args) {\n"
"      return String.format(fmt, args);\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1118
#, no-wrap
msgid ""
"   static String reverse(String val) {\n"
"      return new StringBuilder(val).reverse().toString();\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1121
#, fuzzy
msgid "These extension methods can be used as follows."
msgstr "これらの拡張方法は、以下のように使用することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1126
#, no-wrap
msgid ""
"{str:format('%s %s!','Hello', 'world')} <1>\n"
"{str:reverse('hello')} <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1128
#, fuzzy
msgid "The output is `Hello world!`"
msgstr "を出力しています。 `Hello world!`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1129
#, fuzzy
msgid "The output is `olleh`"
msgstr "を出力しています。 `olleh`"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:1130
#, no-wrap, fuzzy
msgid "Built-in Template Extension"
msgstr "組み込みのテンプレート拡張機能"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1133
#, fuzzy
msgid "Quarkus provides a set of built-in extension methods."
msgstr "Quarkusは、組み込みの拡張メソッドのセットを提供しています。"

#. type: Title =====
#: upstream/_guides/qute-reference.adoc:1134
#, no-wrap, fuzzy
msgid "Maps"
msgstr "地図"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1137
#, fuzzy
msgid "`keys` or `keySet`: Returns a Set view of the keys contained in a map"
msgstr "`keys` または `keySet`: マップに含まれるキーのセットビューを返します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1138
#, fuzzy
msgid "`{#for key in map.keySet}`"
msgstr "`{#for key in map.keySet}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1140
#, fuzzy
msgid "`values`: Returns a Collection view of the values contained in a map"
msgstr "`values`: マップに含まれる値のコレクションビューを返します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1141
#, fuzzy
msgid "`{#for value in map.values}`"
msgstr "`{#for value in map.values}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1143
#, fuzzy
msgid "`size`: Returns the number of key-value mappings in a map"
msgstr "`size`: マップ内のキーと値の対応付けの数を返します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1144
#, fuzzy
msgid "`{map.size}`"
msgstr "`{map.size}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1146
#, fuzzy
msgid "`isEmpty`: Returns true if a map contains no key-value mappings"
msgstr "`isEmpty`: マップにキーと値のマッピングが含まれていない場合に true を返します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1147
#, fuzzy
msgid "`{#if map.isEmpty}`"
msgstr "`{#if map.isEmpty}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1149
#, fuzzy
msgid "`get(key)`: Returns the value to which the specified key is mapped"
msgstr "`get(key)`: 指定したキーがマッピングされた値を返します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1150
#, fuzzy
msgid "`{map.get('foo')}`"
msgstr "`{map.get('foo')}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1152
#, fuzzy
msgid ""
"A map value can be also accessed directly: `{map.myKey}`. Use the bracket "
"notation for keys that are not legal identifiers: `{map['my key']}`."
msgstr ""
"マップ値は、直接アクセスすることもできます ： `{map.myKey}` 。法的な識別子ではないキーには大括弧表記を使用します: `{map['my "
"key']}` 。"

#. type: Title =====
#: upstream/_guides/qute-reference.adoc:1153
#, no-wrap, fuzzy
msgid "Collections"
msgstr "コレクション"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1156
#, fuzzy
msgid "`get(index)`: Returns the element at the specified position in a list"
msgstr "`get(index)`: リストの指定した位置の要素を返す"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1157
#, fuzzy
msgid "`{list.get(0)}`"
msgstr "`{list.get(0)}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1159
#, fuzzy
msgid "A list element can be accessed directly: `{list.10}` or `{list[10]}`."
msgstr "list 要素に直接アクセスすることができます： `{list.10}` または `{list[10]}`."

#. type: Title =====
#: upstream/_guides/qute-reference.adoc:1160
#, no-wrap, fuzzy
msgid "Numbers"
msgstr "数字"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1163
#, fuzzy
msgid "`mod`: Modulo operation"
msgstr "`mod`: モデューロ演算"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1164
#, fuzzy
msgid "`{#if counter.mod(5) == 0}`"
msgstr "`{#if counter.mod(5) == 0}`"

#. type: Title =====
#: upstream/_guides/qute-reference.adoc:1165
#, no-wrap, fuzzy
msgid "Config "
msgstr "設定"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1168
#, fuzzy
msgid ""
"`config:<name>` or `config:[<name>]`: Returns the config value for the given "
"property name"
msgstr ""
"`config:&amp;lt;name&amp;gt;` 又は `config:[&amp;lt;name&amp;gt;]`: "
"指定したプロパティ名の設定値を返します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1169
#, fuzzy
msgid "`{config:foo}` or `{config:['property.with.dot.in.name']}`"
msgstr "`{config:foo}` または `{config:['property.with.dot.in.name']}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1171
#, fuzzy
msgid ""
"`config:property(name)`: Returns the config value for the given property "
"name; the name can be obtained dynamically by an expression"
msgstr "`config:property(name)`: 指定したプロパティ名の設定値を返します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1172
#, fuzzy
msgid ""
"`{config:property('quarkus.foo')}` or `{config:property(foo."
"getPropertyName())}`"
msgstr ""
"`{config:property('quarkus.foo')}` または `{config:property(foo."
"getPropertyName())}`"

#. type: Title =====
#: upstream/_guides/qute-reference.adoc:1173
#, no-wrap, fuzzy
msgid "Time"
msgstr "時間"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1176
#, fuzzy
msgid ""
"`format(pattern)`: Formats temporal objects from the `java.time` package"
msgstr "`format(pattern)`: `java.time` パッケージのテンポラリオブジェクトをフォーマットします。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1177
#, fuzzy
msgid "`{dateTime.format('d MMM uuuu')}`"
msgstr "`{dateTime.format('d MMM uuuu')}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1179
#, fuzzy
msgid ""
"`format(pattern,locale)`: Formats temporal objects from the `java.time` "
"package"
msgstr "`format(pattern,locale)`: `java.time` パッケージのテンポラリオブジェクトをフォーマットします。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1180
#, fuzzy
msgid "`{dateTime.format('d MMM uuuu',myLocale)}`"
msgstr "`{dateTime.format('d MMM uuuu',myLocale)}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1182
#, fuzzy
msgid ""
"`format(pattern,locale,timeZone)`: Formats temporal objects from the `java."
"time` package"
msgstr ""
"`format(pattern,locale,timeZone)`: `java.time` パッケージのテンポラリオブジェクトをフォーマットします。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1183
#, fuzzy
msgid "`{dateTime.format('d MMM uuuu',myLocale,myTimeZoneId)}`"
msgstr "`{dateTime.format('d MMM uuuu',myLocale,myTimeZoneId)}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1185
#, fuzzy
msgid ""
"`time:format(dateTime,pattern)`: Formats temporal objects from the `java."
"time` package, `java.util.Date`, `java.util.Calendar` and `java.lang.Number`"
msgstr ""
"`time:format(dateTime,pattern)`: `java.time` パッケージ、 `java.util.Date` 、 `java."
"util.Calendar` 、 のテンポラリオブジェクトをフォーマットします。 `java.lang.Number`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1186
#, fuzzy
msgid "`{time:format(myDate,'d MMM uuuu')}`"
msgstr "`{time:format(myDate,'d MMM uuuu')}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1188
#, fuzzy
msgid ""
"`time:format(dateTime,pattern,locale)`: Formats temporal objects from the "
"`java.time` package, `java.util.Date`, `java.util.Calendar` and `java.lang."
"Number`"
msgstr ""
"`time:format(dateTime,pattern,locale)`: `java.time` パッケージ、 `java.util.Date` "
"、 `java.util.Calendar` 、 のテンポラリオブジェクトをフォーマットします。 `java.lang.Number`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1189
#, fuzzy
msgid "`{time:format(myDate,'d MMM uuuu', myLocale)}`"
msgstr "`{time:format(myDate,'d MMM uuuu', myLocale)}`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1191
#, fuzzy
msgid ""
"`time:format(dateTime,pattern,locale,timeZone)`: Formats temporal objects "
"from the `java.time` package, `java.util.Date`, `java.util.Calendar` and "
"`java.lang.Number`"
msgstr ""
"`time:format(dateTime,pattern,locale,timeZone)`: `java.time` パッケージ、 `java."
"util.Date` 、 `java.util.Calendar` 、 のテンポラリオブジェクトをフォーマットします。 `java.lang."
"Number`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1192
#, fuzzy
msgid "`{time:format(myDate,'d MMM uuuu',myTimeZoneId)}`"
msgstr "`{time:format(myDate,'d MMM uuuu',myTimeZoneId)}`"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:1194
#, no-wrap, fuzzy
msgid "@TemplateData"
msgstr "テンプレートデータ"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1198
#, fuzzy
msgid ""
"A value resolver is automatically generated for a type annotated with "
"`@TemplateData`.  This allows Quarkus to avoid using reflection to access "
"the data at runtime."
msgstr ""
"値リゾルバは、 `@TemplateData` "
"でアノテーションされた型に対して自動的に生成されます。これにより、Quarkusでは、実行時にデータにアクセスするためのリフレクションの使用を避けることができます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1200
#, fuzzy
msgid ""
"Non-public members, constructors, static initializers, static, synthetic and "
"void methods are always ignored."
msgstr "非公開のメンバ、コンストラクタ、静的イニシャライザ、静的メソッド、合成メソッド、ボイドメソッドは常に無視されます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1207
#, no-wrap
msgid "@TemplateData\n"
"class Item {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1213
#, no-wrap
msgid "    public Item(BigDecimal price) {\n"
"        this.price = price;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1218
#, no-wrap
msgid ""
"    public BigDecimal getDiscountedPrice() {\n"
"        return price.multiply(new BigDecimal(\"0.9\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1221
#, fuzzy
msgid "Any instance of `Item` can be used directly in the template:"
msgstr "`Item` の任意のインスタンスをテンプレート内で直接使用することができます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1227
#, no-wrap
msgid "{#each items} <1>\n"
"  {it.price} / {it.discountedPrice}\n"
"{/each}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1229
#, fuzzy
msgid "`items` is resolved to a list of `org.acme.Item` instances."
msgstr "`items` は `org.acme.Item` インスタンスのリストに解決されています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1232
#, fuzzy
msgid ""
"Furthermore, `@TemplateData.properties()` and `@TemplateData.ignore()` can "
"be used to fine-tune the generated resolver.  Finally, it is also possible "
"to specify the \"target\" of the annotation - this could be useful for third-"
"party classes not controlled by the application:"
msgstr ""
"さらに、 `@TemplateData.properties()` と `@TemplateData.ignore()` "
"を使用して、生成されたリゾルバを微調整することができます。最後に、アノテーションの「ターゲット」を指定することも可能です。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1238
#, no-wrap
msgid "@TemplateData(target = BigDecimal.class)\n"
"@TemplateData\n"
"class Item {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1252
#, no-wrap
msgid "{#each items} <1>\n"
"  {it.price.setScale(2, rounding)} <1>\n"
"{/each}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1254
#, fuzzy
msgid ""
"The generated value resolver knows how to invoke the `BigDecimal.setScale()` "
"method."
msgstr "生成された値リゾルバは、 `BigDecimal.setScale()` メソッドを呼び出す方法を知っています。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:1256
#, no-wrap, fuzzy
msgid "RESTEasy Integration"
msgstr "RESTEasyの統合"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1260
#, fuzzy
msgid ""
"If you want to use Qute in your JAX-RS application, you'll need to add the "
"`quarkus-resteasy-qute` extension first.  In your `pom.xml` file, add:"
msgstr ""
"JAX-RSアプリケーションでQuteを使用したい場合は、まず `quarkus-resteasy-qute` の拡張子を追加する必要があります。 "
"`pom.xml` ファイルに追加します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1271
#, fuzzy
msgid ""
"This extension registers a special `ContainerResponseFilter` implementation "
"so that a resource method can return a `TemplateInstance` and the filter "
"takes care of all necessary steps.  A simple JAX-RS resource may look like "
"this:"
msgstr ""
"この拡張機能は、リソースメソッドが `TemplateInstance` を返すことができるように、特別な "
"`ContainerResponseFilter` 実装を登録します。単純な JAX-RS リソースは次のようになります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1303
#, fuzzy
msgid ""
"Users are encouraged to use <<typesafe_templates,Type-safe templates>> that "
"help to organize the templates for a specific JAX-RS resource and enable "
"<<typesafe_expressions,type-safe expressions>> automatically."
msgstr ""
"ユーザーは、特定のJAX-RSリソースのテンプレートを整理し、自動的に link:"
"#typesafe_expressions[タイプセーフ表現を]有効にするのに役立つタイプセーフ link:"
"#typesafe_templates[テンプレートを]使用することが推奨されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1306
#, fuzzy
msgid ""
"The content negotiation is performed automatically.  The resulting output "
"depends on the `Accept` header received from the client."
msgstr "コンテントネゴシエーションは自動的に実行されます。結果の出力はクライアントから受け取った `Accept` ヘッダーに依存します。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1311
#: upstream/_guides/qute-reference.adoc:1332
#, no-wrap
msgid "@Path(\"/detail\")\n"
"class DetailResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1321
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces({ MediaType.TEXT_HTML, MediaType.TEXT_PLAIN })\n"
"    public TemplateInstance item() {\n"
"        return item.data(\"myItem\", new Item(\"Alpha\", 1000)); <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1323
#, fuzzy
msgid ""
"Inject a variant template with base path derived from the injected field - "
"`src/main/resources/templates/item`."
msgstr ""
"注入されたフィールドから派生したベースパスを持つバリアントテンプレートを注入する - `src/main/resources/templates/"
"item`."

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1324
#, fuzzy
msgid ""
"For `text/plain` the `src/main/resources/templates/item.txt` template is "
"used. For `text/html` the `META-INF/resources/templates/item.html` template "
"is used."
msgstr ""
"`text/plain` では `src/main/resources/templates/item.txt` のテンプレートを使用しています。 "
"`text/html` では `META-INF/resources/templates/item.html` のテンプレートを使用しています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1326
#, fuzzy
msgid ""
"The `io.quarkus.resteasy.qute.RestTemplate` util class can be used to obtain "
"a template instance from a body of a JAX-RS resource method:"
msgstr ""
"`io.quarkus.resteasy.qute.RestTemplate` utilクラスは、JAX-"
"RSリソースメソッドのボディからテンプレートインスタンスを取得するために使用することができます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:1327
#, no-wrap, fuzzy
msgid "RestTemplate Example"
msgstr "RestTemplateの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1339
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces({ MediaType.TEXT_HTML, MediaType.TEXT_PLAIN })\n"
"    public TemplateInstance item() {\n"
"        return RestTemplate.data(\"myItem\", new Item(\"Alpha\", 1000)); <1>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1341
#, fuzzy
msgid ""
"The name of the template is derived from the resource class and method name; "
"`DetailResource/item` in this particular case."
msgstr "`DetailResource/item` テンプレートの名前は、リソースクラスとメソッド名から派生しています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1343
#, fuzzy
msgid ""
"Unlike with `@Inject` the templates obtained via `RestTemplate` are not "
"validated, i.e. the build does not fail if a template does not exist."
msgstr "`@Inject` とは異なり、 `RestTemplate` 経由で取得したテンプレートは検証されません。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:1344
#, no-wrap, fuzzy
msgid "Development Mode"
msgstr "開発モード"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1347
#, fuzzy
msgid ""
"In the development mode, all files located in `src/main/resources/templates` "
"are watched for changes and modifications are immediately visible."
msgstr ""
"開発モードでは、 `src/main/resources/templates` にあるすべてのファイルの変更が監視され、変更はすぐに表示されます。"

#. type: Title ===
#: upstream/_guides/qute-reference.adoc:1348
#, no-wrap, fuzzy
msgid "Type-safe Message Bundles"
msgstr "タイプセーフメッセージバンドル"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1356
#, fuzzy
msgid ""
"The basic idea is that every message is potentially a very simple template.  "
"In order to prevent type errors a message is defined as an annotated method "
"of a *message bundle interface*.  Quarkus generates the *message bundle "
"implementation* at build time.  Subsequently, the bundles can be used at "
"runtime:"
msgstr ""
"基本的な考え方は、すべてのメッセージは潜在的に非常にシンプルなテンプレートであるということです。型エラーを防ぐために、メッセージは "
"*メッセージバンドルインターフェース*のアノテーションメソッドとして定義されます。Quarkusは、ビルド時に "
"*メッセージバンドルの実装を*生成します。その後、実行時にバンドルを使用することができます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1358
#, fuzzy
msgid ""
"Directly in your code via `io.quarkus.qute.i18n.MessageBundles#get()`; e.g. "
"`MessageBundles.get(AppMessages.class).hello_name(\"Lucie\")`"
msgstr ""
"`io.quarkus.qute.i18n.MessageBundles#get()` を経由して直接コードの中に入れてください。 "
"`MessageBundles.get(AppMessages.class).hello_name(\"Lucie\")`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1359
#, fuzzy
msgid "Injected in your beans via `@Inject`; e.g. `@Inject AppMessages`"
msgstr "`@Inject` を介してあなたの豆に注入されます。 `@Inject AppMessages`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1360
#, fuzzy
msgid "Referenced in the templates via the message bundle namespace:"
msgstr "メッセージ・バンドル・ネームスペースを介してテンプレート内で参照されます。"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1365
#, no-wrap
msgid " {msg:hello_name('Lucie')} <1> <2> <3>\n"
" {msg:message(myKey,'Lu')} <4>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1367
#, fuzzy
msgid "`msg` is the default namespace."
msgstr "`msg` がデフォルトの名前空間です。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1368
#, fuzzy
msgid "`hello_name` is the message key."
msgstr "`hello_name` がメッセージキーです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1369
#, fuzzy
msgid "`Lucie` is the parameter of the message bundle interface method."
msgstr "`Lucie` はメッセージバンドルインターフェースメソッドのパラメータです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1370
#, fuzzy
msgid ""
"It is also possible to obtain a localized message for a key resolved at "
"runtime using a reserved key `message`. The validation is skipped in this "
"case though."
msgstr ""
"また、予約された鍵を使用して、実行時に解決された鍵のローカライズされたメッセージを取得することも可能である `message` "
"。この場合、検証はスキップされます。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:1371
#, no-wrap, fuzzy
msgid "Message Bundle Interface Example"
msgstr "メッセージバンドルインタフェースの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1376
#, no-wrap
msgid ""
"import io.quarkus.qute.i18n.Message;\n"
"import io.quarkus.qute.i18n.MessageBundle;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1379
#, no-wrap
msgid "@MessageBundle <1>\n"
"public interface AppMessages {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1383
#, no-wrap
msgid ""
"    @Message(\"Hello {name}!\") <2>\n"
"    String hello_name(String name); <3>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1385
#, fuzzy
msgid ""
"Denotes a message bundle interface. The bundle name is defaulted to `msg` "
"and is used as a namespace in templates expressions, e.g. `{msg:hello_name}`."
""
msgstr ""
"メッセージバンドルのインターフェイスを表します。 `{msg:hello_name}`バンドル名のデフォルトは `msg` "
"で、テンプレート式の名前空間として使用されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1386
#, fuzzy
msgid ""
"Each method must be annotated with `@Message`. The value is a qute template."
msgstr "各メソッドには `@Message` をアノテーションする必要があります。値は qute テンプレートです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1387
#, fuzzy
msgid "The method parameters can be used in the template."
msgstr "メソッドのパラメータはテンプレートで使用することができます。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:1388
#, no-wrap, fuzzy
msgid "Bundle Name and Message Keys"
msgstr "バンドル名とメッセージキー"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1396
#, fuzzy
msgid ""
"Keys are used directly in templates.  The bundle name is used as a namespace "
"in template expressions.  The `@MessageBundle` can be used to define the "
"default strategy used to generate message keys from method names.  However, "
"the `@Message` can override this strategy and even define a custom key.  By "
"default, the annotated element's name is used as-is.  Other possibilities "
"are:"
msgstr ""
"キーはテンプレート内で直接使用します。バンドル名はテンプレート式の名前空間として使用されます。 `@MessageBundle` "
"は、メソッド名からメッセージキーを生成するために使用されるデフォルトのストラテジーを定義するために使用することができます。しかし、 `@Message` "
"はこのストラテジーをオーバーライドし、カスタム・キーを定義することもできます。デフォルトでは、注釈付き要素の名前がそのまま使用されます。他の可能性としては、以下のようなものがあります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1398
#, fuzzy
msgid "De-camel-cased and hyphenated; e.g. `helloName()` -> `hello-name`"
msgstr "`helloName()` 脱キャメル化してハイフン化したもの。 `hello-name`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1399
#, fuzzy
msgid ""
"De-camel-cased and parts separated by underscores; e.g. `helloName()` -> "
"`hello_name`."
msgstr "`helloName()` `hello_name`脱キャメル化されており、アンダースコアで区切られている部分があります。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:1400
#, no-wrap, fuzzy
msgid "Validation"
msgstr "バリデーション"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1403
#, fuzzy
msgid "All message bundle templates are validated:"
msgstr "すべてのメッセージバンドルテンプレートが検証されています。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1404
#, fuzzy
msgid ""
"All expressions without a namespace must map to a parameter; e.g. `Hello "
"{foo}` -> the method must have a param of name `foo`"
msgstr "`Hello {foo}` 名前空間を持たないすべての式はパラメータにマッピングしなければなりません。 `foo`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1405
#, fuzzy
msgid ""
"All expressions are validated against the types of the parameters; e.g. "
"`Hello {foo.bar}` where the parameter `foo` is of type `org.acme.Foo` -> "
"`org.acme.Foo` must have a property of name `bar`"
msgstr ""
"すべての式はパラメータの型に対して検証されます。例えば `Hello {foo.bar}` の場合、パラメータ `foo` の型は `org.acme."
"Foo` → `org.acme.Foo` の場合は name のプロパティを持たなければなりません。 `bar`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1407
#, fuzzy
msgid "A warning message is logged for each _unused_ parameter."
msgstr "_未使用の_パラメータごとに警告メッセージが記録されます。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1408
#, fuzzy
msgid ""
"Expressions that reference a message bundle method, such as `{msg:hello(item."
"name)}`, are validated too."
msgstr "`{msg:hello(item.name)}` のようなメッセージバンドルメソッドを参照する式も検証されます。"

#. type: Title ====
#: upstream/_guides/qute-reference.adoc:1409
#, no-wrap, fuzzy
msgid "Localization"
msgstr "ローカライゼーション"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1414
#, fuzzy
msgid ""
"The default locale of the Java Virtual Machine used to *build the "
"application* is used for the `@MessageBundle` interface by default.  "
"However, the `io.quarkus.qute.i18n.MessageBundle#locale()` can be used to "
"specify a custom locale.  Additionally, there are two ways to define a "
"localized bundle:"
msgstr ""
"*アプリケーションの構築*に使用する Java 仮想マシンのデフォルトのロケールは、デフォルトでは `@MessageBundle` "
"インターフェイスに使用されます。ただし、 `io.quarkus.qute.i18n.MessageBundle#locale()` "
"を使用してカスタムロケールを指定することができます。さらに、ローカライズされたバンドルを定義するには、2 つの方法があります。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1416
#, fuzzy
msgid ""
"Create an interface that extends the default interface that is annotated "
"with `@Localized`"
msgstr "でアノテーションされたデフォルトのインターフェイスを拡張するインターフェイスを作成します。 `@Localized`"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1417
#, fuzzy
msgid ""
"Create an UTF-8 encoded file located in `src/main/resources/messages`; e.g. "
"`msg_de.properties`."
msgstr ""
"`src/main/resources/messages` `msg_de.properties` にある UTF-8 "
"エンコードされたファイルを作成します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1419
#, fuzzy
msgid ""
"A localized interface is the preferred solution mainly due to the "
"possibility of easy refactoring."
msgstr "ローカライズされたインターフェイスは、主にリファクタリングが容易になる可能性があるため、好ましい解決策です。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:1420
#, no-wrap, fuzzy
msgid "Localized Interface Example"
msgstr "ローカライズされたインターフェースの例"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1425
#, no-wrap
msgid ""
"import io.quarkus.qute.i18n.Localized;\n"
"import io.quarkus.qute.i18n.Message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1428
#, no-wrap
msgid ""
"@Localized(\"de\") <1>\n"
"public interface GermanAppMessages extends AppMessages {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1433
#, no-wrap
msgid ""
"    @Override\n"
"    @Message(\"Hallo {name}!\") <2>\n"
"    String hello_name(String name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1435
#, fuzzy
msgid "The value is the locale tag string (IETF)."
msgstr "値はロケールタグ文字列（IETF）です。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1436
#, fuzzy
msgid "The value is the localized template."
msgstr "値はローカライズされたテンプレートです。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1444
#, fuzzy
msgid ""
"Message bundle files must be encoded in UTF-8.  The file name consists of "
"the relevant bundle name (e.g. `msg`) and underscore followed by the locate "
"tag (IETF).  The file format is very simple: each line represents either a "
"key/value pair with the equals sign used as a separator or a comment (line "
"starts with `#`).  Keys are mapped to method names from the corresponding "
"message bundle interface.  Values represent the templates normally defined "
"by `io.quarkus.qute.i18n.Message#value()`.  We use `.properties` suffix in "
"our example because most IDEs and text editors support syntax highlighting "
"of `.properties` files.  But in fact, the suffix could be anything."
msgstr ""
"メッセージバンドルファイルはUTF-8でエンコードされている必要があります。ファイル名は、関連するバンドル名（例： `msg` "
"）とアンダースコアの後にロケートタグ（IETF）が続きます。フ ァ イ "
"ル形式は非常に単純です。各行は、キーと値のペアを表すもので、等号をセパレータとして使用するか、コメント（行頭が `#` "
"で始まる）のいずれかになります。キーは、対応するメッセージ・バンドル・インターフェースのメソッド名にマッピングされています。値は、通常 `io."
"quarkus.qute.i18n.Message#value()` で定義されているテンプレートを表します。この例では `.properties` "
"サフィックスを使用しています。これは、ほとんどの IDE やテキスト・エディタが `.properties` "
"ファイルのシンタックス・ハイライトをサポートしているからです。しかし、実際には、サフィックスは何でも構いません。"

#. type: Block title
#: upstream/_guides/qute-reference.adoc:1445
#, no-wrap, fuzzy
msgid "Localized File Example - `msg_de.properties`"
msgstr "ローカライズされたファイルの例 `msg_de.properties`"

#. type: delimited block -
#: upstream/_guides/qute-reference.adoc:1449
#, no-wrap
msgid "hello_name=Hallo {name}! <1> <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1451
#, fuzzy
msgid "Each line in a localized file represents a message template."
msgstr "ローカライズされたファイルの各行は、メッセージテンプレートを表します。"

#. type: Plain text
#: upstream/_guides/qute-reference.adoc:1452
#, fuzzy
msgid "Keys and values are separated by the equals sign."
msgstr "キーと値は等号で区切られています。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/vault-transit.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using HashiCorp Vault's Transit Secret Engine"
msgstr "Quarkus - HashiCorp Vaultのトランジットシークレットエンジンを使用する"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:18
#, fuzzy
msgid ""
"Vault's Transit Secret Engine offers an \"encryption as a service\" "
"functionality. It allows to store encryption keys into Vault, and provides "
"services to encrypt/decrypt and sign/verify arbitrary pieces of data. This "
"brings several advantages, such as:"
msgstr ""
"VaultのTransit Secret "
"Engineは、「サービスとしての暗号化」機能を提供します。これは、暗号化キーをVaultに格納することを可能にし、データの任意の部分を暗号化/"
"復号化し、署名/検証するサービスを提供します。これにより、以下のようないくつかの利点がもたらされます。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:21
#, fuzzy
msgid ""
"limited key exposure: keys never leave the Vault. Instead the data is sent "
"to Vault to get encrypted/decrypted/signed/verified."
msgstr ""
"限られた鍵の露出：鍵は、Vaultを離れることはありません。代わりにデータは、暗号化/復号化/署名/検証を取得するためにボールトに送信されます。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:23
#, fuzzy
msgid ""
"reliable and consistent algorithms: algorithms are implemented by Vault. It "
"supports a wide variety, and there is only one implementation used for a "
"given algorithm type, regardless of the client's technology."
msgstr ""
"信頼性の高い一貫したアルゴリズム：アルゴリズムはVaultによって実装されています。多種多様なアルゴリズムをサポートしており、クライアントの技術に関係なく、与えられたアルゴリズムタイプに使用される実装は1つしかありません。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:24
#, fuzzy
msgid ""
"it relieves developers from having to embed cryptographic libraries into "
"their applications."
msgstr "これにより、開発者は暗号ライブラリをアプリケーションに組み込む必要がなくなります。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:26
#, fuzzy
msgid ""
"In the context of Quarkus, the main (non administration) services are being "
"covered:"
msgstr "Quarkusの文脈では、主な（管理以外の）サービスが対象となっています。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:28
#, fuzzy
msgid "encrypt: encrypt some data and return the cipher text"
msgstr "encrypt: データを暗号化して暗号文を返す"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:29
#, fuzzy
msgid "decrypt: decrypt the cipher text and return the clear data"
msgstr "decrypt: 暗号文を復号してクリアデータを返す"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:30
#, fuzzy
msgid "rewrap: reencrypt a cipher text using the most recent key version"
msgstr "rewrap: 最新の鍵バージョンを使って暗号文を再暗号化する"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:31
#, fuzzy
msgid "sign: sign a piece of data"
msgstr "sign: データに署名する"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:32
#, fuzzy
msgid ""
"verify signature: verify that a signature is correct for a piece of data"
msgstr "verify signature: 署名がデータに対して正しいことを検証する"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:34
#, fuzzy
msgid ""
"See https://www.vaultproject.io/docs/secrets/transit/index.html#transit-"
"secrets-engine[Vault Transit Secret Engine's official documentation]"
msgstr ""
"link:https://www.vaultproject.io/docs/secrets/transit/index.html#transit-"
"secrets-engine[Vault Transit Secret Engineの公式ドキュメントを]参照してください。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:42
#, fuzzy
msgid "to complete the \"Starting Vault\" section of the {base-guide}"
msgstr "ベースガイド}の「Vaultの起動」セクションを完了させるために"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:43
#, fuzzy
msgid "roughly 15 minutes"
msgstr "ざっと15分"

#. type: Title ==
#: upstream/_guides/vault-transit.adoc:48
#, no-wrap, fuzzy
msgid "Setup"
msgstr "セットアップ"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:52
#, fuzzy
msgid ""
"We assume there is a Vault running from the {base-guide}, and the root token "
"is known.  The first step consists in activating the Transit Secret Engine, "
"and creating the different keys:"
msgstr ""
"ここでは、{base-"
"guide}から実行されているVaultがあり、ルート・トークンが既知であると仮定します。最初のステップは、トランジット・シークレット・エンジンを起動し、異なる鍵を作成することです。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:60
#, no-wrap
msgid ""
"vault secrets enable transit\n"
"# ==> Success! Enabled the transit secrets engine at: transit/\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:63
#, no-wrap
msgid ""
"vault write -f transit/keys/my-encryption-key\n"
"# ==> Success! Data written to: transit/keys/my-encryption-key\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:66
#, no-wrap
msgid ""
"vault write transit/keys/my-sign-key type=ecdsa-p256\n"
"# ==> Success! Data written to: transit/keys/my-sign-key\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:70
#, fuzzy
msgid ""
"Note that you did not have to provide the key value. You only provide its "
"name, and Vault will generate it for you and keep it secured."
msgstr ""
"キーの値を提供する必要がなかったことに注意してください。あなたはその名前を提供するだけで、Vaultはあなたのためにそれを生成し、それを安全に保つことができます。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:72
#, fuzzy
msgid ""
"Once the keys have been created, we now need to create a policy that "
"provides access for it:"
msgstr "鍵が作成されたら、次に鍵へのアクセスを提供するポリシーを作成する必要があります。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:90
#, no-wrap
msgid ""
"cat <<EOF | vault policy write vault-transit-quickstart-policy -\n"
"path \"transit/encrypt/my-encryption-key\" {\n"
"  capabilities = [ \"update\" ]\n"
"}\n"
"path \"transit/decrypt/my-encryption-key\" {\n"
"  capabilities = [ \"update\" ]\n"
"}\n"
"path \"transit/sign/my-sign-key\" {\n"
"  capabilities = [ \"update\"]\n"
"}\n"
"path \"transit/verify/my-sign-key\" {\n"
"  capabilities = [ \"update\" ]\n"
"}\n"
"EOF\n"
"# ==> Success! Uploaded policy: vault-transit-quickstart-policy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:93
#, fuzzy
msgid ""
"And finally, let's add the `vault-transit-quickstart-policy` to user `bob` "
"that was created in the {base-guide}:"
msgstr ""
"そして最後に、{base-guide}で作成したユーザー `bob` に `vault-transit-quickstart-policy` "
"を追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:97
#, no-wrap
msgid ""
"vault write auth/userpass/users/bob password=sinclair policies=vault-"
"quickstart-policy,vault-transit-quickstart-policy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:127
#, fuzzy
msgid ""
"Now set `VAULT_TOKEN` to the `token` above (instead of the root token), and "
"try encrypting some data:"
msgstr ""
"ここで `VAULT_TOKEN` を上記の `token` に設定して（ルートトークンの代わりに）、いくつかのデータを暗号化してみてください。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:133
#, no-wrap
msgid ""
"export VAULT_TOKEN={client-token}\n"
"# note: \"my secret data\" in base64 is \"bXkgc2VjcmV0IGRhdGEK\"\n"
"vault write transit/encrypt/my-encryption-key plaintext="
"bXkgc2VjcmV0IGRhdGEK\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:141
#, no-wrap
msgid ""
"Key           Value\n"
"---           -----\n"
"ciphertext    vault:v1:vIQxsLANFbcfKofJL55zjoIXV6MqAzvjKUUQLGg5pWTz0W2Qab/"
"B4nEJaQ==\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vault-transit.adoc:143
#, no-wrap, fuzzy
msgid "Encrypt and Decrypt"
msgstr "暗号化と復号化"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:146
#, fuzzy
msgid ""
"First, let's create a simple Quarkus application with Vault and Jackson "
"extensions:"
msgstr "まずは、VaultとJacksonの拡張機能を使って、シンプルなQuarkusアプリケーションを作ってみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:156
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=vault-transit-quickstart \\\n"
"    -DclassName=\"org.acme.quickstart.GreetingResource\" \\\n"
"    -Dpath=\"/hello\" \\\n"
"    -Dextensions=\"vault,resteasy-jackson\"\n"
"cd vault-transit-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:159
#, fuzzy
msgid "Now, configure access to Vault from the `{config-file}`:"
msgstr "さて、 `{config-file}` から Vault へのアクセスを設定します。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:173
#, fuzzy
msgid ""
"Note that you did not need to specify the existence of a particular "
"encryption key in the configuration. You only do so in special cases such as "
"specifying the key type for upsert, or changing the signature algorithm, ... "
"Check the complete configuration for more information."
msgstr ""
"構成で特定の暗号化キーの存在を指定する必要はないことに注意してください。アップサートのキータイプを指定したり、署名アルゴリズムを変更したりするなど、特別な場合にのみ指定する必要があります。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:175
#, fuzzy
msgid ""
"We can then add a new endpoint that will allow us to encrypt and decrypt "
"data:"
msgstr "そして、データの暗号化と復号化を可能にする新しいエンドポイントを追加することができます。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:182
#, no-wrap
msgid ""
"@Path(\"/transit\")\n"
"@Produces(TEXT_PLAIN)\n"
"@Consumes(TEXT_PLAIN)\n"
"public class TransitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:185
#, no-wrap
msgid "    @Inject\n"
"    public VaultTransitSecretEngine transitSecretEngine;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:191
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/encrypt\")\n"
"    public String encrypt(String clearData) {\n"
"        return transitSecretEngine.encrypt(\"my-encryption-key\", "
"clearData);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:198
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/decrypt\")\n"
"    public String decrypt(String cipherText) {\n"
"        return transitSecretEngine.decrypt(\"my-encryption-key\", "
"cipherText).asString();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:201
#, fuzzy
msgid ""
"After compiling and starting the Quarkus application, let's encrypt some "
"data:"
msgstr "Quarkusアプリケーションをコンパイルして起動したら、データを暗号化してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:205
#, no-wrap
msgid ""
"curl -X POST --data 'some secret data' --header \"Content-Type: text/plain\" "
" http://localhost:8080/transit/encrypt\n"
"# ==> vault:v1:fN4P7WNjIegpb3lD/pSuhXvyONhGrI21gcKNcedk+5jpjguOw6JkqXYXlkY="
"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:208
#, fuzzy
msgid "And decrypt back this cipher text:"
msgstr "そして、この暗号文を復号化して"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:212
#, no-wrap
msgid ""
"curl -X POST --data 'vault:v1:fN4P7WNjIegpb3lD/"
"pSuhXvyONhGrI21gcKNcedk+5jpjguOw6JkqXYXlkY=' --header \"Content-Type: text/"
"plain\"  http://localhost:8080/transit/decrypt\n"
"# ==> some secret data\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/vault-transit.adoc:214
#, no-wrap, fuzzy
msgid "Sign and Verify"
msgstr "署名と検証"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:217
#, fuzzy
msgid "Let's add 2 new methods to our `TransitResource`:"
msgstr "`TransitResource` に 2 つの新しいメソッドを追加してみましょう。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:225
#, no-wrap
msgid ""
"@POST\n"
"@Path(\"/sign\")\n"
"public String sign(String input) {\n"
"    return transitSecretEngine.sign(\"my-sign-key\", input);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:230
#, no-wrap
msgid ""
"public static class VerifyRequest {\n"
"    public String signature;\n"
"    public String input;\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:238
#, no-wrap
msgid ""
"@POST\n"
"@Path(\"/verify\")\n"
"@Consumes(APPLICATION_JSON)\n"
"public Response verify(VerifyRequest request) {\n"
"    transitSecretEngine.verifySignature(\"my-sign-key\", request.signature, "
"request.input);\n"
"    return Response.accepted().build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:241
#, fuzzy
msgid "And start signing some data:"
msgstr "データに署名して"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:245
#, no-wrap
msgid ""
"curl -X POST --data 'some secret data' --header \"Content-Type: text/plain\" "
" http://localhost:8080/transit/sign\n"
"# ==> vault:v1:MEUCIQDl+nE4y4E878bkugGG6FG1/"
"RsttaQnoWfZHppeuk4TnQIgTGWTtMhVPCzN8VH/EEr2qp5h34lI1bnEP6L1F+QQoPI=\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:248
#, fuzzy
msgid "And finally, let's make sure the signature is matching our input data:"
msgstr "そして最後に、署名が入力データと一致していることを確認しましょう。"

#. type: delimited block -
#: upstream/_guides/vault-transit.adoc:252
#, no-wrap
msgid ""
"curl -v -X POST --data '{\"input\":\"some secret data\",\"signature\":"
"\"vault:v1:MEUCIQDl+nE4y4E878bkugGG6FG1/"
"RsttaQnoWfZHppeuk4TnQIgTGWTtMhVPCzN8VH/EEr2qp5h34lI1bnEP6L1F+QQoPI=\"}' --"
"header \"Content-Type: application/json\" http://localhost:8080/transit/"
"verify\n"
"# ==> ... < HTTP/1.1 202 Accepted\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:259
#, fuzzy
msgid ""
"The Transit Secret Engine is a powerful tool in the enterprise.  We have "
"seen the most obvious functions of the interface, but the rest of the "
"methods or flavors should not be overlooked:"
msgstr ""
"トランジット・シークレット・エンジンは、企業の強力なツールです。インターフェイスの最も明白な機能を見てきましたが、残りのメソッドやフレーバーも見落としてはいけません。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:261
#, fuzzy
msgid ""
"For instance batch oriented methods are strongly recommended for mass "
"operations (encrypt, decrypt, ...)"
msgstr "例えば、大量処理（暗号化、復号化、...）には、バッチ指向の方法が強く推奨されます。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:263
#, fuzzy
msgid ""
"Transit contexts allow key derivation where one key is used to derive other "
"keys for specific named contexts (e.g. person names, person addresses, ...)"
msgstr ""
"トランジットコンテキストでは、特定の名前付きコンテキスト(人名、人の住所、...)のために、1つのキーを使用して他のキーを導出することができます。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:265
#, fuzzy
msgid ""
"Rewrapping allows to reencrypt data with the most recent key version when "
"the Vault administrator decides to rotate keys"
msgstr "リラップでは、Vault 管理者がキーをローテートすることを決定した場合に、最新のキーバージョンでデータを再暗号化することができます。"

#. type: Plain text
#: upstream/_guides/vault-transit.adoc:267
#, fuzzy
msgid ""
"Feel free to look at the `VaultTransitSecretEngine` interface plus the "
"dedicated Transit Secret Engine configuration properties in the {base-guide} "
"for all the details."
msgstr ""
"詳細については、 `VaultTransitSecretEngine` インターフェイスと{base-guide}にある専用のTransit "
"Secret Engineコンフィギュレーション・プロパティをご覧ください。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/credentials-provider.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using a Credentials Provider"
msgstr "Quarkus - クレデンシャルプロバイダの使用"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:18
#, fuzzy
msgid ""
"Interacting with a datastore typically implies first connecting using "
"credentials.  Those credentials will allow the client to be identified, "
"authenticated and eventually authorized.  Username/password based "
"authentication is very common, but that is not by any means the only one.  "
"Such credentials information may appear in the application configuration, "
"but it is becoming increasingly popular to store this type of sensitive "
"information in secure stores, such as HashiCorp Vault, Azure Key Vault or "
"the AWS Secrets Manager to name just a few."
msgstr ""
"データストアとのやりとりは、通常、最初にクレデンシャルを使用して接続することを意味します。これらの認証情報によって、クライアントは識別され、認証され、最終的には認可されるようになります。ユーザ名/"
"パスワードベースの認証は非常に一般的ですが、それだけではありません。このようなクレデンシャル情報はアプリケーションの設定に表示されるかもしれませんが、HashiCorp "
"Vault、Azure Key Vault、AWS Secrets "
"Managerなどのセキュアなストアにこのタイプの機密情報を保存することが一般的になってきています。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:24
#, fuzzy
msgid ""
"To bridge datastores that consume credentials, which can take different "
"forms, and secure stores that provide those credentials, Quarkus introduces "
"an intermediate abstraction called `Credentials Provider`, that some "
"extensions may support to consume credentials (e.g. `agroal`), and some "
"others may implement to produce credentials (e.g. `vault`)."
msgstr ""
"さまざまな形式をとることができるクレデンシャルを消費するデータストアと、それらのクレデンシャルを提供する安全なストアの橋渡しをするために、Quarkusでは、 "
"`Credentials Provider` "
"と呼ばれる中間的な抽象化を導入しています。これは、一部の拡張機能がクレデンシャルを消費するためにサポートしている場合もあれば（例： `agroal` "
"）、クレデンシャルを生成するために実装している場合もあります（例： `vault` ）。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:27
#, fuzzy
msgid ""
"This Service Programming Interface (SPI) may also be used by implementers "
"that want to support custom providers not yet implemented in Quarkus (e.g. "
"Azure Key Vault)."
msgstr ""
"このService Programming Interface（SPI）は、Quarkusにまだ実装されていないカスタムプロバイダ（Azure Key "
"Vaultなど）をサポートしたい実装者が使用することもできます。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:30
#, fuzzy
msgid ""
"Currently, the `Credentials Provider` interface is implemented by the "
"`vault` extension, and is supported by the following credentials consumer "
"extensions:"
msgstr ""
"現在、 `Credentials Provider` インターフェイスは `vault` "
"拡張モジュールによって実装されており、以下のクレデンシャル消費者拡張モジュールによってサポートされています。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:32
#, fuzzy
msgid "`agroal`"
msgstr "`agroal`"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:33
#, fuzzy
msgid "`reactive-db2-client`"
msgstr "`reactive-db2-client`"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:34
#, fuzzy
msgid "`reactive-mysql-client`"
msgstr "`reactive-mysql-client`"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:35
#, fuzzy
msgid "`reactive-pg-client`"
msgstr "`reactive-pg-client`"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:39
#, fuzzy
msgid ""
"All extensions that rely on username/password authentication also allow "
"setting configuration properties in the `application.properties` as an "
"alternative. But the `Credentials Provider` is the only option if "
"credentials are generated (e.g. `Vault Dynamic DB Credentials`) or if a "
"custom credentials provider is required."
msgstr ""
"ユーザー名/パスワード認証に依存するすべての拡張機能では、代替として `application.properties` "
"で設定プロパティを設定することもできます。しかし、クレデンシャルが生成されている場合 (例: `Vault Dynamic DB "
"Credentials`) やカスタムのクレデンシャルプロバイダが必要な場合は `Credentials Provider` が唯一の選択肢です。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:43
#, fuzzy
msgid ""
"This guide will show how to use the `Credentials Provider` provided in the "
"`vault` extension, then we will look at implementing a custom `Credentials "
"Provider`, and finally we will talk about additional considerations "
"regarding implementing a `Credentials Provider` in a new extension."
msgstr ""
"このガイドでは、 `vault` 拡張モジュールで提供されている `Credentials Provider` の使い方を紹介し、次にカスタム "
"`Credentials Provider` の実装について見ていき、最後に新しい拡張モジュールで `Credentials Provider` "
"を実装する際の追加考慮事項について説明します。"

#. type: Title ==
#: upstream/_guides/credentials-provider.adoc:56
#, no-wrap, fuzzy
msgid "Vault Credentials Provider"
msgstr "Vault Credentials Provider"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:59
#, fuzzy
msgid ""
"To configure a `Vault Credentials Provider` you need to provide the "
"following properties:"
msgstr "`Vault Credentials Provider` を設定するには、以下のプロパティを提供する必要があります。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:63
#, no-wrap
msgid "quarkus.vault.credentials-provider.<name>.<property>=<value>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:66
#, fuzzy
msgid ""
"The `<name>` will be used in the consumer to refer to this provider. The "
"`<property>` and `<value>` fields are specific to the `Vault Credentials "
"Provider`. For complete details, please refer to the {vault-datasource-"
"guide}."
msgstr ""
"`&amp;lt;name&amp;gt;` は、消費者がこのプロバイダを参照するために使用されます。 "
"`&amp;lt;property&amp;gt;` および `&amp;lt;value&amp;gt;` フィールドは、 `Vault "
"Credentials Provider`.完全な詳細については、{vault-datasource-guide}を参照してください。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:72
#, no-wrap
msgid ""
"quarkus.vault.credentials-provider.mydatabase.kv-path=myapps/vault-"
"quickstart/db\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:75
#, fuzzy
msgid ""
"Once defined, the `mydatabase` provider can be used in any extension that "
"supports the `Credentials Provider` interface. For instance in `agroal`:"
msgstr ""
"一度定義すると、 `mydatabase` プロバイダは `Credentials Provider` "
"インターフェイスをサポートするすべての拡張機能で使用することができます。例えば、 `agroal`."

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:83
#, no-wrap
msgid ""
"# configure your datasource\n"
"quarkus.datasource.db-kind = postgresql\n"
"quarkus.datasource.username = sarah\n"
"quarkus.datasource.credentials-provider = mydatabase\n"
"quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/mydatabase\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:90
#, fuzzy
msgid ""
"Note that `quarkus.datasource.username` is the original `agroal` property, "
"whereas the `password` property is not included because the value will come "
"from the `mydatabase` credentials provider we just defined.  An alternative "
"is to define both username and password in Vault and drop the `quarkus."
"datasource.username` property from configuration. All consuming extensions "
"do support the ability to fetch both the username and password from the "
"provider, or just the password."
msgstr ""
"`quarkus.datasource.username` `mydatabase` が元々の プロパティであるのに対し、 "
"プロパティは含まれていないことに注意してください。別の方法としては、Vault でユーザー名とパスワードの両方を定義し、設定から "
"プロパティを削除する方法があります。すべての消費型拡張機能は、ユーザー名とパスワードの両方をプロバイダから取得する機能、またはパスワードのみを取得する機能をサポートしています。 "
"`agroal` `password` `quarkus.datasource.username`"

#. type: Title ==
#: upstream/_guides/credentials-provider.adoc:91
#, no-wrap, fuzzy
msgid "Custom Credentials Provider"
msgstr "カスタム認証情報プロバイダ"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:94
#, fuzzy
msgid ""
"Implementing a custom credentials provider is the only option when a vault "
"product is not yet supported in Quarkus, or if credentials need to be "
"retrieved from a custom store."
msgstr ""
"カスタム認証情報プロバイダの実装は、QuarkusでVault製品がまだサポートされていない場合や、カスタムストアから認証情報を取得する必要がある場合の唯一のオプションです。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:96
#, fuzzy
msgid "The only interface to implement is:"
msgstr "実装するインターフェースはこれだけです。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:100
#, no-wrap
msgid "public interface CredentialsProvider {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:103
#, no-wrap
msgid ""
"    String USER_PROPERTY_NAME = \"user\";\n"
"    String PASSWORD_PROPERTY_NAME = \"password\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:105
#, no-wrap
msgid ""
"    Map<String, String> getCredentials(String credentialsProviderName);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:110
#, fuzzy
msgid ""
"`USER_PROPERTY_NAME` and `PASSWORD_PROPERTY_NAME` are standard properties "
"that should be recognized by any consuming extension that support username/"
"password based authentication."
msgstr ""
"`USER_PROPERTY_NAME` と `PASSWORD_PROPERTY_NAME` は、ユーザ名/"
"パスワードベースの認証をサポートするすべてのコンシューマー拡張機能で認識されるべき標準的なプロパティです。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:112
#, fuzzy
msgid ""
"It is required that implementations be valid `@ApplicationScoped` CDI beans."
msgstr "実装は有効な `@ApplicationScoped` CDI ビーンズであることが要求されます。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:114
#, fuzzy
msgid "Here is a simple example:"
msgstr "簡単な例を挙げてみます。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:120
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Unremovable\n"
"public class MyCredentialsProvider implements CredentialsProvider {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:123
#, no-wrap
msgid ""
"\t@Override\n"
"\tpublic Map<String, String> getCredentials(String credentialsProviderName) "
"{\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:129
#, no-wrap
msgid ""
"\t\tMap<String, String> properties = new HashMap<>();\n"
"\t\tproperties.put(USER_PROPERTY_NAME, \"hibernate_orm_test\");\n"
"\t\tproperties.put(PASSWORD_PROPERTY_NAME, \"hibernate_orm_test\");\n"
"\t\treturn properties;\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:134
#, fuzzy
msgid ""
"Note that we decided here to return both the username and the password."
msgstr "ここでは、ユーザー名とパスワードの両方を返すことにしました。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:136
#, fuzzy
msgid "This provider may be used in a datasource definition like this:"
msgstr "このプロバイダは、次のようなデータソースの定義で使用することができます。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:142
#, no-wrap
msgid ""
"quarkus.datasource.db-kind=postgresql\n"
"quarkus.datasource.credentials-provider=custom\n"
"quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5431/"
"hibernate_orm_test\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:145
#, fuzzy
msgid ""
"It is also possible to pass configuration properties to the provider using "
"standard MicroProfile Config injection:"
msgstr "標準的なMicroProfile Configインジェクションを使用して、設定プロパティをプロバイダに渡すことも可能です。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:149
#, no-wrap
msgid "custom.foo=bar\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:152
#, fuzzy
msgid "And in the provider implementation:"
msgstr "そして、プロバイダの実装では"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:157
#, no-wrap
msgid "@Inject\n"
"Config config;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:160
#, no-wrap
msgid ""
"@Override\n"
"public Map<String, String> getCredentials(String credentialsProviderName) "
"{\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:163
#, no-wrap
msgid ""
"    System.out.println(\"MyCredentialsProvider called with foo=\" + config."
"getValue(credentialsProviderName + \".foo\", String.class));\n"
"    ...\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/credentials-provider.adoc:165
#, no-wrap, fuzzy
msgid "New Credentials Provider extension"
msgstr "新しいクレデンシャルプロバイダ拡張機能"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:168
#, fuzzy
msgid ""
"When creating a custom credentials provider in a new extension, there are a "
"few additional considerations."
msgstr "新しい拡張機能でカスタムクレデンシャルプロバイダを作成する際には、いくつかの追加考慮事項があります。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:170
#, fuzzy
msgid ""
"First, you need to name it to avoid collisions in case multiple credentials "
"providers are available in the project:"
msgstr "まず、プロジェクト内で複数のクレデンシャルプロバイダが利用可能な場合の衝突を避けるために、名前を付ける必要があります。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:177
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Unremovable\n"
"@Named(\"my-credentials-provider\")\n"
"public class MyCredentialsProvider implements CredentialsProvider {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:180
#, fuzzy
msgid ""
"It is the responsibility of the consumer to allow a `credentials-provider-"
"name` property:"
msgstr "`credentials-provider-name` の物件を許可するのは消費者の責任です。"

#. type: delimited block -
#: upstream/_guides/credentials-provider.adoc:185
#, no-wrap
msgid ""
"quarkus.datasource.credentials-provider = custom\n"
"quarkus.datasource.credentials-provider-name = my-credentials-provider\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:189
#, fuzzy
msgid ""
"The extension should allow runtime config, such as the "
"`CredentialsProviderConfig` from the `vault` extension to configure any "
"custom property in the provider. For an AWS Secrets Manager extension, this "
"could be:"
msgstr ""
"拡張機能では、 `vault` 拡張機能の `CredentialsProviderConfig` "
"のように、ランタイムコンフィグでプロバイダ内の任意のカスタムプロパティを設定できるようにしておく必要があります。AWS Secrets "
"Managerエクステンションの場合は、これが可能です。"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:191
#, fuzzy
msgid "`region`"
msgstr "`region`"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:192
#, fuzzy
msgid "`credentials-type`"
msgstr "`credentials-type`"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:193
#, fuzzy
msgid "`secrets-id`"
msgstr "`secrets-id`"

#. type: Plain text
#: upstream/_guides/credentials-provider.adoc:197
#, fuzzy
msgid ""
"Note also that some consumers such as `agroal` will add to their connection "
"configuration any properties returned by the credentials provider, not just "
"the username and password. So when you design the new credentials provider "
"limit the properties to what would be understood by consumers, or provide "
"appropriate configuration options to support different modes."
msgstr ""
"また、 `agroal` "
"のような消費者の中には、ユーザー名とパスワードだけでなく、クレデンシャル・プロバイダが返すプロパティを接続構成に追加するものがあることにも注意してください。したがって、新しいクレデンシャル・プロバイダを設計する際には、プロパティを消費者が理解できるものに限定するか、異なるモードをサポートするための適切な構成オプションを提供してください。"

#. type: delimited block =
#: upstream/_guides/duration-format-note.adoc:5
#, fuzzy
msgid ""
"The format for durations uses the standard `java.time.Duration` format.  You "
"can learn more about it in the link:https://docs.oracle.com/javase/8/docs/"
"api/java/time/Duration.html#parse-java.lang.CharSequence-[Duration#parse() "
"javadoc]."
msgstr ""
"デュレーションのフォーマットは標準の `java.time.Duration` フォーマットを使用します。詳細は link:https://docs."
"oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang."
"CharSequence-[Duration#parse() javadoc] を参照してください。"

#. type: delimited block =
#: upstream/_guides/duration-format-note.adoc:9
#, fuzzy
msgid ""
"You can also provide duration values starting with a number.  In this case, "
"if the value consists only of a number, the converter treats the value as "
"seconds.  Otherwise, `PT` is implicitly prepended to the value to obtain a "
"standard `java.time.Duration` format."
msgstr ""
"数字で始まる持続時間の値を指定することもできます。この場合、値が数値のみで構成されている場合、コンバータは値を秒として扱います。そうでない場合は、 "
"`PT` が暗黙的に値の前に付加され、標準の `java.time.Duration` 形式が得られます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kogito.adoc:6
#, no-wrap, fuzzy
msgid ""
"Quarkus - Using Kogito to add business automation capabilities to an "
"application"
msgstr "Quarkus - Kogitoを使用してアプリケーションにビジネスオートメーション機能を追加する"

#. type: Plain text
#: upstream/_guides/kogito.adoc:13
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can use Kogito to add "
"business automation to power it up with business processes and rules."
msgstr ""
"このガイドでは、QuarkusアプリケーションがKogitoを使用してビジネスオートメーションを追加し、ビジネスプロセスとルールでパワーアップする方法を説明します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:18
#, fuzzy
msgid ""
"Kogito is a next generation business automation toolkit that originates from "
"well known Open Source projects Drools (for business rules) and jBPM (for "
"business processes). Kogito aims at providing another approach to business "
"automation where the main message is to expose your business knowledge "
"(processes, rules and decisions)  in a domain specific way."
msgstr ""
"Kogitoは、有名なオープンソースプロジェクトであるDrools (ビジネスルール用)とjBPM "
"(ビジネスプロセス用)から生まれた次世代のビジネスオートメーションツールキットです。Kogitoは、ビジネスナレッジ（プロセス、ルール、意思決定）をドメイン固有の方法で公開することを主なメッセージとするビジネスオートメーションへの別のアプローチを提供することを目的としています。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:27
#, fuzzy
msgid "an IDE (Eclipse is preferred with the BPMN modeller plugin)"
msgstr "IDE (BPMN モデラプラグインを使用したEclipseが望ましい)"

#. type: Title ===
#: upstream/_guides/kogito.adoc:31
#, no-wrap, fuzzy
msgid "Install modelling plugins in your IDE"
msgstr "モデリングプラグインをIDEにインストールする"

#. type: Plain text
#: upstream/_guides/kogito.adoc:34
#, fuzzy
msgid "Kogito Tooling is currently supported in Eclipse and VSCode:"
msgstr "Kogito Toolingは現在EclipseとVSCodeでサポートされています。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:36
#, fuzzy
msgid "Eclipse"
msgstr "エクリプス"

#. type: Plain text
#: upstream/_guides/kogito.adoc:39
#, fuzzy
msgid ""
"To be able to make use of visual modelling of your processes, download "
"Eclipse IDE and install from Market place Eclipse BPMN2 Modeller plugin "
"(with jBPM Runtime Extension)"
msgstr ""
"プロセスのビジュアルモデリングを利用するには、Eclipse IDEをダウンロードし、マーケットプレイスからEclipse BPMN2 "
"Modellerプラグイン（jBPMランタイム拡張機能付き）をインストールします。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:41
#, fuzzy
msgid "VSCode"
msgstr "ブイエスコード"

#. type: Plain text
#: upstream/_guides/kogito.adoc:43
#, fuzzy
msgid ""
"Download and install the VSCode Extension from https://github.com/kiegroup/"
"kogito-tooling/releases[Kogito Tooling release page] to edit and model "
"process definitions from VSCode IDE."
msgstr ""
"link:https://github.com/kiegroup/kogito-tooling/releases[Kogito "
"Toolingのリリースページ]からVSCode Extensionをダウンロードしてインストールすると、VSCode "
"IDEからプロセス定義を編集してモデル化することができます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:45
#, fuzzy
msgid "Online"
msgstr "オンライン"

#. type: Plain text
#: upstream/_guides/kogito.adoc:47
#, fuzzy
msgid ""
"To avoid any modeler installation you can use directly use https://bpmn."
"new[BPMN.new] to design and model your process through your favorite web "
"browser."
msgstr ""
"モデラーのインストールを避けるために、 link:https://bpmn.new[BPMN."
"new]を直接使用して、お気に入りのWebブラウザを使ってプロセスの設計とモデリングを行うことができます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:51
#, fuzzy
msgid ""
"In this example, we build a very simple microservice which offers one REST "
"endpoint:"
msgstr "この例では、1つのRESTエンドポイントを提供する非常にシンプルなマイクロサービスを構築します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:53
#, fuzzy
msgid "`/persons`"
msgstr "`/persons`"

#. type: Plain text
#: upstream/_guides/kogito.adoc:56
#, fuzzy
msgid ""
"This endpoint will be automatically generated based on business process, "
"that in turn will make use of business rules to make certain decisions based "
"on the data being processed."
msgstr ""
"このエンドポイントは、ビジネスプロセスに基づいて自動的に生成され、ひいてはビジネスルールを利用して処理中のデータに基づいて一定の判断を下すことになります。"

#. type: Title ===
#: upstream/_guides/kogito.adoc:57
#, no-wrap, fuzzy
msgid "Business process"
msgstr "ビジネスプロセス"

#. type: Plain text
#: upstream/_guides/kogito.adoc:62
#, fuzzy
msgid ""
"The business process will be responsible for encapsulating business logic of "
"our microservice.  It should provide complete set of steps to achieve a "
"business goal.  At the same time this is the entry point to the service that "
"can be consumed by clients."
msgstr ""
"ビジネスプロセスは、マイクロサービスのビジネスロジックをカプセル化する責任があります。これは、ビジネス目標を達成するためのステップの完全なセットを提供する必要があります。同時に、これはクライアントが消費することができるサービスへの入り口となります。"

#. type: Title ===
#: upstream/_guides/kogito.adoc:63
#, no-wrap, fuzzy
msgid "Business rule"
msgstr "ビジネスルール"

#. type: Plain text
#: upstream/_guides/kogito.adoc:69
#, fuzzy
msgid ""
"A business rule allows to externalise decision logic into reusable pieces "
"that can be easily used in declarative way. There are multiple ways of "
"writing rules like decision tables, decision trees, rules, etc. For this "
"example we focus on the rule format backed by DRL (Drools Rule Language)."
msgstr ""
"ビジネスルールでは、意思決定ロジックを、宣言的な方法で簡単に使える再利用可能なものに外部化することができます。ルールの書き方には、ディシジョンテーブル、ディシジョンツリー、ルールなど複数の書き方があります。この例では、DRL（Drools "
"Rule Language）に裏打ちされたルール形式に焦点を当てています。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:74
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step.  However, you can go right to the "
"complete example."
msgstr ""
"次のセクションの指示に従って、ステップバイステップでアプリケーションを作成することをお勧めします。ただし、完全な例に右に行くことができます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:78
#, fuzzy
msgid ""
"The solution is located in the `kogito-quickstart` {quickstarts-tree-url}/"
"kogito-quickstart[directory]."
msgstr ""
"解決策は `kogito-quickstart` {quickstarts-tree-url}/kogito-quickstart[directory] "
"にあります。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:90
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kogito-quickstart \\\n"
"    -Dextensions=\"kogito\"\n"
"cd kogito-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:95
#, fuzzy
msgid ""
"This command generates a Maven project, importing the `kogito` extension "
"that comes with all needed dependencies and configuration to equip your "
"application with business automation."
msgstr ""
"このコマンドは、アプリケーションにビジネスオートメーションを装備するために必要なすべての依存関係と構成を含む `kogito` "
"拡張機能をインポートして、Maven プロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:98
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`kogito` extension to your project by running the following command in your "
"project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`kogito` 拡張機能を追加することができます。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:102
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"kogito\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:112
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>org.kie.kogito</groupId>\n"
"    <artifactId>kogito-quarkus</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:117
#, fuzzy
msgid ""
"Let's start by implementing the simple data object `Person`. As you can see "
"from the source code below it is just a POJO:"
msgstr "まずはシンプルなデータオブジェクト `Person` を実装してみましょう。下のソースコードを見ればわかるように、ただのPOJOです。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:121
#, no-wrap
msgid "package org.acme.kogito.model;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:127
#, no-wrap
msgid "\tprivate String name;\n"
"\tprivate int age;\n"
"\tprivate boolean adult;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:131
#, no-wrap
msgid "\tpublic String getName() {\n"
"\t\treturn name;\n"
"\t}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:135
#, no-wrap
msgid "\tpublic void setName(String name) {\n"
"\t\tthis.name = name;\n"
"\t}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:139
#, no-wrap
msgid "\tpublic int getAge() {\n"
"\t\treturn age;\n"
"\t}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:143
#, no-wrap
msgid "\tpublic void setAge(int age) {\n"
"\t\tthis.age = age;\n"
"\t}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:147
#, no-wrap
msgid "\tpublic boolean isAdult() {\n"
"\t\treturn adult;\n"
"\t}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:151
#, no-wrap
msgid "\tpublic void setAdult(boolean adult) {\n"
"\t\tthis.adult = adult;\n"
"\t}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:156
#, no-wrap
msgid ""
"\t@Override\n"
"\tpublic String toString() {\n"
"\t\treturn \"Person [name=\" + name + \", age=\" + age + \", adult=\" + "
"adult + \"]\";\n"
"\t}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:163
#, fuzzy
msgid ""
"Next, we create a rule file `person-rules.drl` inside the `src/main/"
"resources/org/acme/kogito` folder of the generated project."
msgstr ""
"次に、生成されたプロジェクトの `src/main/resources/org/acme/kogito` フォルダ内にルールファイル `person-"
"rules.drl` を作成します。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:167
#, no-wrap
msgid "package org.acme.kogito\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:169
#, no-wrap
msgid "import org.acme.kogito.model.Person;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:172
#, no-wrap
msgid "rule \"Is adult\" ruleflow-group \"person\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kogito.adoc:180
#, no-wrap
msgid ""
"when\n"
"    $person: Person(age > 18)\n"
"then\n"
"    modify($person) {\n"
"    \tsetAdult(true)\n"
"    };\n"
"end\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:183
#, fuzzy
msgid ""
"This is really a simple rule that marks a person who is older that 18 years "
"as an adult."
msgstr "これは本当にシンプルなルールで、18歳以上の人を大人としてマークしています。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:187
#, fuzzy
msgid ""
"Finally we create a business process that will make use of this rule and "
"some other activities to approve a given person. Using new item wizard (File "
"-> New -> Other -> BPMN2 Model)  create `persons.bpmn` inside `src/main/"
"resources/org/acme/kogito` folder of the generated project."
msgstr ""
"最後に、このルールを利用して、ある人物を承認するビジネスプロセスを作成します。新規項目ウィザード(ファイル→新規→その他→BPMN2モデル)を使用して、生成されたプロジェクトの "
"`src/main/resources/org/acme/kogito` フォルダ内に `persons.bpmn` を作成します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:189
#, fuzzy
msgid "This process should consist of"
msgstr "このプロセスは次のように構成されています。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:191
#, fuzzy
msgid "start event"
msgstr "スタートイベント"

#. type: Plain text
#: upstream/_guides/kogito.adoc:192
#, fuzzy
msgid "business rule task"
msgstr "ビジネスルールタスク"

#. type: Plain text
#: upstream/_guides/kogito.adoc:193
#, fuzzy
msgid "exclusive gateway"
msgstr "専用ゲートウェイ"

#. type: Plain text
#: upstream/_guides/kogito.adoc:194
#, fuzzy
msgid "user task"
msgstr "ユーザータスク"

#. type: Plain text
#: upstream/_guides/kogito.adoc:195
#, fuzzy
msgid "end events"
msgstr "エンドイベント"

#. type: Plain text
#: upstream/_guides/kogito.adoc:197
#, fuzzy
msgid "And should look like"
msgstr "そして、次のように見えるはずです。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:199
#, fuzzy
msgid "image:kogito-guide-screenshot.png[alt=Process definition]"
msgstr "image:kogito-guide-screenshot.png[alt=Process definition]"

#. type: Plain text
#: upstream/_guides/kogito.adoc:202
#, fuzzy
msgid ""
"To get started quickly copy the process definition from the {quickstarts-"
"tree-url}/kogito-quickstart/src/main/resources/org/acme/kogito/persons."
"bpmn2[quickstart]"
msgstr ""
"開始するには、{quickstarts-tree-url}/kogito-quickstart/src/main/resources/org/acme/"
"kogito/persons.bpmn2[quickstart]からプロセス定義をコピーします。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:204
#, fuzzy
msgid ""
"To model this process yourself, just follow these steps (start event should "
"be automatically added)"
msgstr "このプロセスを自分でモデル化するには、以下の手順に従ってください（開始イベントが自動的に追加されます）。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:206
#, fuzzy
msgid ""
"define a process variable with name `person` of type `org.acme.kogito.model."
"Person`"
msgstr "型の名前 `person` を持つプロセス変数を定義します。 `org.acme.kogito.model.Person`"

#. type: Plain text
#: upstream/_guides/kogito.adoc:207
#, fuzzy
msgid ""
"drag the Tasks -> Business Rule Task from the palette and drop it next to "
"start event, link it with start event"
msgstr "タスク→ビジネスルールタスクをパレットからドラッグしてスタートイベントの横にドロップし、スタートイベントと連動させます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:208
#, fuzzy
msgid "double click on the business rule task"
msgstr "ビジネスルールタスクをダブルクリック"

#. type: Plain text
#: upstream/_guides/kogito.adoc:209
#, fuzzy
msgid ""
"on tab I/O Parameters, set data input and output (map `person` process "
"variable to input data with name `person` and same for data output)"
msgstr ""
"I/Oパラメータタブで、データの入出力を設定します（ `person` プロセス変数を `person` "
"という名前の入力データにマップし、データの出力も同じにします）。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:210
#, fuzzy
msgid ""
"on tab Business Rule Task, set rule flow group to the value defined in the "
"drl file (`person`)"
msgstr "タブの「ビジネス・ルール・タスク」で、ルール・フロー・グループをdrlファイル( `person`)で定義された値に設定します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:211
#, fuzzy
msgid ""
"drag the Gateways -> XOR gateway from the palette and drop it next to the "
"business rule task, link it with rule task"
msgstr "パレットからゲートウェイ→XORゲートウェイをドラッグして、ビジネスルールタスクの横にドロップし、ルールタスクとリンクさせます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:212
#, fuzzy
msgid ""
"drag the Tasks -> User Task from the palette and drop it next to the "
"gateway, link it with gateway"
msgstr "パレットからタスク→ユーザータスクをドラッグしてゲートウェイの横にドロップし、ゲートウェイと連携させる"

#. type: Plain text
#: upstream/_guides/kogito.adoc:213
#, fuzzy
msgid "double click on the user task"
msgstr "ユーザータスクをダブルクリック"

#. type: Plain text
#: upstream/_guides/kogito.adoc:214
#, fuzzy
msgid "on tak User Task, set task name to `ChildrenHandling`"
msgstr "タスク名を `ChildrenHandling`"

#. type: Plain text
#: upstream/_guides/kogito.adoc:215
#, fuzzy
msgid ""
"on tab I/O Parameters, set data input (map `person` process variable to "
"input data with name `person`)"
msgstr ""
"I/Oパラメータタブで、データ入力を設定します（ `person` プロセス変数を `person` という名前の入力データにマップします）。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:216
#, fuzzy
msgid ""
"drag the End Events -> End from the palette and drop it next to the user "
"task, link it with the user task"
msgstr "パレットから終了イベント→終了をドラッグして、ユーザータスクの横にドロップして、ユーザータスクとリンクさせます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:217
#, fuzzy
msgid ""
"drag the End Events -> End from the palette and drop it next to the gateway, "
"link it with the user task"
msgstr "パレットから終了イベント→終了をドラッグして、ゲートウェイの横にドロップして、ユーザータスクとリンクさせます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:218
#, fuzzy
msgid "double click on the gateway"
msgstr "ゲートウェイをダブルクリック"

#. type: Plain text
#: upstream/_guides/kogito.adoc:219
#, fuzzy
msgid "on tab Gateway, set the diverging direction for the gateway"
msgstr "タブの Gateway で、ゲートウェイの発散方向を設定します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:220
#, fuzzy
msgid "on tab Gateway, set conditions on sequence flow list"
msgstr "タブの Gateway で、シーケンスフローリストの条件を設定します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:221
#, fuzzy
msgid ""
"-> going to end event `return person.isAdult() == true;` with language "
"`Java`"
msgstr "→ 言語でイベント `return person.isAdult() == true;` を終了させる予定 `Java`"

#. type: Plain text
#: upstream/_guides/kogito.adoc:222
#, fuzzy
msgid ""
"-> going to user task `return person.isAdult() == false;` with language "
"`Java`"
msgstr "→ ユーザータスク `return person.isAdult() == false;` に言語で行く `Java`"

#. type: Plain text
#: upstream/_guides/kogito.adoc:223
#, fuzzy
msgid "save the file"
msgstr "ファイルを保存する"

#. type: Title ==
#: upstream/_guides/kogito.adoc:224
#, no-wrap, fuzzy
msgid "Running and Using the Application"
msgstr "アプリケーションの実行と使用"

#. type: Title ===
#: upstream/_guides/kogito.adoc:226
#, no-wrap, fuzzy
msgid "Running in Developer Mode"
msgstr "デベロッパーモードでの実行"

#. type: Plain text
#: upstream/_guides/kogito.adoc:229
#, fuzzy
msgid ""
"To run the microservice in dev mode, use `./mvnw clean compile quarkus:dev`."
msgstr "マイクロサービスをdevモードで実行するには、 `./mvnw clean compile quarkus:dev`."

#. type: Title ===
#: upstream/_guides/kogito.adoc:230
#, no-wrap, fuzzy
msgid "Running in JVM Mode"
msgstr "JVMモードでの実行"

#. type: Plain text
#: upstream/_guides/kogito.adoc:233
#, fuzzy
msgid ""
"When you're done playing with \"dev-mode\" you can run it as a standard Java "
"application."
msgstr "dev-mode」で遊び終わったら、標準のJavaアプリケーションとして実行することができます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:235
#, fuzzy
msgid "First compile it:"
msgstr "まずコンパイルします。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:239
#, no-wrap
msgid "./mvnw package\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:242
#, fuzzy
msgid "Then run it:"
msgstr "それから実行してください。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:246
#, no-wrap
msgid "java -jar ./target/kogito-quickstart-runner.jar\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kogito.adoc:248
#, no-wrap, fuzzy
msgid "Running in Native Mode"
msgstr "ネイティブモードでの実行"

#. type: Plain text
#: upstream/_guides/kogito.adoc:251
#, fuzzy
msgid ""
"This same demo can be compiled into native code: no modifications required."
msgstr "同じデモをネイティブコードにコンパイルすることができます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:255
#, fuzzy
msgid ""
"This implies that you no longer need to install a JVM on your production "
"environment, as the runtime technology is included in the produced binary, "
"and optimized to run with minimal resource overhead."
msgstr ""
"これは、生成されたバイナリにランタイム技術が含まれており、最小限のリソースオーバーヘッドで実行できるように最適化されているため、本番環境にJVMをインストールする必要がないことを意味します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:258
#, fuzzy
msgid ""
"Compilation will take a bit longer, so this step is disabled by default; "
"let's build again by enabling the `native` profile:"
msgstr ""
"コンパイルには少し時間がかかるので、このステップはデフォルトで無効になっています。 `native` プロファイルを有効にして再度ビルドしてみましょう。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:262
#, no-wrap
msgid "./mvnw package -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:265
#, fuzzy
msgid ""
"After getting a cup of coffee, you'll be able to run this binary directly:"
msgstr "コーヒーを飲んでから、このバイナリを直接実行してみましょう。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:269
#, no-wrap
msgid "./target/kogito-quickstart-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:275
#, fuzzy
msgid ""
"To test your application, just send request to the service with giving the "
"person as JSON payload."
msgstr "アプリケーションをテストするには、JSONペイロードとして人を指定してサービスにリクエストを送信するだけです。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:282
#, no-wrap
msgid ""
"curl -X POST http://localhost:8080/persons \\\n"
"    -H 'content-type: application/json' \\\n"
"    -H 'accept: application/json' \\\n"
"    -d '{\"person\": {\"name\":\"John Quark\", \"age\": 20}}'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:285
#, fuzzy
msgid ""
"In the response, the person should be approved as an adult and that should "
"also be visible in the response payload."
msgstr "レスポンスの中では、本人は成人として認められているべきであり、それもレスポンスのペイロードの中で見えるようにしなければならない。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:289
#, no-wrap
msgid ""
"{\"id\":\"dace1d6a-a5fa-429d-b253-d6b66e265bbc\",\"person\":{\"adult\":"
"true,\"age\":20,\"name\":\"John Quark\"}}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:292
#, fuzzy
msgid "You can also verify that there are no more active instances"
msgstr "アクティブなインスタンスがないことを確認することもできます。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:298 upstream/_guides/kogito.adoc:402
#: upstream/_guides/kogito.adoc:413
#, no-wrap
msgid ""
"curl -X GET http://localhost:8080/persons \\\n"
"    -H 'content-type: application/json' \\\n"
"    -H 'accept: application/json'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:301
#, fuzzy
msgid ""
"To verify the non adult case, send another request with the age set to less "
"than 18"
msgstr "成人していないケースを確認するには、年齢を18歳未満に設定して別のリクエストを送信してください。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:308 upstream/_guides/kogito.adoc:393
#, no-wrap
msgid ""
"curl -X POST http://localhost:8080/persons \\\n"
"    -H 'content-type: application/json' \\\n"
"    -H 'accept: application/json' \\\n"
"    -d '{\"person\": {\"name\":\"Jenny Quark\", \"age\": 15}}'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:311
#, fuzzy
msgid ""
"this time there should be one active instance, replace `{uuid}` with the id "
"attribute taken from the response"
msgstr "今回はアクティブなインスタンスが一つあるはずです。 `{uuid}` をレスポンスから取得した id 属性に置き換えてください。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:317
#, no-wrap
msgid ""
"curl -X GET http://localhost:8080/persons/{uuid}/tasks \\\n"
"    -H 'content-type: application/json' \\\n"
"    -H 'accept: application/json'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:322
#, fuzzy
msgid ""
"You can get the details of the task by calling another endpoint, replace "
"`uuids` with the values taken from the responses (`uuid-1` is the process "
"instance id and `uuid-2` is the task instance id).  First corresponds to the "
"process instance id and the other to the task instance id."
msgstr ""
"別のエンドポイントを呼び出すことでタスクの詳細を取得することができます。 `uuids` をレスポンスから取得した値( `uuid-1` "
"はプロセスインスタンス ID、 `uuid-2` はタスクインスタンス "
"ID)に置き換えてください。最初の値はプロセスインスタンスIDに、もう一方の値はタスクインスタンスIDに対応します。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:328
#, no-wrap
msgid ""
"curl -X GET http://localhost:8080/persons/{uuid-1}/ChildrenHandling/{uuid-2} "
"\\\n"
"    -H 'content-type: application/json' \\\n"
"    -H 'accept: application/json'\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:332
#, fuzzy
msgid ""
"You can complete this person evaluation process instance by calling the same "
"endpoint but with POST, replace `uuids` with the values taken from the "
"responses (`uuid-1` is the process instance id and `uuid-2` is the task "
"instance id)."
msgstr ""
"同じエンドポイントを呼び出して、 `uuids` をレスポンスから取得した値( `uuid-1` はプロセスインスタンス ID、 `uuid-2` "
"はタスクインスタンス ID)で置き換えて、この人物評価プロセスインスタンスを完成させることができます。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:339
#, no-wrap
msgid ""
"curl -X POST http://localhost:8080/persons/{uuid-1}/ChildrenHandling/{uuid-"
"2} \\\n"
"    -H 'content-type: application/json' \\\n"
"    -H 'accept: application/json' \\\n"
"    -d '{}'\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kogito.adoc:341
#, no-wrap, fuzzy
msgid "Enabling persistence"
msgstr "永続性を有効にする"

#. type: Plain text
#: upstream/_guides/kogito.adoc:346
#, fuzzy
msgid ""
"Since 0.3.0 of Kogito, there is an option to enable persistence to preserve "
"process instance state across application restarts. That supports long "
"running process instances that can be resumed at any point in time."
msgstr ""
"Kogito の 0.3.0 "
"以降、アプリケーションの再起動時にプロセスインスタンスの状態を保持するために永続性を有効にするオプションがあります。これにより、いつでも再開できる長時間稼働しているプロセスインスタンスをサポートします。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:351
#, fuzzy
msgid ""
"Kogito uses Infinispan as the persistence service so you need to have "
"Infinispan server installed and running.  Version of the Infinispan is "
"aligned with Quarkus BOM so make sure the right version is installed."
msgstr ""
"Kogitoでは、パーシステンスサービスとしてInfinispanを使用しているため、Infinispanサーバーがインストールされている必要があります。InfinispanのバージョンはQuarkusのBOMに合わせているので、正しいバージョンがインストールされていることを確認してください。"

#. type: Title ===
#: upstream/_guides/kogito.adoc:352
#, no-wrap, fuzzy
msgid "Add dependencies to project"
msgstr "プロジェクトに依存関係を追加する"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:365
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-infinispan-client</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"  <groupId>org.kie.kogito</groupId>\n"
"  <artifactId>infinispan-persistence-addon</artifactId>\n"
"  <version>${kogito.version}</version>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kogito.adoc:367
#, no-wrap, fuzzy
msgid "Configure connection with Infinispan server"
msgstr "Infinispanサーバーとの接続設定"

#. type: Plain text
#: upstream/_guides/kogito.adoc:370
#, fuzzy
msgid ""
"Add following into the src/main/resources/application.properties file "
"(create the file if it does not exist)"
msgstr ""
"src/main/resources/application.propertiesファイルに以下を追加します（存在しない場合は作成してください）。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:374
#, no-wrap
msgid "quarkus.infinispan-client.server-list=localhost:11222\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:377
#, fuzzy
msgid ""
"Adjust the host and port number according to your Infinispan server "
"installation."
msgstr "Infinispan サーバーのインストールに合わせて、ホストとポート番号を調整します。"

#. type: Title ===
#: upstream/_guides/kogito.adoc:378
#, no-wrap, fuzzy
msgid "Test with enabled persistence"
msgstr "永続性を有効にしたテスト"

#. type: Plain text
#: upstream/_guides/kogito.adoc:382
#, fuzzy
msgid ""
"After configuring persistence on the project level, you can test and verify "
"that the process instance state is preserved across application restarts."
msgstr ""
"プロジェクト レベルで永続性を設定した後、アプリケーションの再起動時にプロセス インスタンスの状態が保持されているかどうかをテストして確認できます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:384
#, fuzzy
msgid "start Infinispan server"
msgstr "インフィニスパンサーバーを起動する"

#. type: Plain text
#: upstream/_guides/kogito.adoc:385
#, fuzzy
msgid "build and run your project"
msgstr "プロジェクトを構築して実行する"

#. type: Plain text
#: upstream/_guides/kogito.adoc:386
#, fuzzy
msgid "execute non adult use case"
msgstr "非成人用ケースを実行する"

#. type: Plain text
#: upstream/_guides/kogito.adoc:396
#, fuzzy
msgid "You can also verify that there is active instance"
msgstr "アクティブなインスタンスがあることを確認することもできます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:405
#, fuzzy
msgid ""
"Restart your application while keeping Infinispan server up and running."
msgstr "Infinispan サーバーを稼働させている間にアプリケーションを再起動します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:407
#, fuzzy
msgid ""
"Check if you can see active instance which should have exactly the same id"
msgstr "全く同じ ID を持つアクティブなインスタンスが表示されているかどうかを確認します。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:417
#, fuzzy
msgid ""
"To learn more about persistence in Kogito visit https://github.com/kiegroup/"
"kogito-runtimes/wiki/Persistence[this page]"
msgstr ""
"小木戸のこだわりについて詳しく知りたい方はこちら link:https://github.com/kiegroup/kogito-runtimes/"
"wiki/Persistence[のページを]ご覧ください。"

#. type: Title ==
#: upstream/_guides/kogito.adoc:418
#, no-wrap, fuzzy
msgid "Using decision tables"
msgstr "意思決定テーブルの使用"

#. type: Plain text
#: upstream/_guides/kogito.adoc:422
#, fuzzy
msgid ""
"Kogito allows to define business rules as decision tables using the "
"Microsoft Excel file formats.  To be able to use such assets in your "
"application, an additional dependency is required:"
msgstr ""
"Kogitoでは、Microsoft "
"Excelファイルフォーマットを使用して、ビジネスルールを決定テーブルとして定義することができます。このようなアセットをアプリケーションで使用するには、追加の依存関係が必要です。"

#. type: delimited block -
#: upstream/_guides/kogito.adoc:429
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>org.kie.kogito</groupId>\n"
"    <artifactId>drools-decisiontables</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kogito.adoc:432
#, fuzzy
msgid ""
"Once the dependency is added to the project, decision tables in `xls` or "
"`xlsx` format can be properly handled."
msgstr "依存関係がプロジェクトに追加されると、 `xls` や `xlsx` 形式の決定表を適切に扱うことができます。"

#. type: Plain text
#: upstream/_guides/kogito.adoc:436
#, fuzzy
msgid "https://kogito.kie.org[Kogito Website]"
msgstr "link:https://kogito.kie.org[こぎとホームページ]"

#. type: Plain text
#: upstream/_guides/kogito.adoc:436
#, fuzzy
msgid ""
"https://docs.jboss.org/kogito/release/latest/html_single[Kogito "
"Documentation]"
msgstr ""
"link:https://docs.jboss.org/kogito/release/latest/html_single[こぎとドキュメント]"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/jms.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using JMS"
msgstr "Quarkus - JMSの使用"

#. type: Plain text
#: upstream/_guides/jms.adoc:13
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can use JMS messaging "
"via the Apache Qpid JMS AMQP client, or alternatively the Apache ActiveMQ "
"Artemis JMS client."
msgstr ""
"このガイドでは、QuarkusアプリケーションがApache Qpid JMS AMQPクライアント、またはApache ActiveMQ "
"Artemis JMSクライアントを介してJMSメッセージングを使用する方法を説明します。"

#. type: Plain text
#: upstream/_guides/jms.adoc:25
#, fuzzy
msgid "A running Artemis server, or Docker to start one"
msgstr "稼働中のArtemisサーバー、またはDockerで起動するもの"

#. type: Plain text
#: upstream/_guides/jms.adoc:26
#, fuzzy
msgid "GraalVM, or Docker, installed if you want to run in native mode."
msgstr "ネイティブモードで実行したい場合は、GraalVM、またはDockerをインストールします。"

#. type: Plain text
#: upstream/_guides/jms.adoc:33
#, fuzzy
msgid ""
"In this guide, we are going to generate (random) prices in one component.  "
"These prices are written to a queue (`prices`) using a JMS client.  Another "
"component reads from the `prices` queue and stores the latest price.  The "
"data can be fetched from a browser using a fetch button from a JAX-RS "
"resource."
msgstr ""
"このガイドでは、1つのコンポーネントに(ランダムな)価格を生成します。これらの価格は、JMS クライアントを使用してキュー ( `prices`) "
"に書き込まれます。別のコンポーネントが `prices` のキューから読み込み、最新の価格を格納します。データは、JAX-"
"RSリソースからフェッチボタンを使用してブラウザから取得することができます。"

#. type: Plain text
#: upstream/_guides/jms.adoc:38
#, fuzzy
msgid ""
"The guide can be used either via the Apache Qpid JMS AMQP client as detailed "
"immediately below, or alternatively with the Apache ActiveMQ Artemis JMS "
"client given some different configuration as <<artemis-jms, detailed later>>."
""
msgstr ""
"このガイドは、以下のように Apache Qpid JMS AMQP クライアントを使って使うこともできますし、 link:#artemis-"
"jms[後ほど詳しく説明する]ように、Apache ActiveMQ Artemis JMS クライアントを使って使うこともできます。"

#. type: Title ==
#: upstream/_guides/jms.adoc:40
#, no-wrap, fuzzy
msgid "Qpid JMS - AMQP"
msgstr "Qpid JMS - AMQP"

#. type: Plain text
#: upstream/_guides/jms.adoc:47
#, fuzzy
msgid ""
"In the detailed steps below we will use the https://qpid.apache.org/"
"components/jms/[Apache Qpid JMS] client via the https://github.com/amqphub/"
"quarkus-qpid-jms/[Quarkus Qpid JMS extension]. Qpid JMS uses the AMQP 1.0 "
"ISO standard as its wire protocol, allowing it to be used with a variety of "
"AMQP 1.0 servers and services such as ActiveMQ Artemis, ActiveMQ 5, Qpid "
"Broker-J, Qpid Dispatch router, Azure Service Bus, and more."
msgstr ""
"以下の詳細な手順では、 link:https://github.com/amqphub/quarkus-qpid-jms/[Quarkus Qpid "
"JMS拡張機能を]使用して link:https://qpid.apache.org/components/jms/[Apache Qpid "
"JMS]クライアントを使用します。Qpid JMSは、ワイヤプロトコルとしてAMQP 1.0 ISO標準を使用しているため、ActiveMQ "
"Artemis、ActiveMQ 5、Qpid Broker-J、Qpid Dispatchルーター、Azure Service "
"Busなど、さまざまなAMQP 1.0サーバーやサービスで使用することができます。"

#. type: Plain text
#: upstream/_guides/jms.adoc:55
#, fuzzy
msgid ""
"Clone the Git repository: `git clone https://github.com/amqphub/quarkus-qpid-"
"jms-quickstart.git`, or download an https://github.com/amqphub/quarkus-qpid-"
"jms-quickstart/archive/master.zip[archive]."
msgstr ""
"Git リポジトリをクローンします。 `git clone &lt;a href=\"https://github.com/amqphub/"
"quarkus-qpid-jms-quickstart.git\" class=\"bare\"&gt;https://github.com/"
"amqphub/quarkus-qpid-jms-quickstart.git&lt;/a&gt;`または link:https://github."
"com/amqphub/quarkus-qpid-jms-quickstart/archive/master.zip[アーカイブ]をダウンロードします。"

#. type: Plain text
#: upstream/_guides/jms.adoc:57
#, fuzzy
msgid ""
"The solution is located in the `jms-quickstart` {quickstarts-tree-url}/jms-"
"quickstart[directory]."
msgstr ""
"ソリューションは `jms-quickstart` {quickstarts-tree-url}/jms-quickstart[directory] "
"にあります。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:71
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=jms-quickstart \\\n"
"    -Dextensions=\"qpid-jms\"\n"
"cd jms-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:74
#, fuzzy
msgid ""
"This command generates a Maven project, with its pom.xml importing the "
"quarkus-qpid-jms extension:"
msgstr "このコマンドは、quarkus-qpid-jms拡張機能をインポートしたpom.xmlを持つMavenプロジェクトを生成します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:80
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>org.amqphub.quarkus</groupId>\n"
"    <artifactId>quarkus-qpid-jms</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/jms.adoc:83
#, no-wrap, fuzzy
msgid "Starting the broker"
msgstr "ブローカーの開始"

#. type: Plain text
#: upstream/_guides/jms.adoc:87
#, fuzzy
msgid ""
"Then, we need an AMQP broker. In this case we will use an ActiveMQ Artemis "
"server.  You can follow the instructions from the https://activemq.apache."
"org/components/artemis/[Apache Artemis web site] or start a broker via "
"docker:"
msgstr ""
"次に、AMQPブローカーが必要です。この場合はActiveMQ Artemisサーバを使用します。 link:https://activemq."
"apache.org/components/artemis/[Apache "
"ArtemisのWebサイト]の指示に従うか、docker経由でブローカーを起動します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:91
#, no-wrap
msgid ""
"docker run -it --rm -p 8161:8161 -p 61616:61616 -p 5672:5672 -e "
"ARTEMIS_USERNAME=quarkus -e ARTEMIS_PASSWORD=quarkus vromero/activemq-"
"artemis:2.11.0-alpine\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/jms.adoc:93
#, no-wrap, fuzzy
msgid "The price producer"
msgstr "価格の生産者"

#. type: Plain text
#: upstream/_guides/jms.adoc:96
#, fuzzy
msgid ""
"Create the `src/main/java/org/acme/jms/PriceProducer.java` file, with the "
"following content:"
msgstr "以下の内容の `src/main/java/org/acme/jms/PriceProducer.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:100 upstream/_guides/jms.adoc:153
#: upstream/_guides/jms.adoc:219
#, no-wrap
msgid "package org.acme.jms;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:105
#, no-wrap
msgid ""
"import java.util.Random;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.ScheduledExecutorService;\n"
"import java.util.concurrent.TimeUnit;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:112
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
"import javax.inject.Inject;\n"
"import javax.jms.ConnectionFactory;\n"
"import javax.jms.JMSContext;\n"
"import javax.jms.Session;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:121
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random prices every 5 seconds and sending them to the "
"prices JMS queue.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceProducer implements Runnable {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:124 upstream/_guides/jms.adoc:178
#, no-wrap
msgid "    @Inject\n"
"    ConnectionFactory connectionFactory;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:127
#, no-wrap
msgid ""
"    private final Random random = new Random();\n"
"    private final ScheduledExecutorService scheduler = Executors."
"newSingleThreadScheduledExecutor();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:131
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent ev) {\n"
"        scheduler.scheduleWithFixedDelay(this, 0L, 5L, TimeUnit.SECONDS);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:135 upstream/_guides/jms.adoc:194
#, no-wrap
msgid ""
"    void onStop(@Observes ShutdownEvent ev) {\n"
"        scheduler.shutdown();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:143
#, no-wrap
msgid ""
"    @Override\n"
"    public void run() {\n"
"        try (JMSContext context = connectionFactory.createContext(Session."
"AUTO_ACKNOWLEDGE)) {\n"
"            context.createProducer().send(context.createQueue(\"prices\"), "
"Integer.toString(random.nextInt(100)));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/jms.adoc:145
#, no-wrap, fuzzy
msgid "The price consumer"
msgstr "価格の消費者"

#. type: Plain text
#: upstream/_guides/jms.adoc:149
#, fuzzy
msgid ""
"The price consumer reads the prices from JMS, and stores the last one.  "
"Create the `src/main/java/org/acme/jms/PriceConsumer.java` file with the "
"following content:"
msgstr ""
"価格消費者はJMSから価格を読み取り、最後の1つを保存します。以下の内容で `src/main/java/org/acme/jms/"
"PriceConsumer.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:156
#, no-wrap
msgid ""
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:166
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.enterprise.event.Observes;\n"
"import javax.inject.Inject;\n"
"import javax.jms.ConnectionFactory;\n"
"import javax.jms.JMSConsumer;\n"
"import javax.jms.JMSContext;\n"
"import javax.jms.JMSException;\n"
"import javax.jms.Message;\n"
"import javax.jms.Session;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:175
#, no-wrap
msgid ""
"/**\n"
" * A bean consuming prices from the JMS queue.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConsumer implements Runnable {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:180
#, no-wrap
msgid ""
"    private final ExecutorService scheduler = Executors."
"newSingleThreadExecutor();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:182
#, no-wrap
msgid "    private volatile String lastPrice;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:186
#, no-wrap
msgid "    public String getLastPrice() {\n"
"        return lastPrice;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:190
#, no-wrap
msgid ""
"    void onStart(@Observes StartupEvent ev) {\n"
"        scheduler.submit(this);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:209
#, no-wrap
msgid ""
"    @Override\n"
"    public void run() {\n"
"        try (JMSContext context = connectionFactory.createContext(Session."
"AUTO_ACKNOWLEDGE)) {\n"
"            JMSConsumer consumer = context.createConsumer(context."
"createQueue(\"prices\"));\n"
"            while (true) {\n"
"                Message message = consumer.receive();\n"
"                if (message == null) return;\n"
"                lastPrice = message.getBody(String.class);\n"
"            }\n"
"        } catch (JMSException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:215
#, fuzzy
msgid ""
"Finally, let's create a simple JAX-RS resource to show the last price.  "
"Create the `src/main/java/org/acme/jms/PriceResource.java` file with the "
"following content:"
msgstr ""
"最後に、前回の価格を表示するための簡単なJAX-RSリソースを作成してみましょう。 `src/main/java/org/acme/jms/"
"PriceResource.java` ファイルを以下の内容で作成します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:231
#, no-wrap
msgid ""
"/**\n"
" * A simple resource showing the last price.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:234
#, no-wrap
msgid "    @Inject\n"
"    PriceConsumer consumer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:242
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"last\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String last() {\n"
"        return consumer.getLastPrice();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/jms.adoc:282
#, no-wrap
msgid ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\"><button id=\"fetch\">Fetch</button>The last price "
"is <strong><span id=\"content\">N/A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script>\n"
"    document.getElementById(\"fetch\").addEventListener(\"click\", "
"function() {\n"
"        fetch(\"/prices/last\").then(function (response) {\n"
"            response.text().then(function (text) {\n"
"                document.getElementById(\"content\").textContent = text;\n"
"            })\n"
"        })\n"
"    })\n"
"</script>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:285
#, fuzzy
msgid "Nothing spectacular here. On each fetch, it updates the page."
msgstr "目を見張るようなものは何もありません。フェッチするたびにページが更新されます。"

#. type: Title ===
#: upstream/_guides/jms.adoc:286
#, no-wrap, fuzzy
msgid "Configure the Qpid JMS properties"
msgstr "Qpid JMSのプロパティを設定する"

#. type: Plain text
#: upstream/_guides/jms.adoc:290
#, fuzzy
msgid ""
"We need to configure the Qpid JMS properties used by the extension when "
"injecting the ConnectionFactory."
msgstr "ConnectionFactoryを注入する際に拡張機能で使用するQpid JMSプロパティを設定する必要があります。"

#. type: Plain text
#: upstream/_guides/jms.adoc:292
#, fuzzy
msgid "This is done in the `src/main/resources/application.properties` file."
msgstr "これは、 `src/main/resources/application.properties` ファイルで行います。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:299
#, no-wrap
msgid ""
"# Configures the Qpid JMS properties.\n"
"quarkus.qpid-jms.url=amqp://localhost:5672\n"
"quarkus.qpid-jms.username=quarkus\n"
"quarkus.qpid-jms.password=quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:302
#, fuzzy
msgid ""
"More detail about the configuration are available in the https://github.com/"
"amqphub/quarkus-qpid-jms#configuration[Quarkus Qpid JMS] documentation."
msgstr ""
"設定の詳細については、 link:https://github.com/amqphub/quarkus-qpid-"
"jms#configuration[Quarkus Qpid JMSの]ドキュメントを参照してください。"

#. type: Plain text
#: upstream/_guides/jms.adoc:308
#, fuzzy
msgid ""
"If you followed the instructions, you should have the Artemis server running."
"  Then, you just need to run the application using:"
msgstr "指示に従えば、Artemis サーバが起動しているはずです。あとは、アプリケーションを使用して実行するだけです。"

#. type: Plain text
#: upstream/_guides/jms.adoc:326
#, fuzzy
msgid ""
"Or, if you don't have GraalVM installed, you can instead use Docker to build "
"the native executable using:"
msgstr "あるいは、GraalVMをインストールしていない場合は、代わりにDockerを使ってネイティブの実行ファイルをビルドすることもできます。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:329
#, no-wrap
msgid "./mvnw package -Pnative -Dquarkus.native.container-build=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:332
#, fuzzy
msgid "and then run with:"
msgstr "と実行します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:336
#, no-wrap
msgid "./target/jms-quickstart-1.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:341
#, fuzzy
msgid "'''"
msgstr ""

#. type: Title ==
#: upstream/_guides/jms.adoc:344
#, no-wrap, fuzzy
msgid "Artemis JMS"
msgstr "アルテミスＪＭＳ"

#. type: Plain text
#: upstream/_guides/jms.adoc:352
#, fuzzy
msgid ""
"The above steps detailed using the Qpid JMS AMQP client, however the guide "
"can also be used with the Artemis JMS client. Many of the individual steps "
"are exactly as previously <<qpid-jms-amqp, detailed above for Qpid JMS>>. "
"The individual component code is the same.  The only differences are in the "
"dependency for the initial project creation, and the configuration "
"properties used. These changes are detailed below and should be substituted "
"for the equivalent step during the sequence above."
msgstr ""
"上記の手順はQpid JMS AMQPクライアントを使用して詳細に説明していますが、このガイドはArtemis "
"JMSクライアントでも使用することができます。個々のステップの多くは、 link:#qpid-jms-amqp[Qpid "
"JMSの上記の詳細]と全く同じです。個々のコンポーネントコードも同じです。唯一の違いは、最初のプロジェクト作成のための依存関係と、使用される設定プロパティです。これらの変更点は以下に詳述されており、上記のシーケンス中の同等のステップで代用する必要があります。"

#. type: Plain text
#: upstream/_guides/jms.adoc:356
#, fuzzy
msgid "You can go right to the completed example."
msgstr "完成した例に進むことができます。"

#. type: Plain text
#: upstream/_guides/jms.adoc:360
#, fuzzy
msgid ""
"The Artemis JMS solution is located in the `jms-quickstart` {quickstarts-"
"tree-url}/jms-quickstart[directory]."
msgstr ""
"Artemis JMS ソリューションは `jms-quickstart` {quickstarts-tree-url}/jms-"
"quickstart[directory] にあります。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:372
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=jms-quickstart \\\n"
"    -Dextensions=\"artemis-jms\"\n"
"cd jms-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:375
#, fuzzy
msgid ""
"This creates a Maven project, with its pom.xml importing the quarkus-artemis-"
"jms extension:"
msgstr "これは、quarkus-artemis-jms拡張機能をインポートしたpom.xmlを持つMavenプロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:381
#, no-wrap
msgid ""
"<dependency>\n"
"  <groupId>io.quarkus</groupId>\n"
"  <artifactId>quarkus-artemis-jms</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:386
#, fuzzy
msgid ""
"With the project created, you can resume from <<starting-the-broker>> in the "
"detailed steps above and proceed until configuring the `application."
"properties` file, when you should use the Artemis configuration below "
"instead."
msgstr ""
"プロジェクトが作成された状態で、上記の詳細な手順で link:#starting-the-broker[[starting-the-"
"broker]]から再開し、代わりに以下のArtemisの設定を使用する必要がある場合は、 `application.properties` "
"ファイルを設定するまで進めることができます。"

#. type: Title ===
#: upstream/_guides/jms.adoc:387
#, no-wrap, fuzzy
msgid "Configure the Artemis properties"
msgstr "Artemisのプロパティを設定する"

#. type: Plain text
#: upstream/_guides/jms.adoc:391
#, fuzzy
msgid ""
"We need to configure the Artemis connection properties.  This is done in the "
"`src/main/resources/application.properties` file."
msgstr ""
"Artemis の接続プロパティを設定する必要があります。これは `src/main/resources/application.properties` "
"ファイルで行います。"

#. type: delimited block -
#: upstream/_guides/jms.adoc:398
#, no-wrap
msgid ""
"# Configures the Artemis properties.\n"
"quarkus.artemis.url=tcp://localhost:61616\n"
"quarkus.artemis.username=quarkus\n"
"quarkus.artemis.password=quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/jms.adoc:401
#, fuzzy
msgid ""
"With the Artemis properties configured, you can resume the steps above from "
"<<get-it-running>>."
msgstr ""
"Artemisのプロパティを設定した状態で、 link:#get-it-running[[get-it-"
"runing]]から上記の手順を再開することができます。"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kubernetes-client.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Kubernetes Client"
msgstr "Quarkus - Kubernetesクライアント"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:13
#, fuzzy
msgid ""
"Quarkus includes the `kubernetes-client` extension which enables the use of "
"the https://github.com/fabric8io/kubernetes-client[Fabric8 Kubernetes "
"Client] in native mode while also making it easier to work with."
msgstr ""
"Quarkusには、 link:https://github.com/fabric8io/kubernetes-client[Fabric8 "
"Kubernetesクライアントを]ネイティブモードで使用できるようにする `kubernetes-client` 拡張機能が含まれています。"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:18
#, fuzzy
msgid ""
"Having a Kubernetes Client extension in Quarkus is very useful in order to "
"unlock the power of Kubernetes Operators.  Kubernetes Operators are quickly "
"emerging as a new class of Cloud Native applications.  These applications "
"essentially watch the Kubernetes API and react to changes on various "
"resources and can be used to manage the lifecycle of all kinds of complex "
"systems like databases, messaging systems and much much more.  Being able to "
"write such operators in Java with the very low footprint that native images "
"provide is a great match."
msgstr ""
"Kubernetes "
"Operatorsのパワーを引き出すためには、QuarkusにKubernetesクライアント拡張機能があると非常に便利です。Kubernetes "
"Operatorsは、クラウドネイティブアプリケーションの新しいクラスとして急速に台頭してきています。これらのアプリケーションは、基本的にKubernetes "
"APIを監視し、様々なリソースの変更に反応し、データベースやメッセージングシステムなど、あらゆる種類の複雑なシステムのライフサイクルを管理するために使用することができます。ネイティブイメージが提供する非常に低いフットプリントで、このような演算子をJavaで書くことができるということは、非常にマッチしています。"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:23
#, fuzzy
msgid ""
"Once you have your Quarkus project configured you can add the `kubernetes-"
"client` extension to your project by running the following command in your "
"project base directory."
msgstr ""
"Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリで次のコマンドを実行して、 `kubernetes-client` "
"拡張機能をプロジェクトに追加できます。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:27
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"kubernetes-client\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:37
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-kubernetes-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kubernetes-client.adoc:39
#, no-wrap, fuzzy
msgid "Usage"
msgstr "使用方法"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:43
#, fuzzy
msgid ""
"Quarkus configures a Bean of type `KubernetesClient` which can be injected "
"into application code using the well known CDI methods.  This client can be "
"configured using various properties as can be seen in the following example:"
msgstr ""
"Quarkusは、よく知られたCDIメソッドを使用してアプリケーションコードに注入できる `KubernetesClient` "
"タイプのBeanを設定します。このクライアントは、以下の例にあるように、さまざまなプロパティを使用して設定することができます。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:48
#, no-wrap
msgid ""
"quarkus.kubernetes-client.trust-certs=false\n"
"quarkus.kubernetes-client.namespace=default\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:51
#, fuzzy
msgid ""
"Note that the full list of properties is available in the https://github.com/"
"quarkusio/quarkus/blob/master/extensions/kubernetes-client/runtime-internal/"
"src/main/java/io/quarkus/kubernetes/client/runtime/"
"KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] class."
msgstr ""
"プロパティの完全なリストは、K link:https://github.com/quarkusio/quarkus/blob/master/"
"extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/"
"kubernetes/client/runtime/KubernetesClientBuildConfig."
"java[ubernetesClientBuildConfig]クラスで確認できます。"

#. type: Title ===
#: upstream/_guides/kubernetes-client.adoc:52
#, no-wrap, fuzzy
msgid "Overriding"
msgstr "オーバーライド"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:56
#, fuzzy
msgid ""
"The extension also allows application code to override either of `io.fabric8."
"kubernetes.client.Config` or `io.fabric8.kubernetes.client.KubernetesClient` "
"which are normally provided by the extension by simply declaring custom "
"versions of those beans."
msgstr ""
"また、この拡張機能では、アプリケーションコードは、単にそれらのビーンズのカスタムバージョンを宣言することで、通常は拡張機能によって提供される `io."
"fabric8.kubernetes.client.Config` や `io.fabric8.kubernetes.client."
"KubernetesClient` のいずれかをオーバーライドすることができます。"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:58
#, fuzzy
msgid "An example of this can be seen in the following snippet:"
msgstr "この例は、次のスニペットに見ることができます。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:63
#, no-wrap
msgid "@Singleton\n"
"public class KubernetesClientProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:70
#, no-wrap
msgid ""
"    @Produces\n"
"    public KubernetesClient kubernetesClient() {\n"
"        // here you would create a custom client\n"
"        return new DefaultKubernetesClient();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:77
#, fuzzy
msgid ""
"To make testing against a mock Kubernetes API extremely simple, Quarkus "
"provides the `KubernetesMockServerTestResource` which automatically launches "
"a mock of the Kubernetes API server and sets the proper environment "
"variables needed so that the Kubernetes Client configures itself to use said "
"mock.  Tests can inject the mock and set it up in any way necessary for the "
"particular testing using the `@MockServer` annotation."
msgstr ""
"モックのKubernetes APIに対するテストを非常に簡単にするために、Quarkusでは、Kubernetes "
"APIサーバーのモックを自動的に起動し、Kubernetesクライアントがそのモックを使用するように設定するために必要な適切な環境変数を設定する "
"`KubernetesMockServerTestResource` を提供しています。テストは、 `@MockServer` "
"アノテーションを使用して、特定のテストに必要な方法でモックを注入し、設定することができます。"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:79
#, fuzzy
msgid "Let's assume we have a REST endpoint defined like so:"
msgstr "このようにRESTエンドポイントが定義されているとします。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:84
#, no-wrap
msgid "@Path(\"/pod\")\n"
"public class Pods {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:86
#, no-wrap
msgid "    private final KubernetesClient kubernetesClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:90
#, no-wrap
msgid ""
"    public Pods(KubernetesClient kubernetesClient) {\n"
"        this.kubernetesClient = kubernetesClient;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:97
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{namespace}\")\n"
"    public List<Pod> pods(@PathParam(\"namespace\") String namespace) {\n"
"        return kubernetesClient.pods().inNamespace(namespace).list()."
"getItems();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:100
#, fuzzy
msgid "We could write a test for this endpoint very easily like so:"
msgstr "このエンドポイントのテストはこんな感じで簡単に書けます。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:106
#: upstream/_guides/kubernetes-client.adoc:163
#, no-wrap
msgid ""
"@QuarkusTestResource(KubernetesMockServerTestResource.class)\n"
"@QuarkusTest\n"
"public class KubernetesClientTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:109
#, no-wrap
msgid "    @MockServer\n"
"    KubernetesMockServer mockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:114
#, no-wrap
msgid ""
"    @BeforeEach\n"
"    public void before() {\n"
"        final Pod pod1 = new PodBuilder().withNewMetadata()."
"withName(\"pod1\").withNamespace(\"test\").and().build();\n"
"        final Pod pod2 = new PodBuilder().withNewMetadata()."
"withName(\"pod2\").withNamespace(\"test\").and().build();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:121
#, no-wrap
msgid ""
"        mockServer.expect().get().withPath(\"/api/v1/namespaces/test/pods\")\n"
"                .andReturn(200,\n"
"                        new PodListBuilder().withNewMetadata()."
"withResourceVersion(\"1\").endMetadata().withItems(pod1, pod2)\n"
"                                .build())\n"
"                .always();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:127
#, no-wrap
msgid ""
"    @Test\n"
"    public void testInteractionWithAPIServer() {\n"
"        RestAssured.when().get(\"/pod/test\").then()\n"
"                .body(\"size()\", is(2));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:132
#, fuzzy
msgid ""
"Note that to take advantage of these features, the `quarkus-test-kubernetes-"
"client` dependency needs to be added, for example like so:"
msgstr ""
"これらの機能を利用するには、例えば次のように `quarkus-test-kubernetes-client` "
"依存関係を追加する必要があることに注意してください。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:140
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-kubernetes-client</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:143
#, fuzzy
msgid ""
"You can create a `CustomKubernetesMockServerTestResource.java` to ensure all "
"your `@QuarkusTest` enabled test classes share the same mock server setup:"
msgstr ""
"`CustomKubernetesMockServerTestResource.java` を作成して、 `@QuarkusTest` "
"を有効にしたすべてのテストクラスが同じモックサーバー設定を共有できるようにすることができます。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:147
#, no-wrap
msgid ""
"public class CustomKubernetesMockServerTestResource extends "
"KubernetesMockServerTestResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:155
#, no-wrap
msgid ""
"    @Override\n"
"    public void configureMockServer(KubernetesMockServer mockServer) {\n"
"        mockServer.expect().get().withPath(\"/api/v1/namespaces/test/pods\")\n"
"                .andReturn(200, new PodList())\n"
"                .always();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:158
#, fuzzy
msgid "and use this in your other test classes as follows:"
msgstr "で、これを次のように他のテストクラスで使用します。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:166
#, no-wrap
msgid "    //tests will now use the configured server...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:171
#, fuzzy
msgid ""
"Furthermore, to get a mock server that replies with empty lists by default "
"(instead of getting 404 responses from the Kubernetes API), you can use the "
"`EmptyDefaultKubernetesMockServerTestResource.class` instead of "
"`KubernetesMockServerTestResource.class`."
msgstr ""
"さらに、デフォルトで空のリストで応答するモックサーバーを取得するには（Kubernetes APIから404の応答を取得するのではなく）、 "
"`KubernetesMockServerTestResource.class` の代わりに "
"`EmptyDefaultKubernetesMockServerTestResource.class`."

#. type: Title ==
#: upstream/_guides/kubernetes-client.adoc:173
#, no-wrap, fuzzy
msgid "Note on implementing the Watcher interface"
msgstr "ウォッチャーインターフェイスの実装についての注意点"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:178
#, fuzzy
msgid ""
"Due to the restrictions imposed by GraalVM, extra care needs to be taken "
"when implementing an `io.fabric8.kubernetes.client.Watcher` if the "
"application is intended to work in native mode.  Essentially every `Watcher` "
"implementation needs to specify the Kubernetes model class that it handles "
"via the ``Watcher``'s generic type at class definition time.  To better "
"understand this, suppose we want to watch for changes to Kubernetes `Pod` "
"resources. There are a couple ways to write such a `Watcher` that are "
"guaranteed to work in native:"
msgstr ""
"GraalVMによって課せられた制限のため、アプリケーションがネイティブモードで動作することを意図している場合、 `io.fabric8."
"kubernetes.client.Watcher` を実装する際には特に注意が必要です。基本的にすべての `Watcher` の実装は、クラス定義時に "
"`Watcher` の汎用型を介して扱う Kubernetes モデルクラスを指定する必要があります。これをよりよく理解するために、Kubernetes "
"`Pod` リソースの変更を監視したいとします。このような `Watcher` を書くには、ネイティブでの動作が保証されている方法がいくつかあります。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:186
#, no-wrap
msgid ""
"client.pods().watch(new Watcher<Pod>() {\n"
"    @Override\n"
"    public void eventReceived(Action action, Pod pod) {\n"
"        // do something\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:192
#, no-wrap
msgid ""
"    @Override\n"
"    public void onClose(KubernetesClientException e) {\n"
"        // do something\n"
"    }\n"
"});\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:195
#, fuzzy
msgid "or"
msgstr "或いは"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:203
#, no-wrap
msgid ""
"public class PodResourceWatcher implements Watcher<Pod> {\n"
"    @Override\n"
"    public void eventReceived(Action action, Pod pod) {\n"
"        // do something\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:209
#: upstream/_guides/kubernetes-client.adoc:250
#, no-wrap
msgid ""
"    @Override\n"
"    public void onClose(KubernetesClientException e) {\n"
"        // do something\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:214
#, no-wrap
msgid "client.pods().watch(new PodResourceWatcher());\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:217
#, fuzzy
msgid ""
"Note that defining the generic type via a class hierarchy similar to the "
"following example will also work correctly:"
msgstr "以下の例のようにクラス階層を介して汎用型を定義すると、正しく動作することに注意してください。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:222
#, no-wrap
msgid "public abstract class MyWatcher<S> implements Watcher<S> {\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:232
#, no-wrap
msgid ""
"client.pods().watch(new MyWatcher<Pod>() {\n"
"    @Override\n"
"    public void eventReceived(Action action, Pod pod) {\n"
"        // do something\n"
"    }\n"
"});\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:236
#, fuzzy
msgid ""
"The following example will **not** work in native mode because the generic "
"type of watcher cannot be determined by looking at the class and method "
"definitions thus making Quarkus unable to properly determine the Kubernetes "
"model class for which reflection registration is needed:"
msgstr ""
"以下の例では、クラスやメソッドの定義を見てウォッチャーの一般的なタイプを判断できないため、Quarkusは反射登録が必要なKubernetesモデルクラスを適切に判断できないため、ネイティブモードでは動作し "
"*ません*。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:244
#, no-wrap
msgid ""
"public class ResourceWatcher<T extends HasMetadata> implements Watcher<T> {\n"
"    @Override\n"
"    public void eventReceived(Action action, T resource) {\n"
"        // do something\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:252
#, no-wrap
msgid "client.pods().watch(new ResourceWatcher<Pod>());\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kubernetes-client.adoc:255
#, no-wrap, fuzzy
msgid "Access to the Kubernetes API"
msgstr "Kubernetes APIへのアクセス"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:259
#, fuzzy
msgid ""
"In many cases in order to access the Kubernetes API server a "
"`ServiceAccount`, `Role` and `RoleBinding` will be necessary.  An example "
"that allows listing all pods could look something like this:"
msgstr ""
"多くの場合、Kubernetes API サーバーにアクセスするには `ServiceAccount` 、 `Role` 、 `RoleBinding` "
"が必要になります。すべてのポッドを一覧表示する例は以下のようになります。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:268
#, no-wrap
msgid ""
"apiVersion: v1\n"
"kind: ServiceAccount\n"
"metadata:\n"
"  name: <applicationName>\n"
"  namespace: <namespace>\n"
"---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:278
#, no-wrap
msgid ""
"apiVersion: rbac.authorization.k8s.io/v1\n"
"kind: Role\n"
"metadata:\n"
"  name: <applicationName>\n"
"  namespace: <namespace>\n"
"rules:\n"
"  - apiGroups: [\"\"]\n"
"    resources: [\"pods\"]\n"
"    verbs: [\"list\"]\n"
"---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:292
#, no-wrap
msgid ""
"apiVersion: rbac.authorization.k8s.io/v1\n"
"kind: RoleBinding\n"
"metadata:\n"
"  name: <applicationName>\n"
"  namespace: <namespace>\n"
"roleRef:\n"
"  kind: Role\n"
"  name: <applicationName>\n"
"  apiGroup: rbac.authorization.k8s.io\n"
"subjects:\n"
"  - kind: ServiceAccount\n"
"    name: <applicationName>\n"
"    namespace: <namespace>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:296
#, fuzzy
msgid ""
"Replace `<applicationName>` and `<namespace>` with your values.  Have a look "
"at https://kubernetes.io/docs/tasks/configure-pod-container/configure-"
"service-account/[Configure Service Accounts for Pods] to get further "
"information."
msgstr ""
"`&amp;lt;applicationName&amp;gt;` と `&amp;lt;namespace&amp;gt;` "
"を値に置き換えてください。 link:https://kubernetes.io/docs/tasks/configure-pod-container/"
"configure-service-account/[ポッドのサービスアカウントの設定]を参照して、詳細な情報を入手してください。"

#. type: Title ==
#: upstream/_guides/kubernetes-client.adoc:297
#, no-wrap, fuzzy
msgid "OpenShift Client"
msgstr "OpenShiftクライアント"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:302
#, fuzzy
msgid ""
"If the targeted Kubernetes cluster is an OpenShift cluster, it is possible "
"to access it through the `openshift-client` extension, in a similar way. "
"This leverages the dedicated fabric8 openshift client, and provides access "
"to `OpenShift` proprietary objects (e.g. `Route`, `ProjectRequest`, "
"`BuildConfig` ...)"
msgstr ""
"対象となるKubernetesクラスタがOpenShiftクラスタであれば、同様の方法で、 `openshift-client` "
"拡張機能を利用してアクセスすることが可能です。これは専用の fabric8 openshift クライアントを利用し、 `OpenShift` "
"の専有オブジェクト（例： `Route`, `ProjectRequest`, `BuildConfig`...）へのアクセスを提供します。"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:305
#, fuzzy
msgid ""
"Note that the configuration properties are shared with the `kubernetes-"
"client` extension. In particular they have the same `quarkus.kubernetes-"
"client` prefix."
msgstr ""
"設定プロパティは `kubernetes-client` 拡張モジュールと共有されていることに注意してください。特に、これらは同じ `quarkus."
"kubernetes-client` プレフィックスを持っています。"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:307
#, fuzzy
msgid "Add the extension with:"
msgstr "で拡張子を追加します。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:311
#, no-wrap
msgid "./mvnw quarkus:add-extension -Dextensions=\"openshift-client\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:314
#, fuzzy
msgid ""
"Note that `openshift-client` extension has a dependency on the `kubernetes-"
"client` extension."
msgstr ""
"`openshift-client` 拡張モジュールは `kubernetes-client` 拡張モジュールに依存していることに注意してください。"

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:316
#, fuzzy
msgid ""
"To use the client, inject an `OpenShiftClient` instead of the "
"`KubernetesClient`:"
msgstr "クライアントを使用するには、 `KubernetesClient` の代わりに `OpenShiftClient` を注入します。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:321
#, no-wrap
msgid "@Inject\n"
"private OpenShiftClient openshiftClient;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:324
#, fuzzy
msgid ""
"If you need to override the default `OpenShiftClient`, provide a producer "
"such as:"
msgstr "デフォルトの `OpenShiftClient` を上書きする必要がある場合は、次のようなプロデューサーを指定してください。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:329
#, no-wrap
msgid "@Singleton\n"
"public class OpenShiftClientProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:336
#, no-wrap
msgid ""
"    @Produces\n"
"    public OpenShiftClient openshiftClient() {\n"
"        // here you would create a custom client\n"
"        return new DefaultOpenShiftClient();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:339
#, fuzzy
msgid "Mock support is also provided in a similar fashion:"
msgstr "モックサポートも同様の方法で提供されています。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:345
#, no-wrap
msgid ""
"@QuarkusTestResource(OpenShiftMockServerTestResource.class)\n"
"@QuarkusTest\n"
"public class OpenShiftClientTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:349
#, no-wrap
msgid "    @MockServer\n"
"    private OpenShiftMockServer mockServer;\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kubernetes-client.adoc:352
#, fuzzy
msgid ""
"To use this feature, you have to add a dependency on `quarkus-test-openshift-"
"client`:"
msgstr "この機能を使用するには、 `quarkus-test-openshift-client` に依存関係を追加する必要があります。"

#. type: delimited block -
#: upstream/_guides/kubernetes-client.adoc:360
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-openshift-client</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""
