# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-12-29 14:10+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka.adoc:6
#, no-wrap, fuzzy
msgid "Quarkus - Using Apache Kafka with Reactive Messaging"
msgstr "Quarkus - Apache Kafkaをリアクティブメッセージングで使用する"

#. type: Plain text
#: upstream/_guides/kafka.adoc:11
#, fuzzy
msgid ""
"This guide demonstrates how your Quarkus application can utilize "
"MicroProfile Reactive Messaging to interact with Apache Kafka."
msgstr ""
"このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを利用してApache "
"Kafkaと対話する方法を説明します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:12
#, no-wrap, fuzzy
msgid "Prerequisites"
msgstr "前提条件"

#. type: Plain text
#: upstream/_guides/kafka.adoc:15
#, fuzzy
msgid "To complete this guide, you need:"
msgstr "このガイドを完成させるには、以下のものが必要です。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:17
#, fuzzy
msgid "less than 15 minutes"
msgstr "15分以内"

#. type: Plain text
#: upstream/_guides/kafka.adoc:18
#, fuzzy
msgid "an IDE"
msgstr "アイディーイーイー"

#. type: Plain text
#: upstream/_guides/kafka.adoc:19
#, fuzzy
msgid "JDK 1.8+ installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 1.8+ がインストールされ、 `JAVA_HOME` が適切に設定されています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:20
#, fuzzy
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version} の場合"

#. type: Plain text
#: upstream/_guides/kafka.adoc:21
#, fuzzy
msgid ""
"A running Kafka cluster, or Docker Compose to start a development cluster"
msgstr "実行中のKafkaクラスタ、またはDocker Composeで開発クラスタを起動する"

#. type: Plain text
#: upstream/_guides/kafka.adoc:22
#, fuzzy
msgid "GraalVM installed if you want to run in native mode."
msgstr "ネイティブモードで動作させたい場合は、GraalVMをインストールします。"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka.adoc:23 upstream/_guides/kafka.adoc:31
#, no-wrap, fuzzy
msgid "Architecture"
msgstr "建築"

#. type: Plain text
#: upstream/_guides/kafka.adoc:30
#, fuzzy
msgid ""
"In this guide, we are going to generate (random) prices in one component.  "
"These prices are written in a Kafka topic (`prices`).  A second component "
"reads from the `prices` Kafka topic and apply some magic conversion to the "
"price.  The result is sent to an in-memory stream consumed by a JAX-RS "
"resource.  The data is sent to a browser using server-sent events."
msgstr ""
"このガイドでは、1 つのコンポーネントで (ランダムな) 価格を生成します。これらの価格は、Kafka トピック ( `prices`) "
"に書かれています。2 番目のコンポーネントは `prices` Kafka トピックから読み込み、価格に魔法のような変換を適用します。その結果は、JAX-"
"RSリソースによって消費されるインメモリストリームに送られます。データは、サーバーから送信されたイベントを使用してブラウザに送信されます。"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:31
#, no-wrap
msgid "kafka-guide-architecture.png"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:33
#, no-wrap, fuzzy
msgid "Solution"
msgstr "解決策"

#. type: Plain text
#: upstream/_guides/kafka.adoc:37
#, fuzzy
msgid ""
"We recommend that you follow the instructions in the next sections and "
"create the application step by step.  However, you can go right to the "
"completed example."
msgstr "次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:39
#, fuzzy
msgid ""
"Clone the Git repository: `git clone {quickstarts-clone-url}`, or download "
"an {quickstarts-archive-url}[archive]."
msgstr ""
"Git リポジトリをクローンします: `git clone {quickstarts-clone-url}` 、または {quickstarts-"
"archive-url}[archive] をダウンロードしてください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:41
#, fuzzy
msgid ""
"The solution is located in the `kafka-quickstart` {quickstarts-tree-url}/"
"kafka-quickstart[directory]."
msgstr ""
"解決策は `kafka-quickstart` {quickstarts-tree-url}/kafka-quickstart[directory] "
"にあります。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:42
#, no-wrap, fuzzy
msgid "Creating the Maven Project"
msgstr "Mavenプロジェクトの作成"

#. type: Plain text
#: upstream/_guides/kafka.adoc:45
#, fuzzy
msgid ""
"First, we need a new project. Create a new project with the following "
"command:"
msgstr "まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:53
#, no-wrap
msgid ""
"mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n"
"    -DprojectGroupId=org.acme \\\n"
"    -DprojectArtifactId=kafka-quickstart \\\n"
"    -Dextensions=\"smallrye-reactive-messaging-kafka\"\n"
"cd kafka-quickstart\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:56
#, fuzzy
msgid ""
"This command generates a Maven project, importing the Reactive Messaging and "
"Kafka connector extensions."
msgstr "このコマンドは、Reactive Messaging と Kafka コネクタ拡張をインポートして Maven プロジェクトを生成します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:59
#, fuzzy
msgid ""
"If you already have your Quarkus project configured, you can add the "
"`smallrye-reactive-messaging-kafka` extension to your project by running the "
"following command in your project base directory:"
msgstr ""
"すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに "
"`smallrye-reactive-messaging-kafka` エクステンションを追加することができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:63
#, no-wrap
msgid ""
"./mvnw quarkus:add-extension -Dextensions=\"smallrye-reactive-messaging-"
"kafka\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:66
#, fuzzy
msgid "This will add the following to your `pom.xml`:"
msgstr "これにより、 `pom.xml`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:73
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:75
#, no-wrap, fuzzy
msgid "Starting Kafka"
msgstr "カフカの起動"

#. type: Plain text
#: upstream/_guides/kafka.adoc:79
#, fuzzy
msgid ""
"Then, we need a Kafka cluster.  You can follow the instructions from the "
"https://kafka.apache.org/quickstart[Apache Kafka web site] or create a "
"`docker-compose.yaml` file with the following content:"
msgstr ""
"次に、Kafkaクラスタが必要です。 link:https://kafka.apache.org/quickstart[Apache Kafka の "
"Web サイト]の指示に従うか、以下の内容の `docker-compose.yaml` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:83
#, no-wrap
msgid "version: '2'\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:85
#, no-wrap
msgid "services:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:96
#, no-wrap
msgid ""
"  zookeeper:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/zookeeper-server-start.sh config/zookeeper.properties\"\n"
"    ]\n"
"    ports:\n"
"      - \"2181:2181\"\n"
"    environment:\n"
"      LOG_DIR: /tmp/logs\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:112
#, no-wrap
msgid ""
"  kafka:\n"
"    image: strimzi/kafka:0.19.0-kafka-2.5.0\n"
"    command: [\n"
"      \"sh\", \"-c\",\n"
"      \"bin/kafka-server-start.sh config/server.properties --override "
"listeners=$${KAFKA_LISTENERS} --override advertised.listeners="
"$${KAFKA_ADVERTISED_LISTENERS} --override zookeeper.connect="
"$${KAFKA_ZOOKEEPER_CONNECT}\"\n"
"    ]\n"
"    depends_on:\n"
"      - zookeeper\n"
"    ports:\n"
"      - \"9092:9092\"\n"
"    environment:\n"
"      LOG_DIR: \"/tmp/logs\"\n"
"      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n"
"      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092\n"
"      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:115
#, fuzzy
msgid "Once created, run `docker-compose up`."
msgstr "作成したら、 `docker-compose up` を実行します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:117
#, fuzzy
msgid "This is a development cluster, do not use in production."
msgstr "これは開発クラスタであり、生産では使用しないでください。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:118
#, no-wrap, fuzzy
msgid "The price generator"
msgstr "価格発生装置"

#. type: Plain text
#: upstream/_guides/kafka.adoc:121
#, fuzzy
msgid ""
"Create the `src/main/java/org/acme/kafka/PriceGenerator.java` file, with the "
"following content:"
msgstr "以下の内容の `src/main/java/org/acme/kafka/PriceGenerator.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:125 upstream/_guides/kafka.adoc:166
#: upstream/_guides/kafka.adoc:206
#, no-wrap
msgid "package org.acme.kafka;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:128
#, no-wrap
msgid "import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:130 upstream/_guides/kafka.adoc:172
#: upstream/_guides/kafka.adoc:423
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:133
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:140
#, no-wrap
msgid ""
"/**\n"
" * A bean producing random prices every 5 seconds.\n"
" * The prices are written to a Kafka topic (prices). The Kafka configuration "
"is specified in the application configuration.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceGenerator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:142
#, no-wrap
msgid "    private Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:149
#, no-wrap
msgid ""
"    @Outgoing(\"generated-price\")                        // <1>\n"
"    public Multi<Integer> generate() {                  // <2>\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(5))\n"
"                .onOverflow().drop()\n"
"                .map(tick -> random.nextInt(100));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:151 upstream/_guides/kafka.adoc:190
#: upstream/_guides/kafka.adoc:442 upstream/_guides/kafka.adoc:612
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:153
#, fuzzy
msgid ""
"Instruct Reactive Messaging to dispatch the items from returned stream to "
"`generated-price`."
msgstr ""
"返されたストリームから `generated-price` にアイテムをディスパッチするように Reactive Messaging に指示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:154
#, fuzzy
msgid ""
"The method returns a Mutiny _stream_ (`Multi`) emitting a random _price_ "
"every 5 seconds."
msgstr "このメソッドは、5秒ごとにランダムな _価格を_放出する Mutiny _ストリーム_( `Multi`) を返します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:157
#, fuzzy
msgid ""
"The method returns a _Reactive Stream_. The generated items are sent to the "
"stream named `generated-price`.  This stream is mapped to Kafka using the "
"`application.properties` file that we will create soon."
msgstr ""
"このメソッドは、 _Reactive ストリーム_を返します。生成されたアイテムは `generated-price` "
"という名前のストリームに送られます。このストリームは、近日中に作成する `application.properties` ファイルを使用して Kafka "
"にマッピングされます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:158
#, no-wrap, fuzzy
msgid "The price converter"
msgstr "価格コンバーター"

#. type: Plain text
#: upstream/_guides/kafka.adoc:162
#, fuzzy
msgid ""
"The price converter reads the prices from Kafka, and transforms them.  "
"Create the `src/main/java/org/acme/kafka/PriceConverter.java` file with the "
"following content:"
msgstr ""
"価格コンバータは、カフカから価格を読み込んで変換します。以下の内容の `src/main/java/org/acme/kafka/"
"PriceConverter.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:170 upstream/_guides/kafka.adoc:421
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:179
#, no-wrap
msgid ""
"/**\n"
" * A bean consuming data from the \"prices\" Kafka topic and applying some "
"conversion.\n"
" * The result is pushed to the \"my-data-stream\" stream which is an in-"
"memory stream.\n"
" */\n"
"@ApplicationScoped\n"
"public class PriceConverter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:181 upstream/_guides/kafka.adoc:432
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:188
#, no-wrap
msgid ""
"    @Incoming(\"prices\")                                 // <1>\n"
"    @Outgoing(\"my-data-stream\")                         // <2>\n"
"    @Broadcast                                          // <3>\n"
"    public double process(int priceInUsd) {\n"
"        return priceInUsd * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:192
#, fuzzy
msgid "Indicates that the method consumes the items from the `prices` topic"
msgstr "メソッドが `prices` トピックのアイテムを消費することを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:193
#, fuzzy
msgid ""
"Indicates that the objects returned by the method are sent to the `my-data-"
"stream` stream"
msgstr "メソッドによって返されたオブジェクトが `my-data-stream` ストリームに送られることを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:194
#, fuzzy
msgid "Indicates that the item are dispatched to all _subscribers_"
msgstr "アイテムがすべての _加入者_に発送されていることを示します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:197
#, fuzzy
msgid ""
"The `process` method is called for every Kafka _record_ from the `prices` "
"topic (configured in the application configuration).  Every result is sent "
"to the `my-data-stream` in-memory stream."
msgstr ""
"`process` メソッドは、 `prices` トピック (アプリケーション構成で構成) からの Kafka "
"_レコード_ごとに呼び出されます。すべての結果は `my-data-stream` インメモリストリームに送信されます。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:198
#, no-wrap, fuzzy
msgid "The price resource"
msgstr "価格資源"

#. type: Plain text
#: upstream/_guides/kafka.adoc:202
#, fuzzy
msgid ""
"Finally, let's bind our stream to a JAX-RS resource.  Creates the `src/main/"
"java/org/acme/kafka/PriceResource.java` file with the following content:"
msgstr ""
"最後に、ストリームをJAX-RSリソースにバインドしてみましょう。以下の内容の `src/main/java/org/acme/kafka/"
"PriceResource.java` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:209 upstream/_guides/kafka.adoc:558
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Channel;\n"
"import org.reactivestreams.Publisher;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:216 upstream/_guides/kafka.adoc:565
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.GET;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Produces;\n"
"import javax.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.annotations.SseElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:222
#, no-wrap
msgid ""
"/**\n"
" * A simple resource retrieving the in-memory \"my-data-stream\" and sending "
"the items as server-sent events.\n"
" */\n"
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:225
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"my-data-stream\") Publisher<Double> prices; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:234
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS) // <2>\n"
"    @SseElementType(\"text/plain\") // <3>\n"
"    public Publisher<Double> stream() { // <4>\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:236
#, fuzzy
msgid "Injects the `my-data-stream` channel using the `@Channel` qualifier"
msgstr "`@Channel` の修飾子を使って `my-data-stream` チャンネルを注入します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:237
#, fuzzy
msgid "Indicates that the content is sent using `Server Sent Events`"
msgstr "を使用してコンテンツが送信されていることを示します。 `Server Sent Events`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:238
#, fuzzy
msgid ""
"Indicates that the data contained within the server sent events is of type "
"`text/plain`"
msgstr "サーバから送信されたイベントに含まれるデータのタイプが `text/plain`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:239
#, fuzzy
msgid "Returns the stream (_Reactive Stream_)"
msgstr "ストリーム _（Reactive Stream_）を返します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:240
#, no-wrap, fuzzy
msgid "Configuring the Kafka connector"
msgstr "Kafka コネクタの設定"

#. type: Plain text
#: upstream/_guides/kafka.adoc:244
#, fuzzy
msgid ""
"We need to configure the Kafka connector. This is done in the `application."
"properties` file.  The keys are structured as follows:"
msgstr ""
"Kafka コネクタを設定する必要があります。これは `application.properties` "
"ファイルで行います。キーは以下のような構造になっています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:246
#, fuzzy
msgid "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"
msgstr "`mp.messaging.[outgoing|incoming].{channel-name}.property=value`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:248
#, fuzzy
msgid ""
"The `channel-name` segment must match the value set in the `@Incoming` and "
"`@Outgoing` annotation:"
msgstr ""
"`channel-name` セグメントは、 `@Incoming` および `@Outgoing` "
"アノテーションで設定された値と一致する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:250
#, fuzzy
msgid "`generated-price` -> sink in which we write the prices"
msgstr "`generated-price` → 価格を書いた流し"

#. type: Plain text
#: upstream/_guides/kafka.adoc:251
#, fuzzy
msgid "`prices` -> source in which we read the prices"
msgstr "`prices` → 価格を読み取ったソース"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:256
#, no-wrap
msgid ""
"# Configure the SmallRye Kafka connector\n"
"kafka.bootstrap.servers=localhost:9092\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:261
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.generated-price.connector=smallrye-kafka\n"
"mp.messaging.outgoing.generated-price.topic=prices\n"
"mp.messaging.outgoing.generated-price.value.serializer=org.apache.kafka."
"common.serialization.IntegerSerializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:265
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka\n"
"mp.messaging.incoming.prices.value.deserializer=org.apache.kafka.common."
"serialization.IntegerDeserializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:268
#, fuzzy
msgid ""
"More details about this configuration is available on the https://kafka."
"apache.org/documentation/#producerconfigs[Producer configuration] and https:/"
"/kafka.apache.org/documentation/#consumerconfigs[Consumer configuration] "
"section from the Kafka documentation. These properties are configured with "
"the prefix `kafka`."
msgstr ""
"この設定の詳細については、Kafka ドキュメントの link:https://kafka.apache.org/documentation/"
"#producerconfigs[Producer 設定]と link:https://kafka.apache.org/documentation/"
"#consumerconfigs[Consumer 設定]のセクションを参照してください。これらのプロパティは、 `kafka` "
"という接頭辞で設定されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:270
#, fuzzy
msgid ""
"What about `my-data-stream`? This is an in-memory stream, not connected to a "
"message broker."
msgstr "`my-data-stream` はどうですか？これはインメモリストリームであり、メッセージブローカには接続されていません。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:271
#, no-wrap, fuzzy
msgid "The HTML page"
msgstr "HTMLページ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:274
#, fuzzy
msgid "Final touch, the HTML page reading the converted prices using SSE."
msgstr "最後に、SSEを使って変換された価格を読み込んだHTMLページ。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:276
#, fuzzy
msgid ""
"Create the `src/main/resources/META-INF/resources/prices.html` file, with "
"the following content:"
msgstr ""
"以下の内容の `src/main/resources/META-INF/resources/prices.html` ファイルを作成します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:284
#, no-wrap
msgid ""
"<!DOCTYPE html>\n"
"<html lang=\"en\">\n"
"<head>\n"
"    <meta charset=\"UTF-8\">\n"
"    <title>Prices</title>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:292
#, no-wrap
msgid ""
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/"
"css/patternfly.min.css\">\n"
"    <link rel=\"stylesheet\" type=\"text/css\"\n"
"          href=\"https://cdnjs.cloudflare.com/ajax/libs/patternfly/3.24.0/"
"css/patternfly-additions.min.css\">\n"
"</head>\n"
"<body>\n"
"<div class=\"container\">\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:307
#, no-wrap
msgid ""
"    <h2>Last price</h2>\n"
"    <div class=\"row\">\n"
"    <p class=\"col-md-12\">The last price is <strong><span id=\"content\">N/"
"A</span>&nbsp;&euro;</strong>.</p>\n"
"    </div>\n"
"</div>\n"
"</body>\n"
"<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\n"
"<script>\n"
"    var source = new EventSource(\"/prices/stream\");\n"
"    source.onmessage = function (event) {\n"
"        document.getElementById(\"content\").innerHTML = event.data;\n"
"    };\n"
"</script>\n"
"</html>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:310
#, fuzzy
msgid "Nothing spectacular here. On each received price, it updates the page."
msgstr "目を見張るようなものは何もありません。受信した価格ごとに、ページを更新します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:311
#, no-wrap, fuzzy
msgid "Get it running"
msgstr "稼動させる"

#. type: Plain text
#: upstream/_guides/kafka.adoc:315
#, fuzzy
msgid ""
"If you followed the instructions, you should have Kafka running.  Then, you "
"just need to run the application using:"
msgstr "指示に従えば、Kafka が起動しているはずです。あとは、アプリケーションを使って実行するだけです。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:319
#, no-wrap
msgid "./mvnw quarkus:dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:322
#, fuzzy
msgid "Open `http://localhost:8080/prices.html` in your browser."
msgstr ""
"開く `&lt;a href=\"http://localhost:8080/prices.html\" class=\"bare\"&gt;http:/"
"/localhost:8080/prices.html&lt;/a&gt;`をブラウザに表示してください。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:324
#, fuzzy
msgid ""
"If you started the Kafka broker with docker compose, stop it using `CTRL+C` "
"followed by `docker-compose down`."
msgstr ""
"Kafka ブローカーを docker compose で起動した場合は、 `CTRL+C` に続いて `docker-compose down`."

#. type: Title ==
#: upstream/_guides/kafka.adoc:325
#, no-wrap, fuzzy
msgid "Running Native"
msgstr "ネイティブの実行"

#. type: Plain text
#: upstream/_guides/kafka.adoc:328
#, fuzzy
msgid "You can build the native executable with:"
msgstr "でネイティブ実行ファイルをビルドすることができます。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:332
#, no-wrap
msgid "./mvnw package -Pnative\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:334
#, no-wrap, fuzzy
msgid "Imperative usage"
msgstr "強制的な使用法"

#. type: Plain text
#: upstream/_guides/kafka.adoc:337
#, fuzzy
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "時には、メッセージを送るための必須の方法が必要になることもあります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:340
#, fuzzy
msgid ""
"For example, if you need to send a message to a stream, from inside a REST "
"endpoint, when receiving a POST request.  In this case, you cannot use "
"`@Output` because your method has parameters."
msgstr ""
"例えば、POST リクエストを受信したときに、REST "
"エンドポイントの内部からストリームにメッセージを送信する必要がある場合。この場合、メソッドにはパラメータがあるため、 `@Output` "
"を使用することはできません。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:342
#, fuzzy
msgid "For this, you can use an `Emitter`."
msgstr "そのためには、 `Emitter`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:347
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:353
#, no-wrap
msgid ""
"import javax.inject.Inject;\n"
"import javax.ws.rs.POST;\n"
"import javax.ws.rs.Path;\n"
"import javax.ws.rs.Consumes;\n"
"import javax.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:356
#, no-wrap
msgid "@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:358
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:365
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:369
#, fuzzy
msgid ""
"The `Emitter` configuration is done the same way as the other stream "
"configuration used by `@Incoming` and `@Outgoing`.  In addition, you can use "
"`@OnOverflow` to configure back-pressure strategy."
msgstr ""
"`Emitter` の設定は、 `@Incoming` と `@Outgoing` が使用する他のストリームの設定と同じ方法で行います。さらに、 "
"`@OnOverflow` を使用して、バックプレッシャー戦略を設定することができます。"

#. type: Block title
#: upstream/_guides/kafka.adoc:371
#, no-wrap, fuzzy
msgid "Deprecation"
msgstr "非推奨"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:374
#, fuzzy
msgid ""
"The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye."
"reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging."
"annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr ""
"`io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive."
"messaging.annotations.Channel`, `io.smallrye.reactive.messaging.annotations."
"OnOverflow` クラスは現在非推奨となっており、以下のように置き換えられています。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:376
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:377
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:378
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:380
#, fuzzy
msgid ""
"The new `Emitter.send` method returns a `CompletionStage` completed when the "
"produced message is acknowledged."
msgstr "新しい `Emitter.send` メソッドは、生成されたメッセージが確認されると `CompletionStage` 完了を返します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:382
#, no-wrap, fuzzy
msgid "Kafka Health Check"
msgstr "カフカの健康チェック"

#. type: Plain text
#: upstream/_guides/kafka.adoc:386
#, fuzzy
msgid ""
"If you are using the `quarkus-smallrye-health` extension, `quarkus-kafka` "
"can add a readiness health check to validate the connection to the broker. "
"This is disabled by default."
msgstr ""
"`quarkus-smallrye-health` エクステンションを使用している場合、 `quarkus-kafka` "
"は、ブローカーへの接続を検証するために準備状態の健全性チェックを追加することができます。これはデフォルトでは無効になっています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:388
#, fuzzy
msgid ""
"If enabled, when you access the `/health/ready` endpoint of your application "
"you will have information about the connection validation status."
msgstr ""
"この機能を有効にすると、アプリケーションの `/health/ready` "
"エンドポイントにアクセスしたときに、接続の検証状態に関する情報が表示されます。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:390
#, fuzzy
msgid ""
"This behavior can be enabled by setting the `quarkus.kafka.health.enabled` "
"property to `true` in your `application.properties`."
msgstr ""
"この動作を有効にするには、 `application.properties` の `quarkus.kafka.health.enabled` "
"プロパティを `true` に設定します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:391
#, no-wrap, fuzzy
msgid "JSON serialization"
msgstr "ＪＳＯＮシリアライズ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:394
#, fuzzy
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "Quarkusには、JSON Kafkaメッセージを扱う機能が組み込まれています。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:396
#, fuzzy
msgid "Imagine we have a `Fruit` pojo as follows:"
msgstr "以下のように `Fruit` のポジョがあると想像してみてください。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:400
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:403
#, no-wrap
msgid "    public String name;\n"
"    public int price;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:406
#, no-wrap
msgid "    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:412
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:415
#, fuzzy
msgid ""
"And we want to use it to receive messages from Kafka, make some price "
"transformation, and send messages back to Kafka."
msgstr "そして、Kafkaからのメッセージを受信して、何らかの価格変換をして、Kafkaにメッセージを送り返すために使いたいと考えています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:430
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" Kafka topic and applying some "
"price conversion.\n"
"* The result is pushed to the \"fruit-out\" stream.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:440
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:445
#, fuzzy
msgid ""
"To do this, we will need to setup JSON serialization with Jackson or JSON-B."
msgstr "そのためには、JacksonやJSON-BでJSONシリアライズを設定する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:447
#, fuzzy
msgid ""
"With JSON serialization correctly configured, you can also use "
"`Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr ""
"JSON シリアライゼーションが正しく設定されていれば、 `Publisher&amp;lt;Fruit&amp;gt;` や "
"`Emitter&amp;lt;Fruit&amp;gt;`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:448
#, no-wrap, fuzzy
msgid "Serializing via Jackson"
msgstr "ジャクソン経由でのシリアライズ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:451
#, fuzzy
msgid ""
"First, you need to include the `quarkus-jackson` extension (if you already "
"use the `quarkus-resteasy-jackson` extension, this is not needed)."
msgstr ""
"まず、 `quarkus-jackson` の拡張子を含める必要があります（すでに `quarkus-resteasy-jackson` "
"の拡張子を使用している場合は、これは必要ありません）。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:458
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jackson</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:462
#, fuzzy
msgid ""
"There is an existing `ObjectMapperSerializer` that can be used to serialize "
"all pojos via Jackson, but the corresponding deserializer is generic, so it "
"needs to be subclassed."
msgstr ""
"Jackson経由で全てのpojosをシリアライズすることができる既存の `ObjectMapperSerializer` "
"がありますが、対応するデシリアライザは汎用的なものなので、サブクラス化する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:464
#, fuzzy
msgid ""
"So, let's create a `FruitDeserializer` that extends the "
"`ObjectMapperDeserializer`."
msgstr "そこで、 `ObjectMapperDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:468
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:470
#, no-wrap
msgid ""
"import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:477
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:480
#, fuzzy
msgid ""
"Finally, configure your streams to use the Jackson serializer and "
"deserializer."
msgstr "最後に、Jackson シリアライザとデシリアライザを使用するようにストリームを設定します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:487
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson."
"FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:492
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client."
"serialization.ObjectMapperSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:495
#, fuzzy
msgid ""
"Now, your Kafka messages will contain a Jackson serialized representation of "
"your Fruit pojo."
msgstr "これで、あなたのカフカのメッセージには、あなたのフルーツポジョのジャクソンのシリアル化された表現が含まれるようになります。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:496
#, no-wrap, fuzzy
msgid "Serializing via JSON-B"
msgstr "JSON-Bによるシリアライズ"

#. type: Plain text
#: upstream/_guides/kafka.adoc:499
#, fuzzy
msgid ""
"First, you need to include the `quarkus-jsonb` extension (if you already use "
"the `quarkus-resteasy-jsonb` extension, this is not needed)."
msgstr ""
"まず、 `quarkus-jsonb` の拡張子を含める必要があります（すでに `quarkus-resteasy-jsonb` "
"の拡張子を使用している場合は、これは必要ありません）。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:506
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:510
#, fuzzy
msgid ""
"There is an existing `JsonbSerializer` that can be used to serialize all "
"pojos via JSON-B, but the corresponding deserializer is generic, so it needs "
"to be subclassed."
msgstr ""
"JSON-B経由ですべてのpojosをシリアライズするために使用できる既存の `JsonbSerializer` "
"がありますが、対応するデシリアライザは汎用的なものなので、サブクラス化する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:512
#, fuzzy
msgid ""
"So, let's create a `FruitDeserializer` that extends the generic "
"`JsonbDeserializer`."
msgstr "そこで、一般的な `JsonbDeserializer` を拡張した `FruitDeserializer` を作成してみましょう。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:516
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:518
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:525
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer(){\n"
"        // pass the class to the parent.\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:529
#, fuzzy
msgid ""
"If you don't want to create a deserializer for each of your pojo, you can "
"use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` "
"that will deserialize to a `javax.json.JsonObject`. The corresponding "
"serializer can also be used: `io.vertx.kafka.client.serialization."
"JsonObjectSerializer`."
msgstr ""
"あなたの pojo のそれぞれのためにデシリアライザを作成したくない場合は、 `javax.json.JsonObject` にデシリアライズする汎用の "
"`io.vertx.kafka.client.serialization.JsonObjectDeserializer` "
"を使用することができます。対応するシリアライザも使用できます: `io.vertx.kafka.client.serialization."
"JsonObjectSerializer`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:531
#, fuzzy
msgid ""
"Finally, configure your streams to use the JSON-B serializer and "
"deserializer."
msgstr "最後に、JSON-Bシリアライザとデシリアライザを使用するようにストリームを設定します。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:538
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb."
"FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:543
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client."
"serialization.JsonbSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:546
#, fuzzy
msgid ""
"Now, your Kafka messages will contain a JSON-B serialized representation of "
"your Fruit pojo."
msgstr "これで、Kafkaのメッセージには、JSON-Bでシリアル化されたFruit pojoの表現が含まれます。"

#. type: Title ===
#: upstream/_guides/kafka.adoc:547
#, no-wrap, fuzzy
msgid "Sending JSON Server-Sent Events (SSE)"
msgstr "JSONサーバーセントイベント（SSE）の送信"

#. type: Plain text
#: upstream/_guides/kafka.adoc:551
#, fuzzy
msgid ""
"If you want RESTEasy to send JSON Server-Sent Events, you need to use the "
"`@SseElementType` annotation to define the content type of the events, as "
"the method will be annotated with `@Produces(MediaType.SERVER_SENT_EVENTS)`."
msgstr ""
"`@Produces(MediaType.SERVER_SENT_EVENTS)`RESTEasy で JSON Server-Sent Events "
"を送信したい場合は、 `@SseElementType` アノテーションを使用してイベントのコンテンツタイプを定義する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:553
#, fuzzy
msgid "The following example shows how to use SSE from a Kafka topic source."
msgstr "次の例は、KafkaトピックソースからSSEを使用する方法を示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:568
#, no-wrap
msgid "@Path(\"/fruits\")\n"
"public class FruitResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:571
#, no-wrap
msgid "    @Inject\n"
"    @Channel(\"fruit-out\") Publisher<Fruit> fruits;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:580
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/stream\")\n"
"    @Produces(MediaType.SERVER_SENT_EVENTS)\n"
"    @SseElementType(MediaType.APPLICATION_JSON)\n"
"    public Publisher<Fruit> stream() {\n"
"        return fruits;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:582
#, no-wrap, fuzzy
msgid "Blocking processing"
msgstr "ブロッキング処理"

#. type: Plain text
#: upstream/_guides/kafka.adoc:586
#, fuzzy
msgid ""
"You often need to combine Reactive Messaging with blocking processing such "
"as database interactions.  For this, you need to use the `@Blocking` "
"annotation indicating that the processing is _blocking_ and cannot be run on "
"the caller thread."
msgstr ""
"リアクティブメッセージングとデータベースインタラクションなどのブロッキング処理を組み合わせる必要があることがよくあります。そのためには、処理が "
"_ブロックさ_れていて呼び出し元のスレッドで実行できないことを示す `@Blocking` アノテーションを使用する必要があります。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:588
#, fuzzy
msgid ""
"For example, The following code illustrates how you can store incoming "
"payloads to a database using Hibernate with Panache:"
msgstr "例えば、以下のコードは、Hibernate with Panacheを使用してデータベースに受信ペイロードを格納する方法を示しています。"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:592
#, no-wrap
msgid "package org.acme.panache;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:595
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:598
#, no-wrap
msgid ""
"import javax.enterprise.context.ApplicationScoped;\n"
"import javax.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:601
#, no-wrap
msgid "@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:610
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Blocking\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:615
#, fuzzy
msgid ""
"The complete example is available in the `kafka-panache-quickstart` "
"{quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr ""
"完全な例は `kafka-panache-quickstart` {quickstarts-tree-url}/kafka-panache-"
"quickstart[directory] にあります。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:619
#, fuzzy
msgid "There are 2 `@Blocking` annotations:"
msgstr "`@Blocking` アノテーションは2つあります。"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:621
#, fuzzy
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:622
#, fuzzy
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:627
#, fuzzy
msgid ""
"They have the same effect.  Thus, you can use both.  The first one provides "
"more fine-grain tuning such as the worker pool to use and whether it "
"preserves the order.  The second one, used in also with other reactive "
"features of Quarkus, uses the default worker pool and preserves the order."
msgstr ""
"どちらも同じ効果があります。したがって、両方を使うことができます。最初のものは、使用するワーカープールや順序を保持するかどうかなど、より細かい調整が可能です。2番目のものは、Quarkusの他のリアクティブ機能でも使用され、デフォルトのワーカープールを使用し、順序を保持します。"

#. type: Title ==
#: upstream/_guides/kafka.adoc:629
#, no-wrap, fuzzy
msgid "Going further"
msgstr "さらに進む"

#. type: Plain text
#: upstream/_guides/kafka.adoc:633
#, fuzzy
msgid ""
"This guide has shown how you can interact with Kafka using Quarkus.  It "
"utilizes MicroProfile Reactive Messaging to build data streaming "
"applications."
msgstr ""
"このガイドでは、Quarkusを使用してKafkaと対話する方法を示しました。MicroProfile Reactive "
"Messagingを利用して、データストリーミングアプリケーションを構築します。"

#. type: Plain text
#: upstream/_guides/kafka.adoc:634
#, fuzzy
msgid ""
"If you want to go further check the documentation of https://smallrye.io/"
"smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation "
"used in Quarkus."
msgstr ""
"さらに詳しく知りたい場合は、Quarkusで使用されている実装である link:https://smallrye.io/smallrye-"
"reactive-messaging[SmallRye Reactive Messaging]のドキュメントを確認してください。"
