<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.3.2" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: security
title: Security
permalink: /security/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: security
title: セキュリティ
permalink: /security/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team and community take all security bugs very seriously. You can find our guidelines here regarding our policy and security disclosure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのチームとコミュニティは、すべてのセキュリティバグを非常に深刻に受け止めています。ポリシーとセキュリティ開示に関するQuarkusのガイドラインはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reporting security issues</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティ問題の報告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please report any security issues you find in Quarkus to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusで見つけたセキュリティ問題を次の場所に報告してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Anyone can post to this list. The subscribers are only trusted individuals from the Quarkus community who will handle the resolution of any reported security issues in confidence. In your report, please note how you would like to be credited for discovering the issue and the details of any embargo you would like to impose. Currently the security response teams for the following distributions are subscribed to this list and will respond to your report:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリストには誰でも投稿できます。このリストの購読者は、Quarkusコミュニティの信頼できる個人のみで、報告されたセキュリティ問題の解決を秘密を守って処理します。報告においては、問題を発見したことについてどのようにクレジットされたいか、またエンバーゴ処理を適用したい場合はその詳細を記載してください。現在、以下のディストリビューションのセキュリティ対応チームがこのリストに登録されており、あなたのレポートに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://access.redhat.com/security/team/contact/[Red Hat]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ecosystem</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エコシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an ecosystem made from many extensions and many libraries (like Eclipse Vert.x, Hibernate, Apache Camel and more), most of them not under the direct responsibility of the Quarkus team. If you find a security bug possibly rooted in one of these libraries, you can either disclose to them directly or disclose them to the Quarkus team (following this process) and we will responsibly disclose the issue to the respective extension or library maintainer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、多くのエクステンションと多くのライブラリ（Eclipse Vert.x、Hibernate、Apache Camelなど）からなるエコシステムであり、そのほとんどはQuarkusチームの直接の責任下にはありません。これらのライブラリに根ざしている可能性のあるセキュリティバグを見つけた場合は、それらのライブラリに直接開示するか、Quarkusチームに開示することが出来（このプロセスに従ってください）、その場合、責任を持ってそれぞれのエクステンションまたはライブラリのメンテナに開示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why follow this process</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロセスに従う理由</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the sensitive nature of security bugs, the disclosure process is more constrained than a regular bug. We appreciate you following these industry accepted guidelines, which gives time for a proper fix and limit the time window of attack.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティバグは機密性が高いため、通常のバグよりも開示プロセスに制約があります。我々は、適切な修正のための時間を与え、攻撃の時間枠を制限する、業界で認められたこれらのガイドラインに従っていただけることに感謝します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported Versions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているバージョン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The community will fix security bugs for the latest major.minor version published at https://quarkus.io/get-started/.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コミュニティは、https://quarkus.io/get-started/ で公開されている最新の major.minor バージョンのセキュリティバグを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*Version &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Supported* +
latest 1.x &amp;nbsp;&amp;nbsp; ✅ +
older 1.x &amp;nbsp;&amp;nbsp; ❌ +
&lt; 1.0 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ❌
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We may fix the vulnerability to older versions depending on the severity of the issue and the age of the release, but we are only committing to the latest version released.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題の深刻度やリリースの経過時間によっては、古いバージョンへの脆弱性を修正する場合がありますが、コミットしているのは、リリースされた最新バージョンのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Handling security issues</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティ問題への対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you represent a Quarkus extension or a Quarkus platform, you are welcome to subscribe to the security at quarkus.io mailing list. Your subscription will only be approved if you can demonstrate that you will handle issues in confidence and properly credit reporters for discovering issues (e.g. experience with embargoe process).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのエクステンションやQuarkusのプラットフォームを代表している場合は、security at quarkus.ioのメーリングリストを購読することを歓迎します。あなたの購読は、あなたが問題を秘密を守って処理し、問題を発見した報告者を適切にクレジット出来ると証明できる場合にのみ承認されます（例：エンバーゴ処理の経験）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Migration Guide</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>移行ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's new?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud Functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud Functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ADOPTERS.md</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ADOPTERS.md</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus and would like to be interviewed on our blog or simply added to this file, please contact us and we will be happy to oblige.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusをご利用の方で、ブログで取材を受けたい方や、このファイルに単純に追加したい方は、ご連絡いただければ、喜んでお受けいたします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Come Join Us</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>参加のお誘い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We value your feedback a lot so please report bugs, ask for improvements... Let's build something great together!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私達は皆様からのフィードバックに重きを置いています。バグ報告、改善要望を是非お願いします。一緒に素晴らしいものを作り上げていきましょう！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are a Quarkus user or just curious, don't be shy and join our welcoming community:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusユーザーの場合でも、単に興味を持っているだけの場合でも、恥ずかしがらずにコミュニティに参加して下さい！：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>provide feedback on https://github.com/quarkusio/quarkus/issues[GitHub];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/issues[GitHub] でフィードバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>craft some code and https://github.com/quarkusio/quarkus/pulls[push a PR];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードを作成し、 https://github.com/quarkusio/quarkus/pulls[プルリクエスト] を送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>discuss with us on https://quarkusio.zulipchat.com/[Zulip] and on the https://groups.google.com/d/forum/quarkus-dev[mailing list];</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://quarkusio.zulipchat.com/[Zulip] や https://groups.google.com/d/forum/quarkus-dev[メーリングリスト] でディスカッションに参加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ask your questions on https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://stackoverflow.com/questions/tagged/quarkus[Stack Overflow] で質問</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Going further</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに詳しく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: Extension codestarts - A new way to learn &amp; discover Quarkus
date: 2020-12-07
tags: extensions codestarts quickstart
synopsis: All our tooling has been updated and can now generate Quarkus application with example code (Extension Codestarts) showing the true power of the selected extensions...
author: adamevin
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Extension codestarts - Quarkusを学習、探索する新しい方法
date: 2020-12-07
tags: extensions codestarts quickstart
synopsis: すべてのツールが更新され、選択したエクステンションの真の力を示すサンプルコード（Extension Codestarts）が付属したQuarkusアプリケーションを生成できるようになりました
author: adamevin
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What’s nice about Extension codestarts is that it’s useful for fresh Quarkus developers as well as experienced ones. This is because of the wide range (and growing) of Quarkus extensions, you simply can’t know them all.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Extension codestartsの良い点は、新しくQuarkusを開発したばかりの開発者だけでなく、経験豊富な開発者にも役立つ点です。これは、Quarkusのエクステンションの範囲が広い（そして増え続けている）ため、すべてを知っていることが単純に不可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When I am comparing frameworks, I think that Doc is a very important factor, but I am also often pretty lazy when it comes to reading it... don't you?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フレームワークの比較をしていると、ドキュメントはとても重要な要素だと思うのですが、私もいざ読むとなるとかなり怠けてしまうとが多いです...あなたはどうですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By the way you can see that Quarkus is pretty well https://quarkus.io/guides/[documented,role=external,window=_blank].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ちなみにQuarkusはかなり https://quarkus.io/guides/[ガイド, role=external, window=_blank]が充実しているのがわかるかと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this feature, we tried to take it a step further and transform that boring learning part to the thing we love most *CODING*..</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能では、さらに一歩進んで、退屈な学習の部分を、私たちが最も好きな *コーディング* に変えようとしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting now, when you wish to try some new extensions, you directly have the code showing you their true power, ready to run in your favorite IDE in a matter of seconds!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今から、いくつかの新しいエクステンションを試してみたいときには、その真の力を示すコードが直接表示され、お気に入りのIDEであっという間に実行できるようになります!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All this, using your chosen build tool (Maven, Gradle or also Gradle with Kotlin DSL) and your chosen language (Java, Kotlin or Scala).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらはすべて、選択したビルドツール（Maven、Gradle、またはKotlin DSLによるGradle）と選択した言語（Java、Kotlin、またはScala）を使用して行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It’s been slowly making its way in for a while now (since 1.7), Codestarts are now the official way of generating your Quarkus applications starting from 1.10!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Codestartsは、（1.7から）ゆっくりと出来上がってきましたが、1.10からQuarkusアプリケーションを生成するための公式な方法になりました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/codestarts/cloud-native-quarkus-app.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Existing Extension codestarts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のエクステンションのコードスタート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We already prepared examples for a dozen of extensions, you may spot them on https://code.quarkus.io[code.quarkus.io,role=external,window=_blank] (with the jet fighter icon).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちはすでに沢山のエクステンションの例を用意しており、 https://code.quarkus.io[code.quarkus.io, role=external, window=_blank](ジェット戦闘機のアイコンが付いている)で見ることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also find them on most of our Quarkus tooling:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Quarkusのほとんどのツールでも見つけることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Maven plugin:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Mavenプラグイン：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI, it is still experimental, and we don't provide an installer yet. Still, you can easily try it using the amazing https://jbang.dev/[JBang,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLIは、まだ実験的なもので、インストーラーはまだ提供されていません。それでも、素晴らしい https://jbang.dev/[JBang, role=external, window=_blank]を使って簡単に試すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://quarkus.io/blog/march-of-ides/[IDE plugins,role=external,window=_blank] which support "Wizards w/code.quarkus.io"</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Wizards w/code.quarkus.io" をサポートする https://quarkus.io/blog/march-of-ides/[IDEプラグイン, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit of fun in some of our examples</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの例の中で、ちょっとした楽しみ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>My favorite one is the new Qute example with a subatomic-particles generator :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私のお気に入りは、素粒子ジェネレーターを備えた新しいQuteのサンプルです :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/codestarts/qute-and-quarks.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;a=subatomic-particles-generator&amp;v=1.0.0-SNAPSHOT&amp;b=MAVEN&amp;s=xTN&amp;cn=code.quarkus.io[Here on code.quarkus.io,role=external,window=_blank]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://code.quarkus.io/?g=its.subatomic&amp;amp;a=subatomic-particles-generator&amp;amp;v=1.0.0-SNAPSHOT&amp;amp;b=MAVEN&amp;amp;s=xTN&amp;amp;cn=code.quarkus.io[code.quarkus.ioでは、以下のようになっています。, role=external, window=_blank]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>With the CLI:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need more Extension codestarts!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もっとエクステンションのcodestartsが必要です！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts are designed to make it easy and quick to provide new examples for extensions. So whether you are an extension owner, or you are keen to create an example for an extension you like, contributions are very welcome!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードスタートは、エクステンションのための新しいサンプルを簡単かつ迅速に提供できるように設計されています。ですから、あなたがエクステンションの所有者の場合でも、あなたが好きなエクステンションの例を作りたい場合でも、貢献は大歓迎です!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We provide https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[doc and tooling,role=external,window=_blank] for it, you may also https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[come and ping me (@ia3andy) on Zulip,role=external,window=_blank] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちはそれのための https://github.com/quarkusio/quarkus/blob/master/independent-projects/tools/codestarts/README.adoc[ドキュメントとツール, role=external, window=_blank]を提供しています。 https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Codestarts.2E.2E.2E[チャットに来て、私(@ia3andy)にpingを打って, role=external, window=_blank] 詳細について聞くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now, we focus on the https://github.com/quarkusio/quarkus/blob/master/extensions[core extensions,role=external,window=_blank], but we will make it available to the broader ecosystem soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところは https://github.com/quarkusio/quarkus/blob/master/extensions[コアなエクステンション, role=external, window=_blank]に焦点を当てていますが、近いうちにより広いエコシステムで利用できるようにする予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A few months back, I blogged about https://quarkus.io/blog/kafka-avro/[Quarkus, Kafka, and Avro] (using the Apicurio schema registry).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数ヶ月前に、 https://quarkus.io/blog/kafka-avro/[QuarkusとKafka、Avro] （Apicurio schema registryを使用）についてブログを書きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We developed a simple application, receives HTTP requests, writes Kafka records, and reads them from Kafka.  It uses Avro to serialize and deserialize the records.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTPリクエストを受信し、Kafkaのレコードを書き込み、Kafkaからレコードを読み出すというシンプルなアプリケーションを開発しました。  Avroを使ってレコードのシリアライズとデシリアライズを行っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-avro/architecture.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At that time, the https://github.com/cescoffier/quarkus-kafka-and-avro[application] was **NOT** working in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その時は、 https://github.com/cescoffier/quarkus-kafka-and-avro[アプリケーション] はネイティブモードで動作して **いません** でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus 1.10.2, it's now working in native mode!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.10.2では、ネイティブモードで動作するようになりました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why didn't it work?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜうまくいかなかったのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native compiler does not support everything that is possible to do in Java.  There are cases not yet supported, and Avro is using some of these unsupported constructs.  Fortunately, we can implement _substitutions_ (to replace unsupported constructs in the code directly) and use Quarkus extensions to configure the compiler correctly.  As a result, your application does not have to configure anything, "it just works™️".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブコンパイラは、Javaでできることをすべてサポートしているわけではありません。  まだサポートされていないケースがあり、Avroではこれらのサポートされていない構文のいくつかを使用しています。幸いなことに、_substitutions_（コード内のサポートされていない構文を直接置き換える）を実装し、Quarkusのエクステンションを使用してコンパイラを正しく設定することができます。その結果、アプリケーションは何も設定する必要がなく、「it just works™️」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's come back to Avro.  Avro uses https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[method handles] that are not supported by the GraalVM native compiler.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Avro の話に戻りましょう。  Avro は GraalVM ネイティブコンパイラがサポートしていない https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html[メソッドハンドル] を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To workaround the unsupported constructs used by Avro, we implemented a set of https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions].  We replaced method handles with reflection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Avro が使用するサポートされていない構文を回避するために、 https://github.com/quarkusio/quarkus/blob/master/extensions/avro/runtime/src/main/java/io/quarkus/avro/graal/AvroSubstitutions.java[substitutions] のセットを実装しました。 メソッドハンドルをリフレクションに置き換えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GenericDatumReader` also needs a bit of work as it touches threads at build time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `GenericDatumReader` は、ビルド時にスレッドに触れるため、少し作業が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, in the Quarkus Avro Processor (part of the Quarkus extension), we register for reflection all the classes annotated with `@AvroGenerated`, as we are using reflection to create new instances of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、Quarkus Avro Processor（Quarkusエクステンションの一部）で、 `@AvroGenerated` でアノテーションされたすべてのクラスをリフレクションの為に登録します。新しいインスタンスの生成にリフレクションを使用している為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>見せて！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the https://github.com/cescoffier/quarkus-kafka-and-avro[code] of the application, and make sure you have GraalVM installed.  Then, build the native executable using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの https://github.com/cescoffier/quarkus-kafka-and-avro[コード] を取得し、GraalVMがインストールされていることを確認してください。そして、ネイティブ実行ファイルを次のようにビルドします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Grab a coffee or tea, as it may take a few minutes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>数分かかる場合がありますので、コーヒーや紅茶を淹れましょう</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start the Kafka broker and the schema registry using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka ブローカーとスキーマレジストリを次のように起動します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, run the application with `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、 `./target/kafka-and-avro-1.0.0-SNAPSHOT-runner` でアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send some movies to the application:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いくつかの映画をアプリに送信します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check they are processed successfully in the application log output:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>正常に処理されていることをアプリケーションログ出力で確認してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Avro support in native is still experimental.  In the last Quarkus version, we made significant progress, but there may be some uncovered areas.  Let us know if you find anything https://github.com/quarkusio/quarkus/issues/new/choose[odd]!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブでのAvroサポートはまだ実験的なものです。前回のQuarkusバージョンでは、かなりの進歩を遂げましたが、いくつかの未発見の部分があるかもしれません。 https://github.com/quarkusio/quarkus/issues/new/choose[何かおかしな点を見つけましたら教えてください] ！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kafka.apache.org/[Apache] Kafka is a prevalent distributed streaming platform offering a unique set of characteristics such as message retention, replay capabilities, consumer groups, and so on.  Kafka is highly scalable, fault-tolerant, and is becoming the spine of many modern systems.  That being said, Kafka is not the only one out there, and choosing the right messaging technology for your application can be challenging.  There are many articles to help you drive your decision, such as https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[this one].  This post is about Kafka, and an equivalent post about AMQP will be published later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://kafka.apache.org/[Apache Kafka] は、メッセージの保持、再生機能、コンシューマーグループなどのユニークな特性を提供する分散型ストリーミングプラットフォームとして広く普及しています。Kafka は非常に拡張性が高く、耐障害性に優れており、多くの近代的なシステムの要になりつつあります。とはいえ、Kafka単体で存在するものではなく、アプリケーションに適したメッセージング技術を選択するのは難しいことです。 link:https://medium.com/@graemecolman/mind-your-amqps-or-kafka-or-interconnect-what-is-in-the-red-hat-messaging-box-9ed5aa590e92[このリンク先] のように、あなたの決定を後押しするために役立つ記事がたくさんあります。この記事は Kafka についてのもので、AMQP についての同等の記事は後日公開される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, you will learn how to get started with Apache Kafka in your Quarkus application in less than 10 steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] - a declarative approach to build event-driven microservices, but you can also use _bare_ Kafka APIs or Kafka Streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この投稿では、QuarkusアプリケーションでApache Kafkaを10ステップ未満で使い始める方法を学びます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[Reactive Messaging] を使用しますが、 _ベア_ Kafka APIやKafka Streamsを使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-kafka[GitHub]から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 1 - Generate your project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ 1 - プロジェクトの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start with the very beginning, getting a new project structure with the right dependencies.  Go to https://code.quarkus.io, enter your group id and artifact id.  Then in the extension list, select:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の一歩として、正しい依存関係を持つ新しいプロジェクト構造を取得してみましょう。 https://code.quarkus.io  にアクセスして、グループIDとアーティファクトIDを入力します。そして、エクステンションのリストで以下を選択します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging - Kafka Connector</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/getting-started-kafka/getting-started-kafka-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project to contain examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Example Code"を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, click on __Generate your application__, download the project as a zip file, unzip it, and load it in your favorite IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 _Generate your application_ をクリックして、プロジェクトをzipファイルとしてダウンロードし、解凍して、お気に入りのIDEにロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-kafka` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-kafka` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 2 - What are we going to exchange?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ2 - 何を交換するか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We need something to exchange.  Without much originality, let's say we will send and receive `Movie` objects.  In your project, create the `org.acme.Movie` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>交換するものが必要です。あまりオリジナリティを持たずに、 `Movie` オブジェクトを送受信するとしましょう。プロジェクトの中で、以下の内容の `org.acme.Movie` クラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Kafka, we produce and consume records.  A record contains a key and a value.  Let's say we will use the movie's publication year as key and the title as value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka では、レコードを生成、消費します。レコードにはキーと値が含まれています。例えば、映画の公開年をキーにして、タイトルを値にするとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to decide on which topic we are going to send these records.  Let's keep things simple and name our topic __movies__.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、これらのレコードを送信するトピックを決める必要があります。単純化して、トピックを _movies_ としましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 3 - Configure the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ3 - アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  In our application, we must indicate that our reception and publication channels will use the __movies__ Kafka channel.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の通り、Reactive Messagingを使用します。Reactive Messagingを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、基礎となるメッセージング技術に設定によってマッピングされます。このアプリケーションでは、受信および配信チャンネルが _movies_ Kafkaチャンネルを使用することを指定する必要があります。 `src/main/resources/application.properties` で、以下の内容を追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location with `kafka.bootstrap.servers`, we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーの場所を `kafka.bootstrap.servers` で設定した後、 `movies-in` （レコードを受信）と `movies-out` （レコードを配信）の 2 つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the Kafka connector.  We also need to configure the key and value deserializers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mp.messaging.incoming.movies-in` というプレフィックスを使ってチャネルを設定します。 `connector` 属性は、このチャネルを担当するコネクタ (ここでは Kafka コネクタ) を示しています。また、キーと値のデシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicate who's responsible for that channel, we also need to configure the key and value serializers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` のプレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、キーと値のシリアライザも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ 4 - Kafkaにムービーを公開する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send a record to Kafka.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、いよいよKafkaにレコードを送信します。以下の内容で `org.acme.MovieProducer` クラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter`, i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and so will send messages to Kafka).  We are sending `Record` objects containing the movie's publication year as key and its title as value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスでは、 `Emitter` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (つまり、Kafka にメッセージを送信します)。映画の公開年をキーに、タイトルを値にして `Record` オブジェクトを送信しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can simply use the `sendMovieToKafka` method to send a movie to our Kafka topic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、残りのアプリケーションは `sendMovieToKafka` メソッドを使って、Kafka トピックにムービーを送信するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 5 - Consuming movies</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ5 - 映画を消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今度は反対側に目を向けて、Kafkaからムービーを取り出してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here, we use the `@Incoming` annotation to indicate to Quarkus to call the `receive` method for every received record.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、 `@Incoming` アノテーションを使用して、受信したレコードごとに `receive` メソッドを呼び出すようにQuarkusに指示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 6 - Sending movies from a REST endpoint</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ6 - RESTエンドポイントからのムービーの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to Kafka from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST エンドポイントから Kafka にメッセージを送信することはよくあることです。そのためには、以下のような内容の `org.acme.MovieResource` クラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 7 - Let's get this running!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ7 - これを実行してみましょう！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need a Kafka broker.  You can follow the https://kafka.apache.org/quickstart[Apache Kafka quickstart], or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、まずはKafkaブローカーが必要です。 link:https://kafka.apache.org/quickstart[Apache Kafka のクイックスタート] に従うか、以下の `docker-compose.yaml` ファイルを使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します： `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, run the application using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、アプリケーションを次のように実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application runs in dev mode, meaning that you can still update the code.  It will reload it automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションはdevモードで動作します。つまり、コードをまだ変更することが出来、変更した場合、自動的にリロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In another terminal, emit a few HTTP POST request such as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の端末で、次のようなHTTP POSTリクエストをいくつか送信します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the terminal running the application, you will see:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行しているターミナルでは、以下のように表示されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It works!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動いています！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 8 - Native packaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ8 - ネイティブパッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have https://quarkus.io/guides/building-native-image[GraalVM installed and configured correctly], you can package this application as a native executable:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://quarkus.io/guides/building-native-image[GraalVMが正しくインストールされ、設定されている場合] 、このアプリケーションをネイティブの実行ファイルとしてパッケージ化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using Kafka starting in a few milliseconds and consuming a ridiculous amount of memory: less than 30Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `./target/getting-started-kafka-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、Kafkaを使用したQuarkusアプリケーションが数ミリ秒で起動し、消費するメモリ量はとんでもない量：100レコードを取り込んでも30MB未満！になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Summary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using Apache Kafka.  If you want to go further, check the https://quarkus.io/guides/kafka[Kafka guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>10分もしないうちに、Apache Kafkaを使った新しいQuarkusアプリケーションができました。さらに進みたい場合は、 link:https://quarkus.io/guides/kafka[Kafkaガイド]をチェックしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It gives the Quarkus and RESTEasy teams great pleasure to announce that RESTEasy Reactive integration in Quarkus has landed in the main Quarkus repo footnote:disclaimer[Currently the main RESTEasy Reactive component resides at https://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactive in the main Quarkus repository; the plan is however that once things settle, this code will move to https://github.com/resteasy/resteasy-reactive. This move should not affect users of the quarkus-resteasy-reactive extensions in any way, just a heads up if anyone reads this blog post in the future and can’t find it.] and will be part of the next Quarkus release 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusとRESTEasyチームは、QuarkusにおけるRESTEasy Reactiveの統合がメインのQuarkusレポジトリに到着したことを発表することに大きな喜びを感じています。 footnote:disclaimer[現在、メインのRESTEasy Reactiveコンポーネントは、メインのQuarkusリポジトリのhttps://github.com/quarkusio/quarkus/tree/master/independent-projects/resteasy-reactiveにあります。この移動は、quarkus-resteasy-reactive エクステンションのユーザーには何ら影響を与えないはずです。このブログポストを将来読んだ人が見つけられなかった場合に備えての追記。] 次のQuarkusリリース 1.11 に含まれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are looking forward to everyone testing it and providing us as much feedback as possible.  In typical Quarkus fashion, the project is consumable as a new set of extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>皆さまにテストしていただき、できるだけ多くのフィードバックを提供していただけると幸いです。 典型的なQuarkusのやり方で、このプロジェクトは新しいエクステンションのセットとして利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you probably guessed from the name, this work is a *new JAX-RS implementation* written from the ground up to work on our common *Vert.x* layer and is thus fully *reactive*, while also being very *tightly integrated with Quarkus* and consequently moving a lot of framework specific work (like annotation scanning and metamodel generation) to *build time*.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前からお察しの通り、この作品は共通の *Vert.x* レイヤー上で動作するように一から書かれた *新しいJAX-RSの実装* であり、完全に *リアクティブ* であると同時に、 *Quarkusと緊密に統合されて* いるため、フレームワーク固有の作業（アノテーションスキャンやメタモデル生成など）の多くを *ビルド時に* 移行させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why should I care?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜ重要なのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest answer is that you can continue to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最も単純な答えは、アプリケーションの REST レイヤを公開する為に広く使われている非常に強力な JAX-RS API を活用し続けながら、アプリケーションが達成できる最大スループットを大幅に向上できるということです。また、アプリケーションは起動が少し速くなり、メモリの消費量が少し減るはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our benchmarks reveal that the measurable performance with this new extension is almost identical to what we would achieve using Quarkus' Reactive Routes API (which is a very interesting API in its own right, but is generally more low level - not to mention the fact that it's a new API developers would need to learn).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベンチマークでは、この新しいエクステンションを使った測定可能なパフォーマンスは、QuarkusのReactive Routes API（それ自体は非常に興味深いAPIですが、一般的には低レベルなものです）とほぼ同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, when comparing our results to other competing enterprise Java frameworks that provide annotation based REST layers, Quarkus provided as much as double the throughput depending on the benchmark.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、アノテーションベースのRESTレイヤーを提供する他の競合するエンタープライズJavaフレームワークと結果を比較すると、ベンチマークによっては、Quarkusは2倍ものスループットを提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What other benefits are there?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にはどんなメリットがあるのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As if the familiar API and the much improved runtime characteristics of the new extension weren't enough, we have added some really exciting and convenient new features (which are not part of the JAX-RS spec) that have either been requested by the community, or are things we feel improve the developer experience and soften some of the spec’s rough edge.  These new features are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おなじみのAPIと、新しいエクステンションの大幅に改善されたランタイム特性だけでは十分ではないかのように、コミュニティからの要望に基づき、あるいは開発者の経験を向上させ、仕様の粗いエッジを和らげてくれると我々が考える、本当にエキサイティングで便利な新機能（JAX-RS仕様の一部ではありません）をいくつか追加しました。これらの新機能は以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non-blocking by default</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでノンブロッキング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All endpoints are now running on the IO thread by default. You can use `@Blocking` to change that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトではすべてのエンドポイントが IO スレッド上で実行されます。 `@Blocking` を使えばこれを変更出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scoring system</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スコアリングシステム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On dev-mode startup, the application will show you a list of your endpoints, along with a performance score telling you why your endpoint is slower than an optimal version. This helps a lot in figuring out how to improve REST performance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>devモードで起動すると、アプリケーションはエンドポイントのリストを表示し、エンドポイントが最適なバージョンよりも遅い理由を示すパフォーマンススコアを表示します。これは、REST のパフォーマンスを向上させる方法を見つけるのに非常に役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New request/response filter design</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエスト/レスポンスフィルターの新しい設計</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JAX-RS filters require implementing an interface and injecting context objects as fields, which is costly and inflexible. Based on our success in the Quarkus build system, filters are now simply annotated methods and any parameter is automatically injected:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSのフィルターは、インターフェースを実装し、コンテキストオブジェクトをフィールドとして注入する必要がありますが、これはコストがかかり、柔軟性に欠けます。Quarkus ビルドシステムでの成功に基づき、フィルタは単にアノテーション付きのメソッドになり、全てのパラメータは自動的に注入されるようになりました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, if filters need to perform blocking operations, then they can return `Uni&lt;Void&gt;` and RESTEasy Reactive will not block the event-loop thread while executing the filter.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、フィルタがブロッキング操作を行う必要がある場合は `Uni&lt;Void&gt;` を返すことができ、RESTEasy Reactive はフィルタを実行している間はイベントループスレッドをブロックしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, although we haven’t done it yet, this approach could easily be extended to other types of JAX-RS Providers thus completely forgoing the need to use `@Context` in their code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、まだ実施していませんが、このアプローチは他のタイプのJAX-RSプロバイダにも簡単に拡張でき、コード中で `@Context` を使用する必要が完全になくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New `*Param` annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい `*Param` アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These annotations are meant to be used instead of the JAX-RS `@PathParam`, `@QueryParam` etc. annotations, without having the need to specify a name.  The reason we chose not to reuse the same annotation names is to avoid conflicting with either JAX-RS or other EE specs:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのアノテーションは、JAX-RSの `@PathParam`, `@QueryParam` などのアノテーションの代わりに、名前を指定することなく使用することを意図しています。  同じアノテーション名を再利用しないことにしたのは、JAX-RSや他のEE仕様との衝突を避けるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simpler parameter and context injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>よりシンプルなパラメータとコンテキストインジェクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With RESTEasy Reactive you don’t even need to use `@PathParam` or `@RestPath` if your parameter has the same name as a path parameter, and similarly you can skip `@Context` for all the known context types, which makes it even simpler:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive では、パラメータがパスパラメータと同じ名前であれば `@PathParam` や `@RestPath` を使用する必要はありませんし、同様に、既知のすべてのコンテキストタイプに対して `@Context` を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New optimal message body reader / writer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい最適なメッセージボディのリーダー/ライター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no filters and interceptors are invoked when an endpoint is serviced, you can use more efficient message body writers that directly write to vert.x and don’t require reflection and annotations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントがサービスされるときにフィルタやインターセプタが呼び出されない場合、 リフレクションやアノテーションを必要としない、vert.x に直接書き込む、更に効率的なメッセージボディライターを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default content types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのコンテンツタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Endpoints that return a String default to producing text/plain. We plan to do the same for JSON and other types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>String を返すエンドポイントは、デフォルトで text/plain を生成します。JSON やその他の型についても同様のことを行う予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All injections via JAX-RS’s @Context are delegated to Arc. This provides users with the benefits of build time injection that Arc brings to all other parts of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSの@Contextを介したインジェクションはすべてArcに委譲されます。これにより、ユーザーは、ArcがQuarkusの他のすべての部分にもたらすビルドタイムインジェクションのメリットを得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Per-class Exception Mapper</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスごとの例外マッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JAX-RS specification there’s no way to handle exceptions differently for a specific JAX-RS Resource Class - all exception mapping is done in a global manner.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS仕様では、特定のJAX-RSリソースクラスに対して異なる例外を処理する方法はありません - すべての例外のマッピングはグローバルな方法で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In RESTEasy Reactive however you can simply do something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、RESTEasy Reactive では、次のようなことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in order to customize the exception handling of certain Resource Classes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のリソースクラスの例外処理をカスタマイズする為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also note that `@ServerExceptionMapper` can be used to handle exceptions in a global manner, just as JAX-RS does with `ExceptionMapper`.  To do that, simply annotate a method that does not belong to a Resource class with `@ServerExceptionMapper`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、`@ServerExceptionMapper`は、JAX-RSが`ExceptionMapper`を使うのと同じように、グローバルな方法で例外を扱うことができることにも注意する必要があります。  そのためには、Resourceクラスに属さないメソッドに `@ServerExceptionMapper` をアノテーションするだけで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do other extensions work with it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のエクステンションでも動作しますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extensions that integrate with the existing quarkus-resteasy extension also integrate with quarkus-resteasy-reactive extensions. So you can continue to use _CDI_, _Security_, _Metrics_, _JSON_, _Qute_, _Bean Validation_, _OpenAPI_ and enjoy a great out of the box and complete development experience.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のquarkus-resteasyエクステンションと統合するエクステンションは、quarkus-resteasy-reactiveエクステンションとも統合されます。そのため、_CDI_、_Security_、_Metrics_、_JSON_、_Qute_、_Bean Validation_、_OpenAPI_を使い続けることができ、素晴らしいアウトオブボックスと完全な開発体験を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How can I try it out?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どうやって試してみたらいいのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project has landed in the Quarkus master branch, so if you’re eager to try it out, you'll have to build Quarkus from source by following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this] and use the proper BOM and version following https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロジェクトはQuarkus masterブランチにありますので、試してみたい方は、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#building-master[this]のようにソースからQuarkusをビルドし、https://github.com/quarkusio/quarkus/blob/master/CONTRIBUTING.md#updating-the-version[this]のように適切なBOMとバージョンを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, you can also use Maven Snapshots (as Quarkus snapshot builds are uploaded to Sonatype once a day), by specifying version `999-SNAPSHOT` as the Quarkus version and using `quarkus-bom` instead of `quarkus-universe-bom` as the BOM.  There are various ways to enable snapshot versions in Maven. https://stackoverflow.com/a/7717234/2504224[This] StackOverflow answer shows configuration that can be used either on a per project basis or globally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、バージョン `999-SNAPSHOT` をQuarkusのバージョンとして指定し、BOMとして `quarkus-universe-bom` の代わりに `quarkus-bom` を使用することで、Mavenのスナップショットを使用することもできます（Quarkusのスナップショットビルドは1日1回Sonatypeにアップロードされるため）。  Mavenでスナップショットバージョンを有効にするには、さまざまな方法があります。 https://stackoverflow.com/a/7717234/2504224[This] StackOverflowの回答では、プロジェクト単位でもグローバルでも使える設定が示されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The available RESTEasy Reactive extensions are:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能な RESTEasy Reactive エクステンションは以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-jsonb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-resteasy-reactive-qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These extensions are the equivalent to the existing _quarkus-resteasy_* extensions, so simply switching from _quarkus-resteasy-jackson_ to _quarkus-resteasy-reactive-jackson_ in your application should allow you to try RESTEasy Reactive with Jackson integration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのエクステンションは、既存の _quarkus-resteasy_* エクステンションと同等ですので、アプリケーション内で _quarkus-resteasy-jackson_ から _quarkus-resteasy-reactive-jackson_ に切り替えるだけで、Jackson 統合による RESTEasy Reactive を試すことができるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, the _quarkus-jaxrs-client_ extension can be used if you need to use the JAX-RS client (this is not the declarative MicroProfile REST Client, but the programmatic client specified by the JAX-RS spec).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、JAX-RSクライアントを使用する必要がある場合は、_quarkus-jaxrs-client_ エクステンションを使用することができます (これは宣言型MicroProfile RESTクライアントではなく、JAX-RS仕様で定義されたプログラマティッククライアントです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What should I be careful of?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どんなことに気をつければいいのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for the time being this set of extensions is currently considered experimental. Although the project passes almost the entirety of the JAX-RS TCK, it’s just the first release, so keep in mind that it might have more bugs than a typical battle hardened library, while some of the new APIs and SPIs might break.  Despite this being a first release, we do envision this work becoming the default REST layer for Quarkus in the near future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初に注意しなければならないのは、当面の間、この一連のエクステンションは実験的なものと考えられているということです。このプロジェクトはJAX-RS TCKのほぼ全体を通過していますが、まだ最初のリリースに過ぎませんので、典型的な実績のあるライブラリよりも多くのバグがあるかもしれないことを覚えておいてください。 これは最初のリリースですが、近い将来、このライブラリがQuarkusのデフォルトのRESTレイヤーになることを見通しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned in the new features section, requests are served on the event-loop threads by default. This ensures maximum throughput, but also means that no blocking work should be performed on these threads. If you use Blocking IO (for example by accessing a database with Hibernate Panache), be sure to use the `@Blocking` annotation on either the method or the class.  This will ensure that the request will be served on a worker thread. It goes without saying that we are also very interested in hearing your feedback about this default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新機能のセクションで述べたように、デフォルトではリクエストはイベントループスレッド上で処理されます。これは最大のスループットを保証しますが、これらのスレッドでブロッキング作業を行うべきではないことも意味します。ブロッキング IO を使用する場合 (例えば、Hibernate Panache でデータベースにアクセスするなど)、メソッドまたはクラスのいずれかで `@Blocking` アノテーションを必ず使用してください。  これにより、リクエストがワーカースレッドで処理されるようになります。言うまでもなく、このデフォルトについてのフィードバックも非常に興味を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no docs yet. Docs will be added before the formal 1.11 release and will be progressively enhanced.  This email should contain all the information you need to get started, but should you run into any trouble, we are available to help on any of the usual channels (Zulip chat, mailing list, GitHub Issues, StackOverflow).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントはまだありません。ドキュメントは正式な1.11リリースの前に追加され、徐々に強化されていく予定です。  このメールには開始に必要な情報がすべて含まれているはずですが、何か問題が発生した場合は、通常のチャネル（Zulip チャット、メーリングリスト、GitHub Issues、StackOverflow）のいずれかで支援を受けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What JAX-RS features are missing?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どのJAX-RSの機能が欠けていますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We decided to focus on what most users need from a modern REST layer instead of implementing every single feature required by the JAX-RS TCK.  So in that vein, there is no XML support in RESTEasy Reactive, while various arcane features of the spec are also not supported (like _javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、JAX-RS TCK が必要とする機能をすべて実装するのではなく、ほとんどのユーザーが最新の REST レイヤから必要とするものに焦点を当てることにしました。  そのため、RESTEasy Reactive には XML サポートがなく、仕様の様々な難解な機能もサポートされていません（_javax.activation.DataSource_, _javax.annotation.ManagedBean_, _javax.ws.rs.core.StreamingOutput_ のようなもの）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Furthermore, worth noting is that the first release will not contain an implementation of the MicroProfile REST Client based on the new JAX-RS Client (for which there is a dedicated extension). This will most likely change in the near future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、最初のリリースには、 (専用のエクステンションが存在する) 新しい JAX-RS Clientをベースにした MicroProfile REST Client の実装が含まれていないことも注目に値する。これは近い将来に変更される可能性が高い。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's next?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のステップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new extensions will be available with the regular _1.11_ release, we are considering doing a `1.11.0.Alpha1` release to make it as easy as possible for you to try out the new extensions and provide early feedback.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいエクステンションは通常の _1.11_ リリースで利用可能になりますが、新しいエクステンションを出来る限り簡単に試せるように、そしてフィードバックを簡単に出来るように、私たちは `1.11.0.Alpha1` リリースを行うことを検討しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very much looking forward to hearing your thoughts about and experience using RESTEasy Reactive in Quarkus and plan to put it to good use to further improve the project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのさらなる改善の為に、RESTEasy ReactiveをQuarkusで使用した感想や経験を是非お聞かせ下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus-tools1.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus-tools1.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving Forward</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>将来</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have any questions, suggestions or feedback, by all means please https://github.com/redhat-developer/intellij-quarkus/issues[open an issue].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご質問、ご意見、ご感想などがありましたら、ぜひ link:https://github.com/redhat-developer/intellij-quarkus/issues[イシューを開いて]ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thank you for reading and stay tuned for the next release!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お読みいただきありがとうございました。次のリリースをお待ちください！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Links</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リンク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.9.2.Final released - Bugfixes'
date: 2020-11-05
tags: release
synopsis: 1.9.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.9.2.Finalリリース - バグフィックス
date: 2020-11-05
tags: release
synopsis: 1.9.2.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just a week after 1.9.1.Final, here comes 1.9.2.Final with some bugfixes and documentation improvements.  Thanks a lot to everyone providing feedback and pull requests!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.9.1.Finalからちょうど一週間後、バグフィックスとドキュメントの改善を加えた1.9.2.Finalがやってきました。フィードバックとプルリクエストを提供してくださった皆様、ありがとうございました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.9.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus 1.9を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.9 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.9を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9移行ガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This release is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリリースはメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[the full changelog of 1.9.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.2.Final[1.9.2.Finalの完全な変更履歴はGitHub]で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.3.Final released - Bugfixes'
date: 2021-02-11
tags: release
synopsis: 1.11.3.Final mainly fixes a regression when using OpenTracing in combination with RESTEasy in a native executable.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.11.3.Finalリリース - バグフィックス
date: 2021-02-11
tags: release
synopsis: 1.11.3.Finalでは、ネイティブ実行可能ファイルで RESTEasy と組み合わせて OpenTracing を使用した場合のリグレッションを主に修正しました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.3.Final mainly fixes a regression introduced in 1.11.2.Final that makes it impossible to build native executables while using both the RESTEasy and OpenTracing extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.3.Finalは主に1.11.2.Finalで導入された、RESTEasy と OpenTracing の両方のエクステンションを使用している場合にネイティブの実行ファイルをビルドできないようにするリグレッションを修正しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.11 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.11を使用していない場合は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11移行ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[the full changelog of 1.11.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.3.Final[GitHubで1.11.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Stylish API'
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: Swagger UI configuration and custom styling
author: phillipkruger
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: スタイリッシュＡＰＩ
date: 2020-11-25
tags: extension openapi swagger-ui
synopsis: SwaggerのUI設定とカスタムスタイリング
author: phillipkruger
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stylish API</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイリッシュAPI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this blog post we are going to look at the new styling and other new options available in OpenAPI and Swagger UI Quarkus extensions (version 1.10+).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のブログ記事では、OpenAPIとSwagger UIのQuarkusエクステンション（バージョン1.10+）で利用できる新しいスタイリングやその他の新しいオプションについて見ていきたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the source code for the examples below is https://github.com/phillip-kruger/openapi-example[available here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の例のすべてのソースコードは、 https://github.com/phillip-kruger/openapi-example[ここ]にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Styling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default style</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトスタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default style for Swagger UI has changed from the vanilla Swagger UI to a Quarkus branded page:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Swagger UIのデフォルトスタイルがバニラのSwagger UIからQuarkusブランドのページに変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post we mostly focus on Swagger UI, but the styling options also apply to the https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI] and the https://quarkus.io/guides/microprofile-health#health-ui[Health UI].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この記事では主に Swagger UI に焦点を当てていますが、スタイリングオプションは https://quarkus.io/guides/microprofile-graphql#graphiql-ui[GraphQL UI]と https://quarkus.io/guides/microprofile-health#health-ui[Health UI] にも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テーマ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://ostranme.github.io/swagger-ui-themes/[Swagger UI Themes] are now available in configuration, with the default theme being 'feeling blue'.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://ostranme.github.io/swagger-ui-themes/[SwaggerのUIテーマ]が設定で利用できるようになり、デフォルトのテーマは「フィーリングブルー」になっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the theme by setting the `quarkus.swagger-ui.theme` property, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 `quarkus.swagger-ui.theme` プロパティを設定することでテーマを変更することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also go back to the original (vanilla) Swagger UI theme:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、元の（バニラの）Swagger UIテーマに戻すこともできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Theme options available:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テーマのオプションが用意されています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>feeling-blue (default)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>feeling-blue (default)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>flattop</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>flattop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>material</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>material</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>monokai</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>monokai</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>muted</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>muted</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>newspaper</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>newspaper</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>outline</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>outline</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Logo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロゴマーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As part of the custom branding, you can supply your own logo to replace the Quarkus logo. For example, let's say you own a company that makes everything, ACME, and you are using REST Services for your online store, and wants to brand the Swagger UI Page:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムブランディングの一環として、Quarkusのロゴの代わりに独自のロゴを付与することができます。例えば、なんでも屋のACMEという会社を経営していて、オンラインストアにRESTサービスを利用していて、Swagger UIページをブランディングしたいとします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme logo</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme logo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot reload is not working for logo changes, and remember browser cache, you might need to https://refreshyourcache.com/en/cache/[force refresh] your browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホットリロードは、ロゴ変更には動作しません。とブラウザのキャッシュを覚えておいてください。ブラウザを https://refreshyourcache.com/en/cache/[強制的にリフレッシュする]必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To supply your own logo, you need to place a file called `logo.png` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自のロゴを提供するには、 `logo.png`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Style</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go further, and supply your own `style.css`, to fine-tune the branding. As an example, to change the `topbar` of the Swagger UI screen to fit the corporate colors of ACME:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、独自の `style.css`  を提供して、ブランディングを微調整することもできます。例として、Swagger UI画面の `topbar`  を ACME のコーポレートカラーに合わせて変更することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>here set the `topbar` background color.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは `topbar`  の背景色を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme css</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme css</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change any styling element in this css file, you need to place this file called `style.css` in `src/main/resources/META-INF/branding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このCSSファイルの中で、任意のスタイル要素を変更することができます。 `style.css`  というファイルを `src/main/resources/META-INF/branding` に配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other styling options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のスタイリングオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also set the HTML title, and add a footer:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTMLタイトルを設定したり、フッターを追加したりすることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Along with other OpenAPI Header fields that can be set via configuration properties (as discussed in link:/blog/openapi-for-everyone/[this post]):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティを介して設定できる他の OpenAPI Header フィールドと一緒に（ /blog/openapi-for-everyone/[この記事]で説明しています）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The UI is now fully branded:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>UIは完全にブランド化されています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>acme footer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>acme footer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Swagger UI Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のスワガーUIオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another new feature available in Quarkus (version 1.10+) is the ability to set any of the https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[configuration options] available in Swagger UI. As an example, we can set the `urls` and add the petstore (as the default selected option) to Swagger UI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus（バージョン1.10+）で利用できるもう一つの新機能は、Swagger UIで利用できる https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/[設定オプション]を任意に設定できることです。例えば、 `urls`  を設定して、Swagger UI にペットストア（デフォルトで選択されているオプションとして）を追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will change the `topbar` to have a dropdown box with the urls provided:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `topbar`  は、提供されたURLのドロップダウンボックスを持つように変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>petstore</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>petstore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another example, `supportedSubmitMethods` can hide the `Try it out` button for certain HTTP Method Types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別の例として、 `supportedSubmitMethods`  は特定の HTTP メソッドタイプに対して `Try it out`  ボタンを非表示にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note below the missing `Try it out` button on the `POST`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`POST` の `Try it out`  ボタンがなくなっていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>try it out</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>try it out</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the other Swagger UI options are now available to configure the UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他のSwagger UIオプションはすべてUIの設定が可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other small new features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の小さな新機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let me present you two small new features in OpenAPI and Swagger UI: the ability to add the Health Endpoints and the ability to disable the UI and/or Schema at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenAPIとSwagger UIの2つの小さな新機能を紹介します。Health Endpointsを追加する機能と、実行時にUIやSchemaを無効にする機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `smallrye-health` extension, you can add the Health Endpoints to OpenAPI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`smallrye-health`  エクステンションを使用している場合は、OpenAPI にヘルスエンドポイントを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Disable at Runtime</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時に無効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you included the UI in your app (`quarkus.swagger-ui.always-include=true`), you can now disable it when starting the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリにUIが含まれている場合( `quarkus.swagger-ui.always-include=true` )、アプリ起動時にUIを無効にできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will return a *HTTP 404 (Not Found)* on the Swagger UI page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは Swagger UI ページで *HTTP 404 (Not Found) を* 返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Similarly you can disable the schema (usually under `/openapi`) by doing:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>同様に、以下のようにしてスキーマを無効にすることができます (通常は `/openapi`  の下にあります)：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon Lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.amqp.org/[AMQP 1.0] is a standard for passing messages between applications or organizations.  It connects systems, feeds business processes with the information they need, and reliably handles communication between systems.  AMQP is a robust and mature protocol widely used in event-driven applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://www.amqp.org/[AMQP 1.0] は、アプリケーションや組織間でメッセージを渡すための標準規格です。AMQP はシステムを接続し、ビジネスプロセスに必要な情報を供給し、システム間の通信を確実に処理します。AMQP は、イベント駆動型のアプリケーションで広く使用されている堅牢で成熟したプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post is the equivalent of the https://quarkus.io/blog/getting-started-kafka/[Kafka getting started post], but focuses on the usage of AMQP.  You will learn how to get started with AMQP in your Quarkus application in less than ten steps.  We will use https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] - a declarative approach to building event-driven microservices.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この投稿は、 link:https://quarkus.io/blog/getting-started-kafka/[Kafkaの入門記事] と同等の内容を説明しますが、AMQPの使用方法に焦点を当てています。QuarkusアプリケーションでAMQPを使い始める方法を10ステップ以内で学ぶことができます。イベント駆動型マイクロサービスを構築するための宣言的アプローチである link:https://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.7/index.html[SmallRye Reactive Messaging] を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete code is available from https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なコードは link:https://github.com/cescoffier/getting-started-quarkus-amqp[GitHub] から入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/getting-started-amqp/getting-started-amqp-code.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can disable the "Example Code" to avoid the generated project containing examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"Example Code" を無効にすることで、生成されたプロジェクトにサンプルコードが含まれないようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you opened the generated `pom.xml`, you would see that the `quarkus-smallrye-reactive-messaging-amqp` and `quarkus-resteasy-jackson` dependencies are declared, so we're ready to write some code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` を開くと、 `quarkus-smallrye-reactive-messaging-amqp` と `quarkus-resteasy-jackson` の依存関係が宣言されていることがわかります。なのでコードを書く準備が出来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With AMQP, we exchange http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[messages], which can have multiple _data_ sections (or multiple AMQP sequences, or a single AMQP value section).  In our application, as we are exchanging `Movie` object, it encodes the instances as JSON and transfers it in a single _data_ section.  The `content-type` header is set to `application/json`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AMQPでは、複数の _データ_ セクション(または複数のAMQPシーケンス、または単一のAMQP値セクション)を持つことができる link:http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format[メッセージ] を交換します。私たちのアプリケーションでは、 `Movie` オブジェクトを交換しているので、インスタンスを JSON としてエンコードし、単一の _データ_ セクションで転送しています。 `content-type` ヘッダは `application/json` です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AMQP messages are sent to a destination.  To keep things simple, let's name it __movies__.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AMQPメッセージを送信先に送信します。簡単にするために、 __movies__ という名前にしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, we will use Reactive Messaging.  When you use Reactive Messaging, you send messages to a channel and receive them from another channel.  These channels are mapped to the underlying messaging technology by configuration.  We must indicate that our reception and publication channels will use the __movies__ address in our application.  In `src/main/resources/application.properties`, add the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の通り、Reactive Messagingを使用します。リアクティブメッセージングを使用する場合、あるチャンネルにメッセージを送信し、別のチャンネルからメッセージを受信します。これらのチャンネルは、設定によって基礎となるメッセージング技術にマッピングされます。受信および公開チャンネルがアプリケーションで __movies__ アドレスを使用することを示す必要があります。 `src/main/resources/application.properties` で、次の内容を追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After having configured the broker location and credentials (`amqp-` properties), we configure our two channels: `movies-in` (receiving the records) and `movies-out` (publishing the records).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブローカーの場所と資格情報（ `amqp-` プロパティ）を設定した後、 `movies-in` （レコードを受信）と `movies-out` （レコードを公開）の2つのチャンネルを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use the `mp.messaging.incoming.movies-in` prefix to configure the channel.  The `connector` attribute indicates who's responsible for this channel, here the AMQP connector.  We also need to specify the consumed destination using the `address` attribute.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>チャンネルの設定には、 `mp.messaging.incoming.movies-in` というプレフィックスを使用します。 `connector` 属性は、このチャネルの責任者（ここでは AMQP コネクタ）を示します。また、 `address` 属性を使用して、消費先を指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To configure the outbound `movies-out` channel, we use the `mp.messaging.outgoing.movies-out` prefix.  In addition to indicating who's responsible for that channel, we also need to configure the address.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アウトバウンド `movies-out` チャネルを設定するには、 `mp.messaging.outgoing.movies-out` プレフィックスを使用します。そのチャネルを担当するコネクタを示すだけでなく、アドレスも設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Step 4 - Publishing movies to AMQP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ステップ4 - AMQPへのムービーの公開</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, it's time to send messages.  Create the `org.acme.MovieProducer` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、いよいよメッセージを送信する時が来ました。以下の内容で `org.acme.MovieProducer` クラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this class, we inject an `Emitter,` i.e., an object responsible for sending a message to a channel.  This emitter is attached to the `movies-out` channel (and will send messages to AMQP).  The connector automatically encoded the content as JSON and set the `content-type` header.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスでは、 `Emitter,` 、つまりチャンネルへのメッセージ送信を担当するオブジェクトを注入します。このエミッタは `movies-out` チャンネルにアタッチされています (AMQP にメッセージを送信します)。コネクタは自動的にコンテンツを JSON としてエンコードし、 `content-type` ヘッダを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to make sure your payload can be encoded to JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ペイロードが JSON にエンコードできることを確認する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, the rest of our application can use the `send` method to send a movie to our AMQP destination.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、私たちのアプリケーションの残りの部分は、 `send` メソッドを使用して、AMQP の宛先にムービーを送信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now look at the other side and retrieve the movies from AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今度は反対側に目を向けて、AMQPからムービーを取得してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remember, the movie is encoded into JSON, so we need to help the connector produce a `Movie` from the received JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ムービーは JSON にエンコードされていることを思い出してください。コネクタが受信した JSON から `Movie` を生成するのを支援する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `org.acme.JsonToObjectConverter` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の内容の `org.acme.JsonToObjectConverter` クラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class is a _converter_.  It maps the content of a `Message` to another type.  In the `canConvert` method, we verify that the incoming message is coming from AMQP (so contain the `IncomingAmqpMetadata` metadata) and that the content-type is set to `application/json`.  The `convert` method maps the received `JsonObject` into the target type (`Movie` in our case).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは _converter_ です。 `Message` の内容を別の型にマッピングします。 `canConvert` メソッドでは、受信メッセージが AMQP からのものであること (つまり `IncomingAmqpMetadata` メタデータを含むこと) と、content-type が `application/json` に設定されていることを確認します。 `convert` メソッドは、受信した `JsonObject` をターゲット型 (私たちの場合は `Movie` ) にマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this converter, our `consume` method will receive the `Movie` objects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコンバータにより、 `consume` メソッドは `Movie` オブジェクトを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's quite common to send messages to AMQP from a REST endpoint.  To do this, create the `org.acme.MovieResource` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントからAMQPにメッセージを送信することはよくあることです。これを行うには、以下の内容で `org.acme.MovieResource` クラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This class uses the `MovieProducer` we implemented above to send the `movies`.  You could also use an `Emitter` directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは、上で実装した `MovieProducer` を使用して `movies` を送信します。 `Emitter` を直接使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Well, first, we need an AMQP broker, for example http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis].  You can follow the http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] documentation, or use the following `docker-compose.yaml` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、AMQPブローカー、例えば link:http://activemq.apache.org/components/artemis/[Apache ActiveMQ Artemis] が必要です。 link:http://activemq.apache.org/components/artemis/documentation/latest/using-server.html[Getting Started with Artemis] のドキュメントに従うか、以下の `docker-compose.yaml` ファイルを使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy the `docker-compose.yaml` file in your project, and from a terminal, start your broker with: `docker-compose up -d'</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト内に `docker-compose.yaml` ファイルをコピーし、ターミナルから、ブローカーを起動します： `docker-compose up -d`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, execute your native executable with: `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner`, and you get a Quarkus application using AMQP starting in a few milliseconds and consuming a ridiculous amount of memory: only 33Mb after 100 ingested records!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、 `./target/getting-started-amqp-1.0.0-SNAPSHOT-runner` でネイティブの実行ファイルを実行すると、AMQPを使用したQuarkusアプリケーションが数ミリ秒で起動し、とんでもない量：100レコードを取り込んでもたったの33MB！になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In less than 10 minutes, we have a new Quarkus application using AMQP.  If you want to go further, check the https://quarkus.io/guides/amqp[AMQP guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>10分もしないうちに、AMQPを使った新しいQuarkusアプリケーションができました。もっと詳しく知りたい方は、 link:https://quarkus.io/guides/amqp[AMQPガイド] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Conclusion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>結論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven Reactive Programming library.  Like other reactive programming libraries, it uses streams as the primary construct.  These streams convey events, and your code processes these events.  Most of the time, your code is only interested in item and failure events.  But there are other kinds of events such as cancellation, request, completion, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。他のリアクティブ・プログラミング・ライブラリと同様に、主要な構成要素としてストリームを使用します。これらのストリームはイベントを伝え、あなたのコードはこれらのイベントを処理します。ほとんどの場合、あなたのコードはアイテムイベントと失敗イベントにしか興味がありません。しかし、キャンセル、リクエスト、完了などの他の種類のイベントもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not rare that you need to look at these various events to understand better what's going on or implement specific side effects. For example, you may need to close a resource after a completion event or log a message on failure or cancellation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何が起こっているのかをよりよく理解したり、特定の副作用を実装したりするために、これらの様々なイベントを見る必要があることは稀ではありません。例えば、完了イベントの後にリソースを閉じたり、失敗やキャンセル時にメッセージをログに記録したりする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each kind of event, there is an associated _group_ providing the methods to handle that specific event: `onItem()`, `onFailure()`, `onCompletion()` and so on.  These groups provide two methods to peek at the various events without impacting its distribution: `invoke` and `call`.  It does not transform the received event; it notifies you that something happened and let you react.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントの種類ごとに、その特定のイベントを処理するための方法を提供する関連 _グループ_ があります: `onItem()`, `onFailure()`, `onCompletion()` など。これらのグループは、配信に影響を与えずに様々なイベントを覗くための 2 つの方法を提供しています: `invoke` と `call` 。これらのグループは、受信したイベントを変換するのではなく、何かが起こったことを通知して反応させてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The invoke method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>invoke メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method is synchronous and does not return anything.  Mutiny invokes the configured callback when the observed stream dispatches the event:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` メソッドは同期で、何も戻りません。Mutinyは、観測されたストリームがイベントをディスパッチするときに、設定されたコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As said above, `invoke` is synchronous.  Mutiny invokes the callback and propagates the event downstream when the callback returns. It blocks the dispatching.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上で述べたように、 `invoke` は同期です。Mutinyはコールバックを呼び出し、コールバックが戻ってきたらイベントを下流に伝播させます。ディスパッチをブロックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-invoke-call/invoke.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Of course, we highly recommend you not to block.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もちろん、ブロックしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following snippets show how you can log the different types of events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のスニペットは、さまざまな種類のイベントをログに記録する方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The arrows from the previous code snippet indicate if the event comes from the upstream (source) or downstream (consumer).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のコードスニペットの矢印は、イベントが上流（ソース）から来るのか、下流（コンシューマ）から来るのかを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` method does not change the event, except in one case.  If the `invoke` callback throws an exception, the downstream does not get the actual event but get a failure event instead.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` メソッドは、1 つのケースを除いて、イベントを変更しません。 `invoke` コールバックが例外をスローした場合、ダウンストリームは実際のイベントを取得せず、代わりに失敗イベントを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When observing the failure event, if the callback throws an exception, Mutiny propagates a `CompositeException` aggregating the original failure and the callback failure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>失敗イベントを観測しているときに、コールバックが例外を投げると、Mutinyは元の失敗とコールバックの失敗を集約した `CompositeException` を伝播します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The call method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>呼び出し方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike `invoke`, `call` is asynchronous, and the callback returns a `Uni&lt;?&gt;` object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` とは異なり、 `call` は非同期で、コールバックは `Uni&lt;?&gt;` オブジェクトを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call` is often used when you need to implement asynchronous side-effects, such as closing resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`call` リソースを閉じるなど、非同期の副作用を実装する必要がある場合によく使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny does not dispatch the original event downstream until the Uni returned by the callback emits an item:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyは、コールバックによって返されたUniがアイテムを放出するまで、元のイベントを下流にディスパッチしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As shown in the previous snippet, you can use this approach to delay items. 
But the primary use case is about completing asynchronous actions:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のスニペットが示すように、このアプローチを使用してアイテムを遅らせることもできます。
ただし、主なユースケースは非同期アクションの完了に関するものです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>multi
    .onCompletion().call(() -&gt; resource.close())
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Under the hood, Mutiny gets the `Uni` (by invoking the callback) and subscribes to it. 
It observes the item or failure event from that `Uni`. 
It discards the item value as only the emission matters in this case.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>内部的には、Mutinyは `Uni` を（コールバックを呼び出すことによって）取得し、サブスクライブします。 
`Uni`からアイテムまたは障害イベントを監視します。
この場合、排出のみが重要であるため、アイテムの値は破棄されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the callback throws an exception or the produced `Uni` produces a failure, Mutiny propagates that failure (or a `CompositeException`) downstream, replacing the original event. 
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コールバックが例外をスローするか、生成された `Uni` が失敗を生成した場合、Mutinyはその失敗（または `CompositeException` ）をダウンストリームに伝播し、元のイベントを置き換えます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `invoke` and `call` methods are handy when you need to observe a stream without changing the transiting events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke` と `call` メソッドはストリームをイベントを変更せずに観察するのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use `invoke` for implementing synchronous side-effects or logging events.  The asynchronous nature of `call` makes it perfect for implementing asynchronous side-effects, such as closing resources, flushing data, delay items, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke`を同期の副作用操作やイベントのロギングの実装の為に使用してください。 `call`の非同期性は、非同期副作用操作、例えばリソースのクローズ、データのフラッシュ、アイテムの遅延などを実装するのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table highlights the key differences:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のテーブルが主な違いを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`invoke`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`invoke`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`call`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`call`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nature</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Return type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>戻り値の型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`void`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`void`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Uni&lt;?&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Main Use cases</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>主なユースケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These methods are available for every kind of event in the associated group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのメソッドは、関連するグループ内のあらゆる種類のイベントに対して利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a https://quarkus.io/blog/kafka-failure-strategy/[previous blog post], we have looked at failure strategies provided by the Reactive Messaging Kafka connector.  But, imagine it's our lucky day, and for once it worked.  We should inform Kafka that the processing succeeded.  In Kafka terminology, we call this: _offset commit_.  This post covers the different strategies to commit offsets with the Reactive Messaging Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://quarkus.io/blog/kafka-failure-strategy/[以前のブログ記事]では、Reactive Messaging Kafkaコネクタが提供する失敗戦略を見てきました。しかし、想像してみてください、それは幸運な日で、一度だけ成功しました。処理が成功したことをKafkaに知らせなければなりません。Kafkaの用語では、これを _オフセットコミット_ と呼びます。この記事では、Reactive Messaging Kafka コネクタを使ったオフセットコミットのさまざまな戦略について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Kafka Consumer Group and Offsets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafkaコンシューマーグループとオフセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka organizes records (_i.e._ messages) around _topics_.  Each topic has a name, and applications send records to topics and poll records from topics.  So far, nothing out of the ordinary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka は、 _トピックを_ 中心にレコード ( _即ち_ メッセージ) を整理します。各トピックには名前があり、アプリケーションはトピックにレコードを送り、トピックからレコードをポーリングします。今のところ、特別なことは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Topics are divided into partitions.  Each partition is an ordered, immutable sequence of records.  Sending a message to a topic appends it to the selected partition.  Each message from a partition gets a sequential id number called _offset_.  It uniquely identifies each message within the partition.  So, with Kafka, you can identify an individual record using a `&lt;topic, partition, offset&gt;` tuple.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トピックはパーティションに分割されます。各パーティションは、順序立てられた不変のレコードのシーケンスです。トピックにメッセージを送信すると、選択したパーティションにメッセージが追加されます。パーティションからの各メッセージは、 _offset_ と呼ばれる連続した ID 番号を取得します。これはパーティション内の各メッセージを一意に識別します。つまり、Kafka を使うと、 `&lt;topic, partition, offset&gt;` タプルを使って個々のレコードを識別することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-commit-strategies/topics-partitions.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When an application consumes messages from Kafka, it uses a Kafka consumer.  With this consumer, it polls batches of messages from a specific topic, for example, `movies` or `actors`.  Retrieved messages belong to partitions assigned to this consumer.  And that aspect is essential.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが Kafka からのメッセージを消費するとき、アプリケーションは Kafka コンシューマを使用します。このコンシューマでは、特定のトピック、例えば `movies` や `actors` などからのメッセージのバッチをポーリングします。取得したメッセージは、このコンシューマに割り当てられたパーティションに属します。そして、この点が重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumers belong to a consumer group, identified with a name (`A` and `B` in the picture above).  A group contains one or more consumers.  In general, when you scale up your application, it creates a consumer joining the same group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンシューマーは、名前（上の図では `A` と `B` ）で識別されるコンシューマーグループに属しています。1 つのグループには 1 つ以上のコンシューマーが含まれます。一般的に、アプリケーションをスケールアップすると、同じグループに参加するコンシューマーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/kafka-commit-strategies/consumer-groups.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each consumer group receives each record from a topic once.  To achieve this, it assigns each consumer from a group to a set of partitions.  For example, in the above picture, the consumer from the application A1 receives the records from the partitions 0 and 1.  A2 receives the records from the partition 2.  App B is the only consumer from its consumer group.  So, it gets the records from all three partitions.  Consequently (ignore rebalance or other subtilities for now), each record from a topic is only received once per consumer group, by a specific consumer from that group.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各コンシューマーグループは、トピックから各レコードを一度だけ受け取ります。これを実現するために、グループからの各コンシューマーをパーティションのセットに割り当てます。例えば、上の図では、アプリケーションA1のコンシューマーはパーティション0と1からレコードを受信し、A2はパーティション2からレコードを受信します。アプリBは、そのコンシューマグループからの唯一のコンシューマーです。したがって、3つのパーティションすべてからレコードを取得します。したがって、(今のところリバランスや他のサブユーティリティは無視して)あるトピックの各レコードは、そのグループの特定のコンシューマーによって、コンシューマーグループごとに 1 回だけ受信されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To orchestrate each consumer group's progress, each consumer periodically informs the broker of its current position - the last processed offset.  It commits the offset, indicating that all the previous records from that partition have been processed.  So, if a consumer stops and comes back later, it restarts from the last committed position (if assigned to that partition again).  Note that this behavior is configurable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各コンシューマーグループの進捗を調整するために、各コンシューマーは定期的に現在の位置、つまり最後に処理されたオフセットをブローカに通知します。コンシューマは、そのパーティションの以前のレコードがすべて処理されたことを示すオフセットをコミットします。つまり、あるコンシューマーが停止して後で戻ってきた場合、最後にコミットされた位置から再スタートします（再びそのパーティションに割り当てられた場合）。この動作は設定可能であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What's important to notice is the periodic aspect of the commit.  Offset commit is expensive, and to enhance performance, we should not commit the offset after each processed record.  In this regard, Kafka behaves differently from traditional messaging solutions, such as JMS, which acknowledges each message individually.  Another important characteristic is the positional aspect of the commit.  You commit the position indicating that all the records located before that position are processed.  But is it really the case?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注目すべきは、コミットの周期的な側面です。オフセットコミットはコストがかかるので、パフォーマンスを向上させるためには、処理された各レコードの後にオフセットをコミットするべきではありません。この点で、Kafkaは、JMSのような従来のメッセージングソリューションとは異なる振る舞いをしており、各メッセージを個別に認識します。もう一つの重要な特徴は、コミットの位置的な側面です。位置をコミットすると、その位置より前にあるすべてのレコードが処理されることを示します。しかし、本当にそうなのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>### The Kafka default behavior</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka のデフォルトの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Apache Kafka consumer uses an auto-commit approach by default.  Applications using such a consumer are structured around a polling loop:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Kafka のコンシューマーはデフォルトで自動コミットアプローチを使用しています。このようなコンシューマを使うアプリケーションはポーリングループを中心に構成されています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a program polls a batch of records, processes them, and then polls the next set.  While calling the `poll` method, the consumer periodically commits the last offset of the previous batches transparently.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなプログラムは、レコードのバッチをポーリングして処理し、次のセットをポーリングします。 `poll` メソッドを呼び出している間、コンシューマーは定期的に前のバッチの最後のオフセットを透過的にコミットします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite nice, right? If the application fails to process a message, it throws an exception, which either interrupts the while loop or is handled gracefully (within the `processRetrievedRecords` method).  In the first case, it means that it won't commit anymore (as it happens in the `poll` method, not called anymore).  If the application restarts, it resumes from the last committed offset (or apply the `auto.offset.reset` strategy, defaulting to `latest`, if there are no offsets for this group yet).  It may re-process a set of messages (it's the application's responsibility to handle duplicates), but at least nothing is lost.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なかなかいいですよね？アプリケーションがメッセージの処理に失敗した場合、アプリケーションは例外をスローし、while ループを中断するか、( `processRetrievedRecords` メソッド内で) 優雅に処理されます。最初のケースでは、それはもうコミットしないことを意味します（ `poll` メソッド内で発生するので、もう呼ばれません）。アプリケーションが再起動した場合、最後にコミットされたオフセットから再開します (または `auto.offset.reset` ストラテジーを適用し、このグループのオフセットがまだない場合は `latest` をデフォルトとして使用します)。一連のメッセージを再処理するかもしれませんが(重複を処理するのはアプリケーションの責任です)、少なくとも何も失われることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, is there anything wrong with this? Looks wonderful... until you add a pinch of asynchrony.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それで、これに何か問題があるの？見た目は素晴らしい...非同期のピンチを追加するまでは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What if the message's processing is asynchronous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## メッセージの処理が非同期の場合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the message processing is asynchronous (offloaded to another thread, use non-blocking I/O...), failures may not interrupt the while loop from above.  Failure happens asynchronously, outside the polling thread.  If the `poll` method gets called again despite a failed processing, and _auto-commit_ is still enabled, we may commit offsets while something wrong happened.  If some processing of previously retrieved records is not completed yet, while this auto commit happens, it may consider the record as processed correctly, but the outcome is unknown at that point.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージ処理が非同期（他のスレッドにオフロードされている、ノンブロッキングI/Oを使用している...）であれば、失敗は上からwhileループを中断しないかもしれません。失敗はポーリングスレッドの外で非同期に起こります。処理に失敗したにもかかわらず `poll` メソッドが再び呼び出され、 _オートコミット_ がまだ有効になっている場合、何か間違ったことが起こっている間にオフセットをコミットすることがあります。このオートコミットが発生している間に、以前に取得したレコードの処理がまだ完了していない場合、そのレコードは正しく処理されたとみなされるかもしれませんが、その時点では結果はわかりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So to handle these case, we can disable the auto-commit and switch to manual commit.  In this case, it's the application's responsibility to commit the offsets regularly.  So, the application needs to track the polled records, their processing, failures, and periodically commits the offsets.  It might not look too tricky, but actually, it can become quite challenging.  Again, in asynchronous scenarios, you may complete the processing of messages in various orders.  For example, if you call a remote service for each record, the responses may not come in the same orders as the records.  You need to track messages individually and only commit the offsets if all the previous messages are processed successfully.  Without this, you may commit offsets while there is processing from previous records still in progress or even failed processing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そこで、これらのケースを処理するために、自動コミットを無効にして手動コミットに切り替えることができます。この場合、定期的にオフセットをコミットするのはアプリケーションの責任です。したがって、アプリケーションはポーリングされたレコード、その処理、失敗を追跡し、定期的にオフセットをコミットする必要があります。これはそれほどトリッキーには見えないかもしれませんが、実際には非常に困難になることがあります。繰り返しになりますが、非同期のシナリオでは、様々な順序でメッセージの処理を完了させることができます。例えば、各レコードに対してリモートサービスを呼び出した場合、レスポンスはレコードと同じ順番で来るとは限りません。メッセージを個別に追跡し、前のすべてのメッセージが正常に処理された場合にのみオフセットをコミットする必要があります。これがないと、前のレコードからの処理がまだ進行中であったり、処理に失敗した場合にオフセットをコミットすることになるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What can we do about this?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはどうしたらいいのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Reactive Messaging and the Kafka connector, you entered an asynchronous world.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Messaging と Kafka コネクタを使用すると、非同期の世界に入りました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message processing may not happen synchronously and sequentially.  When a Reactive Messaging `Message` processing completes, it acknowledges the message.  In the case of processing failures, it sends a negative acknowledgment.  The Kafka connector receives these acknowledgments and can decide what needs to be done, basically: to commit or not to commit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージ処理は、同期的・逐次的に行われるとは限りません。リアクティブメッセージング `Message` 処理が完了すると、メッセージを確認します。処理に失敗した場合は、否定的な確認応答を送信します。Kafka コネクタはこれらの確認応答を受信して、コミットするかしないかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can choose among three strategies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>3つの戦略から選択することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ignore (default if `enabled.auto.commit=true` is set)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>無視 ( `enabled.auto.commit=true` が設定されている場合のデフォルト)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is configured using the `commit-strategy` attribute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `commit-strategy` 属性を使用して設定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The throttled strategy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## スロットル化された戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The throttled strategy can be seen as an asynchronous variant of the default "auto-commit" behavior described above.  When enabled, the connector tracks each received message and monitors their acknowledgment.  When the connector finds out that all messages before a position are processed successfully, it commits that position.  This commit happens periodically to avoid committing too often.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スロットル戦略は、上述のデフォルトの「オートコミット」動作の非同期的な変形として見ることができます。有効にすると、コネクタは受信した各メッセージを追跡し、その確認応答を監視します。コネクタは、あるポジションの前のすべてのメッセージが正常に処理されたことを確認すると、そのポジションをコミットします。このコミットは、頻繁にコミットしないように定期的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy provides very good throughput and can handle asynchronous processing.  To enable this strategy configures the channel with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このストラテジーは非常に優れたスループットを提供し、非同期処理を処理することができます。このストラテジーを有効にするには、チャネルを以下のように設定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is one detail to mention.  If an old message is neither acked nor nacked, the strategy cannot commit the position anymore.  It will enqueue messages forever, waiting for that missing ack to happen.  It can lead to out of memory, as the connector would never be able to commit a position and to clear the queue.  Fortunately, the strategy detects this situation and reports a failure to the connector, marking the application unhealthy.  The `throttled.unprocessed-record-max-age.ms` attribute configures the deadline for each message to be acked or nacked before being considered as a poison pill (Default is 1 minute).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一つだけ注意すべき点があります。古いメッセージが ack されず、nack されない場合、ストラテジーはもうポジションをコミットすることができません。それは永遠にメッセージをエンキューし、その欠落したアックが起こるのを待ちます。これは、コネクタがポジションをコミットしてキューをクリアすることができなくなるため、メモリ不足につながる可能性があります。幸いなことに、このストラテジーはこの状況を検出してコネクタに失敗を報告し、アプリケーションが不健全であることをマークします。 `throttled.unprocessed-record-max-age.ms` 属性は、ポイズンピルとみなされる前に、各メッセージが ack されるか nacked されるかの期限を設定します (デフォルトは 1 分です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector uses this strategy by default if you explicitly enabled Kafka's auto-commit (with the `enable.auto.commit` attribute set to `true`).  In this case, the connector ignores acknowledgment and won't commit the offsets.  The Kafka consumer commits the offset periodically when polling batches, as described above.  This strategy works well if the message processing is synchronous and failures handled gracefully.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka の自動コミットを明示的に有効にした場合 ( `enable.auto.commit` 属性を `true` に設定した場合)、コネクタはデフォルトでこのストラテジーを使用します。この場合、コネクタは確認応答を無視してオフセットをコミットしません。Kafka コンシューマは、前述のように、バッチをポーリングする際に定期的にオフセットをコミットします。この方法は、メッセージ処理が同期的で、失敗があっても潔く処理される場合に有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can enable this strategy by configured enabled-auto-commit to true:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>enabled-auto-commitをtrueに設定することで、このストラテジーを有効にすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be aware that starting Quarkus 1.9, auto commit is disabled by default. So you need to explicitly enable it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.9からは、オートコミットがデフォルトで無効になっていることに注意してください。そのため、明示的に有効にする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't enable auto-commit, using this strategy is still possible but will never commit the offsets.  In other words, you would restart from the oldest stored records every time.  While there are use cases for this, double-check that's what you want. In this case, enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オートコミットを有効にしていない場合、この戦略を使用することは可能ですが、オフセットをコミットすることはありません。言い換えれば、保存されている最も古いレコードから毎回再起動することになります。これにはユースケースがありますが、あなたが望むものであることを再確認してください。当てはまる場合、以下のようにこのストラテジーを有効にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## The latest strategy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 最新の戦略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This strategy commits the offset every time a message is acknowledged.
This strategy tends to commit often, and so decrease the throughput.   
However, it also reduces the risk of duplicates if the messages are processed synchronously. 
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このストラテジーは、メッセージが確認されるたびにオフセットをコミットします。
このストラテジーは頻繁にコミットする傾向があるため、スループットが低下します。
しかし、メッセージが同期的に処理されている場合には、重複のリスクを減らすことができます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable this strategy with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この戦略を有効にするのは以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Conclusion</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 結論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, use the `throttled` strategy.  It provides high-throughput and handles the asynchronous use cases.  This strategy is becoming the default strategy in Quarkus 1.10.  You can also switch to the `ignore` strategy if the Kafka auto-commit is acceptable for you, or if you want to skip offset commit altogether.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的には、 `throttled` 戦略を使用します。これはハイスループットを提供し、非同期のユースケースを処理します。このストラテジーは、Quarkus 1.10ではデフォルトのストラテジーになっています。また、Kafkaのオートコミットが許容できる場合や、オフセットコミットを完全にスキップしたい場合は、 `ignore` 戦略に切り替えることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That concludes this blog post.  The next one will discuss how to receive and produce Cloud Events using the Kafka connector.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以上でこのブログ記事は終了です。次回は、Kafkaコネクタを使ってクラウドイベントを受信して生成する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.5.Final released - Bugfixes'
date: 2020-12-16
tags: release
synopsis: 1.10.5.Final fixes several important issues in Quarkus 1.10.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.10.5.Finalリリース - バグフィックス
date: 2020-12-16
tags: release
synopsis: 1.10.5.Finalでは、Quarkus 1.10のいくつかの重要な問題が修正されました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.5.Final is a maintenance release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.5.Final はメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a safe upgrade for everyone using Quarkus 1.10.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.10を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not using 1.10 already, please refer to the https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10 migration guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだ1.10をお使いでない方は、 link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10移行ガイド] をご参照ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It fixes some important issues in Quarkus, most notably in the Hibernate ORM extension which got Hibernate ORM upgraded to 5.4.26.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの幾つかの重要な課題を修正します。特に注目すべき点として、Hibernate ORMエクステンションにおいて、Hibernate ORMが5.4.26.Finalにアップグレードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[the full changelog of 1.10.4.Final] and the https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[full changelog for 1.10.5.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.4.Final[1.10.4.Finalの完全な変更履歴]と https://github.com/quarkusio/quarkus/releases/tag/1.10.5.Final[1.10.5.Finalの完全な変更履歴] をGitHubで取得出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just before my PTO, someone told me: '_I don't like magic._' In this context, _magic_ refers to the amount of hidden _stuff_ done by Quarkus under the hood for the sake of simplicity.  It includes dependency injection, annotations, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>有休の直前に 誰かに言われました _"私はマジックが好きじゃない"_ って。この文脈では、 _マジック_ とは、シンプルにするためにQuarkusが裏側で行っている隠れた _作業_ のことを指します。これには依存性注入やアノテーションなどが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not the first time that I get that kind of comment, and coming from the Vert.x project, it makes sense.  Vert.x has (almost) no magic, and for a good reason: too much magic can be terrible and make production tuning utterly expensive.  Sometimes you want to have more control and avoid unexpected behaviors: execute the code you wrote, and nothing else.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなコメントを受けるのは初めてではないし、Vert.xプロジェクトから来ているので、それは理にかなっています。Vert.x には（ほとんど）マジックがありませんが、それには正当な理由があります: マジックが多すぎるとひどいことになり、プロダクションチューニングが全く大変になります。時には、より多くの制御をして予期せぬ動作を避けたい場合があります: ただ書いたコードだけが実行され、それ以外は何もしないで欲しい、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But magic is not inherently bad.  Magic is power that can be used for good or for bad.  After all, your application runs on a silicon with microcode magic powering an Operating System with abstraction magic powering the Java Virtual Machine with Just In Time magic.  There is magic, it's just magic you have enough knowledge (or trust) of vs magic you don't.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、マジックは本質的に悪いものではありません。マジックは良いことにも悪いことにも使えるパワーなのです。結局のところ、あなたのアプリケーションは、マイクロコードで力を与えられた半導体上で実行される、抽象化のマジックで力を与えられたオペレーティングシステム上の、JITのマジックで力を与えられたJava仮想マシンで動いています。マジックはありますが、それはあなたが十分な知識を持っている（または信頼している）マジックと、そうでないマジックのことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may think that Quarkus has a lot of magic tricks.  It is true in some sense but it is easily understood and comes with strong benefits in either memory optimization, startup time optimization or last but not least developer experience improvements.  You can decide the amount of magic that you want and the amount of control you feel comfortable with.  You don't have to use dependency injection or managed clients if you prefer doing things yourself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusにはたくさんのマジックのトリックがあると思うかもしれません。ある意味ではそうなのですが、簡単に理解でき、メモリの最適化、起動時間の最適化、または開発者の経験の向上のいずれかにおいて強力なメリットがあります。あなたが望むマジックの量と、あなたが快適に感じるコントロールの量を決めることができます。もし自分でやりたいのであれば、依存性注入や管理クライアントを使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this post, we will cover three different approaches to reducing the amount of magic.  We will go from almost no magic to just enough to get a good developer experience.  Examples from this blog post are available on https://github.com/cescoffier/quarkus-magic-control[GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回の記事では、マジックの量を減らすための3つの異なるアプローチを取り上げます。マジックをほとんど使わない状態から、良い開発者体験を得るために必要なだけの状態にしていきます。このブログ記事の例は link:https://github.com/cescoffier/quarkus-magic-control[GitHub]で公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The _almost no magic_ approach</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_ほとんどマジックがない_ アプローチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are Java applications.  So, somewhere there is a `public static void main(String... args)`.  While you don't need to write that method when using Quarkus, it can still be convenient and give you more control about your application startup.  It's also a good trick to start your Quarkus application directly from your IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのアプリケーションはJavaアプリケーションです。そのため、どこかに `public static void main(String…​ args)` が存在します。Quarkusを使用する際にそのメソッドを記述する必要はありませんが、それでも便利で、アプリケーションの起動についてより多くのコントロールが可能になります。また、IDEから直接Quarkusアプリケーションを起動するのも良いでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an example, we will implement a straightforward HTTP application. Nothing fancy:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例として、簡単な HTTP アプリケーションを実装します。派手なものは何もありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The complete source code is available https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[here].  Don't expect much more; the application had only one Java class, but let's look into it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全なソースコードは link:https://github.com/cescoffier/quarkus-magic-control/tree/main/no-magic-example[ここ]にあります。アプリケーションにはJavaクラスが1つしかありませんが、それを調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@QuarkusMain` indicates that Quarkus should use this class as the _main entry point_ of the application.  The `run` method contains your application logic.  We will come back to this logic later.  First, look at the `public static void main(String... args)` method.  It just starts the application.  You can use this entry point directly from your IDE.  Yes, there is still a bit of magic behind `Quarkus.run`; that's where the extension initialization happens - not unlike _any_ framework initialization including Vert.x.  As this application does not use any extension, nothing much will happen.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusMain` は、Quarkusがこのクラスをアプリケーションの _メインエントリーポイント_ として使用することを示しています。 `run` メソッドには、アプリケーションのロジックが含まれています。このロジックについては後ほど説明します。まず、 `public static void main(String…​ args)` メソッドを見てください。これはアプリケーションを起動するだけです。このエントリーポイントは、IDE から直接使用できます。そう、 `Quarkus.run` の背後にはまだちょっとしたマジックがあります。エクステンションの初期化が行われるのは、 Vert.x を含む _どの_ フレームワークの初期化とも異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[depends] directly on Vert.x Web and Vert.x Core.  The only Quarkus dependency is Arc (not used directly but required):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションは Vert.x Web と Vert.x Core に直接 link:https://github.com/cescoffier/quarkus-magic-control/blob/main/no-magic-example/pom.xml#L17-L26[依存します]。Quarkusの依存関係はArcだけです（直接は使用しませんが必須です）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's go back to the `run` method.  It contains the application logic, here, a dummy Vert.x application.  It creates the `Vertx` instance, a `Router`, registers a few routes, and starts the HTTP server.  Because we don't want the application to stop immediately, we _wait for exit_.  The `/bye` request handler illustrates how you can programmatically trigger the application shutdown.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`run` メソッドに戻りましょう。これにはアプリケーション・ロジックが含まれており、ここではダミーの Vert.x アプリケーションを使用しています。 `Vertx` インスタンス、 `Router` を作成し、いくつかのルートを登録し、HTTP サーバーを起動します。アプリケーションをすぐに停止させたくないので、 _終了を待ちます_。 `/bye` リクエスト・ハンドラは、アプリケーションのシャットダウンをプログラムでトリガーする方法を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This application has almost no magic, just a single annotation, and a regular Java entry point.  You may wonder why not using a bare Java program? Even used that way, Quarkus provides benefits. For example, you can access the built-in configuration support as illustrated in the snippet:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプリケーションにはマジックはほとんどなく、ただのアノテーション1つと、普通のJavaのエントリーポイントがあるだけです。なぜむき出しのJavaプログラムを使わないのかと疑問に思うかもしれません。そのように使用しても、Quarkusには利点があります。例えば、スニペットに示されているように、組み込みの設定サポートにアクセスすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration is located in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定は、 `application.properties` ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This first approach has a few drawbacks.  It does not benefit from the built-time processing of Quarkus.  The logic executed at build time is packaged inside extensions, and in this case, we don't use extensions (except Arc).  Another issue is that compiling this application to native will fail because extensions are also involved during the native compilation.  Finally, the hot reload won't work, but you can directly restart the application from your IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この最初のアプローチには、いくつかの欠点があります。これはQuarkusのビルド時処理の恩恵を受けていません。ビルド時に実行されるロジックはエクステンションの中にパッケージ化されており、この場合はエクステンションは使用されません（Arcを除く）。もう一つの問題は、このアプリケーションをネイティブにコンパイルすると、ネイティブのコンパイル時にエクステンションも絡んでくるので失敗するということです。最後に、ホットリロードはうまくいきませんが、IDEから直接アプリケーションを再起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses Vert.x heavily.  The `quarkus-vertx-core` extension manages the Vert.x instance used by Quarkus.  You can use that instance directly and avoid creating the Vert.x instance.  If you need to configure the instance, you can configure it from https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[the `application.properties`].  It also enables native packaging (as that extension contains the directive to compile Vert.x applications to native).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはVert.xを多用しています。 `quarkus-vertx-core` エクステンションは、Quarkusが使用するVert.xインスタンスを管理します。そのインスタンスを直接使用することができ、Vert.xインスタンスを作成する必要はありません。インスタンスを設定する必要がある場合は、 link:https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus-vertx-core-eclipse-vert.x-core[`application.properties`] から設定することができます。また、ネイティブパッケージングも可能になります（このエクステンションには Vert.x アプリケーションをネイティブにコンパイルするためのディレクティブが含まれているため）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your pom.xml file, just add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pom.xmlファイルに以下の依存関係を追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, the _run_ method becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 _run_ メソッドは以下のようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note how it retrieves the managed Vert.x instance.  While you can use `@Inject`, you can also retrieve it programmatically, the rest of the code does not change.  See? No magic for you! We can still start it from the IDE using the _main_ method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されている Vert.x インスタンスを取得する方法に注目してください。 `@Inject` を使用することができますが、プログラムで取得することも出来、残りのコードは変更しません。ご覧になりましたか？魔法はありません! _メイン_ メソッドを使用して、IDE から起動することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don't include the `quarkus-vertx-core` extension (or any extension depending on it), Quarkus won't create the Vert.x instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-vertx-core` エクステンション（またはそれに依存するエクステンション）を含まない場合、QuarkusはVert.xインスタンスを作成しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using extensions gives you some property wiring as well as the build time optimisations and native image compilation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを使用すると、プロパティの設定や、ビルド時間の最適化、ネイティブイメージのコンパイルも行うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, still no hot reload 😿.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、やはりホットリロードはダメですね😿。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of using only the `quarkus-vertx-core` extension, we can choose to delegate the HTTP server to Quarkus.  You may see that as a loss of control, but actually, we rarely do much around it, and again, you can configure it from the `application.properties` file if needed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-vertx-core` のエクステンションだけを使用するのではなく、HTTPサーバーをQuarkusに委任することもできます。 これは制御できないと思われるかもしれませんが、実際には、そのようなことは滅多にしませんが、必要なら、 `application.properties` ファイルから設定することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of ``quarkus-vertx-core`, use `quarkus-vertx-http`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>``quarkus-vertx-core` の代わりに、 `quarkus-vertx-http` を使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>No need to depend on Vert.x Web directly, it's included.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x Webに直接依存する必要はなく、含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You will still register your routes, but using a managed `Router`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルートの登録は引き続き行いますが、管理されている `Router` を使用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That approach enables the Quarkus hot reload as it intercepts the HTTP requests.  You are still in control of everything related to your application logic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチでは、HTTPリクエストをインターセプトするため、Quarkusのホットリロードが可能になります。アプリケーションロジックに関連するすべてのことを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can start the hot reload using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次を使ってホットリロードを開始することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The final _magic touch_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後の _マジックタッチ_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The question, now, is how far are we from a _regular_ Quarkus application? Quite close, actually.  The equivalent application using RESTEasy Reactive would be something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題は、Quarkusの _通常の_アプリケーションからどれくらい離れているかということです。実際には、かなり近いです。RESTEasy Reactiveを使った同等のアプリケーションは、次のようなものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Unlike the previous approaches, this one leverages a declarative (annotation-based) model.  Under the hood, it's not that different from the last approach.  Quarkus registers a route (on the router), which then calls the `hello` method when a matching request is received.  The router gets initialized during the `Quarkus.run` method.  No need for the _main_ endpoint, but you can still use one, often convenient in IDEs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでのアプローチとは異なり、このアプローチは宣言的な（アノテーションベースの）モデルを活用しています。内部では、前のアプローチとそれほど違いはありません。Quarkusは（ルーター上で）ルートを登録し、一致するリクエストを受信すると `hello` メソッドを呼び出します。ルータは、 `Quarkus.run` メソッドの間に初期化されます。 _メインエンドポイント_ は必要ありませんが、1つのエンドポイントを使用することができ、IDEでは便利なことが多いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our relation to magic depends on our background and experience.  Quarkus lets you decide how much magic you accept.  This post presented fours configurations, going from almost no magic to the _regular_ Quarkus code.  Each approach has pros and cons:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのマジックとの関係は、私たちのバックグラウンドや経験によって異なります。Quarkusでは、どの程度のマジックを受け入れるかを決めることができます。この記事では、ほとんど魔法を使わない状態から _通常の_ Quarkusコードまで、4つの設定を紹介しました。それぞれのアプローチには長所と短所があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Control</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コントロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build time optimizations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時最適化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hot Reload</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ホットリロード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Almost no magic_</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_殆どマジックなし_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed Vert.x instance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理された Vert.x インスタンスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the managed HTTP server</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>管理されたHTTPサーバーの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>_Regular_ Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_通常の_ Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pick the approach that fits your needs.  Besides, most of Quarkus services are also available using a programmatic approach, as we have seen for configuration.  So, if you prefer avoiding managed objects, feel free just to use the available APIs.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ニーズに合ったアプローチを選びましょう。また、設定について見てきたように、Quarkusのサービスのほとんどは、プログラム的なアプローチを使用して利用することもできます。管理されたオブジェクトを避けたい場合は、利用可能なAPIを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vault</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10 released - JSON as default, Multiple reactive datasources, new Micrometer registries...'
date: 2020-12-01
tags: release
synopsis: Quarkus 1.10 has been released. JSON is now the default content type for your REST resources, multiple reactive datasources are supported and we added several registries to our Micrometer extension. 
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: 'Quarkus 1.10 がリリースされました - デフォルトがJSONに、複数のリアクティブデータソース、新しいマイクロサービスレジストリ...'
date: 2020-12-01
tags: release
synopsis: Quarkus 1.10がリリースされました。JSONがRESTリソースのデフォルトのコンテンツタイプになり、複数のリアクティブデータソースがサポートされ、Micrometerエクステンションにいくつかのレジストリが追加されました。 
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The just released Quarkus 1.10.2.Final comes with a lot of improvements and new features:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リリースされたばかりのQuarkus 1.10.2.Finalには、多くの改善と新機能が搭載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Default media type is now JSON</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのメディアタイプがJSONになりました</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts is now the default project generation tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CodeStarts はデフォルトのプロジェクト生成ツールになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Micrometer extension got its fair share of improvements (e.g. new registries)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マイクロメーターのエクステンションは、改善のかなりの割合を占めています（新規登録など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Qute error pages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいQuteエラーページ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Part of the Hibernate ORM configuration is now overridable at runtime</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HibernateのORM設定の一部が実行時にオーバーライド可能になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients support multiple datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ SQL クライアントが複数のデータソースをサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>New Amazon IAM extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいAmazon IAMのエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, it also comes with its fair share of bugfixes and usability and documentation improvements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、バグ修正や使い勝手の改善、ドキュメントの改善なども行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[our migration guide for 1.10].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか？ここに https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.10[1.10への移行ガイド]があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is still the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11のフレーバーのGraalVM 20.2は、まだ推奨されているGraalVMのバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where is my 1.10.0.Final (and my 1.10.1.Final)?!?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.0.Final（と1.10.1.Final）はどこにあるの！？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We spotted a regression in the Caffeine extension and decided to skip the announcement of 1.10.0.Final altogether.  And then we spotted an issue with the Platform BOM and had to release a 1.10.2.Final.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Caffeine エクステンションのリグレッションを発見し、1.10.0.Final の発表を完全にスキップすることにしました。そして、Platform BOM の問題を発見し、1.10.2.Final をリリースしなければなりませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All in all, we managed to fix a few more issues in the meantime so that makes 1.10.2.Final a greater release.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その間にいくつかの問題を修正することができたので、1.10.2.Finalはより大きなリリースとなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON as the Default Content Type</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのコンテンツタイプとしての JSON</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In an effort to make your REST resources less verbose and considering nowadays JSON is the most widely used content type for REST services, it is now the default in Quarkus for your REST resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTリソースが冗長にならないようにするための努力と、最近ではJSONがRESTサービスで最も広く使用されているコンテンツタイプであることを考慮から、QuarkusではRESTリソースのデフォルトとしてJSONが使用されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It means that, if you are using JSON, you don't need to add `@Produces` and `@Consumes` annotations anymore.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、JSONを使っているのであれば、 `@Produces`  と `@Consumes`  のアノテーションを追加する必要がなくなったということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also means that if you were relying on content type negotiation, you will have to add these annotations with the content types you support.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コンテンツタイプネゴシエーションに頼っていた場合、サポートしているコンテンツタイプでこれらのアノテーションを追加しなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CodeStarts as Default Project Generation Tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトのプロジェクト生成ツールとしてのCodeStarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The CodeStarts project has been a long and steady effort.  Good news: it is now the default project generation tool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CodeStartsプロジェクトは長い間、地道な努力を続けてきました。良いニュースです: 今ではデフォルトのプロジェクト生成ツールとなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From an end user perspective, it brings a better UI, more flexibility and code examples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドユーザーの視点から見ると、より良いUI、より柔軟性のあるコード例をもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Micrometer Registries</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マイクロメーターレジストリー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Two new registries were added:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新たに2つのレジストリが追加されました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>StatsD</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>StatsD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SignalFX</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SignalFX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also added more metrics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらにメトリクスを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of work has been done to make the Swagger/GraphQL/Health/OpenAPI UIs consistent and Quarkus-themed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Swagger/GraphQL/Health/OpenAPI UI に一貫性を持たせ、Quarkusのテーマを適用するために、多くの作業が行われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also now disable them at runtime.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、実行時にそれらを無効にすることもできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More specifically on the Swagger UI front, all the Swagger UI configuration knobs have been exposed as Quarkus configuration properties.  You can learn more about it in link:/blog/stylish-api/[the just published Stylish API blog post].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より具体的には、Swagger UIのフロントでは、Swagger UIの設定ノブがすべてQuarkusの設定プロパティとして公開されています。詳細については、 /blog/stylish-api/[先日公開されたばかりのStylish APIのブログ記事]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Qute, our template engine, you will be pleased to see our shiny new error pages, which points you to the error and makes you even more productive:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートエンジンのQuteをお使いの場合は、エラーを指摘してくれるピカピカの新しいエラーページが登場し、さらに生産性を高めてくれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before 1.10, all of the Hibernate ORM configuration properties were fixed at build time.  Mostly for optimization purposes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10以前は、ビルド時にすべてのHibernate ORM構成プロパティが固定されていました。主に最適化のためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With 1.10, we started to relax this rule for some carefully chosen properties and you can now override the following properties at runtime:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10では、慎重に選択したいくつかのプロパティについてこのルールを緩和し、以下のプロパティを実行時にオーバーライドできるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation.create-schemas`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.database.generation.halt-on-error`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.log.sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.hibernate-orm.log.format-sql`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Reactive Changes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>更なるリアクティブの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.5.0 which includes several improvements and Mutiny to 0.11.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging が 2.5.0 にアップグレードされ、いくつかの改善と Mutiny が 0.11.0 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Reactive SQL Clients now support multiple datasources: you can connect to several databases, exactly in the same way as for JDBC datasources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive SQL クライアントは複数のデータソースをサポートするようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Amazon Services extensions got a new friend: a brand new Amazon IAM extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アマゾンサービスのエクステンションに新しい友人ができました：全く新しいAmazon IAMエクステンションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More on this one in link:/guides/amazon-iam[the Amazon IAM guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これについては、 /guides/amazon-iam[Amazon IAMガイド]で詳しく紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Google Cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A lot of Google Cloud-related work is taking place in the https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Google Cloud関連の作業の多くは https://github.com/quarkiverse/quarkiverse-google-cloud-services[Quarkiverse]で行われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And if you wonder how you will deploy your Quarkus application to Google Cloud, we have a link:/guides/deploying-to-google-cloud[new guide] for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、QuarkusアプリケーションをどのようにGoogle Cloudにデプロイするのか疑問に思っている方のために、 /guides/deploying-to-google-cloud[新しいガイドを]ご用意しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other Changes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他の変更点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.24.Final</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM が 5.4.24.Final にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full Changelog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[1.10.0.CR1], https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final], https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1.Final] and https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[1.10.2.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1. https://github.com/quarkusio/quarkus/releases/tag/1.10.0.CR1[10.0.CR1]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.0.Final[1.10.0.Final]、 https://github.com/quarkusio/quarkus/releases/tag/1.10.1.Final[1.10.1].Final、1.10. https://github.com/quarkusio/quarkus/releases/tag/1.10.2.Final[2.Final]の完全な変更ログはGitHubで入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To share stories about Quarkus usage, we added https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[an `ADOPTERS.md` file] at the root of the repository.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの使用についてのストーリーを共有するために、リポジトリのルートに link:https://github.com/quarkusio/quarkus/blob/master/ADOPTERS.md[`ADOPTERS.md`] ファイルを追加しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributors</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コントリビューター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[395 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコミュニティは成長しており、現在 https://github.com/quarkusio/quarkus/graphs/contributors[395人の貢献者が]います。一人ひとりの貢献者に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.10 release, thanks to Alexey Loubyansky, Andrea Cosentino, Andreas Eberle, Andrej Petras, Andrew Hatch, Andy Damevin, Anton Fagerberg, Antonio Goncalves, antonwiens, Arne Mejlholm, Auri Munoz, Bill Burke, Bobby Alex Philip, Bobby Philip, Cem Nura, Clement Escoffier, Daniel Platz, David M. Lloyd, Denis Fuenzalida, Dheeraj Nalluri, Dmitry Telegin, Dominik Henneke, Dušan Križan, Erin Schnabel, Falko Modler, Felix Wong, Foivos Zakkak, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Gytis Trikleris, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Antosik, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, jyemin, jzuriaga, Jérôme TAMA, Jörg von Frantzius, kdnakt, Kevin Viet, Knut Wannheden, Kuba Antosik, Ladislav Thon, Libor Krzyzanek, Lovekesh Garg, Loïc Mathieu, luneo7, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Martin Kouba, Matej Novotny, Matej Vasek, Matthias Harter, Michal Szynkiewicz, Nathan Erwin, osaka-svg, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Kruger, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Samuel Le Berrigaud, Sanne Grinovero, seregamorph, Sergey Beryozkin, Simon Bengtsson, Stefan Hacker, Stephane Epardaud, Stuart Douglas, Thorasine, Vincent Sevel, Vincent Sourin, Vinod Anandan, xstefank, Xumk, Yoann Rodière.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に1.10のリリースについては、以下の方々に感謝します： Alexey Loubyansky, Andrea Cosentino, Andreas Eberle, Andrej Petras, Andrew Hatch, Andy Damevin, Anton Fagerberg, Antonio Goncalves, antonwiens, Arne Mejlholm, Auri Munoz, Bill Burke, Bobby Alex Philip, Bobby Philip, Cem Nura, Clement Escoffier, Daniel Platz, David M. Lloyd, Denis Fuenzalida, Dheeraj Nalluri, Dmitry Telegin, Dominik Henneke, Dušan Križan, Erin Schnabel, Falko Modler, Felix Wong, Foivos Zakkak, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, ghokun, Guillaume Le Floch, Guillaume Smet, Gwenneg Lepage, Gytis Trikleris, Ioannis Canellos, Jack Hu, Jaikiran Pai, Jakub Antosik, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, jyemin, jzuriaga, Jérôme TAMA, Jörg von Frantzius, kdnakt, Kevin Viet, Knut Wannheden, Kuba Antosik, Ladislav Thon, Libor Krzyzanek, Lovekesh Garg, Loïc Mathieu, luneo7, Maciej Swiderski, Manyanda Chitimbo, Marcin Czeczko, Martin Kouba, Matej Novotny, Matej Vasek, Matthias Harter, Michal Szynkiewicz, Nathan Erwin, osaka-svg, Paul Kunysch, Pedro Igor, Peter Palaga, Phillip Kruger, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Samuel Le Berrigaud, Sanne Grinovero, seregamorph, Sergey Beryozkin, Simon Bengtsson, Stefan Hacker, Stephane Epardaud, Stuart Douglas, Thorasine, Vincent Sevel, Vincent Sourin, Vinod Anandan, xstefank, Xumk, Yoann Rodière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.9 comes with a lot of improvements on top of our existing feature set:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.9 では、既存の機能セットに対して多くの改良が加えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis clients are supported (as well as Sentinel connections)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の Redis クライアントのサポート (Sentinel 接続も同様)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Last but not least, we also started &lt;&lt;quarkiverse,the Quarkiverse initiative&gt;&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後ですが重要なことに、 link:#quarkiverse[Quarkiverseの取組] も開始しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[our migration guide for 1.9].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか？ここに link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.9[1.9の移行ガイド] があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The biggest change is that the old datasource (JDBC and reactive) configuration that was deprecated in 1.3 is now gone.  So if your datasources don't work anymore, that's probably because you haven't migrated to the new configuration yet.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最大の変更点は、1.3 で非推奨となった古いデータソース (JDBC とリアクティブ) の設定がなくなったことです。ですから、もしあなたのデータソースが動作しなくなった場合、それはおそらくあなたがまだ新しい設定に移行していないことが原因です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.2 in its Java 11 flavor is the recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11 のフレーバーの GraalVM 20.2 が、推奨される GraalVM のバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.8 introduced a new Micrometer extension.  During the 1.9 development cycle, it matured a lot and is now the recommended way to collect metrics in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.8 では、新しく Micrometer エクステンションが導入されました。1.9 の開発サイクルの間に、このエクステンションは大きく発展し、現在では Quarkus でメトリクスを収集するための推奨される方法となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For instance, you now get metrics for Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Kafka のメトリクスを取得できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean Validation constraints are now taken into account for parameters and return values (`Uni` is supported but not `Multi`) of Reactive Routes methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Bean Validation 制約が Reactive Routes メソッドのパラメータと戻り値 ( `Uni` はサポートされていますが、 `Multi` はサポートされていません) で考慮されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye Reactive Messaging was upgraded to 2.4.0 which includes several improvements - including Cloud Event support for Kafka - and bugfixes and Mutiny to 0.9.0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye Reactive Messaging は 2.4.0 にアップグレードされました。KafkaのCloud Event サポートを含むいくつかの改善、バグ修正などが含まれています。Mutinyは 0.9.0 へアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://github.com/quarkusio/quarkus/pull/12470[pull request description] lists the main changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/pull/12470[プルリクエストの説明] に主な変更点が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is now easier than ever to use Mutiny with the REST Client thanks to the `quarkus-rest-client-mutiny` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-rest-client-mutiny` エクステンションのおかげで、REST クライアントで Mutiny を使用することがこれまで以上に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation is our response to a recurring request from the community: having the ability to rollback changes made in a test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、コミュニティからの繰り返し要望のあった、テストで行われた変更をロールバックする機能への対応です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of annotating your test with `@Transactional` (which will persist the changes), annotate your test with `@TestTransaction` and the changes will be automatically rolled back at the end of the test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを (変更を持続させる) `@Transactional` でアノテーションするのではなく、テストを `@TestTransaction` でアノテーションすると、テストの最後に変更が自動的にロールバックされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Redis Clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の Redis クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, you could only connect to one Redis instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは 1 つの Redis インスタンスにしか接続できませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with 1.9, you can connect to multiple instances.  Also Sentinel is now supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.9 からは、複数のインスタンスに接続できるようになりました。また、Sentinel にも対応しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now have a separate JAXP extension. Until now, it was intertwined with the JAXB extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAXP のエクステンションを別に用意するようになりました。今までは JAXB エクステンションと絡み合っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM has been upgraded to 5.4.22.Final and Hibernate Reactive to 1.0.0.Alpha10</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM が 5.4.22.Final に、Hibernate Reactive が 1.0.0.Alpha10 にアップグレードされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] and https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.CR1[1.9.0.CR1] と link:https://github.com/quarkusio/quarkus/releases/tag/1.9.0.Final[1.9.0.Final] の完全な変更ログは GitHub で取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus wouldn't be as successful if it weren't for its extension ecosystem.  In the beginning, we were adding all extensions to the core Quarkus repository, but eventually it became too much of an overhead or just not always sensible to include an extension into the core.  Some have since then created their own repositories external to Quarkus, but others just never happened because not everyone wants the overhead of maintaining a build setup while in other cases we actually had an idea for an extension but not solidified enough yet to be included in core (and consequently failed to find other community members interested and eager to help).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのエコシステムがなければ、Quarkus はこれほどの成功を収められなかったでしょう。当初は、すべてのエクステンションを Quarkus のコアリポジトリーに追加していました。しかし、最終的にはオーバーヘッドが大きすぎたり、エクステンションをコアに含めることが必ずしも賢明とは限らなくなってしまいました。それ以来、Quarkus の外部に独自のリポジトリーを作成した人もいますが、誰もがビルドセットアップを維持するためのオーバーヘッドを望んでいるわけではないので、それが実現しなかった人もいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Meet Quarkiverse!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse と会いましょう！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkiverse is a separate GitHub organization (https://github.com/quarkiverse) that offers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse は GitHub とは別の組織 (https://github.com/quarkiverse) で、以下を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inclusion in registry used by Quarkus tooling to browse extensions (i.e. code.quarkus.io, command line and IDE tools).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション (code.quarkus.io、コマンドライン、IDEツールなど) を参照するための Quarkus ツールで使用されるレジストリーへの収録</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consistent formatting and release of projects</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトの一貫したフォーマットとリリース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bigger Community outreach and a great place to collaborate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より大きなコミュニティのアウトリーチと素晴らしいコラボレーションの場</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to lead the development of an extension, see if it wasn't already https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[proposed on GitHub] or https://github.com/quarkusio/quarkus/issues/new/choose[create an Extension Proposal issue].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの開発をリードしたい場合は、 link:https://github.com/quarkusio/quarkus/issues?q=is%3Aopen+is%3Aissue+label%3Akind%2Fextension-proposal[GitHub でまだ提案されていないかどうか] を確認したり、 link:https://github.com/quarkusio/quarkus/issues/new/choose[エクステンションの提案課題を作成] してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A blog post is in the works and should give more details.  In the meantime, check out https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[the extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ブログ記事を作成中ですので、そちらで詳細をお知らせします。それまでは、 link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[すでにある拡張機能] をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[378 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus コミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[378人のコントリビューター] がいます。一人一人に多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today we're proud to announce link:https://github.com/quarkiverse[Quarkiverse Hub], a GitHub organization where any contributor can host their Quarkus extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今日は、コントリビューターが誰でもQuarkusのエクステンションをホストできるGitHub Organizationである https://github.com/quarkiverse[Quarkiverse Hub]を発表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-repos.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hosting your extension in the Quarkiverse Hub makes it available to all Quarkus users through the Quarkus tooling.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをQuarkiverse Hubでホスティングすると、Quarkusツールを介してすべてのQuarkusユーザーが利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So read on to discover more and find out how you can make your extension available to all Quarkus developers today!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細をお読みになり、すべてのQuarkus開発者が今すぐエクステンションを利用できるようにする方法をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特徴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By hosting an extension under the Quarkiverse Hub, the following features are enabled:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverse Hubの下でエクステンションをホスティングすることで、以下の機能が有効になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registering and publishing artifacts to Maven central can become a daunting task. In Quarkiverse that is automated by GitHub Actions, requiring no manual interaction with any command line tools.  Releasing an artifact is as simple as opening a pull-request changing the https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[`.github/project.yml`] file in the extension's repository.  Once the pull-request is merged, a GitHub action is triggered invoking `mvn release:prepare release:perform` and the extension is deployed to Maven central.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven centralに成果物を登録して公開するのは、大変な作業になることがあります。Quarkiverseでは、GitHub Actionsによって自動化されており、コマンドラインツールを使って手動で操作する必要はありません。アーティファクトのリリースは、プルリクエストを開いて  https://github.com/quarkiverse/quarkiverse-template/blob/master/.github/project.yml[.github/project.yml]ファイルを作成します。プルリクエストがマージされると、GitHub アクションがトリガーされて `mvn release:prepare release:perform` が呼び出され、エクステンションが Maven セントラルにデプロイされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-release.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Core releases happen constantly and keeping up with the latest changes before a release is performed is crucial. Quarkiverse extensions are built daily against the latest https://github.com/quarkusio/quarkus[Quarkus core] using the https://github.com/quarkusio/quarkus-ecosystem-ci[Quarkus Ecosystem CI] and listed in the https://status.quarkus.io/[Quarkus Status] page.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコアのリリースは常に行われており、リリースを実行する前に最新の変更点を把握しておくことは非常に重要です。Quarkiverseのエクステンションは、Quark https://github.com/quarkusio/quarkus-ecosystem-ci[us Ecosystem CI]を使用して最新の https://github.com/quarkusio/quarkus[Quarkusコア]に対して毎日ビルドされ、Quark https://status.quarkus.io/[usのステータス]ページに表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkiverse-parent` artifact (inherited by each extension in Quarkiverse) enables plugins that will format your source code to the same format used in Quarkus core.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkiverse-parent` アーティファクト（Quarkiverseの各エクステンションに継承されています）は、プラグインがソースコードをQuarkusコアで使用されているのと同じフォーマットにフォーマットすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Documentation aggregation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントの集約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get your versioned extension documentation automatically published (including guides)! Quarkiverse Hub uses https://antora.org[Antora] to aggregate each extension documentation in the Quarkiverse docs website.  Although the layout is still a work in progress, you can check it out at https://quarkiverse.github.io/quarkiverse-docs/</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バージョン管理されたエクステンションドキュメント（ガイドを含む）を自動的に公開しましょう！Quarkiverse Hubでは、 https://antora.org[Antora]を使用して、Quarkiverse docsのウェブサイト内の各エクステンションドキュメントを集約しています。レイアウトはまだ作業中ですが、 https://quarkiverse.github.io/quarkiverse-docs/ で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-guides.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automated inclusion in the upcoming Extension registry</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今後のエクステンションレジストリへの自動インクルード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Extension registry is still a work in progress (https://registry.quarkus.io), but the gist of it is to have a single place to browse for extensions (including https://code.quarkus.io, command line and IDE plugins).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Extension レジストリはまだ作業中ですが( https://registry.quarkus.io )、その要旨は、エクステンション ( https://code.quarkus.io 、コマンドライン、IDE プラグインを含む) を単一の場所で閲覧できるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Requirements</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to automate extension releases and publication of docs, there are some rules that need to be followed for projects under the Quarkiverse organization:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのリリースやドキュメントの公開を自動化するために、Quarkiverseの組織の下にあるプロジェクトでは、いくつかのルールに従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension repository should be named `quarkiverse-&lt;project&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションのリポジトリの名前は `quarkiverse-&lt;project&amp;amp&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkiverse extension MUST belong to the `io.quarkiverse.&lt;project&gt;` groupId</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverseのエクステンションは、 `io.quarkiverse.&lt;project&gt;` groupIdに属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The root pom.xml MUST inherit from `io.quarkiverse:quarkiverse-parent`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ルート pom.xml は `io.quarkiverse:quarkiverse-parent` を継承しなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A Quarkiverse extension has the following structure:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkiverseのエクステンションは、次のような構造です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The *deployment*, *runtime* and *integration-test* directories containing the extension classes. See link:https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[How to create new extension modules using Maven] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*デプロイメント* 、 *ランタイム* 、および *統合テスト* のディレクトリがエクステンションクラスを含みます。詳細は「 https://quarkus.io/guides/writing-extensions#create-new-extension-modules-using-maven[Mavenを使って新しい拡張モジュールを作成する方法]」を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*docs* (optional): The docs should follow the link:https://docs.antora.org/antora/2.3/standard-directories/[Antora's Standard File and Directory Set]. See an example link:https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[here].
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*docs* (オプション)。docsは https://docs.antora.org/antora/2.3/standard-directories/[Antoraの標準ファイルとディレクトリセット]に従ってください。サンプルは https://github.com/quarkiverse/quarkiverse-freemarker/tree/b41701b05f5886fd7c91148cdd273028fcd28950/docs[ここ] を参照して下さい。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, look at the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/assets/images/posts/quarkiverse/quarkiverse-way.jpg</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How do I sign-up?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どうやったら申し込めますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create an *Extension Proposal* ticket in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] (first check if the extension you're proposing is not created yet) and let us know if you want to lead the development of this extension by commenting on the issue.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/issues[Quarkusの課題管理]で *エクステンション提案の* チケットを作成し（まず、提案しているエクステンションがまだ作成されていないかどうかを確認してください）、このエクステンションの開発をリードしたい場合は、イシューにコメントをつけてお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus team will get you started with the boring stuff of setting up a brand new repository and deployment scripts, so you'll have fun coding it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusチームは、ブランドの新しいリポジトリやデプロイメントスクリプトを設定するという退屈な作業すませるので、あなたは楽しくコーディングを行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, we're always improving, so take a look at link:https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse] for the process we are currently using.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他と同様に、我々は常に改善していますので、現在使用しているプロセスについては、 https://github.com/quarkiverse/quarkiverse/wiki#joining-quarkiverse[Joining Quarkiverse]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What extensions are in Quarkiverse already?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkiverseにはどのようなエクステンションがあるのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;type=Repositories[extensions that are already there].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/search?q=topic%3Aquarkus-extension+org%3Aquarkiverse&amp;amp;type=Repositories[すでにあるエクステンション]をチェックしてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stay tuned for the latest info about Quarkiverse in the link:https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkiverse/quarkiverse/wiki[Quarkiverse Wiki]では、Quarkiverseの最新情報をご確認いただけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I reuse this setup for an extension outside the Quarkiverse organization?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この設定をQuarkiverseの組織外のエクステンションに再利用することはできますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, right now we're in the process of documenting the extra steps to make your extension releases visible to our tooling in this case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、現在、外部のエクステンションのリリースを我々のツールから見えるようにするための追加のステップを文書化しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11 released - RESTEasy Reactive, Dev UI, and more!'
date: 2021-01-20
tags: release
synopsis: Quarkus 1.11 has been released. It comes with RESTEasy Reactive, a Dev UI, Micrometer enhancements, dev mode support for jbang, and Spring Data REST. 
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: 'Quarkus 1.11リリース - RESTEasy Reactive、Dev UI、その他もろもろ！'
date: 2021-01-20
tags: release
synopsis: Quarkus 1.11がリリースされました。RESTEasy Reactive、Dev UI、マイクロメーターの強化、jbangのdevモードのサポート、Spring Data RESTが一緒です。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each Quarkus release, it's the same story: it comes with a ton of exciting new features and enhancements... But believe it or not, it's true.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのリリースのたびに、同じことが起きています：沢山の刺激的な新機能や機能強化が行われています、、信じられないかもしれませんが、本当です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11 is an important milestone as it marks the beginning of two amazing new features:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11は、2つの驚くべき新機能の始まりを示す重要なマイルストーンです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive,</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Dev UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But it also comes with many other enhancements be it for Micrometer, for jbang or for our Spring compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、Micrometer、jbang、スプリング互換性レイヤーなどに対しても、他にも多くの機能強化が施されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And this release wouldn't be so great without all the people who tested our Betas and CR so a big thanks to everyone who participated in testing this release!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、このリリースはBetaとCRをテストしてくれた全ての人がいなければ、ここまで素晴らしいものにはならなかったでしょう。このリリースのテストに参加したすべての人に感謝します！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eager to migrate your existing applications? Here is https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[our migration guide for 1.11].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のアプリケーションの移行をお考えですか？ link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-1.11[1.11の移行ガイド]はこちらです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3 in its Java 11 flavor is the newly recommended GraalVM version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11のフレーバーのGraalVM 20.3は、新たに推奨されているバージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive allows you to leverage the widely used and very powerful JAX-RS APIs to expose a REST layer for your application, while gaining a significant improvement in the maximum throughput the application can achieve. The application should also start slightly faster and consume a little less memory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、広く使用されている非常に強力な JAX-RS API を活用してアプリケーションの REST レイヤーを公開し、アプリケーションが達成できる最大スループットを大幅に向上させることができます。また、アプリケーションの起動がわずかに速くなり、メモリの消費量が少し減ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It got presented in great details by Georgios in https://quarkus.io/blog/resteasy-reactive/[the RESTEasy Reactive announcement].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは link:https://quarkus.io/blog/resteasy-reactive/[RESTEasy Reactiveの発表] の中で、Georgios氏によって非常に詳細に紹介されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A detailed documentation is available in the link:/guides/resteasy-reactive[RESTEasy Reactive guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細なドキュメントは、 link:/guides/resteasy-reactive[RESTEasy Reactiveガイド] にございます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the beginning of a great story: Quarkus 1.11 offers a UI dedicated to development to make it easier than ever.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは素晴らしい物語の始まりです。Quarkus 1.11では、開発をこれまで以上に簡単にする為に、特化したUIが提供されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each extension can expose features in this Dev UI, be it to list the CDI beans, list your endpoints, replay your Flyway migrations, deploy to OpenShift... Sky is the limit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各エクステンションは、CDI Beanのリスト、エンドポイントのリスト、Flywayマイグレーションのリプレイ、OpenShiftへのデプロイなど、このDev UIで機能を公開することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus 1.11 introduces the infrastructure of this Dev UI and some features already.  If you are an extension developer or wants to do some frontend work, additions and improvements are very welcome.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.11では、このDev UIのインフラと、すでにいくつかの機能が提供されています。もしあなたがエクステンションの開発者であったり、フロントエンドの仕事をしたいと思っているなら、追加や改善は大歓迎です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Dev UI is available in dev mode only (e.g. `mvn quarkus:dev`) and accessible at the `/q/dev` endpoint by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI は開発モードでのみ利用可能で（例： `mvn quarkus:dev` ）、デフォルトでは `/q/dev` エンドポイントからアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Want to add a feature to the Dev UI? Just have a look at link:/guides/dev-ui[our Dev UI guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev UI に機能を追加したいですか？ link:/guides/dev-ui[Dev UI ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our Micrometer support is continuously improving:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当社のMicrometer対応は常に改善しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Streams metrics are now exposed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kafka Streams のメトリクスが公開されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Registries were moved to extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリはエクステンションに移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for registries, the one for **Prometheus** is part of our Core extensions: `io.quarkus:quarkus-micrometer-registry-prometheus`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリに関しては、 **Prometheus** 用のものはCoreエクステンション： `io.quarkus:quarkus-micrometer-registry-prometheus` の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the registries are hosted in the Quarkiverse (our home for additional extensions):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>残りのレジストリはQuarkiverseでホストされています（追加のエクステンションのためのホーム）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Azure Monitor</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Azure Monitor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-azure-monitor`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Datadog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Datadog</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-datadog`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-jmx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-signalfx`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Stackdriver</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Stackdriver</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-stackdriver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkiverse.micrometer.registry:quarkus-micrometer-registry-statsd`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you feel like contributing to these registries or creating new ones, the https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registry project] is the place you are looking for.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのレジストリに貢献したい、または新しいレジストリを作成したいとお考えの方は、 link:https://github.com/quarkiverse/quarkus-micrometer-registry[Quarkus Micrometer Registryプロジェクト] をご利用ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Spring Data REST</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using our Spring Data compatibility layer, you can now benefit from the Spring Data REST extension to simplify writing a CRUD REST layer.  It is very similar to our REST with Panache extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>弊社のSpring Data互換レイヤーを使用している場合、Spring Data RESTエクステンションの恩恵を受けて、CRUD RESTレイヤーの記述を簡単にすることができます。これはREST with Panacheエクステンションと非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about it in link:/guides/spring-data-rest[the dedicated guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:/guides/spring-data-rest[専用のガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Non application endpoints moved to `/q/`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション以外のエンドポイントは `/q/` に移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus exposes some technical endpoints that are not part of your application (for example, the Health endpoints).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、アプリケーションの一部ではない技術的なエンドポイント（Healthエンドポイントなど）をいくつか公開しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To avoid conflicts with your application endpoints, they have all been moved to the `/q/` namespace.  Redirects have been added to redirect the old URLs to the new ones.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのエンドポイントとの衝突を避けるために、これらはすべて `/q/` 名前空間に移動されました。古い URL を新しい URL にリダイレクトするためのリダイレクトが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This root path can be customized with `quarkus.http.non-application-root-path`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このルートパスは、 `quarkus.http.non-application-root-path`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, it was only possible to inject the JPA `EntityManagerFactory` and `EntityManager` in your applications.  Starting with 1.11, you can inject the Hibernate ORM-specific `SessionFactory` and `Session` if you need to access their specific methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、JPA `EntityManagerFactory` と `EntityManager` をアプリケーションに注入することしかできませんでした。1.11 からは、Hibernate ORM 固有の `SessionFactory` と `Session` の特定のメソッドにアクセスする必要がある場合は、注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jackson</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jackson</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`FAIL_ON_UNKNOWN_PROPERTIES` is now disabled by default for the default CDI-enabled `ObjectMapper`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトで CDI で有効になっている `ObjectMapper` で `FAIL_ON_UNKNOWN_PROPERTIES` が無効になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See https://quarkus.io/guides/rest-json#jackson for more details about how to go back to the previous behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の動作に戻す方法については、 https://quarkus.io/guides/rest-json#jackson を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The integration with https://jbang.dev[jbang] now supports enabling development mode and can use Quarkus platforms (BOM) for version management.  For this you need to use jbang v0.62+.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://jbang.dev[jbang]との統合は、開発モードの有効化をサポートするようになり、バージョン管理にQuarkusプラットフォーム(BOM)を使用できるようになりました。このためには、jbang v0.62+を使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run it, just pass in `-Dquarkus.dev`, i.e.:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行するには、 `-Dquarkus.dev` を渡すだけです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>where `myapp.java` for example is the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、例えば `myapp.java` は以下のようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice the use of `@pom` in the first line; that instructs jbang to load the pom for the platform and use it for version management and the other dependency versions can be left out.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の行で `@pom` を使用していることに注意してください。これは jbang にプラットフォーム用の pom をロードしてバージョン管理に使用するように指示しており、他のバージョン指定をしないで済むようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then with dev mode you can edit that file and save it again and Quarkus live reload feature will take care of applying the changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、開発モードでファイルを編集して再度保存すると、Quarkusのライブリロード機能が変更の適用の世話をしてくれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Other dev mode features like `https://localhost:8080/q/dev` and `https://localhost:8080/q/swagger-ui` are also available.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にも `https://localhost:8080/q/dev` や `https://localhost:8080/q/swagger-ui` のような開発モードの機能が用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now this only works for single file jbang scripts, future releases will enable it to work for multiple files too.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ、これは単一ファイルのjbangスクリプトに対してのみ動作しますが、将来のリリースでは複数のファイルに対しても動作するようになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 20.3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM 20.3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended version of GraalVM for Quarkus 1.11 is GraalVM 20.3.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 1.11に対するGraalVMの推奨バージョンはGraalVM 20.3です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get the full changelogs of https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2], https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1], and https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final] on GitHub.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta1[1.11.0.Beta1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Beta2[1.11.0.Beta2]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.CR1[1.11.0.CR1]、 link:https://github.com/quarkusio/quarkus/releases/tag/1.11.0.Final[1.11.0.Final]の全変更履歴は GitHub で入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus community is growing and has now https://github.com/quarkusio/quarkus/graphs/contributors[417 contributors].  Many many thanks to each and everyone of them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusコミュニティは成長しており、現在 link:https://github.com/quarkusio/quarkus/graphs/contributors[417人の貢献者] がいます。一人ひとりに多くの感謝の意を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In particular for the 1.11 release, thanks to Alex Soto, Alexey Loubyansky, Amos Feng, Andy Damevin, Auri Munoz, Bill Burke, Bruno Gonçalves, Cem Nura, Chin Huang, Chris Laprun, Christian von Atzigen, Christoph Hermann, Clement Escoffier, cristhiank, David M. Lloyd, Davide D'Alto, Dejan Bosanac, Dennis Kieselhorst, Erin Schnabel, essobedo, Falko Modler, Foivos Zakkak, Galder Zamarreño, Geoffrey De Smet, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Henrique Prange, Ioannis Canellos, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, Jérôme TAMA, Kai Hudalla, Katia Aresti, kdnakt, Ken Finnigan, Ken Kwan, Kevin Viet, Knut Wannheden, Ladislav Thon, Loïc Mathieu, Lucca Biagi de Paula Prado, luneo7, Manyanda Chitimbo, Mark Little, Martin Kouba, Martin Panzer, Masafumi Miura, Matej Vasek, Max Rydahl Andersen, Mayank Kunwar, Michael Edgar, Michał Szynkiewicz, mrizzi, Nicolas Gimenez, nragon, Oscar, Peter Palaga, Phillip Kruger, Pierre Smeyers, Piotr Delert, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Rustam Sultansoy, Samuel Le Berrigaud, Sanne Grinovero, Saumya Singh, Sergey Beryozkin, Simon Bengtsson, Slava, Stuart Douglas, Stéphane Épardaud, Timothy Power, Viacheslav Medvediev, Vincent Sevel, Willem Jan Glerum, Yoann Rodière, Zach Kimberg, and Àngel Ollé Blázquez.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に 1.11 のリリースについては、以下の方々に感謝します： Alex Soto, Alexey Loubyansky, Amos Feng, Andy Damevin, Auri Munoz, Bill Burke, Bruno Gonçalves, Cem Nura, Chin Huang, Chris Laprun, Christian von Atzigen, Christoph Hermann, Clement Escoffier, cristhiank, David M. Lloyd, Davide D'Alto, Dejan Bosanac, Dennis Kieselhorst, Erin Schnabel, essobedo, Falko Modler, Foivos Zakkak, Galder Zamarreño, Geoffrey De Smet, George Andrinopoulos, George Gastaldi, Georgios Andrianakis, Guillaume Le Floch, Guillaume Smet, Gunnar Morling, Gwenneg Lepage, Gytis Trikleris, Henrique Prange, Ioannis Canellos, Jan Martiška, Jordi Sola, Julien Ponge, Justin Holmes, Justin Lee, Jérôme TAMA, Kai Hudalla, Katia Aresti, kdnakt, Ken Finnigan, Ken Kwan, Kevin Viet, Knut Wannheden, Ladislav Thon, Loïc Mathieu, Lucca Biagi de Paula Prado, luneo7, Manyanda Chitimbo, Mark Little, Martin Kouba, Martin Panzer, Masafumi Miura, Matej Vasek, Max Rydahl Andersen, Mayank Kunwar, Michael Edgar, Michał Szynkiewicz, mrizzi, Nicolas Gimenez, nragon, Oscar, Peter Palaga, Phillip Kruger, Pierre Smeyers, Piotr Delert, René Grob, Robbie Gemmell, Roberto Cortez, Rostislav Svoboda, Rustam Sultansoy, Samuel Le Berrigaud, Sanne Grinovero, Saumya Singh, Sergey Beryozkin, Simon Bengtsson, Slava, Stuart Douglas, Stéphane Épardaud, Timothy Power, Viacheslav Medvediev, Vincent Sevel, Willem Jan Glerum, Yoann Rodière, Zach Kimberg, and Àngel Ollé Blázquez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I had the question multiple times: how do I use Eclipse Vert.x in Quarkus? Indeed, you can use Vert.x in Quarkus.  You can deploy _verticles_, communicate with the event bus, or use anything from the Vert.x ecosystem.  But, you can also use the Mutiny variant of Vert.x in Quarkus, and get a seamless experience with the other reactive APIs offered by Quarkus.  Several posts have already mentioned this, but it deserves a specific blog post.  So, here we are.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>よく次の質問をされます：「QuarkusでEclipse Vert.xを使うにはどうすればいいですか？」確かに、QuarkusではVert.xを使用することができます。 _Verticles_ をデプロイしたり、イベントバスと通信したり、Vert.xエコシステムのものなら何でも使えます。しかし、QuarkusでVert.xのMutinyバリアントを使用して、Quarkusが提供する他のReactive APIとシームレスな体験を得ることもできます。これについてはすでにいくつかの記事で触れていますが、具体的なブログ記事に値する内容です。というわけで、ここで紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Eclipse Vert.x</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse Vert.x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://vertx.io[Vert.x] is a toolkit to build reactive applications.  The Vert.x ecosystem is enormous.  From HTTP and data access abilities to messaging clients via microservice and security facilities, the Vert.x ecosystem is remarkably diverse and versatile.  To understand that variety, just check the https://vertx.io/docs/[Vert.x documentation].  That makes Vert.x popular in many areas such as web applications, IoT gateways, banking applications and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://vertx.io[Vert.x] はリアクティブなアプリケーションを構築するためのツールキットです。Vert.x のエコシステムは膨大です。HTTP やデータアクセス機能からマイクロサービスやセキュリティ機能を介したメッセージングクライアントまで、Vert.x のエコシステムは非常に多様で汎用性に富んでいます。その多様性を理解するには、Vert https://vertx.io/docs/[Vert.xのドキュメント]をチェックしてください。そのため、Vert.xはWebアプリケーション、IoTゲートウェイ、銀行アプリケーションなど、多くの分野で人気があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you may know, Quarkus is based on Vert.x.  Under the hood, there is a managed Vert.x instance that powers the rest of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご存知のように、QuarkusはVert.xをベースにしています。裏側では、マネージドのVert.xのインスタンスが存在し、Quarkusに力を与えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-vertx/architecture.png[width=50%]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When Quarkus serves a HTTP endpoint, under the hood, there is a Vert.x HTTP server handling the request and response.  That's also true for messaging, gRPC and almost any I/O.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusがHTTPエンドポイントを提供する場合、フードの下には、リクエストとレスポンスを処理するVert.x HTTPサーバーがあります。これは、メッセージング、gRPC、およびほぼすべてのI/Oにも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Vert.x "bare" API and friends</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.xの「素の」APIとその仲間たち</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x provides multiple APIs.  Let's focus on the "bare" one for now.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.xは複数のAPIを提供しています。ここでは「素」のものに注目してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Following the reactive nature of Vert.x, the API contains mostly asynchronous methods.  These methods are following a syntax convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x のリアクティブな性質にしたがって、API のほとんどを非同期メソッドが占めています。これらのメソッドは構文規則に従っています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The interesting part is the last parameter.  It's a function, a callback to be more precise, that gets called when the operation completes or fails.  Indeed, the asynchronous nature of Vert.x does not allow using `try/catch` blocks.  So you need to pass a continuation callback, invoked with the outcome.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>興味深いのは最後のパラメータです。これは関数、より正確にはコールバックで、操作が完了したときや失敗したときに呼び出されます。実際、Vert.xの非同期の性質上、 `try/catch`  ブロックを使用することはできません。そのため、結果に応じて呼び出される継続コールバックを渡す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AsyncResult` is a structure capturing this outcome.  It contains the result (of type `&lt;T&gt;`) produced by the operation, or the failure if it failed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AsyncResult`  は、この結果をキャプチャする構造体です。これは、操作によって生成された結果 ( `&lt;T&gt;`  型)、または失敗した場合の失敗を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's take an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を挙げてみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This code reads a file, and as it's an asynchronous operation, invokes the callback when the file is read.  The `readFile` method reads the complete content of the file and accumulates it in a _buffer_.  The callback receives the asynchronous result containing either the file's content (`ar.result()`) or a failure.  Vert.x invokes this callback when the operation has either completed or failed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコードはファイルを読み込み、非同期操作であるため、ファイルが読み込まれたときにコールバックを呼び出します。 `readFile`  メソッドは、ファイルの完全な内容を読み込み、 _バッファ_ に蓄積します。コールバックは、ファイルの内容 ( `ar.result()` ) または失敗を含む非同期の結果を受け取ります。Vert.x は、操作が完了または失敗したときにこのコールバックを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x also supports streams thanks to the `ReadStream` and `WriteStream` classes.  A `ReadStream` represents a stream of data you can read.  So you can attach a callback invoked on every item traversing the stream.  A `WriteStream` is a data source.  You can push items to a `WriteStream.` These items will be consumed by a `ReadStream`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x は `ReadStream`  と `WriteStream`  クラスのおかげでストリームもサポートしています。 `ReadStream`  は読み込み可能なデータのストリームを表します。そのため、ストリームを通過するすべての項目で呼び出されるコールバックをアタッチすることができます。 `WriteStream`  はデータソースです。アイテムを `WriteStream.`  にプッシュすることができます。 これらのアイテムは `ReadStream`  によって消費されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x streams do not implement Reactive Streams.  Vert.x provides a different back-pressure protocol.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x ストリームは、Reactive Streams を実装していません。Vert.x は別のバックプレッシャープロトコルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why are these API shaping rules important? Vert.x does not provide a single API.  The "bare" API presented above is just one of the proposed API.  It also provides API in Kotlin, API for RX Java, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜこれらの API シェーピングルールが重要なのか？Vert.xは単一のAPIを提供していません。上で紹介した「素の」APIは、提案されているAPIの1つに過ぎません。他にもKotlinでのAPIやRX JavaでのAPIなども提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These APIs are **generated**.  Vert.x provides a code generator that _ translates_ the Vert.x "bare" API into the other APIs.  Because all methods are well-formed, the generator understands how they should be adapted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの API は *生成され* ます。Vert.x は、Vert.x の "むき出しの" API を他の API に変換するコード ジェネレーターを提供します。すべてのメソッドは整形されているので、ジェネレータはどのように適応されるべきかを理解しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:/assets/images/posts/mutiny-vertx/generation.png[]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated code exposes a different API; each method delegating to the "bare" API.  Asynchronous methods and streams can follow different transformations, so the resulting API uses the right idioms.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたコードは、異なる API を公開しており、各メソッドは「素」の API にデリゲートします。非同期メソッドとストリームは異なる変換を行うことができるので、生成されたAPIは適切なイディオムを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny is an event-driven reactive programming library.  It's not related to Vert.x.  However, we have written a code generator that generates the Mutiny variant for the Vert.x API:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny はイベント駆動型のリアクティブプログラミングライブラリです。Vert.xとは関係ありませんが、Vert.x API用のMutiny版を生成するコードジェネレータを書いています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:/assets/images/posts/mutiny-vertx/mutiny.png[]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;span class="image"&gt;&lt;img src="/assets/images/posts/mutiny-vertx/mutiny.png" alt="mutiny"&gt;&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transformations are straightforward:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>変換は簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.vertx` package =&gt; `io.vertx.mutiny` package</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.vertx`  パッケージ ⇒ `io.vertx.mutiny`  パッケージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Asynchronous methods =&gt; method returning a `Uni&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非同期メソッド⇒メソッドが返す `Uni&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`ReadStreams&lt;T&gt;` =&gt; can be consumed as `Multi&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ReadStreams&lt;T&gt;`  ⇒消費することができます。 `Multi&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`WriteStreams&lt;T&gt;` =&gt; can be consumed as Reactive Streams `Subscriber&lt;T&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`WriteStreams&lt;T&gt;` ⇒ リアクティブストリームとして消費することができます。 `Subscriber&lt;T&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It also adapts the Vert.x back pressure protocol to Reactive Streams, as Mutiny implements Reactive Streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、MutinyがReactive Streamsを実装しているため、Vert.xのバックプレッシャープロトコルをReactive Streamsに適応させています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the first example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、上から1番目の例では、次のようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One difference between the two APIs is related to laziness. The Vert.x "bare" API triggers the operation as soon as the method is called.  The Mutiny variant expects a subscription to trigger the operation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>2つのAPIの違いの1つは、怠惰性に関連しています。Vert.x の "素の" API は、メソッドが呼び出されるとすぐに操作をトリガーします。Mutiny 版では、操作をトリガーするためにサブスクリプションを期待しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The stream example from above becomes:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上からのストリームの例は以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bit more than this</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう少し補足</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Mutiny variant does not only apply the rules exposed in the previous section.  For asynchronous methods, it also provides:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny版は、前のセクションで公開されたルールを適用するだけではありません。非同期メソッドに対しても提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndAwait()` methods - blocks the caller thread until the outcome is received. In the case of a failure, throws a `RuntimeException`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`xAndAwait()`  メソッド - 結果を受け取るまで呼び出し元のスレッドをブロックします。失敗した場合は `RuntimeException` を発生させます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`xAndForget()` methods - triggers the operation, discard the outcome</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`xAndForget()`  methods - 操作をトリガし、結果を破棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can we find this API?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このAPIはどこにありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment of writing, we only provide Vert.x core and Vert.x clients (MongoDB, Redis, Web client, Mqtt, and so on).  We are extending the support to cover the full Vert.x stack.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>執筆時点では、Vert.xコアとVert.xクライアント（MongoDB、Redis、Webクライアント、Mqttなど）のみを提供しています。私たちはVert.x スタック全体をカバーするようにサポートを拡張しているところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use the Mutiny clients, you need to add the right dependency to your project.  Browse https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[the list of dependency] to pick the one you need.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutinyクライアントを使用するには、適切な依存関係をプロジェクトに追加する必要があります。 https://search.maven.org/search?q=a:smallrye-mutiny-vertx*[依存関係のリスト]を見て、必要なものを選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, to you use the Mutiny variant of the Vert.x Web client, add the following dependency:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、Vert.x Web クライアントの Mutiny 版を使用するには、以下の依存関係を追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have the dependency, just create the web client instance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係ができたら、あとはWebクライアントのインスタンスを作成するだけです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Something missing? Open an issue on https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何か足りないものがあった場合は、 https://github.com/smallrye/smallrye-reactive-utils/issues[SmallRye Reactive Utils] に課題を提起してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Javadoc is available http://smallrye.io/smallrye-reactive-utils/apidocs/[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Javadocは http://smallrye.io/smallrye-reactive-utils/apidocs/[こちら] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The road ahead: Vert.x 4!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今後の道：Vert.x 4!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Vert.x 4 is coming soon! We are already working in Quarkus and the different satellite projects to migrate.  With Vert.x 4, a new generator has been implemented (following the same code generation approach), paving the road to a smooth upgrade.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Vert.x 4が間もなく登場します！既にQuarkusと異なるサテライトプロジェクトで移行作業を行っています。Vert.x 4では、新しいジェネレータが実装されており（同じコード生成アプローチを踏襲しています）、スムーズなアップグレードへの道が開かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: Next Monday (8th Feb 21), we will do Quarkus Insights based on your questions.
author: maxandersen
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus Insights Q&amp;A
date: 2021-02-02
tags: insights
synopsis: 来週の月曜日（2月8日）は、ご質問をもとにQuarkus Insightsを行います。
author: maxandersen
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the next Quarkus Insights episode, we are trying something new.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のQuarkus Insightsのエピソードでは、新しいことを試しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will cover the most often asked questions we have seen and any question tagged with `#quarkusinsights` on our various social media presences: https://twitter.com/search?q=%23quarkusinsights[Twitter], https://www.facebook.com/hashtag/quarkusinsights/[Facebook], https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] or on the https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtube event] directly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、私たちが見てきた最も頻繁に質問された質問や、私たちの様々なソーシャルメディアで `#quarkusinsights` とタグ付けされた任意の質問をカバーします（ link:https://twitter.com/search?q=%23quarkusinsights[Twitter] 、 link:https://www.facebook.com/hashtag/quarkusinsights/[Facebook] 、 link:https://www.linkedin.com/search/results/content/?keywords=%23quarkusinsights&amp;origin=GLOBAL_SEARCH_HEADER[LinkedIn] 、または link:https://www.youtube.com/watch?v=OV-ZnvHoQIk[youtubeイベント] で直接）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have a question about Quarkus you would like answered let us know on one of thoses sites.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>答えてほしいQuarkusに関する質問がある場合は、以下のいずれかのサイトでお知らせください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See you all Monday!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>月曜日にお会いましょう！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://cloudevents.io/[Cloud Events] is a specification for describing events.  It aims to ease interoperability.  With the rise of event-driven architecture, it's not surprising to see Cloud Events gaining popularity.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://cloudevents.io/[クラウドイベントは]、イベントを記述するための仕様です。相互運用性を容易にすることを目的としています。イベント駆動型アーキテクチャの台頭により、Cloud Eventsの人気が高まっているのは驚くに値しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This post explains how you can generate and consume Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを生成して消費する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is Cloud Event?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントとは？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, let's look at the why.  Events are everywhere.  Many modern systems are using events one way or another.  Events can be used to implement event sourcing, communicate facts, trigger out-of-band processing, or send notifications.  Events become an essential piece of any system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは「なぜ」を見てみましょう。イベントはどこにでもあります。最近のシステムの多くは、何らかの方法でイベントを使用しています。イベントは、イベントソーシングの実装、事実の伝達、帯域外処理のトリガー、通知の送信などに使用できます。イベントはどんなシステムにも欠かせないものとなっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yet event publishers tend to describe events differently.  I don't mean the content is different, but the envelope and the event's format are heterogeneous, even if these events transit on the same event mesh.  Some applications choose JSON and encode everything in the event's payload; some other systems prefer binary formats, such as Avro or Protobuf, and use the protocol capability, such as headers or properties, to transport metadata about the wrapped payload.  While event-driven architecture claims to ease the integration with external systems, this disparity is doing the opposite.  It's not rare to need a specific event translator with the only purpose to adapt events from one format to another.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、イベント発行者はイベントを異なる形で表現する傾向があります。内容が違うという意味ではありませんが、エンベロープとイベントのフォーマットは異種混在で、たとえこれらのイベントが同じイベントメッシュ上を通過するとしてもです。アプリケーションの中には JSON を選択してイベントのペイロードにすべてをエンコードするものもあれば、Avro や Protobuf のようなバイナリ形式を好み、ヘッダやプロパティのようなプロトコル機能を使って、ラップされたペイロードに関するメタデータを転送するものもあります。イベント駆動型アーキテクチャは外部システムとの統合を容易にすると主張していますが、この不均衡はその逆を行っています。イベントをあるフォーマットから別のフォーマットに適応させることだけを目的とした特定のイベントトランスレータを必要とすることは珍しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So, what's Cloud Event? Cloud Event proposes a common way to describe events.  The goal is, obviously, interoperability and easing the integration burden.  Cloud Event 1.0 was released almost a year ago.  Over the past year, many Cloud Providers adopted this format, such as Azure and Oracle.  Several middlewares have also added support for Cloud Events, such as Knative, Kogito, Debezium, and Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、クラウドイベントとは何か？クラウドイベントは、イベントを記述するための共通の方法を提案しています。目的は明らかに相互運用性と統合負担の軽減です。クラウドイベント1.0はほぼ1年前にリリースされました。この1年で、AzureやOracleなど、多くのクラウドプロバイダーがこの形式を採用しました。また、Knative、Kogito、Debezium、Quarkusなど、いくつかのミドルウェアがクラウドイベントのサポートを追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Show me some examples!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例を見せてください！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ok, so, how does it look? The easiest way to understand Cloud Event is to look at one of them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さてさて、どんな感じでしょうか？クラウドイベントを理解する一番簡単な方法は、そのうちの一つを見てみることです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This event is described in JSON, but that's just one of the possibilities.  Let's look at the fields.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このイベントはJSONで記述されていますが、それは可能性の一つに過ぎません。フィールドを見てみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the `specversion` indicates which version of Cloud Event it is using (1.0).  The `id` field provides an id for that specific event.  The `source` attribute is a URI identifying the event source, i.e., the context in which an event happened or the application that emitted that specific event.  Combining the `id` and the `source` provides a unique identifier.  Such uniqueness is essential to implement idempotence and handle potential duplicates.  The `type` is the last mandatory attribute.  It indicates the _type_ of the event.  Here, I use the fully qualified class name, but you can imagine anything.  It should refer to the kind of event you have defined in your system.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、 `specversion`  は、使用しているクラウドイベントのバージョン（1.0）を示しています。 `id`  フィールドは、その特定のイベントの ID を提供します。 `source`  属性は、イベントソースを識別する URI であり、イベントが発生したコンテキストや、特定のイベントを発生させたアプリケーションを示します。 `id`  と `source`  を組み合わせることで、一意な識別子が得られます。このような一意性は、冪等性を実装し、潜在的な重複を処理するために不可欠です。 `type`  は最後の必須属性です。これはイベントの _タイプ_ を示します。ここでは完全修飾クラス名を使用していますが、何を想像しても構いません。システムで定義されているイベントの種類を参照する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other attributes are optional.  `datacontenttype` defines the content-type of the `data` attribute.  `subject` allows passing extra details about the event, such as an additional hint about the context or the type of event.  `time` is a timestamp, generally indicating the creation time.  There is another optional attribute not used in my example.  The `dataschema` attribute lets you pass the schema of the event data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`datacontenttype`  は `data`  属性の content-type を定義します。 `subject`  では、コンテキストやイベントのタイプに関する追加のヒントなど、イベントに関する追加の詳細を渡すことができます。 `time`  はタイムスタンプで、一般的には作成時刻を示します。私の例では使用していない別のオプションの属性があります。 `dataschema`  属性は、イベントデータのスキーマを渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `data` attribute contains the wrapped business event.  It is an essential part, and the other attributes are just providing details about that specific business event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`data`  属性には、ラップされたビジネスイベントが含まれています。これは本質的な部分であり、他の属性はその特定のビジネスイベントについての詳細を提供しているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also define _extensions_.  These extensions would be a set of custom attributes used when the proposed set of attributes is not enough for your use case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_拡張_ を定義することもできます。これらの拡張は、提案された属性のセットがユースケースに十分でない場合に使用されるカスタム属性のセットになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's it! So, we can summarize Cloud Events as _just enough metadata to understand an event_ - its source, an id, a type, and the business data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これだ！これだ！と思ったイベントをまとめてみました。ということで、クラウドイベントを、 _イベントを理解するために必要な最低限のメタデータ、つまり、イベントの_ ソース、ID、タイプ、ビジネスデータとしてまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud Events on the wire - the bindings</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>転送におけるクラウドイベント - バインディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>But, how would these events be encoded? The previous example using JSON is nice, but some protocols may want to leverage their own capabilities to transmit these metadata.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、これらのイベントはどのようにエンコードされるのでしょうか？JSON を使った先ほどの例もいいですが、プロトコルによっては、独自の機能を活用してこれらのメタデータを送信したい場合もあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>That's why Cloud Events also proposes bindings.  A binding is a set of recommendations specific to one protocol.  It explains how each protocol should encode Cloud Events.  For example, there is a binding for HTTP, one for Kafka, and another for AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、Cloud Eventsではバインディングも提案しています。バインディングとは、あるプロトコルに固有の推奨事項のセットです。各プロトコルがどのようにCloud Eventsをエンコードすべきかを説明します。例えば、HTTP用のバインディング、Kafka用のバインディング、AMQP用のバインディングがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of these bindings propose two approaches:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのバインディングのほとんどは、2つのアプローチを提案しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>structured</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>structured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>binary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>binary</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach keeps event metadata and data together in the payload of the message or request.  It generally uses JSON to encode that data.  If you pass the Cloud Event example (from above), in an HTTP request, it will use the structured mode.  It will also use the structured mode when you write that JSON snippet in a Kafka record's value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構造化されたアプローチは、イベントのメタデータとデータをメッセージやリクエストのペイロードにまとめて保持します。一般的には JSON を使用してデータをエンコードします。Cloud Event の例 (上記) を HTTP リクエストで渡すと、構造化モードを使用します。また、Kafka レコードの値にその JSON スニペットを書き込む場合も構造化モードを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The structured approach allows simple forwarding across multiple protocols.  However, it may not be efficient and may constraint the type of business data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>構造化されたアプローチでは、複数のプロトコルをまたいで簡単に転送することができます。しかし、効率的でない場合があり、ビジネスデータの種類を制約する場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The other approach relies on protocol capabilities and enables efficient transfer and encoding.  If we use the binary mode with Kafka, we will store the `data` attribute value in the Kafka record's value and pass the other attributes using the record's headers.  Consequently, business data can be encoded using binary protocols such as Avro, leading to higher efficiency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つのアプローチはプロトコルの能力に依存しており、効率的な転送とエンコードを可能にします。Kafkaでバイナリモードを使用する場合、Kafkaレコードの値に `data`  属性の値を格納し、レコードのヘッダを使用して他の属性を渡すことになります。その結果、Avroなどのバイナリプロトコルを使ってビジネスデータをエンコードすることができ、効率化につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The rest of the post explains how you can send and receive Cloud Events using Quarkus, Kafka, and Reactive Messaging.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>残りの記事では、Quarkus、Kafka、Reactive Messagingを使用してクラウドイベントを送受信する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Cloud Events on Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントをKafkaで送信する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Kafka connector used by Quarkus has built-in support for Cloud Events.  It can send and consume Cloud Events using the structured mode (encoding everything in a JSON payload) or the binary mode (using Kafka headers).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusが使用するKafkaコネクタは、Cloud Eventsをビルトインでサポートしています。構造化モード（JSONペイロードですべてをエンコード）またはバイナリモード（Kafkaヘッダーを使用）を使用して、クラウドイベントを送信したり消費したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write your outgoing messages as Cloud Event, you only need to specify the `cloud-events-type` and `cloud-events-source` attributes on your channel:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>送信メッセージをクラウドイベントとして記述するには、チャンネルに `cloud-events-type`  と `cloud-events-source`  属性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the connector writes Cloud Events using the binary mode.  The connector generates a random `id` for each message.  You can also customize the other Cloud Event attributes using `cloud-events-$attribute`, such as `cloud-events-subject`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、コネクタはバイナリモードを使用してクラウドイベントを書き込みます。コネクタはメッセージごとにランダムな `id`  を生成します。 `cloud-events-$attribute`  を使用して、 `cloud-events-subject`  などの他のクラウドイベント属性をカスタマイズすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration shown above is applied to all the outgoing messages.  Sometimes, you want to customize the value for each message individually.  To achieve this, you can also attach `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata` to your message to customize the id, source, type and subject for each message:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記の設定は、すべての送信メッセージに適用されます。場合によっては、各メッセージの値を個別にカスタマイズしたいこともあるでしょう。これを実現するには、メッセージに `io.smallrye.reactive.messaging.ce.OutgoingCloudEventMetadata`  を添付して、各メッセージの id、ソース、タイプ、件名をカスタマイズすることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The connector also supports the _structured_ mode.  You can write structured Cloud Events by setting the `cloud-events-mode` attribute to `structured`.  It only supports JSON at the moment.  The written record gets its `content-type` header set to `application/cloudevents+json; charset=UTF-8`, which allows the receiver to understand that it's a structured Cloud Event.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コネクタは _構造化_ モードもサポートしています。 `cloud-events-mode`  属性を `structured`  に設定することで、構造化された Cloud Events を書くことができます。現時点では JSON のみサポートしています。書き込まれたレコードの `content-type`  ヘッダーは `application/cloudevents+json; charset=UTF-8`  に設定され、これにより受信者はそれが構造化されたクラウドイベントであることを理解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming Cloud Event from Kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドイベントをKafkaから消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, the connector can also consume Cloud Events.  The connector detects Cloud Events automatically by checking the record's headers.  It also determines the mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当然のことながら、コネクタはクラウドイベントを消費することもできます。コネクタは、レコードのヘッダをチェックすることで、自動的にクラウドイベントを検出します。また、モードも決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When the connector receives a Cloud Event, it attaches an `IncomingKafkaCloudEventMetadata` to the message metadata.  So, you can retrieve the various attributes as well as the extensions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コネクタはクラウドイベントを受信すると、メッセージのメタデータに `IncomingKafkaCloudEventMetadata`  をアタッチします。そのため、拡張だけでなく様々な属性を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the rise of event-driven architecture, Cloud Events are becoming highly popular.  Since Quarkus 1.9, the Kafka Connector used in Quarkus has built-in support for Cloud Events.  This post introduced Cloud Events and showed how you could write and read Cloud Events easily.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベント駆動型アーキテクチャの台頭に伴い、クラウドイベントの人気が高まっています。Quarkus 1.9以降、Quarkusで使用されているKafka ConnectorはCloud Eventsをビルトインでサポートしています。この投稿では、Cloud Eventsを紹介し、Cloud Eventsを簡単に書いたり読んだりする方法を紹介しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Many more options are http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[available], and Kafka is not the only part of Quarkus with Cloud Events support.  For example, Funqy[https://quarkus.io/guides/funqy#context-injection] also supports Cloud Event out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他にも多くのオプションが http://smallrye.io/smallrye-reactive-messaging/smallrye-reactive-messaging/2.5/kafka/kafka.html[用意]されており、KafkaだけがクラウドイベントをサポートしているQuarkusの一部ではありません。例えば、Funqy https://quarkus.io/guides/funqy#context-injection ]もクラウドイベントをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are very pleased to announce the 1.3.0 release of Quarkus Tools for IntelliJ.  This release brings codestarts support in the Quarkus project wizard.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Tools for IntelliJの1.3.0リリースを発表できることを大変嬉しく思います。このリリースでは、Quarkusプロジェクトウィザードにcodestartsのサポートが追加されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Codestarts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Codestarts</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus project wizard adds a new codestarts option, allowing to enable/disable codestarts generation for Quarkus extensions that support this feature.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトウィザードに新しいcodestartsオプションが追加され、この機能をサポートするQuarkusエクステンションのcodestarts生成を有効/無効にすることができるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Picocli</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.2.Final released - Bugfixes'
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.11.2.Final リリース - バグ修正
date: 2021-02-09
tags: release
synopsis: 1.11.2.Final では問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.2.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.2.Final は、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We upgraded to Hibernate ORM 5.4.27.SP1 which fixes an important issue, potentially causing data losses.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM 5.4.27.SP1 にアップグレードし、データ損失を引き起こす可能性のある重要な問題が修正されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus the upgrade is highly recommended.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>したがって、アップグレードを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Full changelog</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>完全な変更履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[the full changelog of 1.11.2.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.2.Final[GitHub 上で 1.11.2.Final の完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon DynamoDB</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon DynamoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We took a little break, but now another Newsletter round of stories found!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>少しお休みをとっていましたが、かなりの量の見つかったストーリーのニュースレターを発行します！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the news below - give it a read and if you feel something is missing or have an article coming out for future Quarkus Newsletter install the https://github.com/quarkusio/url2quarkuspub[bookmarklet] on your laptop and phone to easily submit a story. If you prefer the manual way please https://github.com/quarkusio/quarkusio.github.io/issues[open an issue] with a short description and a url.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のニュースを読んで、もし、何かが欠けていると感じたり、将来のQuarkus ニュースレターのために記事をお持ちの場合は、 link:https://github.com/quarkusio/url2quarkuspub[ブックマークレット] をラップトップやスマートフォンにインストールして、簡単に記事を投稿することができます。あなたが手動の方法を好む場合は、短い説明とURLを link:https://github.com/quarkusio/quarkusio.github.io/issues[Issueを登録] してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>楽しんで！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prerequisites</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.10.3.Final released - Bugfixes'
date: 2020-12-08
tags: release
synopsis: 1.10.3.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.10.3.Finalリリース - バグフィックス
date: 2020-12-08
tags: release
synopsis: 1.10.3.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.10.3.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.10.3.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it really helped a lot!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題を報告し、再現手順を提供してくれたすべてのコントリビューターに感謝します。非常に助かりました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[the full changelog of 1.10.3.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://github.com/quarkusio/quarkus/releases/tag/1.10.3.Final[GitHub上の1.10.3.Finalの完全な変更履歴]を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: post
title: 'Quarkus 1.11.1.Final released - Bugfixes'
date: 2021-01-27
tags: release
synopsis: 1.11.1.Final fixes issues and comes with documentation improvements.
author: gsmet
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: post
title: Quarkus 1.11.1.Finalリリース - バグフィックス
date: 2021-01-27
tags: release
synopsis: 1.11.1.Finalでは問題を修正し、ドキュメントの改善を行いました。
author: gsmet
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a maintenance release fixing bugs and improving the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.1.Finalは、バグの修正とドキュメントの改善を行うメンテナンスリリースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to all the contributors who reported issues and provided reproducers: it allowed us to make steady progress on fixing issues.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>問題点を報告し、再現手順を提供してくれたすべての貢献者に感謝します。問題の修正の確かな進捗に繋がりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also a big thanks to all the contributors providing pull requests, be they for the code or the documentation!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コードであれドキュメントであれ、プルリクエストを提供してくれたすべての貢献者にも感謝しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>1.11.1.Final is a safe upgrade for everyone using Quarkus 1.11.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.11.1.Finalは、Quarkus 1.11を使用しているすべての人にとって安全なアップグレードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recommended GraalVM version is now GraalVM 20.3.1.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの推奨バージョンはGraalVM 20.3.1になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can get https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[the full changelog of 1.11.1.Final on GitHub].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/quarkusio/quarkus/releases/tag/1.11.1.Final[GitHubで1.11.1.Finalの完全な変更履歴] を入手できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The purpose of this blog post is to clear up some confusion about RESTEasy Reactive and answer some commonly asked questions around it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このブログ記事の目的は、RESTEasy Reactive についての混乱を解消し、よくある質問に答えることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Acknowledgement</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>謝辞</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This blog post would not have been possible without the expert advice of https://twitter.com/clementplop[Clement Escoffier] and https://twitter.com/unfromage[Stéphane Épardaud]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このブログ記事は、 link:https://twitter.com/clementplop[Clement Escoffier] と link:https://twitter.com/unfromage[Stéphane Épardaud] の専門的なアドバイスなしでは実現できませんでした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Imperative and Reactive: the elevator pitch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令型とリアクティブ型: エレベーターピッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our quest to understand why RESTEasy Reactive is important and how it differs from RESTEasy Classic, it helps to paraphrase a very important message that was first introduced https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[here].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が重要な理由と、RESTEasy Classic と異なる点を理解するために、link:https://quarkus.io/blog/io-thread-benchmark/#imperative-and-reactive-the-elevator-pitch[ここ] で最初に紹介した非常に重要なメッセージを再び考察してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In general, Java web applications use imperative programming combined with blocking IO operations. This is incredibly popular because it is easier to reason about the code.  Things get executed sequentially. When the application receives a request, the framework associates this request to a worker thread.  When the request processing needs to interact with a database or another remote service, it relies on blocking IO.  The thread is blocked waiting for the answer, making the communication synchronous. With this model one request is not affected by another as they are run on different threads.  Even when one thread is waiting, other requests running on different threads are not slowed down significantly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的に、Java のWeb アプリケーションでは、ブロッキング IO 操作と組み合わせた命令型プログラミングを使用します。これは、コードを推論するのが簡単なので、非常に人気があります。物事は順次実行されます。アプリケーションがリクエストを受け取ると、フレームワークはこのリクエストをワーカースレッドに関連付けます。リクエスト処理がデータベースや他のリモートサービスと対話する必要があるときは、ブロッキング IO に依存します。スレッドは応答を待ってブロックされ、通信を同期化します。このモデルでは、1 つのリクエストは別のスレッドで実行されるので、別のリクエストの影響を受けません。1 つのスレッドが待機している場合でも、異なるスレッド上で実行されている他のリクエストが大幅に遅くなることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, with this model, you need one thread for every concurrent request, which places a limit on the achievable concurrency.  On the other side, the reactive execution model embraces asynchronous development models and non-blocking IO.  With this model, multiple requests can be handled by the same thread. When the processing of a request can no longer make progress (because it requests a remote service, or interacts with a database for example), it uses non-blocking IO.  Instead of blocking the thread, it schedules the operation and passes a continuation which would be invoked after the completion of the operationfootnote:[This article won’t detail how operating systems and non-blocking IO libraries enable such a model. Under the hood, kernel mechanisms such as select, epoll and ICMP are making the handling of IO very efficient, in terms of speed and resource utilization.].  This releases the thread immediately, which can then be used to serve another request. When the result of the IO operation is available, the processing of the request is resumed and continues its execution.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、このモデルでは、同時実行リクエストごとに1つのスレッドが必要となり、達成可能な同時実行性に制限が生じます。一方、リアクティブ実行モデルでは、非同期開発モデルとノンブロッキング IO を採用しています。このモデルでは、複数のリクエストを同じスレッドで処理することができます。(リモートサービスをリクエストしたり、データベースと対話したりするために) リクエストの処理が進まなくなった場合は、ノンブロッキング IO を使用します。スレッドをブロックする代わりに、操作をスケジュールし、操作の完了後に呼び出される継続を渡します footnote:[この記事ではOSとノンブロッキング IO ライブラリがどのようにそういったモデルを実現しているかの詳細には踏み込みません。内部的に、select、epoll、ICMPといったカーネルメカニズムがIO処理をスピードとリソース利用の観点で非常に効率的にしています]。これによりスレッドはすぐに解放され、別のリクエストに対応するために使用することができます。IO 操作の結果が利用可能になると、リクエストの処理が再開され、その実行が継続されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This model enables the usage of a single IO thread to handle multiple requests. There are three significant benefits.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このモデルでは、単一の IO スレッドを使用して複数のリクエストを処理することができます。3 つの大きなメリットがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, the response time is smaller because it does not have to jump to another thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、別のスレッドにジャンプする必要がないので、レスポンス時間が短くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Second, it reduces memory consumption as it decreases the usage of threads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>第 2 に、スレッドの使用量が減るため、メモリの消費量を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Third, your concurrency is no longer limited by the number of threads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>第 3 に、並行処理はスレッド数に制限されなくなりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The reactive model uses the hardware resources more efficiently, but... a significant pitfall lurks. If the processing of a request starts to block, things can go south really quickly as no other request can be handled. To avoid this, you need to learn how to write asynchronous and non-blocking code, how to schedule operations, how to write continuations, how to chain actions.  Basically, we need a way to structure asynchronous processing, and use non-blocking IO. No doubt, that consists of a paradigm shift.  In Quarkus, we want to make the shift as easy as possible, so RESTEasy Reactive allows you to choose whether an endpoint is blocking or non-blocking (an application is free to mix and match blocking and non-blocking methods at will).  So don’t be intimidated by the reactive word, the infrastructure is reactive, but your code can be either reactive or imperative. That’s what we mean by unification of reactive and imperative.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブモデルはハードウェアリソースをより効率的に使用しますが、重大な落とし穴が潜んでいます。もしリクエストの処理がブロックされ始めると、他のリクエストが処理できなくなるため、本当にすぐに事態が悪化してしまいます。これを避けるためには、非同期でノンブロッキングなコードの書き方、操作のスケジュールの立て方、連続処理の書き方、アクションの連鎖の仕方などを学ぶ必要があります。基本的には、非同期処理を構造化し、ノンブロッキングIOを使う方法が必要です。これは間違いなく、パラダイムシフトであることは間違いありません。Quarkusでは、このシフトをできるだけ簡単にしたいと考えているので、RESTEasy Reactiveでは、エンドポイントがブロッキングかノンブロッキングかを選択することができます (アプリケーションはブロッキングとノンブロッキングのメソッドを自由に組み合わせて使用することができます)。インフラストラクチャはリアクティブですが、あなたのコードはリアクティブ型にも命令型にもなり得ます。これが、リアクティブ型と命令型の統一の意味です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive by default handles each HTTP request on an IO thread (otherwise known as an event-loop thread)footnote:[More information about the execution model of RESTEasy Reactive can be found https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[here]].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、デフォルトでは IO スレッド(イベントループスレッドとして知られている)上の各 HTTP リクエストを処理します footnote:[RESTEasy Reactiveの実行モデルについて詳細は https://quarkus.io/guides/resteasy-reactive#execution-model-blocking-non-blocking[ここ] にあります]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following image shows what that looks at a high level:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のイメージでは、ハイレベルの様子を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-non-blocking.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RR-non-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This ensures that maximum throughput can be achieved, but it also means that the implementation of an endpoint method should complete in a timely fashion otherwise the thread will be used for too longfootnote:["Too long" depends on your target concurrency. You may consider 1ms as too long for some endpoint heavily used, but 100ms might be acceptable for less used endpoints] and other requests will be queued up and lead to degraded throughput.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、最大のスループットを達成することがきます。ただし、エンドポイントメソッドの実装がタイムリーに完了しなければならないことも意味しています。そうでなければ、スレッドの使用が長くなり過ぎてしまい footnote:["長過ぎる" は目標とする並列度次第です。頻繁に使用されるエンドポイントでは 1ms も長過ぎると考える場合もありますし、あまり使われないエンドポイントでは 100ms でも許容可能かもしれません。]、他のリクエストがキューイングされ、スループットの低下につながります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important to understand that a method body that uses imperative code only becomes a problem when it takes a long time to execute - which is almost always the case for blocking IO operations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>命令型コードを使用するメソッド本体が問題になるのは、実行に長い時間がかかるときだけ - ブロッキング IO 処理がほぼ全てのケース - であることを理解することが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For that reason, when the body of the method performs some kind of blocking IO operation (or even some CPU bound operation that requires time to complete), the request needs to be offloaded to a worker thread.  In RESTEasy Reactive that is done declaratively using the `@Blocking` annotation - no reactive programming or complex Java concurrency related code is needed.  Quarkus also warns you when you attempt to use blocking IO on an IO thread.  If however the method body performs non-blocking IO (or some CPU bound operation that completes very quickly) then RESTEasy Reactive can continue to serve the entire request on the IO thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、メソッドの本体が何らかのブロッキング IO 操作 (あるいは完了までに時間を要する CPU バインド操作) を実行する場合、リクエストはワーカースレッドにオフロードされる必要があります。RESTEasy Reactiveでは、`@Blocking` アノテーションを使用して宣言的に行われます。Quarkus は、IO スレッドでブロッキング IO を使用しようとした場合にも警告します。しかし、メソッド本体がノンブロッキング IO (または非常に速く完了するCPUバインド操作) を実行する場合、RESTEasy Reactive は、IO スレッド上でリクエスト全体を提供し続けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Is RESTEasy Reactive limited to using reactive APIs?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive はリアクティブAPIの使用に限定されているのでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Absolutely not!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もちろん違います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although RESTEasy Reactive was built from the ground up to do non-blocking IO and serve requests from the event loop threads (thus avoiding the needless usage of worker pool threads)  it can effortlessly work with blocking IO and any piece of code that provides a blocking API (such as Hibernate) without blocking the event loop.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、ノンブロッキング IO とイベントループスレッドからのリクエストを処理するために一から構築されていますが(そのため、ワーカープールスレッドの不要な使用を避けることができます)、ブロッキング IO と、(Hibernate のような) ブロッキング APIを提供するあらゆるコードをイベントループをブロッキングせずに簡単に動作させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The only thing you have to do is add `@Blocking` on your endpoint method or class.  That’s it! If you use `@Blocking` you are back to the regular dispatching mechanism: a worker thread is used to execute your method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントのメソッドやクラスに `@Blocking` を追加するだけです。これだけです。`@Blocking` を使用すると、通常のディスパッチの仕組み：ワーカースレッドがメソッドの実行に使用される方式に戻れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At a high level it this looks like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ハイレベルでは以下のようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RR-blocking.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RR-blocking.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Does RESTEasy Reactive require Hibernate Reactive?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy ReactiveはHibernate Reactiveを必要としますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can probably guess from the answer to the previous question, the answer is no.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の質問の答えからわかる通り、答えは「ノー」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate, the `@Blocking` annotation should be placed on the endpoint methods that interact with Hibernate.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が Hibernate と一緒に使用されるシナリオでは、 `@Blocking` アノテーションを Hibernate と相互作用するエンドポイントメソッドに配置する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In scenarios where RESTEasy Reactive is used along with Hibernate Reactive, no `@Blocking` annotation is necessary on the endpoint methods that interact with Hibernate Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive が Hibernate Reactive とともに使用されるシナリオでは、Hibernate Reactive と相互作用するエンドポイントメソッドに `@Blocking` アノテーションは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the performance implication of using @Blocking?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Blocking を使用することによるパフォーマンスへの影響について</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the absolute highest throughput is achieved when an endpoint method is non-blocking (that is the HTTP request is served completely from the event loop thread), great performance can nonetheless be achieved even when `@Blocking` is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンドポイントメソッドがノンブロッキング (つまり、HTTP リクエストがイベントループスレッドから完全に提供される) の場合には、絶対的に最高のスループットが達成されますが、 `@Blocking` を使用していても優れたパフォーマンスを達成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our benchmarks we see the use of `@Blocking` reduce maximum throughput by around 30%footnote:[This is basically the cost we have to pay for dispatching the request to a worker thread. The percentage of the slowdown decreases the longer the target method takes to execute].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのベンチマークでは、`@Blocking` を使用することで最大スループットが約 30%footnote 低下することがわかります footnote:[これは基本的にワーカースレッドにリクエストを振り分けるためにかかるコストです]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, an endpoint method using `@Blocking` in RESTEasy Reactive still achieves around 50% higher throughput than the same method using RESTEasy Classic.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、RESTEasy Reactive で `@Blocking` を使用したエンドポイントメソッドでは、RESTEasy Classic を使用した同じメソッドよりも約 50% 高いスループットを達成しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Why does RESTEasy Reactive using @Blocking perform better than RESTEasy Classic?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>なぜ @Blocking を使用した RESTEasy Reactive は RESTEasy Classic よりもパフォーマンスが良いのですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is able to gain its performance advantage over RESTEasy Classic by:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、RESTEasy Classic と比較して、以下のような特徴を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integrating very tightly with Eclipse Vert.x for everything IO related. Vert.x has been extremely well optimized for IO operations and so tight integration with it allows RESTEasy Reactive to benefit from all that work.  You might recall that RESTEasy Classic on Quarkus uses Vert.x under the hood as well, but in that case the integration is not as deep and is therefore unable to fully utilize the power of Vert.x.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IO に関連するすべてを Eclipse Vert.x と緊密に統合します。Vert.x は IO 操作のために非常によく最適化されています。そのため、RESTEasy Reactive はそれとの緊密な統合により、その恩恵を受けることができます。RESTEasy Classic on Quarkus も同様に Vert.x を使用しています。ただし、その場合、統合はそれほど深くないため、Vert.x のパワーを十分に活用することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Moving a lot of work to build time. As RESTEasy Reactive was built from the ground up to serve the needs of Quarkus, it benefits from the tightest possible integration with Quarkus and is probably the extension that does the most build time work.  This in turn results in creating an optimal data pipeline for serving each request, helping the JIT compiler by generating bytecode to inline runtime operations, eliminating reflection at runtime (both for invoking methods and for determining types) and reducing memory allocations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの作業をビルド時に移行しています。RESTEasy Reactive は、Quarkus のニーズに応えるためにゼロから構築されています。そのため、Quarkus との統合が可能な限り緊密に行われており、おそらく最も多くをビルド時に作業を行うエクステンションとなっています。これにより、各リクエストを処理するための最適なデータパイプラインを作成し、実行時の操作をインラインで行うバイトコードを生成することで JIT コンパイラを支援し、実行時の (メソッドの呼び出しと型の決定のための) リフレクションを排除し、メモリの割り当てを削減します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Avoiding the use of ThreadLocals and instead by utilizing a context object that contains all the necessary information.  ThreadLocals are a convenient way to make data available to different parts of a framework, but their frequent use comes at a cost and are thus fully avoided in RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ThreadLocals の使用を避け、代わりに必要な情報をすべて含むコンテキストオブジェクトを利用します。ThreadLocals はフレームワークのさまざまな部分でデータを利用できるようにする便利な方法です。ただし、その頻繁な使用にはコストがかかるため、RESTEasyReactive では完全に回避されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Utilizing Arc in an optimal manner for all necessary injections. RESTEasy Classic provides an abstraction layer that performs the various injection operations, which for the needs of Quarkus is entirely unnecessary since Arc provides the same functionality with better performance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要なすべてのインジェクションに最適な方法でArcを活用します。RESTEasy Classic は、さまざまなインジェクション操作を実行する抽象化レイヤーを提供しますが、Arcは同じ機能をより優れたパフォーマンスで提供するため、Quarkus のニーズには全く不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>How does it compare to RESTEasy Classic with Mutiny?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Classic with Mutiny との比較はどうでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You might recall that Quarkus allows you to use Mutiny return types (Uni and Multi) when using RESTEasy Classic via the `quarkus-resteasy-mutiny` extension and thus might be wondering how that compares to using RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Classic を使用しているときに Quarkus では、`quarkus-resteasy-mutiny` エクステンションを介して Mutiny 戻り値の型 (UniとMulti) を使用することができることや、これが RESTasy Reactive の使用と、どのように異なるかと思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main thing to understand about RESTEasy Classic is that it *always* handles requests on a worker thread as it does not use the event-loop concept at all.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Classic について最も理解しておくべきこととして、RESTEasy Classic はイベントループの概念を一切使用しないため、*常に*ワーカースレッド上でリクエストを処理することがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is best shown by the following image:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを最もよく表しているのは、以下の画像です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CR.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CR.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So when using RESTEasy Classic even when you return a reactive type like `Uni` or `Multi` the initial request is still being handled on a worker thread and while the call to the library may result in non-blocking IO, nevertheless there is no way for RESTEasy Classic to reuse the worker thread once it is blocked waiting on IO.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そのため、RESTEasy Classic を使用する場合、`Uni` や `Multi` のようなリアクティブ型を返しても、最初のリクエストはワーカースレッドで処理され、ライブラリーの呼び出しはノンブロッキング IO になることがあります。それでも IO の待機中にブロックされると、RESTEasyClassic がワーカースレッドを再利用する方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, the gain of using reactive return types in RESTEasy Classic is a syntactic gain, not a runtime gain - the underlying hardware isn’t used more efficiently despite the use of reactive types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように、RESTEasy Classic でリアクティブな戻り値型を使用することで得られる利益は、ランタイムの利益ではなく、構文的な利益です。リアクティブ型を使用していても、基礎となるハードウェアが、より効率的に使用されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When returning Mutiny types using RESTEasy Reactive, everything happens on the IO Thread (except if the endpoint is annotated with `@Blocking`). By the way, no need for an external extension to use Mutiny with RESTEasy Reactive, it’s built-in!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive を使用して Mutiny 型を返す場合、すべての処理は IO スレッド上で行われます (エンドポイントが `@Blocking` でアノテーションされている場合を除く)。RESTEasy Reactive で Mutiny を使用するための外部エクステンションは不要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do I have to use the new RESTEasy Reactive APIs to achieve maximum performance?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最大のパフォーマンスを実現するためには、新しい RESTEasy Reactive API を使用する必要がありますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reading through the RESTEasy Reactive documentation you soon come across the new APIs for writing request filters (https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[@ServerRequestFilter]), response filters (`@ServerResponseFilter`) and exception mappers (https://quarkus.io/guides/resteasy-reactive#exception-mapping[@ServerExceptionMapper]).  You might wonder if their usage affects performance in any way compared to the standard JAX-RS APIs (`ContainerRequestFilter`, `ContainerResponseFilter` and `ExceptionMapper`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive のドキュメントを読むと、すぐにリクエストフィルター link:https://quarkus.io/guides/resteasy-reactive#request-or-response-filters[(@ServerRequestFilter])、レスポンスフィルター (`@ServerResponseFilter`)、例外マッパー link:https://quarkus.io/guides/resteasy-reactive#exception-mapping[(@ServerExceptionMapper]) を記述するための新しい API に出くわします。これらの使用法が標準の JAX-RS API (`ContainerRequestFilter`, `ContainerResponseFilter`, `ExceptionMapper`) と比べてパフォーマンスに影響を与えるかどうかを疑問に思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the new APIs will give a tiny performance advantage over using the old APIs if the use of `@Context` is involved in the latter case, the advantage is negligible and should not worry you unless you are trying to squeeze out every inch of performance you can find.  One thing to keep in mind when writing filters with either API, is that using `org.jboss.resteasy.reactive.server.SimpleResourceInfo` instead of `javax.ws.rs.container.ResourceInfo` is advised as the latter results in reflection being performed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>後者のケースで `@Context` を使用する場合、新しい API は古い API を使用するよりもわずかなパフォーマンスの優位性を与えます。ただし、その優位性は取るに足らない程度で、可能な限りのパフォーマンスを限界まで引き出すのでない限り、心配する必要はありません。どちらの API を使ってフィルターを書く場合でも注意すべきことは、`javax.ws.rs.container.ResourceInfo` の代わりに `org.jboss.resteasy.reactive.server.SimpleResourceInfo` を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A special (albeit rather advanced) case where the new APIs do result in noticeably better performance is the case of `MessageBodyReader` and `MessageBodyWriter` classes.  When reading the HTTP request and writing the HTTP response, the use of https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader] and `ServerMessageBodyWriter` allows RESTEasy Reactive to optimize the data-path for serving the request.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しい API によってパフォーマンスが顕著に向上する特別なケースとして、`MessageBodyReader` と `MessageBodyWriter` クラスがあります。HTTP リクエストの読み込みと HTTP レスポンスの書き込みの際に、 link:https://quarkus.io/guides/resteasy-reactive#readers-and-writers-mapping-entities-and-http-bodies[ServerMessageBodyReader]と `ServerMessageBodyWriter` を使用することで、RESTEasy Reactive はリクエストを提供するためのデータパスを最適化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What about Reactive Routes?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブルートは？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus was already providing a way to handle HTTP requests from the IO thread. Reactive Routes provides a declarative model to implement HTTP API. Each route can be called on the IO thread (default) or on a worker thread (using the `@Blocking` annotation).  Reactive Routes provide very good throughput and performance as highlighted in https://quarkus.io/blog/io-thread-benchmark/[this] article. How does reactive routes compare to RESTEasy Reactive?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはすでに IO スレッドから HTTP リクエストを処理する方法を提供していました。Reactive Routes (リアクティブルート) は、HTTP API を実装するための宣言モデルを提供します。各ルートは、IO スレッド (デフォルト) またはワーカースレッド (`@Blocking` アノテーションを使用) で呼び出すことができます。link:https://quarkus.io/blog/io-thread-benchmark/[この]記事で強調されているように、Reactive Routes は非常に優れたスループットとパフォーマンスを提供します。リアクティブルートは RESTEasy Reactive と比較してどうでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main complaints we got about Reactive Routes was about the development model: it’s very different from the one used with RESTEasy. However, Reactive Routes allowed us to verify the performance and efficiency benefits of using an end-to-end reactive model on top of Quarkus.  RESTEasy Reactive can be seen as the “next generation”: you get the runtime benefits while also using a familiar development model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Reactive Routes についての主な不満の 1 つは、開発モデルに関するものでした。RESTEasy で使用したものとは大きく異なります。しかし、Reactive Routes を使用することで、Quarkus 上にエンドツーエンドのリアクティブモデルを使用することで得られるパフォーマンスと効率性のメリットを検証することができました。RESTEasy Reactive は「次世代」と考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTEasy Reactive is the next generation of HTTP framework. It unifies reactive (non-blocking IO, asynchronous APIs) and imperative (thanks to the `@Blocking` annotation). It improves raw performances without constraining the user experience.  Its reactive/imperative duality makes it fit any use cases, from highly concurrent HTTP APIs, to more traditional transactional CRUD applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は次世代の HTTP フレームワークです。リアクティブ型 (ノンブロッキング IO、非同期 API) と命令型 (`@Blocking` アノテーションを使用) を統合しています。ユーザーエクスペリエンスを制限することなく、生のパフォーマンスを向上させます。その命令型/リアクティブ型の二面性により、高度に並列化された HTTP API から、より伝統的なトランザクション型の CRUD アプリケーションまで、あらゆるユースケースに適合するようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We see RESTEasy Reactive as becoming the default HTTP layer in Quarkus in the near future and are completely committed to making it perform at the best possible level while also introducing new features that spark developer joy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasy Reactive は、近い将来 Quarkus のデフォルト HTTP レイヤーになると思われます。また、開発者にうれしい新機能を導入しながら、可能な限り最高のパフォーマンスを実現することに完全にコミットしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In that vein, we hope that this short blog post will provide you with some insight on what makes RESTEasy Reactive special and clear up any misconceptions you may have had about it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この短いブログ記事が、RESTEasy Reactive が特別である理由と、RESTEasy Reactive について抱いていた誤解を解き明かすためのヒントになればと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`-Djava.util.logging.manager=org.jboss.logmanager.LogManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Core</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Error 404</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Error 404</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have found nowhere.&lt;br/&gt;The pathway to normal space&lt;br/&gt;is found in the nav.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どこでもないスペースを見つけました。&lt;br/&gt;
通常のスペースへのパスは、&lt;br/&gt;
ナビゲーションメニューに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A haiku for you.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ポエム
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide, you need:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドを完成させるには、以下が必要です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 1.8+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK 1.8+ がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Maven {maven-version}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `pom.xml` に以下が追加されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>References</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security provides the architecture, multiple authentication and authorization mechanisms, and other tools for the developers to build a production-quality security for their Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityでは、開発者がQuarkusアプリケーションの商用品質のセキュリティを構築するためのアーキテクチャ、複数の認証および認可メカニズム、その他のツールを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document provides a brief overview of Quarkus Security and links to the individual guides.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus Securityの簡単な概要と、各ガイドへのリンクについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`HttpAuthenticationMechanism` is the main entry into Quarkus HTTP Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`HttpAuthenticationMechanism`  は、Quarkus HTTP Securityのメインエントリです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security Manager uses `HttpAuthenticationMechanism` to extract the authentication credentials from the HTTP request and delegates to `IdentityProvider` to complete the conversion of these credentials to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Security Managerは、 `HttpAuthenticationMechanism`  を使用してHTTPリクエストから認証資格情報を抽出し、 `IdentityProvider`  に委任して、これらの資格情報の `SecurityIdentity`  への変換を完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the credentials may be coming with the HTTP `Authorization` header, client HTTPS certificates or cookies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、資格情報は、HTTP `Authorization`  ヘッダー、クライアントの HTTPS 証明書、またはクッキーを使用している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` verifies the authentication credentials and maps them to `SecurityIdentity` which contains the username, roles, the original authentication credentials, and other attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`IdentityProvider`  は認証資格情報を検証し、ユーザ名、ロール、元の認証資格情報、およびその他の属性を含む `SecurityIdentity`  にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For every authenticated resource, you can inject a `SecurityIdentity` instance to get the authenticated identity information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証済みリソースごとに、 `SecurityIdentity`  インスタンスを注入して、認証済みの ID 情報を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In some other contexts you may have other parallel representations of the same information (or parts of it) such as `SecurityContext` for JAX-RS or `JsonWebToken` for JWT.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>他の文脈では、JAX-RSであれば `SecurityContext`  、JWTであれば `JsonWebToken`  のように、同じ情報（またはその一部）を他の別の表現で表現している場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authentication mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports several sources to load authentication information from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、認証情報をロードするためのいくつかのソースをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基本認証とフォーム認証の仕組み</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic and Form HTTP-based authentication mechanisms are the core authentication mechanisms supported in Quarkus.  Please see link:security-built-in-authentication#basic-auth[Basic HTTP Authentication] and link:security-built-in-authentication#form-auth[Form HTTP Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Basic HTTPベースの認証メカニズムとForm HTTPベースの認証メカニズムは、Quarkusでサポートされている主要な認証メカニズムです。詳細については、 link:security-built-in-authentication#basic-auth[基本HTTP認証]と link:security-built-in-authentication#form-auth[フォームHTTP認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutual TLS Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>相互TLS認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides Mutual TLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは相互TLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security-built-in-authentication#mutual-tls[Mutual TLS Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳しくは link:security-built-in-authentication#mutual-tls[相互TLS認証] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenId Connect</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenId Connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-oidc` extension provides a reactive, interoperable, multi-tenant enabled OpenId Connect adapter which supports `Bearer Token` and `Authorization Code Flow` authentication mechanisms.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-oidc`  エクステンションは、 `Bearer Token`  および `Authorization Code Flow`  認証メカニズムをサポートする、リアクティブで相互運用可能なマルチテナント対応の OpenId Connect アダプタを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Bearer Token` mechanism extracts the token from HTTP `Authorization` header.  `Authorization Code Flow` mechanism uses OpenId Connect Authorization Code flow. It redirects the user to IDP to authenticate and completes the authentication process after the user has been redirected back to Quarkus by exchanging the provided code grant for ID, access and refresh tokens.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer Token`  メカニズムは、HTTP `Authorization`  ヘッダーからトークンを抽出します。 `Authorization Code Flow`  メカニズムは、OpenId Connect Authorization Code Flowを使用します。ユーザーをIDPにリダイレクトして認証を行い、提供されたCode GrantをID、アクセストークン、リフレッシュトークンと交換することで、ユーザーがQuarkusにリダイレクトされた後に認証プロセスを完了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ID and access `JWT` tokens are verified with the refreshable `JWK` key set but both JWT and opaque (binary) tokens can be introspected remotely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ID とアクセス `JWT` トークンは、リフレッシュ可能な `JWK` キーセットで検証されますが、JWT と不透明な (バイナリの) トークンの両方をリモートで検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect[Using OpenID Connect to Protect Service Applications] guide for more information about `Bearer Token` authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer Token` 認証メカニズムの詳細については、 link:security-openid-connect[Using OpenID Connect to Protect Service Applications]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application] guide for more information about `Authorization Code Flow` authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Authorization Code Flow`  認証メカニズムの詳細については、 link:security-openid-connect-web-authentication[Using OpenID Connect to Protect Web Application]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both `quarkus-oidc` `Bearer` and `Authorization Code Flow` Authentication mechanisms use &lt;&lt;smallrye-jwt, SmallRye JWT&gt;&gt; to represent JWT tokens as Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-oidc` の`Bearer` と `Authorization Code Flow`  認証メカニズムはいずれも link:#smallrye-jwt[SmallRye JWT ]を使用して、JWT トークンを Microprofile JWT `org.eclipse.microprofile.jwt.JsonWebToken` として表現しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-openid-connect-multitenancy[Using OpenID Connect Multi-Tenancy] for more information about multiple tenants which can support `Bearer` or `Authorization Code Flow` authentication mechanism and configured statically or dynamically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Bearer`  または `Authorization Code Flow`  認証メカニズムをサポートし、静的または動的に設定できる複数のテナントの詳細については、 link:security-openid-connect-multitenancy[OpenID Connect マルチテナントの使用]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you would like to have Quarkus OIDC extension enabled at runtime then set `quarkus.oidc.tenant-enabled=false` at build time and re-enable it at runtime using a system property.  See also link:security-openid-connect-multitenancy#disable-tenant[Disabling Tenant Configurations] for more information about managing the individual tenant configurations in the multi-tenant OIDC deployments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行時にQuarkus OIDCエクステンションを有効にしたい場合は、ビルド時に `quarkus.oidc.tenant-enabled=false` を設定し、システムプロパティを使用して実行時に再度有効にします。マルチテナントOIDCデプロイメントでの個々のテナント設定の管理の詳細については、テナント link:security-openid-connect-multitenancy#disable-tenant[設定の無効化]も参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Keycloak and Bearer tokens then also see the link:security-keycloak-authorization[Using Keycloak to Centralize Authorization] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Keycloak と Bearer トークンを使用する場合は、 link:security-keycloak-authorization[Using Keycloak to Centralize Authorization]ガイドも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to configure Keycloak programmatically then consider using https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API] with the help of the `quarkus-keycloak-admin-client` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Keycloakをプログラムで設定する必要がある場合は、 `quarkus-keycloak-admin-client` エクステンションの助けを借りて、 link:https://www.keycloak.org/docs/latest/server_development/#admin-rest-api[Keycloak Admin REST API]の使用を検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SmallRye JWT</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SmallRye JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-smallrye-jwt` provides Microprofile JWT 1.1.1 implementation and many more options to verify signed and encrypted `JWT` tokens and represent them as `org.eclipse.microprofile.jwt.JsonWebToken`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-smallrye-jwt` はMicroprofile JWT 1.1.1.1 の実装と、署名・暗号化された `JWT` トークンを検証し、 `org.eclipse.microprofile.jwt.JsonWebToken` として表現するための多くのオプションを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It can currently verify only `JWT` tokens using the PEM keys or refreshable `JWK` key set.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それは `quarkus-oidc` ベアラートークン認証メカニズムに代わるものを提供します。現在、PEM 鍵または更新可能な `JWK` 鍵セットを使用して `JWT` トークンのみを検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additionally it provides `JWT Generation API` for creating `signed`, `inner-signed` and/or `encrypted` `JWT` tokens with ease.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、 `JWT Generation API` を提供して、 `signed` , `inner-signed` , および/または `encrypted` `JWT`トークンを簡単に作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-jwt[Using SmallRye JWT] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-jwt[Using SmallRye JWT]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OAuth2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OAuth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-elytron-security-oauth2` provides an alternative to `quarkus-oidc` Bearer Token Authentication Mechanism. It is based on `Elytron` and is primarily meant for introspecting the opaque tokens remotely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-elytron-security-oauth2`  は `quarkus-oidc`  Bearer Token 認証メカニズムの代替手段を提供します。これは `Elytron` をベースにしており、主に不透明なトークンをリモートでイントロスペクトするためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:security-oauth2[Using OAuth2] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-oauth2[OAuth2 の使用]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see the link:security-ldap[Authenticate with LDAP] guide for more information about LDAP authentication mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>LDAP認証メカニズムの詳細については、 link:security-ldap[Authenticate with LDAP]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity Providers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイデンティティ・プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`IdentityProvider`  は、 `HttpAuthenticationMechanism`  が提供する認証資格情報を `SecurityIdentity`  に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions such as `OIDC`, `OAuth2`, `SmallRye JWT`, `LDAP` have the inlined `IdentityProvider` implementations which are specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`OIDC` , `OAuth2` , `SmallRye JWT` , `LDAP`  などのエクステンションには、サポートされている認証フローに固有の `IdentityProvider` のインライン実装があります。例えば、 `quarkus-oidc` は独自の `IdentityProvider` を使用してトークンを `SecurityIdentity` に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use `Basic` or `Form` HTTP-based authentication then you have to add an `IdentityProvider` which can convert a user name and password to `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Basic` または `Form` HTTP ベースの認証を使用している場合は、ユーザー名とパスワードを `SecurityIdentity` に変換できる `IdentityProvider` を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-jpa[JPA IdentityProvider] and link:security-jdbc[JDBC IdentityProvider] for more information.  You can also use link:security-testing#configuring-user-information[User Properties IdentityProvider] for testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、 link:security-jpa[JPA IdentityProvider]および link:security-jdbc[JDBC IdentityProvider]を参照してください。また、テストに link:security-testing#configuring-user-information[User Properties IdentityProvider を]使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Combining Authentication Mechanisms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証メカニズムの組み合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One can combine multiple authentication mechanisms if they get the authentication credentials from the different sources.  For example, combining built-in `Basic` and `quarkus-oidc` `Bearer` authentication mechanisms is allowed, but combining `quarkus-oidc` `Bearer` and `smallrye-jwt` authentication mechanisms is not allowed because both will attempt to verify the token extracted from the HTTP `Authorization Bearer` scheme.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるソースから認証証明書を取得する場合、複数の認証メカニズムを組み合わせることができます。例えば、組み込みの `Basic`  と `Bearer`   `quarkus-oidc`  認証機構を組み合わせることはできますが、 `quarkus-oidc`   `Bearer`  と `smallrye-jwt`  認証機構を組み合わせることはできません。なぜなら、両方とも HTTP `Authorization Bearer`  スキームから抽出されたトークンを検証しようとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proactive Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロアクティブ認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます（ターゲットページが認証を必要としない場合でも）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-built-in-authentication#proactive-authentication[Proactive Authentication] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security-built-in-authentication#proactive-authentication[プロアクティブ認証]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Authorization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-authorization[Security Authorization] for more information about Role Based Access Control and other authorization options.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>役割ベースのアクセス制御およびその他の認可オプションの詳細については、 link:security-authorization[セキュリティ認可]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customization and other useful tips</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタマイズやその他の便利なヒント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Security is highly customizable. One can register custom ``HttpAuthenticationMechanism``s, ``IdentityProvider``s and ``SecurityidentityAugmentor``s.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityは、高度なカスタマイズが可能です。カスタム `HttpAuthenticationMechanism` 、 `IdentityProvider` 、 `SecurityidentityAugmentor` を登録することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-customization[Security Customization] for more information about customizing Quarkus Security and other useful tips about the reactive security, registering the security providers, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityのカスタマイズの詳細や、リアクティブセキュリティ、セキュリティプロバイダーの登録などの便利なヒントについては、セキュリティの link:security-customization[カスタマイズ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:http-reference#ssl[Supporting secure connections with SSL] guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:http-reference#ssl[SSL による安全な接続のサポート]ガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cross-Origin Resource Sharing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クロスオリジンリソース共有</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to make your Quarkus application accessible to another application running on a different domain, you will need to configure CORS (Cross-Origin Resource Sharing). Please read the link:http-reference#cors-filter[HTTP CORS documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを別のドメインで実行している別のアプリケーションにアクセスできるようにする場合は、CORS（Cross-Origin Resource Sharing）を設定する必要があります。詳細については、 link:http-reference#cors-filter[HTTP CORSのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:security-testing[Security Testing] for more information about testing Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityのテストの詳細については、 link:security-testing[セキュリティのテスト]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secret Engines</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットエンジン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a very comprehensive HashiCorp Vault support, please see the link:vault[Quarkus and HashiCorp Vault] documentation for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは非常に包括的な HashiCorp Vault のサポートを提供しています。詳しくは link:vault[Quarkus and HashiCorp Vault] のドキュメントを参照下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mutiny</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mutiny</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw compile quarkus:dev
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、完成した例にそのまま進んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gitレポジトリをクローンするか `git clone {quickstarts-clone-url}` 、 {quickstarts-archive-url}[アーカイブ] をダウンロードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need a new project. Create a new project with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、新しいプロジェクトが必要です。以下のコマンドで新規プロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello";
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with AMQP.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを利用してAMQPと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルの構築</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Package and run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをパッケージ化して実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Reactive Routes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブルートの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for properties file based authentication that is intended for development and testing purposes. It is not recommended that this be used in production as at present only plaintext and MD5 hashed passwords are used, and properties files are generally too limited to use in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、開発とテストを目的としたプロパティファイルベースの認証をサポートしています。現在のところ、平文とMD5ハッシュ化されたパスワードしか使用されておらず、プロパティファイルは一般的に本番環境で使用するには制限が多すぎるため、本番環境で使用することはお勧めできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下を `pom.xml` に追加してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The elytron-security-properties-file extension currently supports two different realms for the storage of authentication and authorization information. Both support storage of this information in properties files. The following sections detail the specific configuration properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>elytron-security-properties-file エクステンションは、現在、認証と認可情報の保存のための2つの異なる領域をサポートしています。どちらもこの情報のプロパティファイルへの保存をサポートしています。以下のセクションでは、特定の設定プロパティについて詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties Files Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティファイルレルム設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties files realm supports mapping of users to password and users to roles with a combination of properties files. They are configured with properties starting with `quarkus.security.users.file`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティファイルのレルムは、プロパティファイルの組み合わせを使用して、ユーザーをパスワードに、ユーザーをロールにマッピングすることをサポートしています。これらは `quarkus.security.users.file` で始まるプロパティで構成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Users.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーズプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `quarkus.security.users.file.users` configuration property specifies a classpath resource which is a properties file with a user to password mapping, one per line. The following &lt;&lt;test-users-example&gt;&gt; illustrates the format:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.security.users.file.users` 設定プロパティは、クラスパスリソースを指定します。これは、1行に1つずつ、ユーザーとパスワードをマッピングしたプロパティファイルです。以下の link:#test-users-example[test-users-example] はそのフォーマットを示しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password defined as `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` のパスワードは `jb0ss` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has password defined as `p4ssw0rd`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `jdoe` のパスワードは `p4ssw0rd` と定義されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルには、ユーザ名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Roles.properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Roles.properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has been assigned the roles `Admin`, `admin`, `Tester` and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester` および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `jdoe` has been assigned the role `NoRolesUser`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `jdoe` に役割が割り当てられています。 `NoRolesUser`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has been assigned the roles `admin` and `user`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` には `admin` と `user` の役割が割り当てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Realm Configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンベデッドレルムの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The embedded realm also supports mapping of users to password and users to roles. It uses the main `application.properties` Quarkus configuration file to embed this information. They are configured with properties starting with `quarkus.security.users.embedded`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>埋め込まれたレルムは、ユーザーのパスワードへのマッピングやユーザーのロールへのマッピングもサポートしています。この情報を埋め込むには、メインの `application.properties` Quarkus設定ファイルを使用します。これらは、 `quarkus.security.users.embedded` で始まるプロパティで設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example application.properties file section illustrating the embedded realm configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下は、組み込みレルムの設定を示すapplication.propertiesファイルのセクションの例です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the first example this file has the usernames and passwords stored in plain text, which is not recommended. If plain-text is set to false (or omitted) in the config then passwords must be stored in the form `MD5 ( username : realm : password )`. This can be generated for the first example above by running the command `echo -n scott:MyRealm:jb0ss | md5` from the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初の例と同様に、このファイルにはユーザ名とパスワードがプレーンテキストで保存されていますが、これは推奨されません。設定でプレーンテキストが false に設定されている (または省略されている) 場合、パスワードは `MD5 ( username : realm : password )` の形式で保存されなければなりません。これは上記の最初の例では、コマンドラインから `echo -n scott:MyRealm:jb0ss | md5` コマンドを実行することで生成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Users</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>組込ユーザー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to password mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;`. The following &lt;&lt;password-example&gt;&gt; illustrates the syntax with 4 user to password mappings:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーからパスワードへのマッピングは、 `application.properties` ファイル内で `quarkus.security.users.embedded.users.&lt;user&gt;=&lt;password&gt;` 形式のプロパティキーで指定します。以下の link:#password-example[password-example] は]、4 つのユーザーからパスワードへのマッピングの構文を示しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Passwords</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスワードの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has password `jb0ss`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` はパスワード `jb0ss` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has password `test`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` はパスワード `test` を持っています</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Embedded Roles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>組込ロール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user to role mappings are specified in the `application.properties` file by properties keys of the form `quarkus.security.users.embedded.roles.&lt;user&gt;=role1[,role2[,role3[,...]]]`. The following &lt;&lt;roles-example&gt;&gt; illustrates the syntax with 4 user to role mappings:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザとロールのマッピングは、 `application.properties` ファイルで `quarkus.security.users.embedded.roles.&amp;amp;lt;user&amp;amp;gt;=role1[,role2[,role3[,…​]]]` 形式のプロパティ・キーで指定されます。以下の link:#roles-example[[role-example]]は、4つのユーザとロールをマッピングした構文を示しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Roles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロールの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `scott` has roles `Admin`, `admin`, `Tester`, and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `scott` には `Admin`, `admin`, `Tester`, および `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>User `stuart` has roles `admin` and `user`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `stuart` には `admin` と `user`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:security[Quarkus Security]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While users are encouraged to use link:cache[Quarkus annotations for caching], Quarkus nevertheless provides a compatibility layer for Spring Cache annotations in the form of the `spring-cache` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーは link:cache[キャッシュ用のQuarkusアノテーション] を使用することが推奨されていますが、Quarkusはそれにもかかわらず、 `spring-cache` エクステンションの形でSpring Cacheアノテーションの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how a Quarkus application can leverage the well known Spring Cache annotations to enable application data caching for their Spring beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがよく知られているSpring Cacheアノテーションを活用して、Spring Beanのアプリケーションデータのキャッシュを可能にする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project with a REST endpoint and imports the `spring-cache` and `spring-di` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `spring-cache` と `spring-di` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `spring-cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `spring-cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service which will simulate an extremely slow call to an external meteorological service.  Create `src/main/java/org/acme/spring/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは、外部の気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/spring/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is where the slowness comes from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅さの原因はここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class which contains the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/spring/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、ユーザーが3日間の天気予報を聞いてきたときに、ユーザーに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/spring/cache/WeatherForecast.java` をこのように作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, we just need to update the generated `WeatherForecastResource` class to use the service and response:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あとは、サービスとレスポンスを使用するために生成された `WeatherForecastResource` クラスを更新するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `daysInFuture` query parameter is omitted, the three days weather forecast will start from the current day.  Otherwise, it will start from the current day plus the `daysInFuture` value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`daysInFuture` クエリパラメータが省略された場合、3 日間の天気予報は現在の日から始まります。それ以外の場合は、現在の日に `daysInFuture` の値を加えたものから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We're all done! Let's check if everything's working.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>終わりました！すべて上手く動いているか確認してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, run the application using `./mvnw compile quarkus:dev` from the project directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、プロジェクトディレクトリから `./mvnw compile quarkus:dev` を使ってアプリケーションを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, call `http://localhost:8080/weather?city=Raleigh` from a browser.  After six long seconds, the application will answer something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、ブラウザから `http://localhost:8080/weather?city=Raleigh` を呼び出します。6秒ほど長い時間が経過すると、アプリケーションはこのような回答をします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The response content may vary depending on the day you run the code.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードを実行する日によってレスポンスの内容が異なる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can try calling the same URL again and again, it will always take six seconds to answer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何度も同じURLを呼び出してみても、必ず6秒で返事が返ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling the cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュの有効化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that your Quarkus application is up and running, let's tremendously improve its response time by caching the external meteorological service responses.  Update the `WeatherForecastService` class as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションが稼働しているので、外部の気象サービスのレスポンスをキャッシュすることで、レスポンスタイムを大幅に改善してみましょう。 `WeatherForecastService` クラスを以下のように更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We only added this annotation (and the associated import of course).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーション（もちろん関連するインポートも）を追加しただけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's try to call `http://localhost:8080/weather?city=Raleigh` again.  You're still waiting a long time before receiving an answer.  This is normal since the server just restarted and the cache was empty.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`http://localhost:8080/weather?city=Raleigh` をもう一度呼び出して確認してみてください。返事が来るまでにまだ長い時間待たされています。これはサーバが再起動したばかりでキャッシュが空になっているので正常です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wait a second! The server restarted by itself after the `WeatherForecastService` update? Yes, this is one of Quarkus amazing features for developers called `live coding`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ちょっと待って！？ `WeatherForecastService` のアップデート後、サーバーが勝手に再起動した？はい、これは、 `live coding` と呼ばれる開発者のためのQuarkusの驚くべき機能の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the cache was loaded during the previous call, try calling the same URL.  This time, you should get a super fast answer with an `executionTimeInMs` value close to 0.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前回の呼び出しでキャッシュが読み込まれたので、同じ URL を呼び出してみてください。今度は、 `executionTimeInMs` の値が 0 に近い超高速な応答が返ってくるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's see what happens if we start from one day in the future using the `http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` URL.  You should get an answer two seconds later since two of the requested days were already loaded in the cache.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>URL `http://localhost:8080/weather?city=Raleigh&amp;daysInFuture=1` を使って未来のある日から始めるとどうなるか見てみましょう。要求された日のうち2つはすでにキャッシュに読み込まれていたので、2秒後に回答が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also try calling the same URL with a different city and see the cache in action again.  The first call will take six seconds and the following ones will be answered immediately.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、同じURLを別の都市で呼び出してみて、再度キャッシュの動作を確認することもできます。最初の呼び出しには6秒ほどかかり、次の呼び出しにはすぐに出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Congratulations! You just added application data caching to your Quarkus application with a single line of code!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おめでとうございます。たった1行のコードでQuarkusアプリケーションにアプリケーションデータのキャッシングを追加できました！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported features</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされている機能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides compatibility with the following Spring Cache annotations:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、以下のSpring Cacheアノテーションとの互換性を提供しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that in this first version of the Spring Cache annotations extension, not all features of these annotations are supported (with proper errors being logged when trying to use an unsupported feature).  However, additional features are planned for future releases.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この最初のバージョンの Spring Cache アノテーションエクステンションでは、これらのアノテーションのすべての機能がサポートされているわけではないことに注意してください (サポートされていない機能を使用しようとすると、適切なエラーがログに記録されます)。しかし、今後のリリースでは追加機能が計画されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More Spring guides</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のSpringガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has more Spring compatibility features. See the following guides for more details:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、より多くのSpring互換機能があります。詳細については、以下のガイドを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OpenTracing to provide distributed tracing for interactive web applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがOpenTracingを利用してインタラクティブなウェブアプリケーションのための分散トレースを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Docker</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Architecture</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward REST application to demonstrate distributed tracing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、分散トレースを実証するための簡単なRESTアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Solution</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can skip right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の章で紹介する手順に沿って、ステップを踏んでアプリを作成することをお勧めします。ただし、すぐに完成した例に飛んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `opentracing-quickstart` {quickstarts-tree-url}/opentracing-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `smallrye-opentracing` extension, which includes the OpenTracing support and the default https://www.jaegertracing.io/[Jaeger] tracer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、OpenTracing サポートとデフォルトの link:https://www.jaegertracing.io/[Jaeger] トレーサーを含む `smallrye-opentracing` エクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `smallrye-opentracing` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `smallrye-opentracing` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/opentracing/TracedResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/opentracing/TracedResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CTRL+C`  を叩いてアプリケーションを停止させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Maven 3.6.2+</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>合成Bean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Setting it up</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは以下をカバーしています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize OAuth2 tokens to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがOAuth2トークンを利用して、JAX-RSエンドポイントへのセキュアなアクセスを提供する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops.  This guide explains how to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、以下の方法を説明します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write a Quarkus application with a main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メインメソッドでQuarkusアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Write command mode applications that run a task and then terminate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タスクを実行して終了するコマンドモードのアプリケーションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application starts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの開始時に通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be notified when the application stops</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが停止したときに通知される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `lifecycle-quickstart` {quickstarts-tree-url}/lifecycle-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `lifecycle-quickstart`  {quickstarts-tree-url}/lifecycle-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下が生成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Maven structure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenの構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a landing page accessible on `http://localhost:8080`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランディングページは次のURLでアクセス可能です： `http://localhost:8080`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`native`  と `jvm`  の両方のモードに対応した `Dockerfile`  ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.lifecycle.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.lifecycle.GreetingResource`  リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メインメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus will automatically generate a main method, that will bootstrap Quarkus and then just wait for shutdown to be initiated. Let's provide our own main method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusは自動的にメインメソッドを生成し、Quarkusを起動し、シャットダウンが開始されるのを待つだけです。独自のメインメソッドを追加してみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation tells Quarkus to use this as the main method, unless it is overridden in the config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、設定でオーバーライドされない限り、これをメインのメソッドとして使用するようQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This launches Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これによりQuarkusが起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This main class will bootstrap Quarkus and run it until it stops. This is no different to the automatically generated main class, but has the advantage that you can just launch it directly from the IDE without needing to run a Maven or Gradle command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメインクラスはQuarkusを起動し、停止するまで実行します。これは自動生成されたメインクラスと変わりませんが、MavenやGradleのコマンドを実行する必要がなく、IDEから直接起動するだけで済むという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not recommenced to do any business logic in this main method, as Quarkus has not been set up yet, and Quarkus may run in a different ClassLoader. If you want to perform logic on startup use an `io.quarkus.runtime.QuarkusApplication` as described below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだQuarkusが設定されておらず、Quarkusは別のClassLoaderで動作する可能性があるため、このメインメソッドでビジネスロジックを行うことは推奨されていません。起動時にロジックを実行したい場合は、以下のように `io.quarkus.runtime.QuarkusApplication`  を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we want to actually perform business logic on startup (or write applications that complete a task and then exit)  we need to supply a `io.quarkus.runtime.QuarkusApplication` class to the run method. After Quarkus has been started the `run` method of the application will be invoked. When this method returns the Quarkus application will exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動時に実際にビジネスロジックを実行したい場合（またはタスクを完了してから終了するアプリケーションを書きたい場合）、runメソッドに `io.quarkus.runtime.QuarkusApplication`  クラスを指定する必要があります。Quarkusが起動すると、アプリケーションの `run`  メソッドが呼び出されます。このメソッドが返されると、Quarkusアプリケーションは終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to perform logic on startup you should call `Quarkus.waitForExit()`, this method will wait until a shutdown is requested (either from an external signal like when you press `Ctrl+C` or because a thread has called `Quarkus.asyncExit()`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動時にロジックを実行したい場合は、 `Quarkus.waitForExit()`  を呼び出す必要があります。このメソッドは、シャットダウンが要求されるまで待機します（ `Ctrl+C`  を押したときのような外部シグナルや、スレッドが `Quarkus.asyncExit()`  を呼び出したときのような外部シグナルのいずれか）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example of what this looks like is below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その一例が以下のようなものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting the command line arguments</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドライン引数の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to inject the arguments that were passed in on the command line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインで渡された引数を注入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listening for startup and shutdown events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタートアップとシャットダウンのイベントをリッスンする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a new class named `AppLifecycleBean` (or pick another name) in the `org.acme.lifecycle` package, and copy the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.lifecycle`  パッケージ内に `AppLifecycleBean`  という名前の新しいクラスを作成し（または別の名前を選び）、以下の内容をコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is starting</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Method called when the application is terminating</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの終了時に呼び出されるメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The events are also called in _dev mode_ between each redeployment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、各再配置の間に _devモード_ でイベントが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The methods can access injected beans. Check the {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] class for details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドは注入されたBeanにアクセスすることができます。詳細は {quickstarts-blob-url}/lifecycle-quickstart/src/main/java/org/acme/lifecycle/AppLifecycleBean.java[AppLifecycleBean.java] クラスを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is the difference from `@Initialized(ApplicationScoped.class)` and `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Initialized(ApplicationScoped.class)`  との違いは？ `@Destroyed(ApplicationScoped.class)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the JVM mode, there is no real difference, except that `StartupEvent` is always fired *after* `@Initialized(ApplicationScoped.class)` and `ShutdownEvent` is fired *before* `@Destroyed(ApplicationScoped.class)`.  For a native executable build, however, `@Initialized(ApplicationScoped.class)` is fired as *part of the native build process*, whereas `StartupEvent` is fired when the native image is executed.  See link:writing-extensions#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMモードでは、 `StartupEvent`  は常に `@Initialized(ApplicationScoped.class)`  の *後に* 実行され、 `ShutdownEvent`  は `@Destroyed(ApplicationScoped.class)`  の *前に* 実行されることを除けば、実質的な違いはありません。しかし、ネイティブの実行可能なビルドでは、 `@Initialized(ApplicationScoped.class)`  はネイティブの *ビルドプロセスの一部* として実行され、 `StartupEvent`  はネイティブイメージが実行されたときに実行されます。詳細については、 link:writing-extensions#bootstrap-three-phases[Bootstrapの3つのフェーズとQuarkusの哲学]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In CDI applications, an event with qualifier `@Initialized(ApplicationScoped.class)` is fired when the application context is initialized. See https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[the spec, window="_blank"] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI アプリケーションでは、アプリケーションコンテキストが初期化されると、修飾子 `@Initialized(ApplicationScoped.class)`  を持つイベントが発生します。詳細は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#application_context[仕様, window=_blank]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@Startup` to initialize a CDI bean at application startup</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  を使用して、アプリケーション起動時に CDI Bean を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean represented by a class, producer method or field annotated with `@Startup` is initialized at application startup:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  でアノテーションされたクラス、プロデューサメソッド、フィールドで表現されたビーンは、アプリケーションの起動時に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For each bean annotated with `@Startup` a synthetic observer of `StartupEvent` is generated. The default priority is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Startup`  でアノテーションされた各Beanに対して、 `StartupEvent`  の合成オブザーバが生成されます。デフォルトの優先度が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The bean constructor is called when the application starts and the resulting contextual instance is stored in the application context.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビーンのコンストラクタは、アプリケーションの起動時に呼び出され、結果として得られるコンテキストインスタンスがアプリケーションのコンテキストに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Dependent` beans are destroyed immediately afterwards to follow the behavior of observers declared on `@Dependent` beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Dependent` ビーンは、 `@Dependent`  ビーンに宣言されたオブザーバーの行動に従うために、その後すぐに破壊されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class is annotated with `@Startup` but with no scope annotation then `@ApplicationScoped` is added automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスが `@Startup`  でアノテーションされていて、スコープのアノテーションがない場合は、 `@ApplicationScoped`  が自動的に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`, the logged message is printed.  When the application is stopped, the second log message is printed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev`  でアプリケーションを実行すると、ログメッセージが表示されます。アプリケーションを停止すると、2 番目のログメッセージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `-runner.jar` file.  You can also generate the native executable using `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、 `./mvnw clean package`  を使ってアプリケーションをパッケージ化し、 `-runner.jar`  ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative`  を使用してネイティブの実行ファイルを生成することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Launch Modes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has 3 different launch modes, `NORMAL` (i.e. production), `DEVELOPMENT` and `TEST`. If you are running `quarkus:dev` then the mode will be `DEVELOPMENT`, if you are running a JUnit test it will be `TEST`, otherwise it will be `NORMAL`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには3種類の起動モードがあります。 `NORMAL`  (つまりプロダクション)、 `DEVELOPMENT`  、 `TEST`  です。 `quarkus:dev`  を実行している場合は `DEVELOPMENT`  、JUnit テストを実行している場合は `TEST`  、それ以外の場合は `NORMAL`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your application can get the launch mode by injecting the `io.quarkus.runtime.LaunchMode` enum into a CDI bean, or by invoking the static method `io.quarkus.runtime.LaunchMode.current()`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは、 `io.quarkus.runtime.LaunchMode`  enum を CDI ビーンに注入するか、静的メソッド `io.quarkus.runtime.LaunchMode.current()`  を呼び出すことで起動モードを取得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Graceful Shutdown</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グレースフルシャットダウン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes support for graceful shutdown, this allows Quarkus to wait for running requests to finish, up till a set timeout. By default this is disabled, however you can configure this by setting the `quarkus.shutdown.timeout` config property. When this is set shutdown will not happen until all running requests have completed, or until this timeout has elapsed. This config property is a duration, and can be set using the standard `java.time.Duration` format, if only a number is specified it is interpreted as seconds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、Quarkusは、実行中のリクエストが終了するまで、設定されたタイムアウトまで待機することができます。デフォルトでは無効になっていますが、 `quarkus.shutdown.timeout`  configプロパティを設定することで設定することができます。これが設定されている場合、すべての実行中のリクエストが完了するまで、またはこのタイムアウトが経過するまでシャットダウンは行われません。この設定プロパティは持続時間であり、標準の `java.time.Duration`  形式で設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions that accept requests need to add support for this on an individual basis. At the moment only the HTTP extension supports this, so shutdown may still happen when messaging requests are active.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストを受け付けるエクステンションは、個別にサポートを追加する必要があります。現時点では HTTP エクステンションだけがこれをサポートしているので、メッセージングリクエストがアクティブなときにシャットダウンが発生する可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/users/me`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/users/me`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/admin`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/admin`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: guides-configuration-reference
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: guides-configuration-reference
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here you can find a list of Build Items and the extension that provides them:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、ビルドアイテムとそれを提供するエクステンションの一覧を見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus extension supports two programming models:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションは、2つのプログラミングモデルをサポートしています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK の `CompletableFuture` オブジェクトと Netty HTTP クライアントをベースにした link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[非同期プログラミング]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon Identity and Access Management (IAM) enables users to manage access to AWS services and resources securely.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon Identity and Access Management（IAM）は、ユーザーがAWSのサービスやリソースへのアクセスを安全に管理できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about IAM at https://aws.amazon.com/iam/[the Amazon IAM website].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://aws.amazon.com/iam/[アマゾンのIAMのサイト]を見てみると、IAMについての詳しい情報が掲載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The IAM extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].  It's a major rewrite of the 1.x code base that offers two programming models (Blocking &amp; Async).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IAMエクステンションは link:https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x]をベースにしており、2つのプログラミングモデル(Blocking &amp; Async)を提供する1.xのコードベースを大幅に書き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to test your Quarkus Application.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションのテスト方法について説明します。このガイドでは、以下の内容について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing in native mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードでのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection of resources into tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへのリソースの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The completed greeter application from the link:getting-started[Getting Started Guide]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:getting-started[入門ガイド]の完成済のgreeterアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we expand on the initial test that was created as part of the Getting Started Guide.  We cover injection into tests and also how to test native executables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、入門ガイドの一部として作成された最初のテストを拡張します。テストへのインジェクションと、ネイティブの実行ファイルをテストする方法もカバーしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started-testing` {quickstarts-tree-url}/getting-started-testing[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started-testing`  {quickstarts-tree-url}/getting-started-testing[ディレクトリ] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide assumes you already have the completed application from the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 `getting-started`  ディレクトリの完成したアプリケーションをすでに持っていることを前提としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have started from the Getting Started example you should already have a completed test, including the correct `pom.xml` setup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はじめにのサンプルから始めた場合は、正しい `pom.xml`  の設定を含めて、すでにテストが完了しているはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file you should see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml`  ファイルには、2つのテスト依存関係があるはずです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus-junit5` is required for testing, as it provides the `@QuarkusTest` annotation that controls the testing framework.  `rest-assured` is not required but is a convenient way to test HTTP endpoints, we also provide integration that automatically sets the correct URL so no configuration is required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-junit5`  は、テストフレームワークを制御する `@QuarkusTest`  アノテーションを提供するため、テストには必須です。 `rest-assured`  は必須ではありませんが、HTTP エンドポイントをテストするのに便利な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because we are using JUnit 5, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JUnit 5を使用しているので、 link:https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin]のバージョンを設定する必要があります。デフォルトのバージョンはJUnit 5をサポートしていない為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging.manager` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `java.util.logging.manager`  システムプロパティを設定して、テストが正しい logmanager と `maven.home`  を使用して、 `${maven.home}/conf/settings.xml` からのカスタム設定が適用されるようにしています (存在する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project should also contain a simple test:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトには簡単なテストも含まれているはずです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This test uses HTTP to directly test our REST endpoint. When the test is run the application will be started before the test is run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストはHTTPを使用して、RESTエンドポイントを直接テストします。テストが実行されると、テストが実行される前にアプリケーションが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Controlling the test port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートの制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Quarkus will listen on port `8080` by default, when running tests it defaults to `8081`. This allows you to run tests while having the application running in parallel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはデフォルトではポート `8080`  をリッスンしますが、テストを実行する場合はデフォルトで `8081`  をリッスンします。これにより、アプリケーションを並行して実行しながらテストを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the test port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートの変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the ports used by tests by configuring `quarkus.http.test-port` for HTTP and `quarkus.http.test-ssl-port` for HTTPS in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `application.properties` の `quarkus.http.test-port` を設定することで、を HTTP 用にテストで使われるポートを設定出来、 `quarkus.http.test-ssl-port` を設定することで HTTPS 用にテストで使用するポートを設定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`0` will result in the use of a random port (assigned by the operating system).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`0` を使用すると、(オペレーティングシステムによって割り当てられた)ランダムなポートが使用されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus also provides RestAssured integration that updates the default port used by RestAssured before the tests are run, so no additional configuration should be required.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはまた、テストを実行する前にRestAssuredによって使用されるデフォルトのポートを更新するRestAssuredインテグレーションも提供しているため、追加の設定は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using REST Assured in your test, the connection and response timeouts are set to 30 seconds.  You can override this setting with the `quarkus.http.test-timeout` property:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストで REST Assured を使用する場合、接続と応答のタイムアウトは 30 秒に設定されます。この設定は `quarkus.http.test-timeout`  プロパティでオーバーライドできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to directly inject the URL into the test which can make is easy to use a different client. This is done via the `@TestHTTPResource` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>URLをテストに直接注入することも可能で、別のクライアントを使用するのが簡単になります。これは `@TestHTTPResource`  アノテーションで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a simple test that shows this off to load some static resources. First create a simple HTML file in `src/main/resources/META-INF/resources/index.html` :</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>静的なリソースをロードするための簡単なテストを書いてみましょう。まず、シンプルなHTMLファイルを `src/main/resources/META-INF/resources/index.html` に作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will create a simple test to ensure that this is being served correctly:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これが正しく提供されているかどうかを確認するための簡単なテストを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation allows you to directly inject the URL of the Quarkus instance, the value of the annotation will be the path component of the URL</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションを使用すると、QuarkusインスタンスのURLを直接注入することができます。アノテーションの値は、URLのパス部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For now `@TestHTTPResource` allows you to inject `URI`, `URL` and `String` representations of the URL.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ `@TestHTTPResource`  では、URL の `URI` , `URL` , `String`  表現を注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing a specific endpoint</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定のエンドポイントのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Both RESTassured and `@TestHTTPResource` allow you to specify the endpoint class you are testing rather than hard coding a path. This currently supports both JAX-RS endpoints, Servlets and Reactive Routes. This makes it a lot easier to see exactly which endpoints a given test is testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured と `@TestHTTPResource`  の両方で、パスをハードコーディングするのではなく、テストするエンドポイントクラスを指定することができます。これは現在、JAX-RS エンドポイント、サーブレット、リアクティブルートの両方をサポートしています。これにより、特定のテストがどのエンドポイントをテストしているかを正確に確認することが非常に簡単になりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the purposes of these examples I am going to assume we have an endpoint that looks like the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらの例では、以下のようなエンドポイントを想定しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This currently does not support the `@ApplicationPath()` annotation to set the JAX-RS context path. Use the `quarkus.resteasy.path` config value instead if you want a custom context path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは現在、JAX-RS のコンテキストパスを設定するための `@ApplicationPath()`  アノテーションをサポートしていません。カスタムのコンテキストパスを設定したい場合は、代わりに `quarkus.resteasy.path`  の設定値を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TestHTTPResource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストHTTPリソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can the use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation to specify the endpoint path, and the path will be extracted from the provided endpoint. If you also specify a value for the `TestHTTPResource` endpoint it will be appended to the end of the endpoint path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用してエンドポイントのパスを指定することが出来、指定されたエンドポイントからパスが抽出されます。 `TestHTTPResource`  エンドポイントにも値を指定すると、エンドポイントパスの最後に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because `GreetingResource` is annotated with `@Path("/hello")` the injected URL will end with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingResource`  は `@Path("/hello")`  とアノテーションされているので、注入された URL は `/hello`  で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>RESTassured</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To control the RESTassured base path (i.e. the default path that serves as the root for every request) you can use the `io.quarkus.test.common.http.TestHTTPEndpoint` annotation. This can be applied at the class or method level. To test out greeting resource we would do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTassured ベースパス (すなわち、すべてのリクエストのルートとなるデフォルトパス) を制御するには、 `io.quarkus.test.common.http.TestHTTPEndpoint`  アノテーションを使用できます。これはクラスやメソッドレベルで適用できます。グリーティングリソースをテストするには、以下のようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells RESTAssured to prefix all requests with `/hello`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、RESTAssured はすべてのリクエストの前に `/hello` を付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note we don't need to specify a path here, as `/hello` is the default for this test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストでは `/hello`  がデフォルトなので、ここでパスを指定する必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection into tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far we have only covered integration style tests that test the app via HTTP endpoints, but what if we want to do unit testing and test our beans directly?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでは、HTTP エンドポイントを介してアプリをテストする統合スタイルのテストしか取り上げてきませんでしたが、ユニットテストを行い、Beanを直接テストしたい場合はどうでしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports this by allowing you to inject CDI beans into your tests via the `@Inject` annotation (in fact, tests in Quarkus are full CDI beans, so you can use all CDI functionality). Let's create a simple test that tests the greeting service directly without using HTTP:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、 `@Inject`  アノテーションを介してテストにCDI Beanを注入できるようにすることで、これをサポートしています（実際、Quarkusのテストは完全なCDI Beanなので、すべてのCDI機能を使用することができます）。HTTPを使用せずにグリーティングサービスを直接テストするシンプルなテストを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `GreetingService` bean will be injected into the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingService`  Beanがテストに注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Applying Interceptors to Tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストへのインターセプターの適用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above Quarkus tests are actually full CDI beans, and as such you can apply CDI interceptors as you would normally. As an example, if you want a test method to run within the context of a transaction you can simply apply the `@Transactional` annotation to the method and the transaction interceptor will handle it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前述したように、Quarkusのテストは実際には完全なCDI Beanであり、通常のようにCDIインターセプターを適用することができます。例えば、トランザクションのコンテキスト内でテストメソッドを実行したい場合、 `@Transactional`  アノテーションをメソッドに適用するだけで、トランザクションインターセプターがそれを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to this you can also create your own test stereotypes. For example we could create a `@TransactionalQuarkusTest` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これに加えて、独自のテスト・ステレオタイプを作成することもできます。例えば、次のように `@TransactionalQuarkusTest`  を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we then apply this annotation to a test class it will act as if we had applied both the `@QuarkusTest` and `@Transactional` annotations, e.g.:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションをテストクラスに適用すると、 `@QuarkusTest`  と `@Transactional`  の両方のアノテーションを適用したかのように動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tests and Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストとトランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use the standard Quarkus `@Transactional` annotation on tests, but this means that the changes your test makes to the database will be persistent. If you want any changes made to be rolled back at the end of the test you can use the `io.quarkus.test.TestTransaction` annotation. This will run the test method in a transaction, but roll it back once the test method is complete to revert any database changes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストでは標準のQuarkus `@Transactional`  アノテーションを使用することができますが、これは、テストでデータベースに加えた変更が永続化されることを意味します。テストの終了時に変更をロールバックしたい場合は、 `io.quarkus.test.TestTransaction`  アノテーションを使用することができます。これは、トランザクション内でテストメソッドを実行しますが、テストメソッドが完了したらロールバックして、データベースの変更を元に戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively or additionally to an interceptor, you can enrich *all* your `@QuarkusTest` classes by implementing the following callback interfaces:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターの代わりに、あるいはインターセプターに加えて、以下のコールバックインターフェースを実装することで、 *すべての* `@QuarkusTest` クラスを充実させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeClassCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback` has been deprecated in favor of `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback` and will be removed in future releases of Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback`  は `io.quarkus.test.junit.callback.QuarkusTestAfterConstructCallback`  に代わって非推奨となり、Quarkusの将来のリリースでは削除される予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Such a callback implementation has to be registered as a "service provider" as defined by `java.util.ServiceLoader`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなコールバックの実装は、 `java.util.ServiceLoader`  で定義されている「サービスプロバイダ」として登録する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>E.g. the following sample callback:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、以下のようなサンプルコールバックです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>has to be registered via `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、以下のように `src/main/resources/META-INF/services/io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback` で登録する必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to read annotations from the test class or method to control what the callback shall be doing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスやメソッドからアノテーションを読み込んで、コールバックが何をするかを制御することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While it is possible to use JUnit Jupiter callback interfaces like `BeforeEachCallback`, you might run into classloading issues because Quarkus has
         to run tests in a custom classloader which JUnit is not aware of.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BeforeEachCallback` のような JUnit Jupiter コールバックインターフェイスを使うことも可能ですが、QuarkusはJUnitが把握しないカスタムクラスローダーでテストを実行する必要がある為、クラスローディングの問題にぶつかるかもしれません。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Different Profiles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>異なるプロファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far in all our examples we only start Quarkus once for all tests. Before the first test is run Quarkus will boot, then all tests will run, then Quarkus will shutdown at the end. This makes for a very fast testing experience however it is a bit limited as you can't test different configurations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これまでのところ、すべての例では、すべてのテストに対して一度だけQuarkusを起動しています。最初のテストが実行される前にQuarkusが起動し、次にすべてのテストが実行され、最後にQuarkusがシャットダウンします。これにより、非常に高速なテストが可能になりますが、異なる設定をテストすることができないため、少し制限があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get around this Quarkus supports the idea of a test profile. If a test has a different profile to the previously run test then Quarkus will be shut down and started with the new profile before running the tests. This is obviously a bit slower, as it adds a shutdown/startup cycle to the test time, but gives a great deal of flexibility.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この問題を回避するために、Quarkusはテストプロファイルの考え方をサポートしています。以前に実行したテストとは異なるプロファイルを持つテストがある場合、Quarkusはテストを実行する前にシャットダウンされ、新しいプロファイルで開始されます。これは、テスト時間にシャットダウン/起動サイクルが追加されるため、明らかに少し遅くなりますが、非常に大きな柔軟性が得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to reduce the amount of times Quarkus needs to restart it is recommended that you place all tests that need a specific profile into their own package, and then run tests alphabetically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの再起動の回数を減らすために、特定のプロファイルを必要とするすべてのテストを独自のパッケージに入れ、アルファベット順にテストを実行することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing a Profile</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロフィールの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To implement a test profile we need to implement `io.quarkus.test.junit.QuarkusTestProfile`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストプロファイルを実装するには、 `io.quarkus.test.junit.QuarkusTestProfile` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to override configuration properties. Here we are changing the JAX-RS root path.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法では、設定プロパティをオーバーライドすることができます。ここでは、JAX-RSのルートパスを変更しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to enable CDI `@Alternative` beans. This makes it easy to mock out certain beans functionality.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドを使うことで、CDI `@Alternative`  Beanを有効にすることができます。これにより、特定のBeanの機能を簡単にモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This can be used to change the config profile. As this default is `test` this does nothing, but is included for completeness.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは設定プロファイルを変更するために使用できます。このデフォルトは `test`  なので、これは何もしませんが、完全性を保つために含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to apply **additional** `QuarkusTestResourceLifecycleManager` classes, specific for this profile only. If this method is not overridden, then only the `QuarkusTestResourceLifecycleManager` classes enabled via the `@QuarkusTestResource` class annotation will be used for the tests using this profile (which is the same behavior as tests that don't use a profile at all).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドを使用すると、このプロファイル専用の `QuarkusTestResourceLifecycleManager`  クラスを *追加で* 適用することができます。このメソッドがオーバーライドされていない場合は、 `@QuarkusTestResource`  クラスアノテーションを介して有効化された `QuarkusTestResourceLifecycleManager`  クラスのみが、このプロファイルを使用するテストに使用されます (これは、プロファイルを全く使用しないテストと同じ動作です)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we have defined our profile we need to include it on our test class. We do this with `@TestProfile(MockGreetingProfile.class)`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルを定義したので、それをテストクラスに含める必要があります。 `@TestProfile(MockGreetingProfile.class)` で、これを行うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All the test profile config is stored in a single class, which makes it easy to tell if the previous test ran with the same configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストプロファイルの設定はすべて単一のクラスに保存されているので、前回のテストが同じ設定で実行されたかどうかが簡単にわかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mock Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>モックサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the use of mock objects using two different approaches. You can either use CDI alternatives to mock out a bean for all test classes, or use `QuarkusMock` to mock out beans on a per test basis.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、2つの異なるアプローチを使用したモックオブジェクトの使用をサポートしています。CDIの代替品を使用してすべてのテストクラスのBeanをモックアウトするか、 `QuarkusMock`  を使用してテストごとにBeanをモックアウトすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>CDI `@Alternative` mechanism.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI `@Alternative`  メカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.  Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.  This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.  For example if I have the following service:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使用するには、 `src/test/java`  ディレクトリのクラスでモックしたいBeanをオーバーライドし、 `@Alternative`  と `@Priority(1)`  アノテーションをBeanに配置するだけです。あるいは、便利な `io.quarkus.test.Mock`  ステレオタイプアノテーションを使用することもできます。この組み込みステレオタイプは、 `@Alternative`  、 `@Priority(1)`  、 `@Dependent`  を宣言します。例えば、以下のようなサービスがあるとします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>I could mock it with the following class in `src/test/java`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/test/java`  で以下のクラスでモックできました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Overrides the `@Dependent` scope declared on the `@Mock` stereotype.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Mock`  ステレオタイプで宣言された `@Dependent`  スコープをオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is important that the alternative be present in the `src/test/java` directory rather than `src/main/java`, as otherwise it will take effect all the time, not just when testing.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替品が `src/main/java`  ではなく `src/test/java`  ディレクトリに存在することが重要です。そうでなければ、テスト以外も常に有効になってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that at present this approach does not work with native image testing, as this would required the test alternatives to be baked into the native image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、このアプローチはネイティブイメージテストでは機能しないことに注意してください。テスト代替品がネイティブイメージに焼き込まれる必要がある為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `io.quarkus.test.junit.QuarkusMock` class can be used to temporarily mock out any normal scoped bean. If you use this method in a `@BeforeAll` method the mock will take effect for all tests on the current class, while if you use this in a test method the mock will only take effect for the duration of the current test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus.test.junit.QuarkusMock`  クラスは、通常のスコープ付きBeanを一時的にモックアウトするために使用することができます。 `@BeforeAll`  メソッドでこのメソッドを使用した場合、モックは現在のクラスのすべてのテストに対して有効になりますが、test メソッドでこれを使用した場合、モックは現在のテストの間のみ有効になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method can be used for any normal scoped CDI bean (e.g. `@ApplicationScoped`, `@RequestScoped` etc, basically every scope except `@Singleton` and `@Dependent`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法は、通常のスコープ付き CDI Bean（例： `@ApplicationScoped` , `@RequestScoped`  など、 `@Singleton`  と `@Dependent`  以外の基本的にすべてのスコープ）に対して使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An example usage could look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用例は次のようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As the injected instance is not available here we use `installMockForType`, this mock is used for both test methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションされたインスタンスはここでは利用できないので、 `installMockForType` を使用します。このモックは両方のテストメソッドに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use `installMockForInstance` to replace the injected bean, this takes effect for the duration of the test method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは `installMockForInstance`  を使用して注入されたBeanを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that there is no dependency on Mockito, you can use any mocking library you like, or even manually override the objects to provide the behaviour you require.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mockitoには依存しないことに注意してください。好きなモッキングライブラリを使うことができますし、必要な動作を提供するためにオブジェクトを手動でオーバーライドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Further simplification with `@InjectMock`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock` での更なる単純化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `QuarkusMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for mocking the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectMock` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusMock`  で提供されている機能をベースに、Quarkusでは、 `QuarkusMock`  でサポートされているBeanをモックするために link:https://site.mockito.org/[Mockito を]簡単に利用できるようにしています。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectMock`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock`  を使用すると、先ほどの例は次のように書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@InjectMock` results in a mock being and is available in test methods of the test class (other test classes are *not* affected by this)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock` により、モックがテストクラスのテストメソッドに存在することになり、利用可能になります (他のテストクラスはこの影響を受け *ません* )。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `mockableBean1` is configured here for every test method of the class</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスのすべてのテストメソッドに対して `mockableBean1`  が設定されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since the `mockableBean2` mock has not been configured, it will return the default Mockito response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mockableBean2`  のモックが設定されていないので、デフォルトの Mockito レスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this test the `mockableBean2` is configured, so it returns the configured response.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このテストでは、 `mockableBean2`  が設定されているので、設定されたレスポンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Although the test above is good for showing the capabilities of `@InjectMock`, it is not a good representation of a real test. In a real test we would most likely configure a mock, but then test a bean that uses the mocked bean.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のテストは `@InjectMock`  の機能を示すのには良いですが、実際のテストを上手く表してはいません。実際のテストでは、ほとんどの場合、モックを設定し、モックされたBeanを使用するBeanをテストします。以下に例を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`greetingService`  をモックとして設定したので、 `GreetingService`  Beanを使用する `GreetingResource`  は、通常の `GreetingService` Beanのレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Spies instead of Mocks with `@InjectSpy`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `@InjectSpy` で、モックの代わりにスパイを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.  This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`InjectMock`  で提供されている機能をベースに、 `QuarkusMock`  でサポートされているビーンズをスパイするために link:https://site.mockito.org/[Mockito ]を簡単に利用できるようにしました。この機能は、 `quarkus-junit5-mockito`  依存関係で利用可能な `@io.quarkus.test.junit.mockito.InjectSpy`  アノテーションを介して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito documentation] for more details on Spy partial mocks.  In either of those situations a Spy of the object is preferable.  Using `@InjectSpy`, the previous example could be written as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストを行う際に、特定の論理パスが取られたかどうかを確認するだけで済む場合もありますし、Spied クローン上で残りのメソッドを実行している間に、1つのメソッドのレスポンスをスタブアウトするだけで済む場合もあります。Spy パーシャル モックの詳細については link:https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#spy-T-[Mockito のドキュメント]を参照してください。いずれの場合も、オブジェクトの Spy が望ましいでしょう。 `@InjectSpy`  を使用して、先ほどの例は次のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instead of overriding the value, we just want to ensure that the greet method on our `GreetingService` was called by this test.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>値をオーバーライドするのではなく、 `GreetingService`  の greet メソッドがこのテストで呼び出されたことを確認したいだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here we are telling the Spy to return "hi" instead of "hello". When the `GreetingResource` requests the greeting from `GreetingService` we get the mocked response instead of the response of the regular `GreetingService` bean</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは、"hello"の代わりに"hi"を返すようにSpyに指示しています。 `GreetingResource`  が `GreetingService`  から挨拶を要求するとき、通常の `GreetingService`  Bean のレスポンスの代わりにモックされたレスポンスを取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are verifying that we get the mocked response from the Spy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちは、スパイからのモックされた応答を得ることを検証しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `@InjectMock` with `@RestClient`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@InjectMock`  との併用 `@RestClient`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RegisterRestClient` registers the implementation of the rest-client at runtime, and because the bean needs to be a regular scope, you have to annotate your interface with `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@RegisterRestClient`  は、実行時に rest-client の実装を登録しています。Beanは通常のスコープである必要があるため、インターフェイスに `@ApplicationScoped` を付与する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the test class here is an example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストクラスの例です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indicate that this injection point is meant to use an instance of `RestClient`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この注入ポイントが `RestClient`  のインスタンスを使用することを意味していることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using the `quarkus-hibernate-orm-panache` or `quarkus-mongodb-panache` extensions, check out the link:hibernate-orm-panache#mocking[Hibernate ORM with Panache Mocking] and link:mongodb-panache#mocking[MongoDB with Panache Mocking] documentation for the easiest way to mock your data access.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus-hibernate-orm-panache`  や `quarkus-mongodb-panache` のエクステンションを使っている場合は、 link:hibernate-orm-panache#mocking[Hibernate ORM とPanache Mocking]や link:mongodb-panache#mocking[MongoDB とPanache Mocking]のドキュメントをチェックして、データアクセスをモックする最も簡単な方法を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Quarkus Security, check out the link:security-testing[Testing Security] section for information on how to easily test security features of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Securityを使用している場合、アプリケーションのセキュリティ機能を簡単にテストする方法については、「 link:security-testing[セキュリティのテスト]」のセクションをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A very common need is to start some services on which your Quarkus application depends, before the Quarkus application starts for testing. To address this need, Quarkus provides `@io.quarkus.test.common.QuarkusTestResource` and `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非常に一般的なニーズは、Quarkusアプリケーションがテストを開始する前に、Quarkusアプリケーションに依存するいくつかのサービスを開始することです。このニーズに対応するために、Quarkusでは、 `@io.quarkus.test.common.QuarkusTestResource`  と `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By simply annotating any test in the test suite with `@QuarkusTestResource`, Quarkus will run the corresponding `QuarkusTestResourceLifecycleManager` before any tests are run.  A test suite is also free to utilize multiple `@QuarkusTestResource` annotations, in which case all the corresponding `QuarkusTestResourceLifecycleManager` objects will be run before the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストスイート内の任意のテストに `@QuarkusTestResource` をアノテーションするだけで、Quarkusは、テストを実行する前に対応する `QuarkusTestResourceLifecycleManager`  を実行します。テストスイートでは、複数の `@QuarkusTestResource`  アノテーションを自由に利用することもできます。この場合、対応するすべての `QuarkusTestResourceLifecycleManager`  オブジェクトがテストの前に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a few implementations of `QuarkusTestResourceLifecycleManager` out of the box (see `io.quarkus.test.h2.H2DatabaseTestResource` which starts an H2 database, or `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource` which starts a mock Kubernetes API server), but it is common to create custom implementations to address specific application needs.  Common cases include starting docker containers using https://www.testcontainers.org/[Testcontainers] (an example of which can be found https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[here]), or starting a mock HTTP server using http://wiremock.org/[Wiremock] (an example of which can be found https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[here]).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、 `QuarkusTestResourceLifecycleManager`  の実装がいくつか提供されていますが（H2データベースを起動する `io.quarkus.test.h2.H2DatabaseTestResource` や、モックKubernetes APIサーバーを起動する `io.quarkus.test.kubernetes.client.KubernetesMockServerTestResource`  を参照）、特定のアプリケーションのニーズに対応するためにカスタム実装を作成するのが一般的です。一般的なケースとしては、 link:https://www.testcontainers.org/[Testcontainers]を使ってdockerコンテナを起動したり(その例は link:https://github.com/quarkusio/quarkus-quickstarts/blob/master/kafka-quickstart/src/test/java/org/acme/kafka/KafkaResource.java[こちら]にあります)、 link:http://wiremock.org/[Wiremock]を使ってモックHTTPサーバを起動したり(その例は link:https://github.com/geoand/quarkus-test-demo/blob/master/src/test/java/org/acme/getting/started/country/WiremockCountries.java[こちら]にあります)などがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Executable Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to test native executables using `@NativeImageTest`. This supports all the features mentioned in this guide except injecting into tests (and the native executable runs in a separate non-JVM process this is not really possible).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@NativeImageTest` を使用してネイティブ実行ファイルをテストすることも可能です。これは、テストに注入すること(そして、ネイティブ実行可能ファイルは別の非JVMプロセスで実行されることーこれは実際には可能ではありません)を除いて、このガイドで述べたすべての機能をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is covered in the link:building-native-image[Native Executable Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは link:building-native-image[ネイティブ実行可能ファイルガイド] で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running `@QuarkusTest` from an IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE から `@QuarkusTest`  を実行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most IDEs offer the possibility to run a selected class as JUnit test directly. For this you should set a few properties in the settings of your chosen IDE:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ほとんどの IDE では、選択したクラスを JUnit テストとして直接実行できるようになっています。そのためには、選択した IDE の設定でいくつかのプロパティを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`java.util.logging.manager` (see link:logging[Logging Guide])</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java.util.logging.manager`  (ロ link:logging[ギングガイド]を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`maven.settings` (in case a custom version of `settings.xml` file should be used for the tests)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`maven.settings`  (カスタム版の `settings.xml`  ファイルをテストに使用する場合)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Copy your current "Installed JRE" definition into a new one, where you will add the properties as a new VM arguments:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の"Installed JRE"定義を新しい定義にコピーし、新しいVMの引数としてプロパティを追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`-Dmaven.home=&lt;path-to-your-maven-installation&gt;`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`-Dmaven.home=&amp;amp;lt;path-to-your-maven-installation&amp;amp;gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use this JRE definition as your Quarkus project targeted runtime and the workaround will be applied to any "Run as JUnit" configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このJRE定義をQuarkusプロジェクトのターゲットランタイムとして使用すると、「Run as JUnit」設定に回避策が適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>VSCode "run with" configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VSCode "run with" 設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `settings.json` placed in the root of your project directory or in the workspace will need the workaround in your test configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトディレクトリやワークスペースのルートにある `settings.json`  は、テスト設定で回避策が必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Nothing needed in IntelliJ because the IDE will pick the `systemPropertyVariables` from the surefire plugin configuration in `pom.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJでは何も必要ありません。なぜなら、IDEは `systemPropertyVariables` を `pom.xml`のsurefireプラグイン設定から取得するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with gRPC</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCを始めるには</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example, we build a very simple microservice which offers three endpoints:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、3つのエンドポイントを提供する非常にシンプルなマイクロサービスを構築します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source code for the `/api/admin` endpoint is also very simple. The main difference here is that we are using a `@RolesAllowed` annotation to make sure that only users granted with the `admin` role can access the endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/admin` エンドポイントのソースコードも非常にシンプルです。ここでの主な違いは、 `admin` ロールで付与されたユーザーだけがエンドポイントにアクセスできるように `@RolesAllowed` アノテーションを使用していることです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Health specification through the SmallRye Health extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Healthエクステンションを使用してMicroProfile Health仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=microprofile-health-quickstart \
    -Dextensions="health"
cd microprofile-health-quickstart
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=microprofile-health-quickstart \
    -Dextensions="health"
cd microprofile-health-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="smallrye-health"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`status` -- the overall result of all the health check procedures</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`checks` -- an array of individual checks</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>adding the `smallrye-health` Quarkus extension to your project using the `quarkus-maven-plugin`: +</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`smallrye-health` Quarkusエクステンションをプロジェクトに追加するには、 `quarkus-maven-plugin`. +</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="health"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="health"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or simply adding the following Maven dependency: +</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、単に以下のMaven依存関係を追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Introduction to Contexts and Dependency Injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - コンテキストと依存性注入（CDI）の紹介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we're going to describe the basic principles of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本原理について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_制御の反転_ （Inversion of Control, IoC ）というプログラミングの原理を聞いたことがあると思います。依存性注入はIoCの実装技術の一つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Bean Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなBeanの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all other beans that inject `Translator`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはスコープアノテーションです。これはコンテナに、Beanのインスタンスをどのコンテキストに関連付けるかを伝えます。この特定のケースでは、 *単一のBeanインスタンス* がアプリケーション用に作成され、 `Translator`の注入を行う他の全てのBeanによって使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはフィールド注入ポイントです。 `Translator`  が `Dictionary`  Beanに依存していることをコンテナに伝えます。マッチするBeanがない場合、ビルドは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics. We will talk about &lt;&lt;interceptors,interceptors&gt;&gt; later.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはインターセプター結合アノテーションです。この場合、アノテーションは MicroProfile Metrics から来ています。関連するインターセプターは呼び出しをインターセプトし、関連するメトリクスを更新します。 &lt;&lt;interceptors,インターセプター&gt;&gt;については後述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your can use programmatic lookup via `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.inject.Instance`  を通じてプログラム的なルックアップを使用して、実行時に曖昧さを解決したり、指定された型を実装しているすべてのBeanを反復処理したりすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このインジェクションポイントは、 `Dictionary`  型を実装した複数のBeanがあっても、曖昧な依存関係にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.inject.Instance` extends `Iterable`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.inject.Instance` は `Iterable` を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Initialized and Constructor Injection Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初期化とコンストラクタのインジェクション例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a constructor injection.  In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor and the bean constructor must be annotated with `@Inject`.  However, in Quarkus we detect the absence of no-args constructor and "add" it directly in the bytecode.  It's also not necessary to add `@Inject` if there is only one constructor present.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはコンストラクタのインジェクションです。実際には、このコードは通常のCDI実装では動作しません。通常のスコープを持つBeanは常にno-argsコンストラクタを宣言しなければならず、Beanのコンストラクタは `@Inject`  でアノテーションされなければなりません。しかし、Quarkusでは、no-argsコンストラクタが存在しないことを検出し、バイトコードに直接「追加」します。また、コンストラクタが1つしかない場合は、 `@Inject`  を追加する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer method must be annotated with `@Inject`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イニシャライザメソッドには `@Inject`  をアノテーションしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An initializer may accept multiple parameters - each one is an injection point.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イニシャライザは複数のパラメータを受け付けることができ、それぞれがインジェクションポイントとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and annotated with the `@javax.inject.Qualifier` meta-annotation:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Qualifier型は、 `@Retention(RUNTIME)`  として定義された Java アノテーションで、 `@javax.inject.Qualifier`  メタアノテーションでアノテーションされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>修飾子の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanの修飾子は、Beanクラスやプロデューサのメソッドやフィールドに修飾子タイプをアノテーションすることで宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bean With Custom Qualifier Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタム修飾子を持つ Bean の例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Superior`  は link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[修飾子アノテーション, window=_blank]です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject Translator`.  The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.  And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このBeanは `@Inject @Superior Translator`  と `@Inject @Superior SuperiorTranslator`  には割り当てられますが、 `@Inject Translator`  には割り当てられません。その理由は、 `@Inject Translator`  はタイプセーフ解決の際に自動的に `@Inject @Default Translator`  に変換されるからです。また、私たちの `SuperiorTranslator`  は `@Default`  を宣言していないので、元の `Translator`  Beanだけが代入可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanのスコープはインスタンスのライフサイクルを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Every bean has exactly one scope.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての豆は、正確に1つのスコープを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There can be other custom scopes provided by Quarkus extensions. For example, `quarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションによって提供される他のカスタムスコープもあります。例えば、 `quarkus-narayana-jta` は `javax.transaction.TransactionScoped` を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window="_blank"] could be hard to grasp but they provide some useful functionality.  A client proxy is basically an object that delegates all method invocations to a target bean instance.  It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実際、 link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[クライアントプロキシ, window=_blank]は理解するのが難しいかもしれませんが、いくつかの有用な機能を提供します。クライアントプロキシは基本的に、すべてのメソッド呼び出しをターゲットのBeanインスタンスに委譲するオブジェクトです。これは `io.quarkus.arc.ClientProxy`  を実装し、Bean クラスを拡張したコンテナ構造体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies only delegate method invocations. So never read or write a field of a normal scoped bean, otherwise you will work with non-contextual or stale data.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシはメソッドの呼び出しをデリゲートするだけです。そのため、通常のスコープされたBeanのフィールドを読み書きしてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Generated Client Proxy Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたクライアントプロキシの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Translator_ClientProxy` instance is always injected instead of a direct reference to a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[contextual instance, window="_blank"] of the `Translator` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Translator_ClientProxy`  インスタンスは、 `Translator`  Beanの link:https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#contextual_instance[コンテキストインスタンス, window=_blank]への直接参照の代わりに、常に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client proxies allow for:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアントプロキシは、以下のことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lazy instantiation - the instance is created once a method is invoked upon the proxy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>遅延インスタンス化 - メソッドがプロキシに呼び出されるとインスタンスが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ability to inject a bean with "narrower" scope to a bean with "wider" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>「狭い」スコープのBeanを「広い」スコープのBeanに注入する機能、すなわち、 `@RequestScoped`  Beanを `@ApplicationScoped`  Beanに注入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, but sometimes it's inevitable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係グラフの円形の依存関係。循環的な依存関係を持つことは、しばしば再設計を検討すべきであることを示していますが、時には避けられないこともあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まれなケースでは、手動でBeanを破棄するのが現実的です。直接参照を注入すると、古くなったBeanのインスタンスになってしまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class beans</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスBean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer fields</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Synthetic beans are usually provided by extensions. Therefore, we are not going to cover them in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>合成Beanは通常、エクステンションによって提供されます。そのため、このガイドではそれらを取り上げません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producer methods and fields are useful if you need additional control over instantiation of a bean.  They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサ・メソッドとフィールドは、Beanのインスタンス化を追加で制御する必要がある場合に便利です。また、サードパーティのライブラリを統合する際に、クラスソースを制御できず、追加のアノテーションなどを追加できない場合にも便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producers Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the field annotations to build a bean metadata.  The _type_ is used to build the set of bean types.  In this case, it will be `double` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナは，フィールドアノテーションを分析して，Beanのメタデータを構築します。 _型_ は，Beanの型の集合を構築するために使用されます。この場合、 `double`  と `java.lang.Object` .スコープアノテーションは宣言されていないので、デフォルトは `@Dependent` になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will read this field when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナは、Beanのインスタンスを作成するときにこのフィールドを読みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container analyses the method annotations to build a bean metadata.  The _return type_ is used to build the set of bean types.  In this case, it will be `List&lt;String&gt;`, `Collection&lt;String&gt;`, `Iterable&lt;String&gt;` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナは，メソッドのアノテーションを解析して，Beanのメタデータを構築します。戻り値の _型_ は、Bean型のセットを構築するために使用されます。この場合、 `List&lt;String&gt;` と `Collection&lt;String&gt;`、 `Iterable&lt;String&gt;`、 `java.lang.Object` となります。スコープアノテーションは宣言されていないので、デフォルトは `@Dependent`  となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The container will call this method when creating the bean instance.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナは、Beanのインスタンスを作成する際にこのメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's more about producers.  You can declare qualifiers, inject dependencies into the producer methods parameters, etc.  You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロデューサーについては他にもあります。修飾子を宣言したり、プロデューサーメソッドのパラメータに依存性を注入したりすることができます。プロデューサについては、例えば link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld, window=_blank] のドキュメントを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルコールバック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanクラスは、ライフサイクル `@PostConstruct`  と `@PreDestroy`  コールバックを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lifecycle Callbacks Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライフサイクルコールバックの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコールバックは、Beanインスタンスがサービスに投入される前に呼び出されます。ここでいくつかの初期化を行うのが安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコールバックは、Beanインスタンスが破棄される前に呼び出されます。ここでいくつかのクリーンアップタスクを実行しても安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a good practice to keep the logic in the callbacks "without side effects", i.e. you should avoid calling other beans inside the callbacks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コールバック内のロジックを「副作用なし」に保つこと、つまり、コールバック内で他のBeanを呼び出すことは避けるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interceptors are used to separate cross-cutting concerns from business logic.  There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターは、横断的な問題をビジネス・ロジックから分離するために使用されます。基本的なプログラミングモデルとセマンティクスを定義した Java Interceptors という別の仕様があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Interceptor Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなインターセプターの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、インターセプターをBeanにバインドするために使用されるインターセプターバインディングアノテーションです。Beanクラスに `@Logged`  をアノテーションします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Priority` enables the interceptor and affects the interceptor ordering. Interceptors with smaller priority values are called first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Priority`  はインターセプターを有効にし、インターセプターの順序に影響を与えます。優先度の値が小さいインターセプターが最初に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Marks an interceptor component.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターコンポーネントをマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An interceptor instance may be the target of dependency injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターインスタンスは、依存性注入の対象となる場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`AroundInvoke` denotes a method that interposes on business methods.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`AroundInvoke`  とは、ビジネスの方法に口出しする方法を指します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプターチェーンの次のインターセプターに進むか、インターセプターされたビジネスメソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepted bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インターセプタのインスタンスは、インターセプトするBeanのインスタンスに依存するオブジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Events and Observers</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントとオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans may also produce and consume events to interact in a completely decoupled fashion.  Any Java object can serve as an event payload.  The optional qualifiers act as topic selectors.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Beanは、完全に分離された方法で相互作用するために、イベントを生成したり消費したりすることもできます。任意の Java オブジェクトをイベントのペイロードとして使用できます。オプションの修飾子は、トピックセレクタとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple Event Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなイベントの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.enterprise.event.Event` is used to fire events.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.enterprise.event.Event`  は、イベントの火付けに使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fire the event synchronously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントを同期的に発生させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method is notified when a `TaskCompleted` event is fired.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは、 `TaskCompleted`  イベントが発生したときに通知されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more info about events/observers visit https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window="_blank"].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベント/オブザーバーの詳細については、 link:https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docsを, window=_blank]をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we've covered some of the basic topics of the Quarkus programming model that is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window="_blank"] specification.  However, a full CDI implementation is not used under the hood.  Quarkus only implements a subset of the CDI features - see also &lt;&lt;cdi-reference.adoc#supported_features,the list of supported features&gt;&gt; and &lt;&lt;cdi-reference.adoc#limitations,the list of limitations&gt;&gt;.  On the other hand, there are quite a few &lt;&lt;cdi-reference#nonstandard_features,non-standard features&gt;&gt; and &lt;&lt;cdi-reference.adoc#build_time_apis,Quarkus-specific APIs&gt;&gt;.  We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=_blank]仕様に基づいたQuarkusプログラミングモデルの基本的なトピックをいくつか取り上げました。ただし、CDIの完全な実装が使用されている訳ではありません。QuarkusはCDI link:cdi-reference.html#supported_features[機能]のサブセットのみを実装しています。一方で、 link:cdi-reference.html#nonstandard_features[非標準の機能]や link:cdi-reference.html#build_time_apis[Quarkus固有のAPI]もかなりの数があります。私たちの努力は、将来的にビルドタイム指向の開発者スタックに向けてCDI仕様の革新を推進するものと信じています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you wish to learn more about Quarkus-specific features and limitations there is a Quarkus link:cdi-reference[CDI Reference Guide].  We also recommend you to read the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex topics.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus固有の機能や制限について詳しく知りたい場合は、Quarkus link:cdi-reference[CDIリファレンスガイド]があります。また、 link:http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDIの仕様]や link:https://docs.jboss.org/weld/reference/latest/en-US/html/[Weldのドキュメント]（WeldはCDIリファレンスインプリメンテーションです）を読んで、より複雑なトピックに精通することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes how to test Quarkus Security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、Quarkus Securityのテスト方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring User Information</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー情報の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use link:security-properties[quarkus-elytron-security-properties-file] for testing security. This supports both embedding user info in `application.properties` and standalone properties files.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティをテストするために link:security-properties[quarkus-elytron-security-properties-file] を使用することができます。これは `application.properties` へのユーザー情報の埋め込みとスタンドアロンのプロパティファイルの両方をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, the following configuration will allow for configuring the users in both the production where OAuth2 is required and development modes using link:https://quarkus.io/guides/config#configuration-profiles[Configuration Profiles].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、以下の構成では、OAuth2が必要な本番モードと開発モードの両方で link:https://quarkus.io/guides/config#configuration-profiles[Configuration Profiles]を使用してユーザーを設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Test Security Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティエクステンションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides explicit support for testing with different users, and with the security subsystem disabled. To use this you must include the `quarkus-test-security` artifact:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、異なるユーザーでのテストや、セキュリティサブシステムを無効にした状態でのテストを明示的にサポートしています。これを使用するには、 `quarkus-test-security` のアーティファクトを含める必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This artifact provides the `io.quarkus.test.security.TestSecurity` annotation, that can be applied to test methods and test classes to control the security context that the test is run with. This allows you to do two things, you can disable authorization so tests can access secured endpoints without needing to be authenticated, and you can specify the identity that you want the tests to run under.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアーティファクトは `io.quarkus.test.security.TestSecurity` アノテーションを提供します。これをテストメソッドやテストクラスに適用することで、テストが実行されるセキュリティコンテキストを制御することができます。認証を必要とせずに安全なエンドポイントにテストがアクセスできるように認証を無効にすることができ、テストを実行する際の ID を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A test that runs with authorization disabled can just set the enabled property to false:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認可を無効にして実行されるテストは、enabled プロパティを false に設定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will disable all access checks, which allows the test to access secured endpoints without needing to authenticate.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、すべてのアクセスチェックが無効になり、認証を必要とせずに保護されたエンドポイントにアクセスできるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use this to configure the current user that the test will run as:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使用して、テストを実行する現在のユーザーを設定することもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will run the test with an identity with the given username and roles. Note that these can be combined, so you can disable authorization while also providing an identity to run the test under, which can be useful if the endpoint expects an identity to be present.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、指定されたユーザ名とロールを持つ ID でテストを実行します。これらを組み合わせることができるので、認証を無効にしながらテストを実行するための ID を提供することができることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The feature is only available for `@QuarkusTest` and will **not** work on a `@NativeImageTest`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能は `@QuarkusTest` でのみ利用可能で、 `@NativeImageTest` では動作 *しません*。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mixing security tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティテストの混合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it becomes necessary to test security features using both `@TestSecurity` and Basic Auth (which is the fallback auth mechanism when none is defined), then Basic Auth needs to be enabled explicitly, for example by setting `quarkus.http.auth.basic=true` or `%test.quarkus.http.auth.basic=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@TestSecurity` と Basic Auth の両方を使ってセキュリティ機能をテストする必要が出てきた場合 (何も定義されていない場合のフォールバック認証メカニズムです)、明示的に有効にする必要があり、例えば `quarkus.http.auth.basic=true` や`%test.quarkus.http.auth.basic=true` と設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Wiremock for Integration Testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合テストにWiremockを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also use Wiremock to mock the authorization OAuth2 and OIDC services: See link:security-oauth2#integration-testing[OAuth2 Integration testing] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、Wiremockを使ってauthorization OAuth2とOIDCサービスをモックすることもできます。詳細は link:security-oauth2#integration-testing[OAuth2 統合テスト]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code are a _no go_ (even if we all did it at some point ;-)).  In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードの中にハードコードされた値を使うことは _できません_ (たとえ誰もがどこかの時点でそうしていたとしてもです ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `config-quickstart` {quickstarts-tree-url}/config-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `config-quickstart` {quickstarts-tree-url}/config-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.config.GreetingResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.config.GreetingResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus reads configuration properties from &lt;&lt;config-reference.adoc#configuration_sources,several sources&gt;&gt;.  For the purpose of this guide, we will use an application configuration file located in `src/main/resources/application.properties`.  Edit the file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus は link:config-reference.html#configuration_sources[複数のソース] から設定プロパティを読み取ります。このガイドでは、 `src/main/resources/application.properties` にあるアプリケーション設定ファイルを使用します。以下の内容でファイルを編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injecting configuration properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロパティの注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、 link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] アノテーションを使用して、アプリケーションに設定プロパティを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.  The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.  This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Inject @ConfigProperty` を使用することも、 `@ConfigProperty` だけを使用することもできます。 `@Inject` アノテーションは、 `@ConfigProperty` でアノテーションされたメンバーには必要ありません。この動作は link:https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] とは異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the application attempts to inject a configuration property that is not set, an error is thrown.  So you can quickly know when your configuration is complete.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが設定されていない設定プロパティを注入しようとすると、エラーがスローされます。そのため、設定が完了したときにすぐに知ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.config.GreetingResource`, and introduce the following configuration properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.config.GreetingResource` を編集し、以下の設定プロパティを導入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロパティに値を指定しないと、アプリケーションの起動は `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message` エラーで失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default value is injected if the configuration does not provide a value for `greeting.suffix`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルト値は、設定が `greeting.suffix` の値を提供していない場合に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このプロパティはオプションです - 設定が `greeting.name` の値を提供していない場合は、空の `Optional` が注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, modify the `hello` method to use the injected properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `hello` メソッドを修正して、注入されたプロパティを使用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once set, check the application with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定したら、アプリケーションを使って確認します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As an alternative to injecting multiple related configuration values, you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.  See the &lt;&lt;config-reference.adoc#using_configproperties,Configuration Reference Guide&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の関連する設定値を注入する代わりに、 `@io.quarkus.arc.config.ConfigProperties` アノテーションを使用して、これらのプロパティをまとめてグループ化することもできます。詳細については、『 link:config-reference.html#using_configproperties[設定リファレンスガイド] 』を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Update the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the functional test to reflect the changes made to the endpoint.  Edit the `src/test/java/org/acme/config/GreetingResourceTest.java` file and change the content of the `testHelloEndpoint` method to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、エンドポイントに加えられた変更を反映させるために、機能テストを更新する必要があります。 `src/test/java/org/acme/config/GreetingResourceTest.java` ファイルを編集し、 `testHelloEndpoint` メソッドの内容を変更します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  Open your browser to http://localhost:8080/greeting.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行するには、次の手順を実行します: `./mvnw compile quarkus:dev` 。ブラウザで http://localhost:8080/greeting を開きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Changing the configuration file is immediately reflected.  You can add the `greeting.suffix`, remove the other properties, change the values, etc.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定ファイルの変更はすぐに反映されます。 `greeting.suffix` の追加、他のプロパティの削除、値の変更などが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `-runner.jar` file.  You can also generate the native executable with `./mvnw clean package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` ファイルを使って実行することができます。また、 `./mvnw clean package -Pnative` でネイティブ実行可能ファイルを生成することも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Programmatically access the configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定にプログラムでアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also access the configuration programmatically.  It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プログラムで設定にアクセスすることもできます。動的なルックアップを実現したり、CDI Bean でも JAX-RS リソースでもないクラスから設定値を取得したりするのに便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `org.eclipse.microprofile.config.ConfigProvider.getConfig()` を使用してプログラムで設定にアクセスすることも出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuration Profiles</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports the notion of configuration profiles.  These allow you to have multiple configuration values in the same file and select between them via a profile name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、設定プロファイルという概念をサポートしています。これにより、同じファイル内に複数の設定値を持つことができ、プロファイル名を使用してそれらの間で選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The syntax for this is `%{profile}.config.key=value`. For example if I have the following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このための構文は `%{profile}.config.key=value` です。例えば、以下のような場合：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then the Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>個の場合、Quarkus の HTTP ポートは9090になります。 `dev` プロファイルがアクティブでない場合は8181になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the &lt;&lt;config-reference.adoc#configuration_profiles,Configuration Reference Guide&gt;&gt; for more information about configuration profiles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定プロファイルの詳細については、 link:config-reference.html#configuration_profiles[設定リファレンスガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace for its own configuration. For example to configure the HTTP server port you can set `quarkus.http.port` in `application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus 自体は、アプリケーションと同じメカニズムで設定されます。Quarkus は、独自の設定のために `quarkus.` ネームスペースを予約します。たとえば、HTTPサーバーのポートを設定するには、 `application.properties` で `quarkus.http.port` を設定します。Quarkusの設定プロパティはすべて link:all-config[文書化されており、検索可能です] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and therefore `quarkus.` should **never** be used as prefix for application specific properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上述したように、 `quarkus.` で始まるプロパティは、Quarkus 自体を設定するために実質的に予約されているため、アプリケーション固有のプロパティのプレフィックスとして `quarkus.` を使用してはいけ *ません* 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前の例では、 `greeting.message` の代わりに `quarkus.message` を使用すると、予期せぬ動作をすることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus does much of its configuration and bootstrap at build time and some configuration properties are read and used during the build.  These properties are _fixed at build time_ and it's not possible to change them at runtime.  You always need to repackage your application in order to reflect changes of such properties.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、その設定とブートストラップの多くをビルド時に行い、いくつかの設定プロパティはビルド中に読み込まれて使用されます。これらのプロパティは _ビルド時に固定され_ ており、実行時に変更することはできません。このようなプロパティの変更を反映させるには、常にアプリケーションをリパッケージする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド時に固定されたプロパティは、 link:all-config[すべての設定オプションのリスト] でロックアイコン([lock])でマークされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, some extensions do define properties _overridable at runtime_.  A canonical example is the database URL, username and password which is only known specifically in your target environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、いくつかのエクステンションは _実行時にオーバーライド可能な_ プロパティを定義しています。定型的な例としては、データベースの URL、ユーザー名とパスワードがありますが、これはターゲット環境でしか知られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>System properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>An environment file named `.env` placed in the current working directory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の作業ディレクトリに配置された `.env` という名前の環境ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A configuration file placed in `$PWD/config/application.properties`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`$PWD/config/application.properties` に配置された設定ファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the &lt;&lt;config-reference.adoc#configuring_quarkus,Configuration Reference Guide&gt;&gt; for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:config-reference.html#configuring_quarkus[設定リファレンスガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a new project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新規プロジェクトの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you just launch `mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create` the Maven plugin asks for user inputs. You can disable (and use default values) this interactive mode by passing `-B` to the Maven command.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create`  を起動するだけで、Maven プラグインはユーザ入力を要求します。 `-B`  を Maven コマンドに渡すことで、この対話型モードを無効にすることができます (デフォルト値を使用します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following table lists the attributes you can pass to the `create` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次の表は、 `create`  コマンドに渡すことができる属性の一覧です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is either generated in the current directory or in a directory named after the passed artifactId.  If the current directory is empty, the project is generated in-place.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトは、カレント・ディレクトリに生成されるか、渡されたartifactIdにちなんだ名前のディレクトリに生成されます。カレントディレクトリが空の場合，プロジェクトはその場で生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dealing with extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションへの対応</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions are passed using a comma-separated list.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、カンマ区切りのリストを使用して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, attach your debugger to `localhost:5005`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、デバッガを `localhost:5005`  にアタッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Maven project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;project-creation, プロジェクトを生成したら&gt;&gt;、お気に入りのIDEでインポートすることができます。唯一の要件は、Mavenプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Eclipse**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Eclipse**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Maven -&gt; Existing Maven Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Maven → Existing Maven Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish` をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**IntelliJ**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**IntelliJ**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In IntelliJ:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJの場合：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From inside IntelliJ select `File -&gt; New -&gt; Project From Existing Sources...` or, if you are on the welcome dialog, select `Import project`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IntelliJの内部から `File → New → Project From Existing Sources…​`  を選択するか、ウェルカム・ダイアログであれば `Import project`  を選択してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select the project root</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのルートを選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Maven`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Import project from external model`  を選択して `Maven`を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On the last screen click on Finish</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後の画面でFinishをクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `File -&gt; Open Project`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`File → Open Project` を選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Visual Studio Code**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Maven project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VS Codeでプロジェクトディレクトリを開きます。Java Extension Pack（Java拡張のセットをグループ化したもの）をインストールしている場合、プロジェクトはMavenプロジェクトとしてロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://picocli.info/[Picocliは] 、リッチなコマンドラインアプリケーションを作成するためのオープンソースツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、Picocli を使用するためのサポートを提供しています。このガイドには、 `picocli` エクステンションの使用例が記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus のコマンドモードに詳しくない場合は、まず link:command-mode-reference[コマンドモードのリファレンスガイド] を読むことを検討してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `picocli` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus プロジェクトを設定すると、プロジェクトのベースディレクトリで次のコマンドを実行することで、 `picocli` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple command line application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simple PicocliApplication with only one `Command` can be created as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Command` を 1 つだけ使ったシンプルな PicocliApplication は、以下のように作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスが 1 つだけある場合、これは Picocli CommandLine のエントリーポイントとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli.CommandLine.Command` でアノテーションされたクラスはすべて CDI Bean として登録されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beans with `@CommandLine.Command` should not use proxied scopes (e.g. do not use `@ApplicationScope`)  because Picocli will not be able set field values in such beans. This extension will register classes with `@CommandLine.Command` annotation using `@Depended` scope. If you need to use proxied scope, then annotate setter and not field, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CommandLine.Command` を持つ Bean では、プロキシされるスコープを使用してはいけません (例: `@ApplicationScope` は使用しないでください)。Picocli はそのような Bean でフィールド値を設定できないためです。このエクステンションは `@CommandLine.Command` アノテーションを持つクラスを `@Depended` スコープを使って登録します。プロキシされるスコープを使用する必要がある場合は、フィールドではなくセッターを次の例のようにアノテーションしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command line application with multiple Commands</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のコマンドを使用したコマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When multiple classes have the `picocli.CommandLine.Command` annotation, then one of them needs to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.  This can be overwritten with the `quarkus.picocli.top-command` property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のクラスが `picocli.CommandLine.Command` アノテーションを持つ場合、そのうちの 1 つに `io.quarkus.picocli.runtime.annotations.TopCommand` アノテーションを付ける必要があります。これは `quarkus.picocli.top-command` プロパティで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can customize CommandLine classes used by the `picocli` extension by producing your own bean instance:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自の Bean インスタンスを生成することで、 `picocli` エクステンションで使用される CommandLine クラスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`PicocliCommandLineFactory` は、 `TopCommand` と `CommandLine.IFactory` を注入した CommandLine のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Different entry command for each profile</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルごとに異なるエントリコマンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create different entry command for each profile, using `@IfBuildProfile`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@IfBuildProfile` を使用して、プロファイルごとに異なるエントリーコマンドを作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can return instance of `java.lang.Class` here. In such case `CommandLine` will try to instantiate this class using `CommandLine.IFactory`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここでは `java.lang.Class` のインスタンスを返すことができます。この場合、 `CommandLine` は `CommandLine.IFactory` を使ってこのクラスのインスタンスを作成しようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure CDI Beans with parsed arguments</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>解析された引数での CDI Beans の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use `Event&lt;CommandLine.ParseResult&gt;` or just `CommandLine.ParseResult` to configure CDI beans based on arguments parsed by Picocli.  This event will be generated in `QuarkusApplication` class created by this extension. If you are providing your own `@QuarkusMain` this event will not be raised.  `CommandLine.ParseResult` is created from default `CommandLine` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli によって解析された引数に基づいて CDI Bean を設定するために、 `Event&lt;CommandLine.ParseResult&gt;` 、または単に `CommandLine.ParseResult` を使用することができます。このイベントは、このエクステンションによって作成された `QuarkusApplication` クラスで生成されます。独自の `@QuarkusMain` を提供している場合、このイベントは発生しません。 `CommandLine.ParseResult` はデフォルトの `CommandLine` Bean から作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Providing own QuarkusMain</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自の QuarkusMain の提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also provide your own application entry point annotated with `QuarkusMain` (as described in link:command-mode-reference[Command Mode reference guide]).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `QuarkusMain` でアノテーションされた独自のアプリケーションのエントリーポイントを提供することもできます (link:command-mode-reference[コマンドモードのリファレンスガイド] に記載されています)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus-compatible `CommandLine.IFactory` bean created by `picocli` extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`picocli` のエクステンションで作成された Quarkus 互換の `CommandLine.IFactory` Bean。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native mode support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension uses the Quarkus standard build steps mechanism to support GraalVM Native images. In the exceptional case that incompatible changes in a future picocli release cause any issue, the following configuration can be used to fall back to the annotation processor from the picocli project as a temporary workaround:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションでは、Quarkus 標準のビルドステップメカニズムを使用して、GraalVM Nativeイメージをサポートしています。将来のpicocliリリースで互換性のない変更が問題を引き起こす例外的なケースでは、一時的な回避策として、以下の設定を使用してpicocliプロジェクトのアノテーションプロセッサにフォールバックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Gradle, you need to add the following in `dependencies` section of the `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradle の場合は、 `build.gradle` ファイルの `dependencies` セクションに以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limitations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約事項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's see our application in action. Run it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、実際にアプリケーションを見てみましょう。以下のように実行してみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As usual, the application can be packaged using `./mvnw clean package` and executed using the `-runner.jar` file.  You can also build the native executable using `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いつものように、 `./mvnw clean package` を使ってアプリケーションをパッケージ化し、 `-runner.jar` ファイルを使って実行することができます。また、 `./mvnw package -Pnative` を使用してネイティブの実行ファイルをビルドすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application.  In this guide, we will explore:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、開発者がライブリーロードから Kubernetes アプリケーションのデプロイまでを可能にするツールチェーンが付属しています。このガイドでは、以下を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to develop your application in your IDE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>IDE でアプリケーションを開発する方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Choosing your build tool</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドツールの選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a native CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には、すべての開発段階で役立つツールチェーンが付属しています。ビルドツールとして Maven や Gradle を使うことができます。また、使い勝手の良いネイティブ CLI も提供しています (近日公開予定)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:maven-tooling[Maven]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:gradle-tooling[Gradle]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before anything can be done you must first install a JVMCI build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何かをする前に、まずJVMCIビルドをインストールしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be downloaded from OTN http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[here]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは link:http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html[ここ]でOTNからダウンロードすることができます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note, if you are installing on an alternative system, you can use the developer tools on chrome or firefox to capture a direct URL with an auth param.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のシステムにインストールする場合は、ChromeやFirefoxの開発者ツールを使用して、auth パラメーターを指定して直接 URL をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After obtaining the download install it and set `JAVA_HOME`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ダウンロードした後、インストールして `JAVA_HOME` をセットします</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Get the latest version available as graal tends to keep updating the minimum requirements.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>graalは最小要件を更新し続ける傾向があるので、最新版を入手しましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to install Graal’s special build tool, `mx`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今、あなたはGraalの特別なビルドツール `mx` をインストールする必要があります、.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the Quarkus Dev UI for link:building-my-first-extension[extension authors].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、 link:building-my-first-extension[エクステンションの作者] のためのQuarkus Dev UIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dev</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: vision
permalink: /vision/container-first
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the outset {project-name} has been designed around a container first philosophy.  What this means in real terms is that {project-name} is optimised for low memory usage and fast startup times in the following ways:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初から {project-name} はコンテナファーストの哲学に基づいて設計されています。これが実際に意味することは、{project-name} は以下の方法でメモリ使用量を抑え、起動時間を短縮するように最適化されているということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Substrate support has been an important part of the design for {project-name} from the beginning.  When an application is compiled down to a native image it starts much faster and can run with a much smaller heap than a standard JVM. {project-name} are all tested in Substrate, and can run without the `-H:+ReportUnsupportedElementsAtRuntime` flag.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サブストレートのサポートは、最初から {project-name} の設計の重要な部分でした。アプリケーションがネイティブイメージにコンパイルされると、標準的なJVMよりもはるかに高速に起動し、より小さなヒープで実行することができます。project-name} はすべて Substrate でテストされており、 `-H:+ReportUnsupportedElementsAtRuntime` フラグなしで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Time Metadata Processing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドタイムメタデータ処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much processing as possible is done at build time, so your application will only contain the classes that are actually needed at runtime. In a traditional model all the classes required to perform the initial application deployment hang around for the life of the application, even though they are only used once. With {project-name} they are not even loaded into the production JVM. This results in less memory usage, and also faster startup time as all metadata processing has already been done.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>可能な限り多くの処理はビルド時に行われるので、アプリケーションは実行時に実際に必要とされるクラスだけを含みます。従来のモデルでは、最初のアプリケーションのデプロイメントを実行するために必要なすべてのクラスは、一度しか使用されないにもかかわらず、アプリケーションの寿命の間、ぶら下がっています。project-name}では、それらのクラスは本番環境のJVMにロードされません。その結果、メモリ使用量が少なくなり、すべてのメタデータ処理がすでに行われているため、起動時間も速くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reduction in Reflection Usage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リフレクション使用量の削減</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As much as possible {project-name} tries to avoid reflection, reducing startup time and memory usage.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{project-name}は可能な限り反射を避け、起動時間とメモリ使用量を減らすようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Image Pre Boot</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージのプリブート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in a native image {project-name} pre-boots as much of the framework as possible during the native image build process. This means that the resulting native image has already run most of the startup code and serialized the result into the executable, resulting in even faster startup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージで {project-name}を実行する場合、ネイティブイメージのビルドプロセスの間に、フレームワークの可能な限りの部分をプリブートします。これは、結果として得られるネイティブイメージがすでにほとんどのスタートアップコードを実行し、その結果を実行ファイルにシリアライズしていることを意味し、より高速なスタートアップを実現します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: vision
permalink: /vision/standards
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Our dependency injection solution is based on CDI.  You can use JAX-RS annotations to define the REST endpoints.  You can use JPA annotations to map your persistent entities and JTA annotations to declare the transaction boundaries.  You can use Eclipse MicroProfile to configure and monitor your application.  You can use Vert.x, Apache Camel and we support much more.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>我々の依存性注入ソリューションはCDIに基づいています。 JAX-RS アノテーションを使用して REST エンドポイントを定義できます。 JPA アノテーションを使用して、永続エンティティーをマップし、 JTA アノテーションを使用してトランザクション境界を宣言することができます。 Eclipse MicroProfileを使用して、アプリケーションを構成およびモニターできます。 Vert.x、Apache Camelを使用することが出来、そして更に多くをサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Since we're not limited to standards we can go beyond and extend your possibilities.  Of course, {project-name} is not a passive consumer.  Our goal is to improve and innovate the technologies we use and contribute back to the open source projects and standards we rely on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>我々は標準に限定されない為、あなたの可能性を広げることが可能です。 もちろん、{project-name} は受動的な消費者ではありません。 私たちのゴールは、使用する技術を改善、革新し、私たちが頼りにしているオープンソースプロジェクトと標準に貢献することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Gradle plugin is published to the https://plugins.gradle.org/plugin/io.quarkus[Gradle Plugin Portal].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Gradle プラグインは、Gradle link:https://plugins.gradle.org/plugin/io.quarkus[プラグインポータル] に公開されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use it, add the following to your `build.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>使用するには、 `build.gradle` ファイルに以下を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>plugins {
    id 'java'
    id 'io.quarkus'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You also need to add the following at the top of your `settings.gradle` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、`settings.gradle` ファイルの先頭に以下を追加する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    plugins {
      id 'io.quarkus' version "${quarkusPluginVersion}"
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>NOTE</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `plugins{}` method in `settings.gradle` is not supported in Gradle 5.x. In this case make sure to explicitly declare the plugin version in the `build.gradle` file like the example below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`settings.gradle` の `plugins{}` メソッドは Gradle 5.x ではサポートされていません。この場合、以下の例のように `build.gradle` ファイルでプラグインのバージョンを明示的に宣言するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>plugins {
    id 'java'
    id 'io.quarkus' version '{quarkus-version}'
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://kotlinlang.org/[Kotlin] is a very popular programming language that targets the JVM (amongst other environments). Kotlin has experienced a surge in popularity the last few years making it the most popular JVM language, except for Java of course.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://kotlinlang.org/[Kotlin] は、JVMをターゲットにした（他の環境を含めても）非常に人気のあるプログラミング言語です。Kotlinはここ数年で人気が急上昇し、Javaを除いて最も人気のあるJVM言語となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>less than 10 minutes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>１０分未満</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>or, if you use the Gradle Kotlin DSL:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、GradleのKotlin DSLを使用している場合：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Qute is a templating engine designed specifically to meet the Quarkus needs.  The usage of reflection is minimized to reduce the size of native images.  The API combines both the imperative and the non-blocking reactive style of coding.  In the development mode, all files located in `src/main/resources/templates` are watched for changes and modifications are immediately visible.  Furthermore, we try to detect most of the template problems at build time.  In this guide, you will learn how to easily render templates in your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteは、Quarkus のニーズを満たすために特別に設計されたテンプレートエンジンです。ネイティブイメージのサイズを小さくするために、リフレクションの使用は最小限に抑えられています。API は、命令型とノンブロッキングリアクティブ型の両方のスタイルのコーディングを組み合わせています。開発モードでは、 `src/main/resources/templates` にあるすべてのファイルが変更のために監視され、変更はすぐに表示されます。さらに、ビルド時にテンプレートの問題のほとんどを検出するようにしています。このガイドでは、アプリケーションでテンプレートを簡単にレンダリングする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to use Qute in your JAX-RS application, you need to add the `quarkus-resteasy-qute` extension first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RS アプリケーションで Qute を使用する場合は、まず `quarkus-resteasy-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに以下を追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll start with a very simple template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずはとてもシンプルなテンプレートから：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`{name}` is a value expression that is evaluated when the template is rendered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{name}` は、テンプレートがレンダリングされたときに評価される値の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, all files located in the `src/main/resources/templates` directory and its subdirectories are registered as templates. Templates are validated during startup and watched for changes in the development mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `src/main/resources/templates` ディレクトリとそのサブディレクトリにあるすべてのファイルがテンプレートとして登録されます。開発モードではテンプレートは起動時に検証され、変更が監視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's inject the "compiled" template in the resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、リソースクラスに「コンパイル済み」テンプレートを注入してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If there is no `@ResourcePath` qualifier provided, the field name is used to locate the template. In this particular case, we're injecting a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ResourcePath` の修飾子が指定されていない場合は、フィールド名がテンプレートの場所を特定するために使用されます。この特定のケースでは、パスが `templates/hello.txt` であるテンプレートを注入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Template.data()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Template.data()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` の下に置きます。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that we don't trigger the rendering - this is done automatically by a special `ContainerResponseFilter` implementation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レンダリングをトリガーしないことに注意してください - これは特別な `ContainerResponseFilter` の実装によって自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application is running, you can request the endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが動作している場合は、エンドポイントを要求することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Type-safe templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>タイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There's an alternate way to declare your templates in your Java code, which relies on the following convention:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java コードでテンプレートを宣言する別の方法もあり、以下の規約に依存しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Organise your template files in the `/src/main/resources/templates` directory, by grouping them into one directory per resource class. So, if your `ItemResource` class references two templates `hello` and `goodbye`, place them at `/src/main/resources/templates/ItemResource/hello.txt` and `/src/main/resources/templates/ItemResource/goodbye.txt`. Grouping templates per resource class makes it easier to navigate to them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートファイルを `/src/main/resources/templates` ディレクトリに整理し、リソースクラスごとに 1 つのディレクトリにグループ化します。つまり、 `ItemResource` クラスが `hello` と `goodbye` の 2 つのテンプレートを参照している場合は、 `/src/main/resources/templates/ItemResource/hello.txt` と `/src/main/resources/templates/ItemResource/goodbye.txt` に配置します。リソースクラスごとにテンプレートをグループ化することで、テンプレートへのナビゲートが容易になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In each of your resource class, declare a `@CheckedTemplate static class Template {}` class within your resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各リソースクラスで、リソースクラス内で `@CheckedTemplate static class Template {}` クラスを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare one `public static native TemplateInstance method();` per template file for your resource.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リ ソ ース のテ ン プ レー ト フ ァ イ ルごとに `public static native TemplateInstance method();` を 1 つずつ宣言 し ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use those static methods to build your template instances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートインスタンスを構築するには、これらの静的メソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Here's the previous example, rewritten using this style:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先ほどの例を、このスタイルで書き換えてみました：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource/hello.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's declare and use those templates in the resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、これらのテンプレートをリソースクラスで宣言して使ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/HelloResource/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パス `templates/HelloResource/hello.txt` でテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`Templates.hello()` returns a new template instance that can be customized before the actual rendering is triggered. In this case, we put the name value under the key `name`. The data map is accessible during rendering.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Templates.hello()` は、実際のレンダリングがトリガーされる前にカスタマイズできる新しいテンプレートインスタンスを返します。この場合、名前の値をキー `name` の下に置きます。データマップはレンダリング中にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have declared a `@CheckedTemplate` class, we will check that all its methods point to existing templates, so if you try to use a template from your Java code and you forgot to add it, we will let you know at build time :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@CheckedTemplate` クラスを宣言したら、すべてのメソッドが既存のテンプレートを指しているかどうかをチェックしますので、もし Java コードからテンプレートを使おうとして追加するのを忘れてしまった場合は、ビルド時にお知らせします :)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind this style of declaration allows you to reference templates declared in other resources too:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このスタイルの宣言では、他のリソースで宣言されたテンプレートも参照できることを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Top-level type-safe templates</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トップレベルのタイプセーフテンプレート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Naturally, if you want to declare templates at the top-level, directly in `/src/main/resources/templates/hello.txt`, for example, you can declare them in a toplevel (non-nested) `Templates` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>当然のことながら、トップレベルでテンプレートを宣言したい場合、例えば `/src/main/resources/templates/hello.txt` で直接宣言したい場合は、トップレベル（非入れ子）の `Templates` クラスで宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This declares a template with path `templates/hello.txt`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パス `templates/hello.txt` のテンプレートを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Parameter Declarations </seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートパラメータ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you declare a *parameter declaration* in a template then Qute attempts to validate all expressions that reference this parameter and if an incorrect expression is found the build fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートで *パラメータ宣言* を宣言した場合、Quteはこのパラメータを参照するすべての式の検証を試み、間違った式が見つかった場合はビルドが失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose we have a simple class like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなシンプルなクラスがあったとしましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Item.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Item.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And we'd like to render a simple HTML page that contains the item name and price.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、商品名と価格が記載されたシンプルな HTML ページをレンダリングしたいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start again with the template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>改めてテンプレートから始めてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource/item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ItemResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is validated. Try to change the expression to `{item.nonSense}` and the build should fail.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この式は検証済みです。式を `{item.nonSense}` に変更するとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is also validated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これも検証されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class with type-safe templates:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、タイプセーフなテンプレートを使ってリソースクラスを作ってみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ItemResource.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ItemResource.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare a method that gives us a `TemplateInstance` for `templates/ItemResource/item.html` and declare its `Item item` parameter so we can validate the template.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`templates/ItemResource/item.html` に対して `TemplateInstance` を与えるメソッドを宣言し、その `Item item` パラメータを宣言することで、テンプレートを検証することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make the `Item` object accessible in the template.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート内で `Item` オブジェクトにアクセスできるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template parameter declaration inside the template itself</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート内部のテンプレートパラメータ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, you can declare your template parameters in the template file itself.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あるいは、テンプレートファイル自体でテンプレートパラメータを宣言することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional parameter declaration. Qute attempts to validate all expressions that reference the parameter `item`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションのパラメータ宣言。Qute は、パラメータ `item` を参照するすべての式の検証を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a resource class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、リソースクラスを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the template with path `templates/item.html`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスが `templates/item.html` のテンプレートを注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Template Extension Methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート拡張メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Template extension methods* are used to extend the set of accessible properties of data objects.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*テンプレート拡張メソッド* は 、データオブジェクトのアクセス可能なプロパティのセットを拡張するために使用されます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you're not in control of the classes that you want to use in your template, and you cannot add methods to them. Template extension methods allows you to declare new method for those classes that will be available from your templates just as if they belonged to the target class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、テンプレートで使用したいクラスをコントロールできず、それらのクラスにメソッドを追加できないことがあります。テンプレート拡張メソッドを使うと、テンプレートから利用できるようになるクラスのメソッドを、あたかもターゲットクラスに属しているかのように宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's keep extending on our simple HTML page that contains the item name, price and add a discounted price.  The discounted price is sometimes called a "computed property".  We will implement a template extension method to render this property easily.  Let's update our template:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アイテム名、価格、値引き価格を含むシンプルな HTML ページを拡張していきましょう。値引き価格は「計算プロパティ」と呼ばれることがあります。このプロパティを簡単にレンダリングするためのテンプレート拡張メソッドを実装します。テンプレートを更新してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HelloResource/item.html</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HelloResource/item.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`if` is a basic control flow section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`if` は、基本的な制御フローのセクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This expression is also validated against the `Item` class and obviously there is no such property declared. However, there is a template extension method declared on the `TemplateExtensions` class - see below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この式は `Item` クラスに対しても検証されており、明らかにそのようなプロパティは宣言されていません。しかし、 `TemplateExtensions` クラスにはテンプレート拡張メソッドが宣言されています - 以下を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's create a class where we put all our extension methods:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、すべての拡張メソッドを置くクラスを作りましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>TemplateExtensions.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>TemplateExtensions.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A static template extension method can be used to add "computed properties" to a data class. The class of the first parameter is used to match the base object and the method name is used to match the property name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>静的テンプレート拡張メソッドを使用して、データクラスに「計算プロパティ」を追加することができます。最初のパラメータのクラスはベースオブジェクトと一致するように使用され、メソッド名はプロパティ名と一致するように使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you can place template extension methods in every class if you annotate them with `@TemplateExtension` but we advise to keep them either grouped by target type, or in a single `TemplateExtensions` class by convention.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレート拡張メソッドは、 `@TemplateExtension` でアノテーションを付ければ、すべてのクラスに配置することができますが、規約上、ターゲットタイプでグループ化するか、 `TemplateExtensions` クラスにまとめておくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Rendering Periodic Reports</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>定期レポートのレンダリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templating engine could be also very useful when rendering periodic reports.  You'll need to add the `quarkus-scheduler` and `quarkus-qute` extensions first.  In your `pom.xml` file, add:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレーティングエンジンは、定期的なレポートをレンダリングする際にも非常に便利かもしれません。最初に `quarkus-scheduler` と `quarkus-qute` のエクステンションを追加する必要があります。 `pom.xml` ファイルに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's suppose the have a `SampleService` bean whose `get()` method returns a list of samples.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`SampleService` ビーンがあり、その `get()` メソッドがサンプルのリストを返すとしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sample.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The template is simple:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートはシンプルです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The loop section makes it possible to iterate over iterables, maps and streams.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ループセクションでは、イテレーション、マップ、ストリームの反復処理が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This value expression is using the https://en.wikipedia.org/wiki/Elvis_operator[elvis operator] - if the name is null the default value is used.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この値式は link:https://en.wikipedia.org/wiki/Elvis_operator[elvis 演算子] を使用します - nameが NULL の場合はデフォルト値が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ReportGenerator.java</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ReportGenerator.java</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, we use the `@ResourcePath` qualifier to specify the template path: `templates/reports/v1/report_01.html`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、 `@ResourcePath` の修飾子を使用してテンプレートのパスを指定します: `templates/reports/v1/report_01.html` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to execute this method on the half hour. For more information see the link:scheduler[Scheduler] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` アノテーションを使用して、Quarkusにこのメソッドを30分に実行するよう指示します。詳細については、 link:scheduler[スケジューラーガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `TemplateInstance.render()` method triggers rendering. Note that this method blocks the current thread.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`TemplateInstance.render()` メソッドはレンダリングをトリガします。このメソッドは現在のスレッドをブロックすることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive and Asynchronous APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブと非同期API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Templates can be rendered as a `CompletionStage&lt;String&gt;` (completed with the rendered output asynchronously) or as `Publisher&lt;String&gt;` containing the rendered chunks:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テンプレートは、 `CompletionStage&lt;String&gt;` （非同期にレンダリングされた出力で完了）としてレンダリングすることも、レンダリングされたチャンクを含む `Publisher&lt;String&gt;` としてレンダリングすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of a `Publisher`, the template is rendered chunk by chunk following the requests from the subscriber.  The rendering is not started until a subscriber requests it.  The returned `Publisher` is an instance of `io.smallrye.mutiny.Multi`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Publisher` の場合、テンプレートはサブスクライバーからのリクエストに応じてチャンクごとにレンダリングされます。レンダリングは、サブスクライバーがリクエストするまで開始されません。返された `Publisher` は `io.smallrye.mutiny.Multi` のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to create an instance of `io.smallrye.mutiny.Uni` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように、 `io.smallrye.mutiny.Uni` のインスタンスを作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this case, the rendering only starts once the subscriber requests it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この場合、サブスクライバーが要求した場合にのみレンダリングが開始されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about Qute, please refer to the link:qute-reference[Qute reference guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Qute について詳しく知りたい方は、 link:qute-reference[Qute リファレンスガイド] を参考にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Validation with Hibernate Validator</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation for:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の場合のHibernate Validator/Bean Validation の使用方法について説明します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the input/output of your REST services;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST サービスの入出力の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>validating the parameters and return values of the methods of your business services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビジネスサービスのメソッドのパラメータと戻り値の検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application built in this guide is quite simple. The user fills a form on a web page.  The web page sends the form content to the `BookResource` as JSON (using Ajax). The `BookResource` validates the user input and returns the _result_ as JSON.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドで構築されたアプリケーションは非常にシンプルです。ユーザーはウェブページ上でフォームを入力します。Web ページはフォームの内容を JSON として `BookResource` に送信します (Ajax を使用)。 `BookResource` はユーザーの入力を検証し、 _結果_ をJSON として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:validation-guide-architecture.png[alt=Architecture]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `validation-quickstart` {quickstarts-tree-url}/validation-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson and Hibernate Validator/Bean Validation extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、RESTEasy/JAX-RS、Jackson、およびHibernate Validator/Bean ValidationエクステンションをインポートするMavenディレクトリ構造を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `hibernate-validator` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `hibernate-validator` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Accessing the Validator</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデータへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `org.acme.validation.BookResource` class, and inject the `Validator` object as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.validation.BookResource` クラスを編集し、以下のように `Validator` オブジェクトを注入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Validator` allows checking constraints on a specific object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Validator` では、特定のオブジェクトに対する制約をチェックすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this application, we are going to test an elementary object, but we support complicated constraints and can validate graphs of objects.  Create the `org.acme.validation.Book` class with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今回のアプリケーションでは、基本のオブジェクトをテストすることになりますが、複雑な制約にも対応しており、オブジェクトのグラフを検証することができます。以下の内容で `org.acme.validation.Book` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Constraints are added on fields, and when an object is validated, the values are checked.  The getter and setter methods are also used for JSON mapping.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フィールドに制約を加え、オブジェクトが検証されると値がチェックされます。ゲッターメソッドとセッターメソッドはJSONマッピングにも使われています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Back to the `BookResource` class.  Add the following method:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`BookResource` クラスに戻り、以下のメソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes it does not compile, `Result` is missing, but we will add it very soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、これはコンパイル出来ません。 `Result` がありませんが、私たちはすぐに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method parameter (`book`) is created from the JSON payload automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メソッドパラメータ( `book` )は、JSONペイロードから自動的に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The method uses the `Validator` to check the payload.  It returns a set of violations.  If this set is empty, it means the object is valid.  In case of failures, the messages are concatenated and sent back to the browser.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このメソッドは `Validator` を使用してペイロードをチェックします。これは違反のセットを返します。このセットが空の場合は、オブジェクトが有効であることを意味します。失敗した場合は、メッセージを連結してブラウザに送り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's now create the `Result` class as an inner class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、 `Result` クラスをインナークラスとして作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The class is very simple and only contains 2 fields and the associated getters and setters.  Because we indicate that we produce JSON, the mapping to JSON is made automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このクラスは非常にシンプルで、2つのフィールドとそれに関連するゲッターとセッターだけが含まれています。JSONを生成することを示しているので、JSONへのマッピングは自動的に行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While using the `Validator` manually might be useful for some advanced usage, if you simply want to validate the parameters or the return value or your REST end point, you can annotate it directly, either with constraints (`@NotNull`, `@Digits`...)  or with `@Valid` (which will cascade the validation to the bean).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Validator` を手動で使用することは、高度な使用法には便利かもしれませんが、単にパラメータや戻り値、RESTのエンドポイントを検証したい場合は、制約( `@NotNull`, `@Digits`...)や `@Valid` (ビーンに検証をカスケードします)を使用して直接アノテーションすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's create an end point validating the `Book` provided in the request:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リクエストで提供された `Book` を検証するエンドポイントを作成してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see, we don't have to manually validate the provided `Book` anymore as it is automatically validated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご覧のように、提供された `Book` は自動的に検証されるので、もう手動で検証する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a validation error is triggered, a violation report is generated and serialized as JSON as our end point produces a JSON output.  It can be extracted and manipulated to display a proper error message.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>検証エラーが発生した場合、違反レポートが生成され、そしてエンドポイントがJSON出力を生成することによってJSONとしてシリアライズされます。これを抽出して操作することで、適切なエラーメッセージを表示することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Service method validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サービスメソッドの検証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It might not always be handy to have the validation rules declared at the end point level as it could duplicate some business validation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデーションルールをエンドポイントレベルで宣言するのは、必ずしも便利とは限りません。ビジネスバリデーションと重複する可能性があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best option is then to annotate a method of your business service with your constraints (or in our particular case with `@Valid`):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最良の選択肢は、ビジネスサービスのメソッドに制約をアノテーションすることです（私たちの場合は `@Valid` ）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Calling the service in your rest end point triggers the `Book` validation automatically:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントでサービスを呼び出すと、自動的に `Book` の検証が行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note that, if you want to push the validation errors to the frontend, you have to catch the exception and push the information yourselves as they will not be automatically pushed to the JSON output.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>検証エラーをフロントエンドにプッシュしたい場合は、例外をキャッチして自分で情報をプッシュしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep in mind that you usually don't want to expose to the public the internals of your services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あなたは通常、あなたのサービスの内部を公開したくないことを覚えておいてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and especially not the validated value contained in the violation object.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特に違反オブジェクトに含まれる検証された値は公開したくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A frontend</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フロントエンド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now let's add the simple web page to interact with our `BookResource`.  Quarkus automatically serves static resources contained in the `META-INF/resources` directory.  In the `src/main/resources/META-INF/resources` directory, replace the `index.html` file with the content from this {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] file in it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>それでは、 `BookResource`.Quarkusと対話するためのシンプルなウェブページを追加してみましょう。Quarkusは、 `META-INF/resources` ディレクトリに含まれる静的リソースを自動的に提供します。 `src/main/resources/META-INF/resources` ディレクトリで、 `index.html` ファイルをこの {quickstarts-blob-url}/validation-quickstart/src/main/resources/META-INF/resources/index.html[index.html] ファイルの内容で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open your browser to http://localhost:8080/:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして、ブラウザで http://localhost:8080/ を開いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enter the book details (valid or invalid)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>書籍の詳細を入力してください（有効または無効）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Click on the _Try me..._ buttons to check if your data is valid using one of the methods we presented above.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_Try me..._ ボタンをクリックして、上記で紹介した方法のいずれかを使用してデータが有効かどうかを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:validation-guide-screenshot.png[alt=Application]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Hibernate Validator extension is tightly integrated with CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ValidatorエクステンションはCDIと緊密に統合されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sometimes, you might need to configure the behavior of the `ValidatorFactory`, for instance to use a specific `ParameterNameProvider`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>時には、 `ValidatorFactory` の動作を設定する必要があるかもしれません。例えば、特定の `ParameterNameProvider` を使用するためなどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While the `ValidatorFactory` is instantiated by Quarkus itself, you can very easily tweak it by declaring replacement beans that will be injected in the configuration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ValidatorFactory` は、Quarkus 自体によってインスタンス化されていますが、設定に注入される代わりのビーンを宣言することで、非常に簡単に微調整することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you create a bean of the following types in your application, it will automatically be injected into the `ValidatorFactory` configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションで以下のタイプのBeanを作成すると、自動的に `ValidatorFactory` の設定に注入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ClockProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ConstraintValidator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ConstraintValidatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.MessageInterpolator`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.ParameterNameProvider`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`javax.validation.TraversableResolver`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.hibernate.validator.spi.properties.GetterPropertySelectionStrategy`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.hibernate.validator.spi.scripting.ScriptEvaluatorFactory`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You don't have to wire anything.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何も設定しなくても大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obviously, for each listed type, you can declare only one bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論、リストされた各型に対して、宣言することができるのは1つのBeanだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These beans should be declared as `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのBeanは、 `@ApplicationScoped` として宣言する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can declare your constraint validators as CDI beans:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>制約バリデータをCDI Beanとして宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When initializing a constraint validator of a given type, Quarkus will check if a bean of this type is available and, if so, it will use it instead of instantiating one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>指定された型の制約バリデータを初期化する際、Quarkusはこの型のBeanが利用可能かどうかをチェックし、利用可能な場合はインスタンスを作成する代わりにそれを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thus, as demonstrated in our example, you can fully use injection in your constraint validator beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このように、例で示したように、制約バリデータビーンでインジェクションを完全に使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Except in very specific situations, it is recommended to make the said beans `@ApplicationScoped`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非常に特定の状況を除いて、このBeanは `@ApplicationScoped` として作ることをお勧めします.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Validation and localization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バリデーションとローカリゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, constraint violation messages will be returned in the build system locale.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、制約違反のメッセージはビルドシステムのロケールで返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure this behavior by adding the following configuration in your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この動作は、以下の設定を `application.properties` に追加することで変更することが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy, in the context of a JAX-RS endpoint, Hibernate Validator will automatically resolve the optimal locale to use from the `Accept-Language` HTTP header, provided the supported locales have been properly specified in the `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTEasyを使用している場合、JAX-RSエンドポイントのコンテキストでは、 サポートされるロケールが `application.properties` で適切に指定されている場合、Hibernate Validatorが使用する最適なロケールを `Accept-Language` HTTPヘッダから自動的に解決します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to interact with Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを利用してApache Kafkaと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Quarkus, you just need to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、以下を実施するだけです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add the following dependencies to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下の依存関係をプロジェクトに追加してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンティティの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configuration properties listed here allow you to override such defaults, and customize and tune various aspects.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここに記載されている設定プロパティでは、このようなデフォルトを上書きしたり、様々な面をカスタマイズしたり調整したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to configure Quarkus to log to Sentry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusがSentryにログ送信するように設定する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Description</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry is a really easy way to be notified of errors happening in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentryは、Quarkusアプリケーションで発生したエラーを通知する本当に簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is a self-hosted and cloud-based error monitoring that helps software teams discover, triage, and prioritize errors in real-time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セルフホスト型か、クラウドベースのエラーモニタリングで、ソフトウェアチームがリアルタイムでエラーを発見し、トリアージし、優先順位をつけるのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>They offer a free starter price for cloud-based or you can self host it for free.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウドベースの場合は無料のスターター価格を提供してくれますし、セルフホストでも無料で利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry's Java SDK is open source, but recently sentry.io https://blog.sentry.io/2019/11/06/relicensing-sentry[changed the license] for their backend to the non-open source https://github.com/getsentry/sentry/blob/master/LICENSE[BSL license]. This might or might not be an issue for your project and product.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentry の Java SDK はオープンソースですが、最近 sentry.io はバックエンドの link:https://blog.sentry.io/2019/11/06/relicensing-sentry[ライセンス] を非オープンソースの link:https://github.com/getsentry/sentry/blob/master/LICENSE[BSL ライセンス]に link:https://blog.sentry.io/2019/11/06/relicensing-sentry[変更しました]。これはあなたのプロジェクトや製品にとって問題になるかもしれませんし、ならないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start with, you need to get a Sentry DSN either by https://sentry.io/signup/[creating a Sentry account] or https://docs.sentry.io/server/[installing your own self-hosted Sentry].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>手始めに、Sentry link:https://sentry.io/signup/[アカウントを作成する]か、自前のSentry link:https://docs.sentry.io/server/[をインストール] してSentry DSNを取得する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In order to configure Sentry logging, add the `logging-sentry` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentry ロギングを設定するには、プロジェクトのベースディレクトリで以下のコマンドを実行して、 `logging-sentry` エクステンションをプロジェクトに追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“In Application” Stack Frames</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>"in Application" スタックフレーム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sentry differentiates stack frames that are directly related to your application (“in application”) from stack frames that come from other packages such as the standard library, frameworks, or other dependencies. The difference is visible in the Sentry web interface where only the “in application” frames are displayed by default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Sentry は、アプリケーションに直接関連するスタックフレーム（"in application"）と、標準ライブラリやフレームワーク、その他の依存関係のあるパッケージから来るスタックフレームを区別します。この違いは、SentryのWebインタフェースでは、デフォルトでは "in application" フレームのみが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure which package prefixes your application uses with the `in-app-packages` option, which takes a comma separated list of packages:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`in-app-packages` オプションで、アプリケーションが使用するパッケージの接頭辞を設定できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you don’t want to use this feature but want to disable the warning, simply set it to `*`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用したくないが警告を無効にしたい場合は、 `*` をセットしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors and warnings occurring in any of the packages will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>いずれかのパッケージで発生したすべてのエラーや警告は、DSNと共にSentryに送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All errors occurring in the package `org.example` will be sent to Sentry with DSN `https://abcd@sentry.io/1234`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージ `org.example` で発生したすべてのエラーは、DSN と共にSentry に送信されます。 `https://abcd@sentry.io/1234`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This extension is configured through the standard `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションは、標準の `application.properties` ファイルを介して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI is provided as a native binary for Linux and macOS or as a jar-file for all operating systems.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI は、Linux と macOS 用のネイティブバイナリーとして、またはすべてのオペレーティングシステム用の jar ファイルとして提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native CLI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the binaries here:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バイナリーはこちらからダウンロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://coming-soon[macOS Binary] (coming soon)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://coming-soon[macOSバイナリ]（近日公開予定)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you create a specific Quarkus folder, eg '~/quarkus' and move the binary there.  Then in your shell profile (for Bash shell edit '~/.bash_profile'), export the 'QUARKUS_HOME' folder and add that to your 'PATH':</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>特定の Quarkus フォルダー、例えば '~/quarkus' を作成し、そこにバイナリを移動することをお勧めします。次に、シェルプロファイル (Bash シェルの場合は'~/.bash_profile' を編集) で、'QUARKUS_HOME' フォルダーをエクスポートして 'PATH' に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>export QUARKUS_HOME=/path/to/quarkus-cli
export PATH="$PATH:$QUARKUS_HOME"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>export QUARKUS_HOME=/path/to/quarkus-cli
export PATH="$PATH:$QUARKUS_HOME"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reload your terminal or do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>端末をリロードするか、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>source ~/.bash_profile
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>source ~/.bash_profile
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can run the Quarkus CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで Quarkus CLI を実行できるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus --help
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will display the help information with all the available commands.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、利用可能なすべてのコマンドのヘルプ情報が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus -i
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus -i
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will start the Quarkus CLI in interactive mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、対話型モードで Quarkus CLI が起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jar CLI</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jar CLI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the jar-file here:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jar ァイルはこちらからダウンロードしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://coming-soon[jar-file] (coming soon)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://coming-soon[jar-file](近日公開)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with the native CLI we recommend that you copy the binary to a specific folder, eg '~/quarkus'.  The jar file requires Java 8 or newer to run. To start the CLI:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ CLI と同様に、バイナリーを特定のフォルダー (例: '~/quarkus') にコピーすることをお勧めします。jar ファイルを実行するには Java 8 以降が必要です。CLI を起動するには以下を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ java -jar quarkus-cli.jar
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ java -jar quarkus-cli.jar
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The jar file CLI accepts all the same options and commands as the native binary.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jar ファイルの CLI は、ネイティブのバイナリーと同じオプションとコマンドをすべて受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Note: In the examples below switch out 'quarkus' with 'java -jar quarkus-cli.jar'.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注意: 以下の例では、'quarkus' を 'java -jar quarkus-cli.jar' で置き換えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a new project we use the create-project command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいプロジェクトを作成するには、create-project コマンドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project hello-world
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project hello-world
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will create a folder called 'hello-world' in your current working directory using default groupId, artifactId and version values (groupId='org.acme', artifactId='quarkus' and version='1.0.0-SNAPSHOT').</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、デフォルトの groupId、artifactId、および version の値 (groupId='org.acme', artifactId='quarkus', version='1.0.0-SNAPSHOT') を使用して、現在の作業ディレクトリーに 'hello-world' という名前のフォルダーが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To specify the groupId, artifactId and version values, use the '--groupid', '--artifactid' and '--version' options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>groupId、artifactId、および version の値を指定するには、'--groupid'、'--artifactid'、および '--version' オプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project --groupid=com.foo --artifactId=bar --version=1.0  hello-world
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the help option to display all the possible options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なすべてのオプションを表示するには、ヘルプオプションを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus create-project --help
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can obtain a list of the available extensions with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI では、利用可能なエクステンションのリストを取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus list-extensions
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus list-extensions
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To more easily get an overview and only display the extension names:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>より簡単に概要を取得し、エクステンション名のみを表示する場合は、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus list-extensions -n
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus list-extensions -n
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Adding extension(s)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus CLI can add Quarkus extensions to your project with the 'add-extension' command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI では、'add-extension' コマンドを使用して、Quarkus のエクステンションをプロジェクトに追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus add-extension --extension=hibernate-validator /path/to/my/project
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus add-extension --extension=hibernate-validator /path/to/my/project
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The argument path either needs to be the base folder for the project or a direct path to the build file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>引数のパスは、プロジェクトのベースフォルダーかビルドファイルへの直接パスである必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start dev mode from the Quarkus CLI do:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus CLI から dev モードを起動するには、以下を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ quarkus dev /path/to/my/project
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ quarkus dev /path/to/my/project
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As with 'add-extension' the argument path needs to be the base folder for the project or a direct path to the build file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>add-extension' と同様、引数のパスは、プロジェクトのベースフォルダーまたはビルドファイルへの直接パスである必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle support is considered preview.  You can use Gradle to create Quarkus projects as outlined in our guides. If you go beyond there will be cases where the Gradle tasks https://github.com/quarkusio/quarkus/issues/5101[does not behave as expected].  This is just a caution, and we recommend if you like Gradle you try it out and give us feedback.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Gradleのサポートはプレビューとされています。Gradleを使用してQuarkusプロジェクトを作成することができます。これを超えると、Gradleのタスクが link:https://github.com/quarkusio/quarkus/issues/5101[期待通りに動作しない場合があります]。これはあくまでも注意事項であり、Gradleが好きな方は試してみてフィードバックをいただくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to scaffold a Gradle project, is currently to use the Quarkus Maven plugin like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleプロジェクトを足場にする最も簡単な方法は、現在のところ、このようにQuarkus Mavenプラグインを使用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus project scaffolding automatically installs the Gradle wrapper (`./gradlew`) in your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトの足場は、プロジェクトにGradleラッパー( `./gradlew` )を自動的にインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you prefer to use a standalone Gradle installation, please use Gradle {gradle-version}.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スタンドアロンのGradleを使用したい場合は、Gradle {gradle-version}を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A pair of Dockerfiles for native and jvm mode are also generated in `src/main/docker`.  Instructions to build the image and run the container are written in those Dockerfiles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードと jvm モード用の Dockerfile も `src/main/docker`  に生成されています。イメージのビルドとコンテナの実行の指示は、これらの Dockerfile に書かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom test configuration profile in JVM mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JVMモードでのカスタムテスト構成プロファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus tests in JVM mode are run using the `test` configuration profile. If you are not familiar with Quarkus configuration profiles, everything you need to know is explained in the link:config#configuration-profiles[Configuration Profiles Documentation].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、JVMモードでのQuarkusテストは、 `test`  設定プロファイルを使用して実行されます。Quarkusの設定プロファイルについてよく知らない場合は、必要な情報はすべて link:config#configuration-profiles[設定プロファイルのドキュメント]で説明されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Gradle build configuration shown below.  This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、以下に示す Gradle ビルド設定でテスト用のカスタム設定プロファイルを使用することは可能です。これは例えば、デフォルトのテストデータベースではない特定のデータベースを使ってテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `foo` configuration profile will be used to run the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`foo`  設定プロファイルがテストの実行に使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is not possible to use a custom test configuration profile in native mode for now. Native tests are always run using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>今のところ、ネイティブモードでカスタムテスト設定プロファイルを使用することはできません。ネイティブテストは常に `prod`  プロファイルを使用して実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension name is the GAV name of the extension: e.g. `io.quarkus:quarkus-agroal`.  But you can pass a partial name and Quarkus will do its best to find the right extension.  For example, `agroal`, `Agroal` or `agro` will expand to `io.quarkus:quarkus-agroal`.  If no extension is found or if more than one extensions match, you will see a red check mark ❌ in the command result.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`io.quarkus:quarkus-agroal` エクステンション名は、エクステンションのGAV名です。しかし、部分的な名前を渡すことができ、Quarkusは適切なエクステンションを見つけるために最善を尽くします。例えば、 `agroal`  、 `Agroal`  、 `agro`  は `io.quarkus:quarkus-agroal`  に展開されます。エクステンションが見つからなかったり、複数のエクステンションが一致した場合は、コマンドの結果に赤いチェックマーク❌が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グロブパターンに一致するエクステンションをすべてインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then update the application sources, resources and configurations.  The changes are automatically reflected in your running application.  This is great to do development spanning UI and database as you see changes reflected immediately.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、アプリケーションのソース、リソース、および設定を更新することができます。変更は実行中のアプリケーションに自動的に反映されます。変更がすぐに反映されるので、UIやデータベースにまたがった開発をするのに最適です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkusDev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkusDev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can change the working directory the development environment runs on:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発環境が動作する作業ディレクトリを変更することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the `quarkusDev` task uses `compileJava` compiler options. These can be overridden by setting the `compilerArgs` property in the task.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quarkusDev`  タスクは `compileJava`  コンパイラ・オプションを使用します。これらは、タスクの `compilerArgs`  プロパティを設定することで上書きすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Remote Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to use development mode remotely, so that you can run Quarkus in a container environment (such as OpenShift)  and have changes made to your local files become immediately visible.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードをリモートで使用することができるので、コンテナ環境（OpenShiftなど）でQuarkusを実行して、ローカルファイルに加えられた変更をすぐに確認できるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This allows you to develop in the same environment you will actually run your app in, and with access to the same services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、実際にアプリを実行するのと同じ環境で、同じサービスにアクセスしながら開発することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production applications in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must have the `quarkus-undertow-websockets` extension installed:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行するためには、 `quarkus-undertow-websockets` エクステンションがインストールされている必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must also have the following config properties set:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下の設定プロパティを設定しておく必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.live-reload.password`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.live-reload.password`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.live-reload.url`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.live-reload.url`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These can be set via `application.properties`, or any other way (e.g. system properties, environment vars etc). The password must be set on both the local and remote processes, while the url only needs to be set on the local host.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは `application.properties`  やその他の方法で設定できます (例: システムのプロパティ、環境変数など)。パスワードはローカルプロセスとリモートプロセスの両方で設定しなければなりませんが、 url はローカルホストでのみ設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Start Quarkus in dev mode on the remote host. Now you need to connect your local agent to the remote host:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモートホストでQuarkusをdevモードで起動します。ここで、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでブラウザを更新するたびに、ローカルで行った変更がリモートアプリにすぐに表示されるようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In development mode, Quarkus starts by default with debug mode enabled, listening to port `5005` without suspending the JVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードでは、Quarkusはデフォルトでデバッグモードを有効にして起動し、JVMをサスペンドせずにポート `5005`  をリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`false` - the JVM will start with debug mode disabled</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`false`  - JVMはデバッグモードを無効にして起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`true` - The JVM is started in debug mode and will be listening on port `5005`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`true`  - JVM はデバッグモードで起動され、 `5005`ポートをリッスンします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`client` - the JVM will start in client mode and attempt to connect to `localhost:5005`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`client`  - JVM はクライアントモードで起動し、 `localhost:5005`に接続を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run a Quarkus application in debug mode with a suspended JVM using `./gradlew quarkusDev -Dsuspend -Ddebug` which is a shorthand for `./gradlew quarkusDev -Dsuspend=true -Ddebug=true`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew quarkusDev -Dsuspend -Ddebug`  を使用して、サスペンドされたJVMでQuarkusアプリケーションをデバッグモードで実行することもできます。 `./gradlew quarkusDev -Dsuspend=true -Ddebug=true` の短縮版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have a &lt;&lt;project-creation, project generated&gt;&gt;, you can import it in your favorite IDE.  The only requirement is the ability to import a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:#project-creation[プロジェクトを生成]したら、お気に入りのIDEでインポートすることができます。唯一の条件は、Gradleプロジェクトをインポートできることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In Eclipse, click on: `File -&gt; Import`.  In the wizard, select: `Gradle -&gt; Existing Gradle Project`.  On the next screen, select the root location of the project.  The next screen list the found modules; select the generated project and click on `Finish`. Done!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Eclipse で、 `File → Import`  をクリックします。ウィザードで、 `Gradle → Existing Gradle Project`  を選択します。次の画面で、プロジェクトのルートの場所を選択します。次の画面では、見つかったモジュールのリストが表示されるので、生成されたプロジェクトを選択して `Finish`  をクリックします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./gradlew quarkusDev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末で `./gradlew quarkusDev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Select `Import project from external model` and `Gradle`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Import project from external model`  を選択して `Gradle`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末または埋め込み端末で、 `./gradlew quarkusDev`  を実行してください。お楽しみください！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Apache NetBeans**
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In NetBeans:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>NetBeansの場合：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./gradlew quarkusDev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./gradlew quarkusDev`  を実行します。お楽しみください！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the project directory in VS Code. If you have installed the Java Extension Pack (grouping a set of Java extensions), the project is loaded as a Gradle project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>VS Codeでプロジェクトディレクトリを開きます。Java Extension Pack（Javaエクステンションのセットをグループ化したもの）をインストールしている場合、プロジェクトはGradleプロジェクトとして読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(必ずGraalVMのJava 11バージョンを使用してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./gradlew build -Dquarkus.package.type=native`.  A native executable will be present in `build/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `./gradlew build -Dquarkus.package.type=native` を実行し、ネイティブ実行ファイルを作成します。ネイティブ実行ファイルは `build/` に存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `buildNative` task has been deprecated in favor of `build -Dquarkus.package.type=native`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`buildNative` タスクは非推奨となり、 `build -Dquarkus.package.type=native` に代わりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native related properties can either be added in `application.properties` file, as command line arguments or in the `quarkusBuild` task.  Configuring the `quarkusBuild` task can be done as following:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ関連のプロパティは、 `application.properties`  ファイルにコマンドライン引数として追加するか、 `quarkusBuild`  タスクに追加することができます。 `quarkusBuild`  タスクの設定は以下のように行います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.containerBuild` property to `true`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.containerBuild`  プロパティを `true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Set `quarkus.native.buildImage` property to `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.buildImage`  プロパティを `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a Docker container.  Note that in this case the build itself runs in a Docker container too, so you don't need to have GraalVM installed locally.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成される実行ファイルは64bitのLinux実行ファイルになるので、OSによっては実行できなくなる可能性があります。しかし、Dockerコンテナにコピーするので問題ありません。この場合、ビルド自体もDockerコンテナ内で動作するので、ローカルにGraalVMをインストールする必要はないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the native executable will be generated using the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` Docker image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、 `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}`  Dockerイメージを使用してネイティブ実行ファイルが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The list of the available Docker images can be found on https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io].  Be aware that a given Quarkus version might not be compatible with all the images available.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>利用可能なDockerイメージのリストは、 link:https://quay.io/repository/quarkus/ubi-quarkus-native-image?tab=tags[quay.io]にあります。特定のQuarkusのバージョンは、利用可能なすべてのイメージと互換性がない場合があることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running native tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブテストの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the native tests using:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のようにネイティブテストを実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This task depends on `quarkusBuild`, so it will generate the native image before running the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このタスクは `quarkusBuild`  に依存しているので、テストを実行する前にネイティブイメージを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Gradle plugin supports the generation of Uber-Jars by specifying an `--uber-jar` argument as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Gradleプラグインは、以下のように `--uber-jar`  引数を指定してUber-Jarsの生成をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `--ignored-entry` argument:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Uber-jar を作成する際に、 `--ignored-entry`  引数を使用して生成された jar から除外したいエントリを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The entries are relative to the root of the generated Uber-Jar. You can specify multiple entries by adding extra `--ignored-entry` arguments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エントリは、生成された Uber-Jar のルートからの相対的なものです。追加の `--ignored-entry`  引数を追加することで、複数のエントリを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include a `META-INF/beans.xml` file, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトのモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されていない限り、`META-INF/beans.xml`  ファイルをインクルードすることです。モジュールが、メインアプリケーションモジュールで、すでにquarkus-maven-pluginで設定されている場合は、自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>More information on this topic can be found on the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このトピックの詳細については、CDIガイドの link:cdi-reference#bean_discovery[Bean Discovery]セクションを参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with `./gradlew build`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./gradlew build` によるビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting from 1.1.0.Final, `./gradlew build` will no longer build the native image. Add `-Dquarkus.package.type=native` build argument explicitly as explained above if needed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>1.1.1.0.Final から、 `./gradlew build`  はネイティブイメージをビルドしなくなりました。必要であれば、上記で説明したように `-Dquarkus.package.type=native`  のビルド引数を明示的に追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can use https://tika.apache.org/[Apache Tika] to parse the documents.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus アプリケーションが link:https://tika.apache.org/[Apache Tika] を使用してドキュメントを解析する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://tika.apache.org/[Apache Tika] is a content analysis toolkit which is used to parse the documents in PDF, Open Document, Excel and many other well known binary and text formats using a simple uniform API. Both the document text and properties (metadata) are available once the document has been parsed.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://tika.apache.org/[Apache Tika] はコンテンツ分析ツールキットで、シンプルな統合 API を使した PDF、Open Document、Excel やその他多くのよく知られたバイナリやテキスト形式の文書解析に使われます。文書のテキストとプロパティー (メタデータ) の両方が、文書が解析されると利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are planning to run the application as a native executable and parse documents that may have been created with charsets different than the standard ones supported in Java such as `UTF-8` then you should configure Quarkus Maven Plugin to get the native image generator include all the charsets available to the JVM:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをネイティブ実行ファイルとして実行し、`UTF-8` のような Java でサポートされている標準の文字セットと異なる文字セットで作成された可能性のあるドキュメントを解析する場合は、Quarkus Maven Plugin を設定して、ネイティブイメージジェネレーターがJVM で利用可能なすべての文字セットを含むようにする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;plugin&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;native-image&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;native-image&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;addAllCharsets&gt;true&lt;/addAllCharsets&gt;
                ...
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;plugin&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;native-image&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;native-image&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;addAllCharsets&gt;true&lt;/addAllCharsets&gt;
                ...
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `tika-quickstart` {quickstarts-tree-url}/tika-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided solution contains a few additional elements such as tests and testing infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>提供されるソリューションには、テストやテストのインフラストラクチャなど、いくつかの追加要素が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme.example \
    -DprojectArtifactId=tika-quickstart \
    -DclassName="org.acme.tika.TikaParserResource" \
    -Dpath="/parse" \
    -Dextensions="tika,resteasy"
cd tika-quickstart
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `tika` and `resteasy` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、`tika` と `resteasy` のエクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured you can add the `tika` and `resteasy` extensions to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリーで、次のコマンドを実行することで、 `tika` と `resteasy` のエクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="tika,resteasy"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-tika&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Examine the generated JAX-RS resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたJAX-RS リソースを調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open the `src/main/java/org/acme/tika/TikaParserResource.java` file and see the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/java/org/acme/tika/TikaParserResource.java` ファイルを開くと、以下のような内容が表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.tika;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>package org.acme.tika;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/parse")
public class TikaParserResource {
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Next update `TikaParserResource` to accept and parse PDF and OpenDocument format documents:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に `TikaParserResource` を更新して、PDF および OpenDocument 形式の文書を受け入れて解析するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import java.io.InputStream;
import java.time.Duration;
import java.time.Instant;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>import io.quarkus.tika.TikaParser;
import org.jboss.logging.Logger;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>@Path("/parse")
public class TikaParserResource {
    private static final Logger log = Logger.getLogger(TikaParserResource.class);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @Inject
    TikaParser parser;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>    @POST
    @Path("/text")
    @Consumes({"application/pdf", "application/vnd.oasis.opendocument.text"})
    @Produces(MediaType.TEXT_PLAIN)
    public String extractText(InputStream stream) {
        Instant start = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        String text = parser.getText(stream);
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        Instant finish = Instant.now();
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        log.info(Duration.between(start, finish).toMillis() + " mls have passed");
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        return text;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>        return text;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As you can see the JAX-RS resource method was renamed to `extractText`, `@GET` annotation was replaced with `POST` and `@Path(/text)` annotation was added, and `@Consumes` annotation shows that PDF and OpenDocument media type formats can now be accepted. An injected `TikaParser` is used to parse the documents and report the extracted text. It also measures how long does it take to parse a given document.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ご覧のように、JAX-RS のリソースメソッドの名前が `extractText` に変更され、`@GET` アノテーションが `POST` に置き換わり、`@Path(/text)` アノテーションが追加されました。また、`@Consumes` アノテーションでは、PDF と OpenDocument のメディアタイプのフォーマットが受け入れられるようになったことが示されています。注入された `TikaParser` は、文書を解析し、抽出されたテキストを報告するために使用されます。また、指定の文書の解析に要する時間を測定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application. Use:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、アプリケーションを実行する準備が整いました。以下を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>and you should see output similar to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のような出力が得られるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus:dev Output</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus:dev 出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ ./mvnw clean compile quarkus:dev
[INFO] Scanning for projects...
[INFO]
INFO] --------------------&lt; org.acme.example:apache-tika &gt;--------------------
[INFO] Building apache-tika 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
Listening for transport dt_socket at address: 5005
2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running without servlet container.
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-undertow to run Resteasy within a servlet container
2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 549ms
2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 1.361s. Listening on: http://0.0.0.0:8080
2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, tika]
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ ./mvnw clean compile quarkus:dev
[INFO] Scanning for projects...
[INFO]
INFO] --------------------&lt; org.acme.example:apache-tika &gt;--------------------
[INFO] Building apache-tika 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
Listening for transport dt_socket at address: 5005
2019-10-15 14:23:26,442 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) Resteasy running without servlet container.
2019-10-15 14:23:26,960 INFO  [io.qua.resteasy] (build-15) - Add quarkus-undertow to run Resteasy within a servlet container
2019-10-15 14:23:26,991 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 549ms
2019-10-15 14:23:27,637 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 1.361s. Listening on: http://0.0.0.0:8080
2019-10-15 14:23:27,638 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2019-10-15 14:23:27,639 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, tika]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now that the REST endpoint is running, we can get it to parse PDF and OpenDocument documents using a command line tool like curl:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>REST エンドポイントが実行されているので、curl のようなコマンドラインツールを使用して PDF や OpenDocument ドキュメントを解析することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ curl -X POST -H "Content-type: application/pdf" --data-binary @target/classes/quarkus.pdf http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>$ curl -X POST -H "Content-type: Content-type: application/vnd.oasis.opendocument.text" --data-binary @target/classes/quarkus.odt http://localhost:8080/parse/text
Hello Quarkus
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can build a native executable with the usual command `./mvnw package -Pnative`.  Running it is as simple as executing `./target/tika-quickstart-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常のコマンド `./mvnw package -Pnative` でネイティブの実行ファイルをビルドできます。`./target/tika-quickstart-1.0-SNAPSHOT-runner` を実行するだけで簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This document describes the Quarkus built-in authentication mechanisms for HTTP based FORM, BASIC and Mutual TLS authentication as well as the proactive authentication.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、HTTPベースのFORM認証、BASIC認証、相互TLS認証、およびプロアクティブ認証のためのQuarkusの組み込み認証メカニズムについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベーシック認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable basic authentication set `quarkus.http.auth.basic=true`. You must also have at least one extension installed that provides a username/password based `IdentityProvider`, such as link:security-jdbc[Elytron JDBC].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ベーシック認証を有効にするには、 `quarkus.http.auth.basic=true` を設定します。また、ユーザー名/パスワードベースの `IdentityProvider` を提供するエクステンションを少なくとも 1 つインストールしておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:security#identity-providers[Security Identity Providers] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:security#identity-providers[セキュリティ ID プロバイダ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please also see link:security-testing#configuring-user-information[Configuring User Information in application.properties] section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:security-testing#configuring-user-information[application.propertiesでユーザー情報の設定]セクションも参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Form Based Authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フォームベース認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides form based authentication that works in a similar manner to traditional Servlet form based auth. Unlike traditional form authentication, the authenticated user is not stored in an HTTP session, as Quarkus does not provide clustered HTTP session support. Instead the authentication information is stored in an encrypted cookie, which can be read by all members of the cluster (provided they all share the same encryption key).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、従来のサーブレットのフォームベースの認証と同様の方法で動作するフォームベースの認証を提供します。従来のフォーム認証とは異なり、Quarkusはクラスター化されたHTTPセッションをサポートしていないため、認証されたユーザーはHTTPセッションに保存されません。代わりに、認証情報は暗号化されたCookieに保存され、クラスターのすべてのメンバーが読み取ることができます（すべてのメンバーが同じ暗号化キーを共有している場合）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The encryption key can be set using the `quarkus.http.auth.session.encryption-key` property, and it must be at least 16 characters long. This key is hashed using SHA-256 and the resulting digest is used as a key for AES-256 encryption of the cookie value. This cookie contains an expiry time as part of the encrypted value, so all nodes in the cluster must have their clocks synchronized. At one minute intervals a new cookie will be generated with an updated expiry time if the session is in use.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>暗号化キーは `quarkus.http.auth.session.encryption-key` プロパティを使って設定でき、少なくとも 16 文字の長さでなければなりません。このキーは SHA-256 を使ってハッシュ化され、その結果のダイジェストがクッキー値の AES-256 暗号化のキーとして使用されます。このクッキーは暗号化された値の一部として有効期限を含んでいますので、クラスター内のすべての ノードはクロックを同期させなければなりません。1 分間隔で、セッションが使用中であれば、更新された有効期限時間を持つ新しいクッキーが生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to configure form based auth:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のプロパティを使用して、フォームベース認証を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides mTLS authentication so that you can authenticate users based on their X.509 certificates.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはmTLS認証を提供しているので、X.509証明書に基づいてユーザーを認証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this authentication method, you should first enable SSL for your application. For more details, check the link:http-reference#ssl[Supporting secure connections with SSL] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この認証方法を利用するには、まずアプリケーションでSSLを有効にする必要があります。詳細については、 link:http-reference#ssl[SSLによるセキュアな接続のサポート]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once your application is accepting secure connections, the next step is to configure a `quarkus.http.ssl.certificate.trust-store-file` holding all the certificates that your application should trust as well as how your application should ask for certificates when a client (e.g.: browser or another service) tries to access one of its protected resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが安全な接続を受け入れたら、次のステップは、アプリケーションが信頼すべきすべての証明書を保持する `quarkus.http.ssl.certificate.trust-store-file` を設定し、クライアント(例: ブラウザや他のサービス)が保護されたリソースにアクセスしようとしたときに、アプリケーションがどのように証明書を要求するかを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a key store where the server's private key is located.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバの秘密鍵が置かれている鍵ストアを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configures a trust store from where the trusted certificates are going to be loaded from.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>信頼された証明書がロードされるトラストストアを構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines that the server should *always* ask certificates from clients. You can relax this behavior by using `REQUEST` so that the server should still accept requests without a certificate. Useful when you are also supporting authentication methods other than mTLS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サーバが *常に*クライアントからの証明書を要求することを定義します。 `REQUEST` を使用することで、この動作を緩和することができます。mTLS 以外の認証方法もサポートしている場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defines a policy where only authenticated users should have access to resources from your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>認証されたユーザーのみがアプリケーションからリソースにアクセスできるようにするポリシーを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once the incoming request matches a valid certificate in the truststore, your application should be able to obtain the subject by just injecting a `SecurityIdentity` as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>受信したリクエストがトラストストアの有効な証明書と一致したら、アプリケーションは以下のように `SecurityIdentity` を注入するだけでサブジェクトを取得できるようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the subject</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>subjectの取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You should also be able to get the certificate as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、以下のように証明書を取得できるようにしておきましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Obtaining the certificate</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>証明書の取得</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The information from the client certificate can be used to enhance Quarkus `SecurityIdentity`. For example, one can add new roles after checking a client certificate subject name, etc.  Please see the link:security-customization#security-identity-customization[SecurityIdentity Customization] section for more information about customizing Quarkus `SecurityIdentity`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クライアント証明書からの情報は、Quarkus `SecurityIdentity` を強化するために使用することができます 。たとえば、クライアント証明書のサブジェクト名などを確認した後に、新しいロールを追加することができます。Quarkus `SecurityIdentity` のカスタマイズの詳細については、 link:security-customization#security-identity-customization[SecurityIdentity]のカスタマイズのセクションを参照してください 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus does what we call proactive authentication. This means that if an incoming request has a credential then that request will always be authenticated (even if the target page does not require authentication).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはプロアクティブ認証と呼ばれる認証を行います。これは、受信したリクエストにクレデンシャルがある場合、そのリクエストは常に認証されます（ターゲットページが認証を必要としない場合でも）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This means that requests with an invalid credential will always be rejected, even for public pages. You can change this behavior and only authenticate when required by setting `quarkus.http.auth.proactive=false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、公開ページであっても、無効なクレデンシャルを持つリクエストは常に拒否されることを意味します。この動作を変更して、 `quarkus.http.auth.proactive=false` を設定することで必要な場合のみ認証を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Traditional blocking code uses link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`]
 variables to store contextual objects in order to avoid
passing them as parameters everywhere. Many Quarkus extensions require those contextual objects to operate
properly: link:rest-json[RESTEasy], link:cdi-reference[ArC] and link:transaction[Transaction]
for example.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>従来のブロッキングコードでは  link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ThreadLocal.html[`ThreadLocal`] 変数を使用してコンテキストオブジェクトを格納します。多くのQuarkusエクステンションは、適切に動作するためにこれらのコンテキストオブジェクトを必要とします。例えば、 link:rest-json[RESTEasy]、 link:cdi-reference[ArC]、 link:transaction[Transaction]などです。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you write reactive/async code, you have to cut your work into a pipeline of code blocks that get executed "later", and in practice after the method you defined them in have returned. As such, `try/finally` blocks as well as `ThreadLocal` variables stop working, because your reactive code gets executed in another thread, after the caller ran its `finally` block.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ/非同期コードを書く場合、「後で」実行されるコードブロックのパイプラインに作業を切り 込まなければならず、実際には、定義したメソッドがreturnされた後に実行されます。そのため、 `try/finally` ブロックや `ThreadLocal` 変数は動作しなくなります。なぜならば、呼び出し元が `finally` ブロックを実行した後に、 リアクティブコードは別のスレッドで実行されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] was made to make those Quarkus extensions work properly in reactive/async settings. It works by capturing those contextual values that used to be in thread-locals, and restoring them when your code is called.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://github.com/eclipse/microprofile-context-propagation[MicroProfile Context Propagation] は、リアクティブ/非同期設定でQuarkusエクステンションが正しく動作するようにするために作られました。これは、スレッドローカルにあったコンテキスト値を取得し、コードが呼び出されたときにそれらを復元することで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:http://smallrye.io/smallrye-mutiny[Mutiny] (the `quarkus-mutiny` extension), you just need to add the the `quarkus-smallrye-context-propagation` extension to enable context propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:http://smallrye.io/smallrye-mutiny[Mutiny] ( `quarkus-mutiny` のエクステンション) を使用している場合は、コンテキストの伝播を有効にするために `quarkus-smallrye-context-propagation` のエクステンションを追加するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other words, add the following dependencies to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>つまり、以下の依存関係を `pom.xml` に追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With this, you will get context propagation for ArC, RESTEasy and transactions, if you are using them.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、ArC、RESTEasy、トランザクションを使用している場合は、コンテキストの伝播を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section uses Mutiny reactive types, if you're not familiar with them, read the link:getting-started-reactive#mutiny[Getting Started with Reactive guide] first.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このセクションでは、Mutinyのリアクティブタイプ を使用しています。慣れていない場合は、 link:getting-started-reactive#mutiny[Getting Started with Reactive guide] を先にお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's write a REST endpoint that reads the next 3 items from a link:kafka[Kafka topic], stores them in a database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client, you can do it like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:kafka[Kafkaトピック] から次の3つのアイテムを読み込んで、 link:hibernate-orm-panache[Hibernate ORM with Panache] を使ってデータベースに保存してからクライアントに返すRESTエンドポイントを書いてみましょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice that thanks to Mutiny support for context propagation, this works out of the box.  The 3 items are persisted using the same transaction and this transaction is committed when the stream completes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキストの伝播のための Mutiny サポートのおかげで、これは、そのまま直ぐに動作することに注目してください。3つのアイテムは同じトランザクションを使用して保持され、このトランザクションはストリームが完了するとコミットされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usage example for `CompletionStage`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CompletionStage` の使用例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`] you need manual context propagation. You can do that by injecting a `ThreadContext` or `ManagedExecutor` that will propagate every context. For example, here we use the link:vertx[Vert.x Web Client] to get the list of Star Wars people, then store them in the database using link:hibernate-orm-panache[Hibernate ORM with Panache] (all in the same transaction) before returning them to the client as JSON using link:rest-json[Jackson or JSON-B]:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletionStage.html[`CompletionStage`]を使用する場合、手動でコンテキストを伝播させる必要があります。 `ThreadContext` や `ManagedExecutor` を注入することで、すべてのコンテキストを伝播させることができます。例えば、ここでは link:vertx[Vert.x Web Client] を使用してスターウォーズの登場人物のリストを取得し、 link:hibernate-orm-panache[Hibernate ORM with Panache を]使用して(全て同じトランザクション内で) データベースに保存します。その後、 link:rest-json[Jackson または JSON-B] を使用して JSON としてクライアントに返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using `ThreadContext` or `ManagedExecutor` you can wrap most useful functional types and `CompletionStage` in order to get context propagated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`ThreadContext` または `ManagedExecutor` を使用することで、ほとんどの有用な関数型と `CompletionStage` をラップしてコンテキストを伝播させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The injected `ManagedExecutor` uses the Quarkus thread pool.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>注入された `ManagedExecutor` は、Quarkus のスレッドプールを使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need to include the following modules to get RxJava2 support:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RxJava2のサポートを得るためには、以下のモジュールを含める必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In terms of CDI, `@RequestScoped`, `@ApplicationScoped` and `@Singleton` beans get propagated and are available in other threads.  `@Dependent` beans as well as any custom scoped beans cannot be automatically propagated via CDI Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDI の観点からは、 `@RequestScoped`, `@ApplicationScoped`, `@Singleton` Beanは伝播され、他のスレッドで利用可能です。 `@Dependent` ビーンやカスタムスコープされたビーンは、CDI コンテキスト伝播を介して自動的に伝播されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@ApplicationScoped` and `@Singleton` beans are always active scopes and as such are easy to deal with - context propagation tasks can work with those beans so long as the CDI container is running.  However, `@RequestScoped` beans are a different story. They are only active for a short period of time which can be bound either to HTTP request or some other request/task when manually activated/deactivated.  In this case user must be aware that once the original thread gets to an end of a request, it will terminate the context, calling `@PreDestroy` on those beans and then clearing them from the context.  Subsequent attempts to access those beans from other threads can result in unexpected behaviour.  It is therefore recommended to make sure all tasks using request scoped beans via context propagation are performed in such a manner that they don't outlive the original request duration.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@ApplicationScoped` と `@Singleton` のBeanは常にアクティブなスコープであり、そのため対処が簡単です - コンテキスト伝播タスクは、CDI コンテナが動作している限り、これらのBeanで動作します。しかし、 `@RequestScoped` Beanは話が違います。手動で有効化/無効化すると、HTTP リクエストや他のリクエスト/タスクにバインドされます。この場合、元のスレッドがリクエストの終了に到達すると、コンテキストを終了し、それらのBeanで `@PreDestroy` を呼び出し、コンテキストからクリアされることに注意しなければなりません。その後、他のスレッドからこれらのBeanにアクセスしようとすると、予期せぬ動作をすることがあります。したがって、コンテキストの伝播を介してリクエストスコープされたBeanを使用するすべてのタスクは、元のリクエストの持続時間を超えないような方法で実行されることを確認することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Due to the above described behavior, it is recommended to avoid using `@PreDestroy` on `@RequestScoped` beans when working with Context Propagation in CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記で説明した動作のため、CDI で Context Propagation を使用する際には `@PreDestroy` を `@RequestScoped` Beanで使用しないことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Infinispan Embedded</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an elastically scalable in-memory data store that you can embed directly in your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanは、アプリケーションに直接埋め込むことができる拡張性の高いインメモリデータストアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check out the link:https://infinispan.org/documentation/[Infinispan documentation] to find out more about the Infinispan project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanプロジェクトの詳細については、Infinispanの link:https://infinispan.org/documentation/[ドキュメント] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you set up your Quarkus project, run the following command from the base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトをセットアップしたら、ベースディレクトリから以下のコマンドを実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command adds the following dependency to your `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、以下の依存関係を `pom.xml` に追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Feature Support</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>機能サポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension offers core caching functionality that includes clustered caches, off-heap memory, data persistence, and transactions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションは、クラスタ化キャッシュ、オフヒープメモリ、データ永続化、トランザクションを含むコアキャッシング機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension does not currently support indexing capabilities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションは、現在のところインデックス機能をサポートしていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure Infinispan caches for transactional operations with a specific `TransactionManagerLookup`, as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan キャッシュを特定の `TransactionManagerLookup` でトランザクション処理用に設定するには、以下のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information, see the Quarkus link:transaction[Transaction Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、Quarkus link:transaction[トランザクションガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native Limitations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブの制限</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running Infinispan in native mode, some limitations apply:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードでInfinispanを実行する場合、いくつかの制限が適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX management is not supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JMX管理には対応していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM does not allow native VM interfaces.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMは、ネイティブVMインターフェースを許可していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`UDP`/`Multicast` is not supported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`UDP` / `Multicast` はサポートされていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You must use `TCP` transport and a non-UDP based membership protocol with JGroups.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JGroupsでは、 `TCP` トランスポートと非UDPベースのメンバーシッププロトコルを使用する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Injection (CDI)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクション(CDI)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Infinispan embedded extension provides injection capabilities so you do not have to configure and start caches manually.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispan Embeddedエクステンションはインジェクション機能を提供するので、手動でキャッシュを設定して起動する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Additional injection functionality will be available in future versions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のインジェクション機能は、将来のバージョンで利用可能になる予定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EmbeddedCacheManager`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the main entry point to configure and obtain caches.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キャッシュを設定したり取得したりするためのメインのエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JMX elements are disabled during native runtime so you can use the same configuration file in JVM and native modes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JMX要素はネイティブ実行時には無効化されるので、JVMとネイティブモードで同じ設定ファイルを使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native compilation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executable fails on macOS with `error: unknown type name 'uint8_t'`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS でのネイティブ実行ファイルが `error: unknown type name 'uint8_t'` で失敗します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is to</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>解決策は、以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`sudo mv /usr/local/include /usr/local/include.old`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reinstall XCode for good measure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>念のためにXCodeを再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>generally reinstall your brew dependencies with native compilation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的には、ネイティブコンパイルでの brew の依存関係を再インストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable should work now.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行ファイルが動作するようになるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started-architecture.png</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>getting-started-architecture.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Running the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once started, you can request the provided endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>起動したら、提供されたエンドポイントにリクエストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically add newline with `curl -w "\n"`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`curl -w "\n"` で自動的に改行を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are using `curl -w "\n"` in this example to avoid your terminal printing a '%' or put both result and next command prompt on the same line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例では、 `curl -w "\n"` を使用して、結果と次のコマンドプロンプトが同じ行に表示されるのを防止しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using injection</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ArC comes as a dependency of `quarkus-resteasy` so you already have it handy.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ArCは `quarkus-resteasy` の依存関係として提供されているので、すでに追加済です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OpenShift</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw clean package -Dquarkus.container-image.build=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.container-image.builder=docker
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add a key/value pair as an environment variable in the generated resources:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースに環境変数としてキーとバリューのペアを追加する場合：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command above will add `MY_ENV_VAR=foobar` as an environment variable.  Please note that the key `my-env-var` will be converted to uppercase and dashes will be replaced by underscores resulting in `MY_ENV_VAR`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上のコマンドは `MY_ENV_VAR=foobar` を環境変数として追加します。キー `my-env-var` は大文字に変換され、ダッシュはアンダースコアに置き換えられて `MY_ENV_VAR` となることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Environment variables from Secret</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シークレットからの環境変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides extensions for building (and pushing) container images. Currently it supports:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は、コンテナーイメージを構築 （およびプッシュ） するためのエクステンションを提供しています。現在は以下をサポートしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#jib,Jib&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#docker,Docker&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;#s2i,S2I&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナイメージのエクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Jib</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Jib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-jib` is powered by https://github.com/GoogleContainerTools/jib[Jib] for performing container image builds.  The major benefit of using Jib with Quarkus is that all the dependencies (everything found under `target/lib`) are cached in a different layer than the actual application making rebuilds really fast and small (when it comes to pushing).  Another important benefit of using this extension is that it provides the ability to create a container image without having to have any dedicated client side tooling (like Docker) or running daemon processes (like the Docker daemon)  when all that is needed is the ability to push to a container image registry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-jib` は、コンテナイメージのビルドを実行するために link:https://github.com/GoogleContainerTools/jib[Jib] を使用しています。Jib を Quarkus で使用する主な利点は、すべての依存関係 （`target/lib` の下にあるすべてのもの） が実際のアプリケーションとは別のレイヤーにキャッシュされるため、リビルドが非常に高速かつ小規模に （プッシュする場合） 行えることです。このエクステンションを使用するもう 1 つの重要な利点は、コンテナイメージレジストリーにプッシュする機能さえあれば、専用のクライアントサイドツール （Docker など） やデーモンプロセス （Docker デーモンなど） を実行しなくてもコンテナイーメージを作成できることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-jib"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In situations where all that is needed to build a container image and no push to a registry is necessary (essentially by having set `quarkus.container-image.build=true` and left `quarkus.container-image.push` unset - it defaults to `false`), then this extension creates a container image and registers it with the Docker daemon. This means that although Docker isn't used to build the image, it is nevertheless necessary. Also note that using this mode, the built container image *will* show up when executing `docker images`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要なことがコンテナーイメージを構築するだけで、レジストリーへのプッシュが不要な場合 （基本的には `quarkus.container-image.build=true` を設定して `quarkus.container-image.push` のままにしておくことで、デフォルトは `false` になります）、このエクステンションはコンテナーイメージを作成し、Docker デーモンに登録します。これは、Docker がイメージのビルドには使われなくても必要であることを意味します。また、このモードを使用すると、`docker images` を実行するとコンテナーイメージが表示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Including extra files</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加ファイルの追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are cases when additional files (other than ones produced by the Quarkus build) need to be added to a container image.  To support these cases, Quarkus copies any file under `src/main/jib` into the built container image (which is essentially the same idea that the Jib Maven and Gradle plugins support).  For example, the presence of `src/main/jib/foo/bar` would result in `/foo/bar` being added into the container filesystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージに追加のファイル（Quarkus のビルドで作成されたもの以外）を追加する必要がある場合があります。このような場合に対応するため、Quarkus は、`src/main/jib` 以下のファイルをすべてビルドされたコンテナーイメージにコピーします （これは、Jib Maven や Gradle プラグインがサポートしているのと基本的に同じ考え方です）。例えば、`src/main/jib/foo/bar` が存在すると、`/foo/bar` がコンテナファイルシステムに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-docker` is using the Docker binary and the generated Dockerfiles under `src/main/docker` in order to perform Docker builds.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-docker` は、Docker ビルドを実行するために `src/main/docker` 下で Docker バイナリと生成された Dockerfiles を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To use this feature, add the following extension to your project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この機能を使用するには、以下のエクステンションをプロジェクトに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-docker"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension `quarkus-container-image-s2i` is using S2I binary builds in order to perform container builds inside the OpenShift cluster.  The idea behind the binary build is that you just upload the artifact and its dependencies to the cluster and during the build they will be merged to a builder image (defaults to `fabric8/s2i-java`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンション `quarkus-container-image-s2i` は、OpenShift クラスター内でコンテナビルドを実行するために S2I バイナリービルドを使用しています。バイナリービルドの考え方は、アーティファクトとその依存関係をクラスタにアップロードするだけで、ビルド中にそれらがビルダーイメージにマージされます （デフォルトは `fabric8/s2i-java`）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The benefit of this approach, is that it can be combined with OpenShift's `DeploymentConfig` that makes it easy to roll out changes to the cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアプローチの利点は、クラスターへの変更を簡単にロールアウトできる OpenShift の `DeploymentConfig` と組み合わせることができることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw quarkus:add-extension -Dextensions="container-image-s2i"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I builds require creating a `BuildConfig` and two `ImageStream` resources, one for the builder image and one for the output image.  The creation of such objects is being taken care of by the Quarkus Kubernetes extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S2I のビルドでは、`BuildConfig` と 2 つの `ImageStream` リソースを作成する必要があります。このようなオブジェクトの作成は、Quarkus Kubernetes エクステンションによって行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build a container image for your project, `quarkus.container-image.build=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト用のコンテナーイメージを作成するには、Quarkus がサポートしている方法のいずれかで、 `quarkus.container-image.build=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pushing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To push a container image for your project, `quarkus.container-image.push=true` needs to be set using any of the ways that Quarkus supports.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトにコンテナーイメージをプッシュするには、Quarkus がサポートしている方法のいずれかで、`quarkus.container-image.push=true` を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>./mvnw clean package -Dquarkus.container-image.push=true
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no registry is set (using `quarkus.container-image.registry`) then `docker.io` will be used as the default.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レジストリーが設定されていない場合 (`quarkus.container-image.registry` を使用) は、 `docker.io` がデフォルトとして使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Selecting among multiple extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のエクステンションから選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It does not make sense to use multiple extension as part of the same build. When multiple container image extensions are present, an error will be raised to inform the user. The user can either remove the uneeded extensions or select one using `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のエクステンションを同じビルドの一部として使用するのは意味がありません。複数のコンテナ－イメージエクステンションが存在する場合は、エラーが発生してユーザーに通知されます。ユーザーは不要なエクステンション削除するか、`application.properties` を使って選択することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, if both `container-image-docker` and `container-image-s2i` are present and the user needs to use `container-image-docker`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、`container-image-docker` と `container-image-s2i` の両方が存在し、ユーザーが `container-image-docker` を使用する場合:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customizing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following properties can be used to customize the container image build process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のプロパティーを使用して、コンテナーイメージのビルドプロセスをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container Image Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナーイメージオプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Various CI environments provide a ready to use container-image registry which can be combined with the container-image Quarkus extensions in order to effortlessly create and push a Quarkus application to said registry.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さまざまな CI 環境では、Quarkus アプリケーションを作成してレジストリーをプッシュするために、コンテナーイメージ Quarkus エクステンションと組み合わせることで、すぐに使えるコンテナーイメージレジストリ－を利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example, https://gitlab.com/[GitLab] provides such a registry and in the provided CI environment, makes available the `CI_REGISTRY_IMAGE` environment variable (see GitLab's https://docs.gitlab.com/ee/ci/variables/[documentation]) for more information), which can be used in Quarkus like so:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、 link:https://gitlab.com/[GitLab] はこのようなレジストリーを提供しており、提供されている CI 環境では、環境変数 `CI_REGISTRY_IMAGE` （詳しくは GitLab の link:https://docs.gitlab.com/ee/ci/variables/[ドキュメント] を参照） を利用できるようになっています。なお、Quarkus ではこのように利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.container-image.image=${CI_REGISTRY_IMAGE}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See link:config.adoc#combine-property-env-var[this] for more information on how to combine properties with environment variables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>環境変数とプロパティーを組み合わせる方法については link:config.adoc#combine-property-env-var[こちら] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-jib` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-jib` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-docker` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-docker` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>S2I  Options</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>S2I オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the generic container image options, the `container-image-s2i` also provides the following options:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>一般的なコンテナーイメージのオプションに加えて、`container-image-s2i` では以下のオプションも用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - JGit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - JGit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus includes the `jgit` extension which enables the use of https://www.eclipse.org/jgit/[Eclipse JGit] in native mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusには、ネイティブモードでの link:https://www.eclipse.org/jgit/[Eclipse JGit]の使用を可能にする `jgit` エクステンションが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once you have your Quarkus project configured you can add the `jgit` extension to your project by running the following command in your project base directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusプロジェクトを設定したら、プロジェクトのベースディレクトリで次のコマンドを実行して、 `jgit` エクステンションをプロジェクトに追加できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The https://wiki.eclipse.org/JGit/User_Guide#API[JGit] dependency is resolved transitively when the extension is added to your project.  Here is an example using it in a JAX-RS endpoint:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://wiki.eclipse.org/JGit/User_Guide#API[JGit]依存関係は、エクステンションがプロジェクトに追加されたときに推移的に解決されます。ここでは、JAX-RS エンドポイントでの使用例を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running in native mode, make sure that the link:native-and-ssl#the-truststore-path[SSL access is configured correctly].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブモードで実行する場合は、 link:native-and-ssl#the-truststore-path[SSLアクセスが正しく設定されていること]を確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Infinispan is an in memory data grid that allows running in a server outside of application processes. This extension provides functionality to allow the client that can connect to said server when running in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Infinispanは、アプリケーションプロセス以外のサーバーでの実行を可能にするメモリ内データグリッドです。このエクステンションは、Quarkusで実行しているときに、クライアントがサーバーに接続できるようにする機能を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the Apache Kafka Streams API to implement stream processing applications based on Apache Kafka.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがApache Kafka Streams APIを利用して、Apache Kafkaベースのストリーム処理アプリケーションを実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Compiling the application to a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションをネイティブ実行ファイルにコンパイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging the native executable in a container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのコンテナへのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debugging native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのデバッグ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、 link:getting-started[入門ガイド] で開発されたアプリケーションを入力としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブな実行可能ファイルをビルドするには、GraalVM のディストリビューションを使用する必要があります。ディストリビューションは3つあります。Oracle GraalVM Community Edition (CE)、Oracle GraalVM Enterprise Edition (EE)、そして Mandrel です。Oracle ディストリビューションと Mandrel ディストリビューションの違いは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは、Oracle GraalVM CEのダウンストリームディストリビューションです。Mandrelの主な目的は、Quarkusをサポートするために特別に設計されたネイティブ実行可能ファイルを構築する方法を提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrel のリリースは、アップストリームのOracle GraalVM CEコードベースから派生したコードベースから構築されており、わずかな変更しか行われていませんが、Quarkusネイティブアプリには必要ない重要な除外事項がいくつかあります。これらのリリースは、Oracle GraalVM CEと同じ機能をサポートしており、機能に大きな変更はありません。特筆すべきは、多言語プログラミングのサポートが含まれていないことです。これらの除外の理由は、大多数のQuarkusユーザーにより良いレベルのサポートを提供するためです。また、これらの除外は、Oracle GraalVM CE/EEと比較して、Mandrelの配布サイズが大幅に縮小されていることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは、標準のOpenJDKプロジェクトを使用して、Oracle GraalVM CEとは少し違った形で構築されています。これは、Oracleが独自のGraalVMダウンロードを構築するために使用するOpenJDKのバージョンに追加したいくつかの小さなエクステンションから利益を得られないことを意味します。アップストリームのOpenJDKはそれらを管理しておらず、保証することができないため、このような機能強化は省略されています。これは、規格適合性とセキュリティに関しては特に重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is currently only recommended for building native executables that target Linux containerized environments.  This means that Mandrel users should use containers to build their native executables.  If you are building native executables for macOS or Windows target platforms, you should consider using Oracle GraalVM instead, because Mandrel does not currently target these platforms.  Building native executables directly on bare metal Linux is possible, with details available in the https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelは現在のところ、Linuxのコンテナ化された環境をターゲットとしたネイティブ実行ファイルの構築にのみ推奨されています。つまり、Mandrelユーザーはコンテナを使用してネイティブ実行ファイルを構築する必要があります。もしmacOSやWindowsをターゲットにしたプラットフォーム用のネイティブ実行ファイルをビルドする場合、Mandrelは現在これらのプラットフォームをターゲットにしていないため、代わりにOracle GraalVMを使用することを検討すべきです。ベアメタルのLinux上で直接ネイティブ実行ファイルをビルドすることも可能ですが、詳細は https://github.com/graalvm/mandrel/blob/master/README-Mandrel.md[rel README]と https://github.com/graalvm/mandrel/releases[Mandrelのリリース]に記載されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The prerequisites vary slightly depending on whether you are using Oracle GraalVM CE/EE or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前提条件は、Oracle GraalVM CE/EEを使用しているか、Mandrelを使用しているかによって若干異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the Java 11 version of GraalVM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java 11 バージョンのGraalVMをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While Oracle GraalVM is available for both Java 8 and Java 11 (Mandrel only supports Java 11), Quarkus only works with the Java 11 version.  If you use the Oracle distribution, make sure to install the Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Oracle GraalVM はJava 8とJava 11の両方に対して存在しますが (Mandrel はJava 11のみをサポート)、Quarkus Java 11でのみ動作します。Oracleのディストリビューションを使用する場合は、Java 11をインストールするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To complete this guide using Mandrel, you need:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelを使用してこのガイドを完成させるには、以下が必要です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11 installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JDK 11 がインストールされ、 `JAVA_HOME`  が適切に設定されていること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A working container runtime (Docker, podman)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動作するコンテナランタイム(Docker, podman)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the link:getting-started[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:getting-started[入門ガイド]で開発したアプリケーションのコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Skip to &lt;&lt;#container-runtime,this section&gt;&gt; to continue with the guide for Mandrel, and follow the Mandrel-specific instructions in that section.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この &lt;&lt;#container-runtime, セクション&gt;&gt;をスキップして、 Mandrel のガイドを続行し、そのセクションの Mandrel 固有の指示に従ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A xref:configuring-c-development[working C development environment]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>xref:configuring-c-development[動作するC言語の開発環境]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM version {graalvm-version} (be sure to install the Java 11 support) installed and xref:configuring-graalvm[configured appropriately]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVM のバージョン {graalvm-version} (必ずJava 11 のサポートをインストールしてください)がインストールされ、 #configuring-graalvm[適切に設定されていること]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What does having a working C developer environment mean?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>動作するC言語の開発環境があるとはどういう意味でしょうか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Linuxでは、GCC、glibc、zlibヘッダが必要です。一般的なディストリビューションでは次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>XCode provides the required dependencies on macOS:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS では、XCode が必要な依存関係を提供します:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Windowsの場合は、 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools] をインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMをインストールできない場合は、マルチステージのDockerビルドを使用して、GraalVMを含むDockerコンテナ内でMavenを実行することができます。このガイドの最後にこれを行う方法の説明があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required. Using the community edition is enough.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Version {graalvm-version} が必要です。コミュニティエディションで大丈夫です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install GraalVM (pick the java 11 version) if you haven't already. You have a few options for this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まだの場合は、GraalVM（のJava 11バージョン）をインストールしてください。いくつかポイントがあります:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォーム固有の方法を用いてください： https://github.com/graalvm/homebrew-tap[homebrew], https://sdkman.io/jdks#Oracle[sdkman], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate Community Edition archive from &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.  Make sure to download and install at Java 11 version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>適切なコミュニティエディションのアーカイブを &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt; からダウンロードし、他のJDK同様に解凍して下さい。Java 11バージョンをダウンロードしてインストールするようにして下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ランタイム環境を構成します。 `GRAALVM_HOME` 環境変数をGraalVMインストールディレクトリに設定します。例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS, point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOSでは、変数を `Home`  サブディレクトリに指定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will have to go through the Control Panel to set your environment variables.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Windowsでは、コントロールパネルから環境変数を設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing via scoop will do this for you.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>scoop でインストールすれば自動的に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Install the `native-image` tool using `gu install`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gu install`  を使用して `native-image`  ツールをインストールします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの以前のリリースでは、デフォルトで `native-image`  ツールが含まれていました。現在はそのようになっておらず、GraalVM自体をインストールした後の第二ステップとしてインストールする必要があります。注意: #graal-and-catalina[macOS CatalinaでGraalVMを使用する]際に、未解決の問題が発生しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(オプション) 環境変数 `JAVA_HOME`  を GraalVM のインストールディレクトリに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>(オプション) GraalVM `bin`  ディレクトリをパスに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Issues using GraalVM with macOS Catalina</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>macOS CatalinaでGraalVMを使用している場合の問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この https://github.com/oracle/graal/issues/1724[GraalVMの問題]で報告されているように、GraalVMバイナリは（まだ）macOS Catalinaに対して認証されていません。これは、`gu` 使用時に次のエラーが表示される可能性があることを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>“gu” cannot be opened because the developer cannot be verified
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>回避策として、次のコマンドを使用して、GraalVMインストールディレクトリ上の `com.apple.quarantine` 拡張属性を再帰的に削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次のセクションの手順に従って、アプリケーションを段階的にパッケージ化することをお勧めします。しかしながら、完成したサンプルに直接進むこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started` ディレクトリに存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのネイティブ実行ファイルには、アプリケーション・コード、必要なライブラリ、Java API、および VM の縮小版が含まれます。VM ベースが小さくなることで、アプリケーションの起動時間が改善され、ディスクフットプリントが最小限に抑えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:native-executable-process.png[Creating a native executable]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:native-executable-process.png[ネイティブ実行ファイルの生成]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前回のチュートリアルでアプリケーションを生成した場合は、 `pom.xml` に以下の _プロファイル_ があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`&lt;quarkus.native.additional-build-args&gt;` プロパティを使用して、 `native-image` コマンドにカスタムオプションを指定できます。複数のオプションはカンマで区切ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つの可能性は、 `application.properties` に `quarkus.native.additional-build-args` 設定プロパティを含めることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the &lt;&lt;configuration-reference&gt;&gt; section below.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージビルド処理の設定方法については、以下の &lt;&lt;設定リファレンス&gt;&gt; の項で詳しく説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as this allows native image tests to also be run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロファイルを使用しているのは、すぐにわかると思いますが、ネイティブの実行ファイルをパッケージ化するのに _数_ 分かかるからです。コマンドラインのプロパティとして -Dquarkus.package.type=native を渡すだけでもいいのですが、プロファイルを使う方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative`  を使用してネイティブ実行ファイルを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At `x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Visual Studio の Microsoft Native Tools はパッケージングを行う前に、初期化する必要があります。これは、Visual Studio ビルドツールと一緒にインストールされた `x64 Native Tools Command Prompt`  を起動することで行うことができます。 `x64 Native Tools Command Prompt` で、プロジェクト・フォルダに移動して `mvnw package -Pnative` を実行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Another solution is to write a script to do this for you:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>もう一つのソリューションは、これを行うためのスクリプトを書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常のファイルに加えて、このビルドでは `target/getting-started-1.0-SNAPSHOT-runner` を生成します。これを実行するには、次のようにします: `./target/getting-started-1.0-SNAPSHOT-runner` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing the native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブな実行ファイルを生成することはいくつかの問題を引き起こす可能性があるので、ネイティブファイルで実行されているアプリケーションに対していくつかのテストを実行するのも良いアイデアです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `pom.xml` file, the `native` profile contains:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml`  ファイルには、 `native`  プロファイルが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、failsaf-maven-plugin が integration-test を実行するように指示し、生成されたネイティブ実行ファイルの場所を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, open the `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`. It contains:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>次に、 `src/test/java/org/acme/quickstart/NativeGreetingResourceIT.java`  を開きます。次の内容が含まれています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use another test runner that starts the application from the native file before the tests.  The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの前にネイティブ ファイルからアプリケーションを起動する別のテスト ランナーを使用します。実行ファイルは、 _Failsafe Maven プラグイン_ で構成された `native.image.path`  システム プロパティを使用して取得されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We extend our previous tests, but you can also implement your tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のテストを extend していますが、自分でテストを実装することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To see the `NativeGreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`NativeGreetingResourceIT`  がネイティブ実行ファイルに対して実行されているのを見るには、 `./mvnw verify -Pnative` を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.native-image-wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはネイティブテストを開始し、自動的に失敗するまでに60秒待機します。この時間は、 `quarkus.test.native-image-wait-time`  システムプロパティを使用して変更できます。たとえば、待機時間を300秒に増やすには、 `./mvnw verify -Pnative -Dquarkus.test.native-image-wait-time=300` となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, native tests runs using the `prod` profile.  This can be overridden using the `quarkus.test.native-image-profile` property.  For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.  Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.  However, don't forget that when the native executable is built the `prod` profile is enabled.  So, the profile you enable this way must be compatible with the produced executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、ネイティブテストは `prod`  プロファイルを使用して実行されます。これは `quarkus.test.native-image-profile`  プロパティを使用して上書きすることができます。たとえば、 `application.properties`  ファイルに `quarkus.test.native-image-profile=test`  を追加します。あるいは、次のようにしてテストを実行することもできます: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` .ただし、ネイティブの実行ファイルがビルドされたときに `prod`  プロファイルが有効になっていることを忘れないでください。したがって、この方法で有効にしたプロファイルは、生成された実行ファイルと互換性がなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Excluding tests when running as a native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルとして実行している場合のテストの除外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running tests this way, the only things that actually run natively are you application endpoints, which you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法でテストを実行する場合、実際にネイティブで実行されるのはアプリケーションのエンドポイントのみで、HTTP 呼び出しでしかテストできません。テストコードは実際にはネイティブには実行されないので、HTTP エンドポイントを呼び出さないコードをテストしている場合は、ネイティブテストの一部として実行するのは良い考えではないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you share your test class between JVM and native executions like we advise above, you can mark certain tests with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のようにJVMとネイティブ実行でテストクラスを共有している場合、特定のテストをJVM上でのみ実行するために、 `@DisabledOnNativeImage`  アノテーションを付けておくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing an existing native executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>既存のネイティブ実行ファイルのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also possible to re-run the tests against a native executable that has already been built. To do this run `./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using failsafe.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにビルドされているネイティブ実行ファイルに対してテストを再実行することも可能です。これを行うには `./mvnw test-compile failsafe:integration-test`  を実行してください。これにより、既存のネイティブイメージが検出され、フェイルセーフを使用してそれに対してテストが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>何らかの理由でプロセスがネイティブイメージを見つけられない場合や、ターゲットディレクトリにないネイティブイメージをテストしたい場合は、 `-Dnative.image.path=`  システムプロパティで実行ファイルを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>先に進む前に、コンテナランタイム（Docker、podman）の動作環境が整っていることを確認しておきましょう。WindowsでDockerを使用している場合は、Docker Desktopのファイル共有設定でプロジェクトのドライブを共有し、Docker Desktopを再起動する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice to install as little software as possible).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>多くの場合、Quarkusアプリケーション用のネイティブLinux実行ファイルを作成する必要があります（例えば、コンテナ化された環境で実行するためなど）、このタスクを達成するために適切なGraalVMバージョンをインストールする手間を省きたいと考えています（例えば、CI環境では、できるだけ少ないソフトウェアをインストールするのが一般的です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このため、Quarkusでは、Dockerやpodmanなどのコンテナランタイムを利用して、ネイティブのLinux実行ファイルを作成する非常に便利な方法を提供しています。このタスクを達成する最も簡単な方法は、次を実行することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default Quarkus automatically detects the container runtime.  If you want to explicitely select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkusはコンテナランタイムを自動的に検出します。コンテナランタイムを明示的に選択したい場合は、次のようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These are normal Quarkus config properties, so if you always want to build in a container it is recommended you add these to your `application.properties` in order to avoid specifying them every time.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは通常のQuarkusの設定プロパティなので、常にコンテナでビルドしたい場合は、毎回指定しなくて済むように、 `application.properties`  に追加することをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building with Mandrel requires a custom builder image parameter to be passed additionally:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mandrelを使ってビルドするには、カスタムビルダーのイメージパラメータを追加で渡す必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>上記のコマンドはフローティングタグを指していることに注意してください。ビルダーイメージを最新かつ安全に保つために、フローティングタグを使用することを強く推奨します。どうしても必要な場合は、特定のタグをハードコーディングしても構いませんが（利用可能なタグについては https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[こちら]を参照してください）、その方法ではセキュリティアップデートが受けられず、サポートされていないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the container-image extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナイメージのエクステンションの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションからコンテナイメージを作成する最も簡単な方法は、コンテナイメージ エクステンションの1つを利用することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのエクステンションのいずれかが存在する場合、ネイティブ実行ファイル用のコンテナイメージを作成することは、基本的には単一のコマンドを実行することになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.native.container-build=true`  では GraalVM がインストールされていなくても Linux の実行ファイルを作成することができます（ローカルに GraalVM がインストールされていない場合や、ローカルのオペレーティングシステムが Linux ではない場合にのみ必要です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.container-image.build=true`  最終的なアプリケーションアーティファクト（この場合はネイティブの実行ファイル）を使用してコンテナイメージを作成するようにQuarkusに指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>See the link:container-image[Container Image guide] for more details.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:container-image[コンテナイメージガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Manually</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>手動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Mavenプラグインで生成されたJARを使用して、コンテナ内でアプリケーションを実行することができます。ただし、このセクションでは、生成されたネイティブ実行ファイルを使用してコンテナイメージを作成することに焦点を当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>image:containerization-process.png[Containerization Process]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>image:containerization-process.png[alt="Containerization Process"]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in &lt;&lt;#container-runtime,this section&gt;&gt;):</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ローカルのGraalVMインストール環境を使用する場合、ネイティブの実行ファイルは、ローカルのオペレーティングシステム（Linux、macOS、Windowsなど）をターゲットにしています。しかし、コンテナはオペレーティングシステムによって生成されたものと同じ _実行_ 形式を使用しない場合があるため、コンテナランタイムを活用して実行形式を生成するようにMavenビルドに指示します（この &lt;&lt;#container-runtime, セクション&gt;&gt; で説明されているように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成される実行ファイルは64ビットのLinux実行ファイルになりますので、お使いのOSによっては実行できなくなる可能性があります。しかし、コンテナにコピーするので問題ありません。プロジェクト生成では、 `src/main/docker`  ディレクトリに `Dockerfile.native`  を用意し、以下のような内容にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ubi?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Ubi?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The provided `Dockerfiles` use https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI] (Universal Base Image) as parent image.  This base image has been tailored to work perfectly in containers.  The `Dockerfiles` use the https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_minimal_ version] of the base image to reduce the size of the produced image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>提供されている `Dockerfiles`  は親イメージとして https://access.redhat.com/containers/?tab=overview#/registry.access.redhat.com/ubi8/ubi[UBI](Universal Base Image) を使用しています。このベースイメージはコンテナ内で完全に動作するように調整されています。 `Dockerfiles`  では、生成されるイメージのサイズを小さくするためにベースイメージの https://access.redhat.com/containers/#/registry.access.redhat.com/ubi8/ubi-minimal[_最小_バージョン]を使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can read more about UBI on:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>UBIについての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, if you didn't delete the generated native executable, you can build the docker image with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>あとは、生成されたネイティブ実行ファイルを削除していなければ、dockerイメージを使ってビルドします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>And finally, run it with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>そして最後に、以下を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are interested in tiny Docker images, check the {quarkus-images-url}/master/distroless[distroless] version.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>小さなDockerイメージに興味がある方は、{quarkus-images-url}/master/distroless[distroless] 版をチェックしてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using a multi-stage Docker build</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチステージDockerビルドの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven, but implicitly required that the proper GraalVM version be installed on the building machine (be it your local machine or your CI/CD infrastructure).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>前のセクションでは、Mavenを使用してネイティブ実行ファイルをビルドする方法を示しましたが、適切なGraalVMバージョンがビルドマシン（ローカルマシンまたはCI/CDインフラストラクチャ）にインストールされていることが暗黙のうちに要求されていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In cases where the GraalVM requirement cannot be met, you can use Docker to perform the Maven or Gradle build by using a multi-stage Docker build. A multi-stage Docker build is like two Dockerfile files combined in one, the first is used to build the artifact used by the second.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMの要件を満たすことができない場合は、Dockerを使ってマルチステージDockerビルドを利用してMavenやGradleのビルドを行うことができます。マルチステージDockerビルドとは、2つのDockerfileファイルを1つにまとめたようなもので、1つ目は2つ目で使用するアーティファクトをビルドするために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide we will use the first stage to generate the native executable and the second stage to create our runtime image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、第一段階でネイティブ実行ファイルを生成し、第二段階でランタイムイメージを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Maven:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MavenでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このファイルは、Getting started quickstartには含まれていないので、 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sample Dockerfile for building with Gradle:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GradleでビルドするためのサンプルDockerfileです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトでGradleを使用している場合は、このサンプルDockerfileを使用することができます。 `src/main/docker/Dockerfile.multistage`  に保存してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory and as we plan to build inside a container we need to be able to copy the `src` directory. So edit your `.dockerignore` and remove or comment its content.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Dockerビルドを起動する前に、デフォルトの `.dockerignore`  ファイルを更新する必要があります。 `target`  ディレクトリ以外は全てフィルタリングされ、コンテナ内でビルドする予定なので、 `src`  ディレクトリをコピーできるようにする必要があります。そのため、 `.dockerignore`  を編集して、その内容を削除するかコメントしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルにSSLサポートが必要な場合は、Dockerイメージに必要なライブラリを簡単に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please see link:native-and-ssl#working-with-containers[our Using SSL With Native Executables guide] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳しくは native-and-ssl#working-with-containers[ネイティブ実行可能ファイルでのSSL利用ガイド] をご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Starting with Oracle GraalVM 20.2 or Mandrel 20.1, debug symbols for native executables can be generated for Linux environments (Windows support is still under development).  These symbols can be used to debug native executables with tools such as `gdb`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Oracle GraalVM 20.2またはMandrel 20.1から、Linux環境用にネイティブ実行ファイルのデバッグシンボルを生成できるようになりました（Windowsのサポートはまだ開発中です）。これらのシンボルは、 `gdb`  のようなツールを使用してネイティブ実行ファイルをデバッグするために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグシンボルを生成するには、ネイティブ実行ファイルの生成時に `-Dquarkus.native.debug.enabled=true`  フラグを追加してください。ネイティブ実行ファイルのデバッグシンボルは、ネイティブ実行ファイルの隣にある `.debug`  ファイルにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  On common Linux distributions and macOS you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`.debug`  ファイルの生成は `objcopy`  に依存します。一般的な Linux ディストリビューションや macOS では、 `binutils`  パッケージをインストールする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When `objcopy` is not available debug symbols are embedded in the executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`objcopy`  が利用できない場合、デバッグシンボルが実行ファイルに埋め込まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デバッグシンボルとは別に、 `-Dquarkus.native.debug.enabled=true`  フラグを設定すると、ネイティブ実行ファイル生成時に解決された JDK ランタイムクラス、GraalVM クラス、アプリケーションクラスのソースファイルのキャッシュが生成されます。このソースキャッシュは、シンボルと一致するソースコード間のリンクを確立するために、ネイティブデバッグツールにとって有用です。ネイティブ実行ファイルをデバッグする際に、必要なソースだけをデバッガ/IDEが利用できるようにする便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのソースコードを含むサードパーティのjar依存関係のソースは、デフォルトではソースキャッシュに追加されません。これらを含めるには、まず `mvn dependency:sources`  を起動してください。このステップは、これらの依存関係のソースを引き出し、ソースキャッシュに含めるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソースキャッシュは `target/sources`  フォルダにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If running `gdb` from a different directory than `target`, then the sources can be loaded by running:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`gdb`  を `target`  とは異なるディレクトリから実行している場合、ソースは以下を</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg> `gdb`  プロンプトで実行することで読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Or start `gdb` with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>または、 `gdb`  を以下のように起動してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Native Executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行ファイルの生成方法に影響を与える設定オプションがたくさんあります。これらは他の設定プロパティと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties are shown below:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティは以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アプリケーション用のネイティブ(バイナリ)実行ファイルの作成について説明しました。これにより、迅速な起動時間と少ないメモリ消費を示すアプリケーションを提供します。しかし、それだけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the link:deploying-to-kubernetes[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:deploying-to-kubernetes[KubernetesとOpenShiftへのデプロイ]で探検を続けることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://flywaydb.org/[Flyway] is a popular database migration tool that is commonly used in JVM environments.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://flywaydb.org/[Flyway] は、JVM環境でよく使われているデータベースマイグレーションツールです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides first class support for using Flyway as will be explained in this guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでは、このガイドで説明するように、Flywayを使用するためのファーストクラスのサポートを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To start using Flyway with your project, you just need to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトで Flyway を使い始めるには、以下のことを行う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>add your migrations to the `{migrations-path}` folder as you usually do with Flyway</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway で通常行うように、マイグレーションを `{migrations-path}` フォルダに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>activate the `migrate-at-start` option to migrate the schema automatically or inject the `Flyway` object and run your migration as you normally do</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`migrate-at-start` オプションを有効にしてスキーマを自動的に移行するか、 `Flyway` オブジェクトを注入して通常のように移行を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In your `pom.xml`, add the following dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`pom.xml` で、以下の依存関係を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Flyway extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway エクステンション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>your JDBC driver extension (`quarkus-jdbc-postgresql`, `quarkus-jdbc-h2`, `quarkus-jdbc-mariadb`, ...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>お使いの JDBC ドライバのエクステンション ( `quarkus-jdbc-postgresql` , `quarkus-jdbc-h2` , `quarkus-jdbc-mariadb` , ...)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway support relies on the Quarkus datasource config.  It can be customized for the default datasource as well as for every &lt;&lt;multiple-datasources,named datasource&gt;&gt;.  First, you need to add the datasource config to the `{config-file}` file in order to allow Flyway to manage the schema.  Also, you can customize the Flyway behaviour by using the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway のサポートは、Quarkus のデータソース設定に依存しています。この設定は、デフォルトのデータソースだけでなく、 すべての link:#multiple-datasources[名前の付いたデータソース] に対してカスタマイズすることができます。まず、Flyway によるスキーマ管理を可能にするために、データソース設定を `{config-file}` ファイルに追加する必要があります。また、以下のプロパティを使用して、Flyway の動作をカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following is an example for the `{config-file}` file:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{config-file}` ファイルの例は以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add a SQL migration to the default folder following the Flyway naming conventions: `{migrations-path}/V1.0.0__Quarkus.sql`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`{migrations-path}/V1.0.0__Quarkus.sql` のように Flyway の命名規則に従って、デフォルトフォルダーに SQL マイグレーションを追加します。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you can start your application and Quarkus will run the Flyway's migrate method according to your config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを起動でき、Quarkus は設定に従って Flyway のマイグレーションメソッドを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the Flyway object if you want to use it directly</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway オブジェクトを直接使用する場合はインジェクトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のデータソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Flyway can be configured for multiple datasources.  The Flyway properties are prefixed exactly the same way as the named datasources, for example:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Flyway は、複数のデータソースに対して設定可能です。Flyway のプロパティーには、例えば、名前の付いたデータソースと全く同じように接頭辞が付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Notice there's an extra bit in the key.  The syntax is as follows: `quarkus.flyway.[optional name.][datasource property]`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>キーに余分なビットがあることに注意してください。構文は次の通りです。`quarkus.flyway.[optional name.][datasource property]` </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Without configuration, Flyway is set up for every datasource using the default settings.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定なしの場合、Flyway はデフォルト設定を使用して各データソースに対して設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In case you are interested in using the `Flyway` object directly, you can inject it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`Flyway` オブジェクトを直接使いたい場合は、以下のように注入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you enabled the `quarkus.flyway.migrate-at-start` property, by the time you use the Flyway instance, Quarkus will already have run the migrate operation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus.flyway.migrate-at-start` プロパティーを有効にした場合、Flyway インスタンスを使用する時点で、Quarkus はすでにマイグレーション操作を実行しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources using the Quarkus `FlywayDataSource` qualifier</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus `FlywayDataSource` 修飾子を使用して、指定されたデータソースに Flyway を注入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject Flyway for named datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>名前の付いたデータソースへの Flyway の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Maven, you can scaffold a new project with:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Mavenを使えば、新しいプロジェクトをスキャフォールド（足場の作成）出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the command will target the latest version of `quarkus-universe-bom` (unless specific coordinates have been specified). If you run offline however, it will look for the latest locally available and if `quarkus-universe-bom` (satisfying the default version range which is currently up to 2.0) is not available locally, it will fallback to the bundled platform based on `quarkus-bom` (the version will match the version of the plugin).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、このコマンドは `quarkus-universe-bom`  の最新バージョンをターゲットにします (特定の座標が指定されていない限り)。しかし、オフラインで実行した場合、ローカルで利用可能な最新のものを探し、 `quarkus-universe-bom`  (現在 2.0 までのデフォルトのバージョン範囲を満たしている) がローカルで利用できない場合は、 `quarkus-bom`  をベースにしたバンドルされたプラットフォームにフォールバックします (バージョンはプラグインのバージョンと一致します)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The project is generated in a directory named after the passed artifactId.  If the directory already exists, the generation fails.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトは、渡された artifactId にちなんだ名前のディレクトリに生成されます。ディレクトリが既に存在する場合は、生成に失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can install all extensions which match a globbing pattern :</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>グロブパターンに一致するすべてのエクステンションをインストールすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect.  This works too for resource files like the configuration property file.  The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus:dev`  は、バックグラウンドでのコンパイルによるホットデプロイを可能にします。つまり、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に有効になります。これは、設定プロパティファイルのようなリソースファイルにも適用されます。ブラウザをリフレッシュする行為は、ワークスペースのスキャンをトリガし、変更が検出された場合、Javaファイルがコンパイルされ、アプリケーションが再配置されると、あなたの要求は再配置されたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページでお知らせします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Do not use this in production. This should only be used in a development environment. You should not run production application in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>本番環境では使用しないでください。開発環境でのみ使用してください。本番環境のアプリケーションを開発モードで実行してはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To do this you must build a mutable application, using the `mutable-jar` format. Set the following properties in `application.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを行うには、 `mutable-jar`  形式を使用して、変異可能なアプリケーションを構築する必要があります。 `application.xml`  で以下のプロパティを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This tells Quarkus to use the mutable-jar format. Mutable applications also include the deployment time parts of Quarkus, so they take up a bit more disk space. If run normally they start just as fast and use the same memory as an immutable application, however they can also be started in dev mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、QuarkusにMutable-jar形式を使用するように指示します。ミュータブルアプリケーションには、Quarkusのデプロイメント時間の部分も含まれているため、より多くのディスクスペースを占有します。普通に実行した場合は、イミュータブルアプリケーションと同じ速度で起動し、同じメモリを使用しますが、devモードで起動することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The password that is used to secure communication between the remote side and the local side.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート側とローカル側の通信を安全に保つためのパスワードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The URL that your app is going to be running in dev mode at. This is only needed on the local side, so you may want to leave it out of the properties file and specify it as a system property on the command line.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリがdevモードで実行されるURL。これはローカル側でのみ必要なので、プロパティ ファイルから除外して、コマンド ラインでシステム プロパティとして指定するとよいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before you start Quarkus on the remote host set the environment variable `QUARKUS_LAUNCH_DEVMODE=true`. If you are on bare metal you can just set this via the `export QUARKUS_LAUNCH_DEVMODE=true` command, if you are running using docker start the image with `-e QUARKUS_LAUNCH_DEVMODE=true`. When the application starts you should now see the following line in the logs: `Profile dev activated. Live Coding activated`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモートホストでQuarkusを起動する前に、環境変数 `QUARKUS_LAUNCH_DEVMODE=true`  を設定します。ベアメタルを使用している場合は、 `export QUARKUS_LAUNCH_DEVMODE=true`  コマンドで設定します。dockerを使用している場合は、 `-e QUARKUS_LAUNCH_DEVMODE=true`  でイメージを起動します。アプリケーションが起動すると、ログに次のような行が表示されるはずです: `Profile dev activated. Live Coding activated` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The remote side does not need to include Maven or any other development tools. The normal `fast-jar` Dockerfile that is generated with a new Quarkus application is all you need. If you are using bare metal launch the Quarkus runner jar, do not attempt to run normal devmode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート側にはMavenなどの開発ツールを入れる必要はありません。新しいQuarkusアプリケーションで生成される通常の `fast-jar`  Dockerfileがあれば大丈夫です。ベアメタルでQuarkus runner jarを起動している場合は、通常のdevmodeを実行しようとしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you need to connect your local agent to the remote host, using the `remote-dev` command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここで、 `remote-dev`  コマンドを使用して、ローカルエージェントをリモートホストに接続する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now every time you refresh the browser you should see any changes you have made locally immediately visible in the remote app. This is done via a HTTP based long polling transport, that will synchronize your local workspace and the remote application via HTTP calls.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、ブラウザを更新するたびに、ローカルで行った変更がリモート アプリに即座に表示されるようになりました。これは、HTTPベースのロングポーリングトランスポートを介して行われ、HTTPコールを介してローカルのワークスペースとリモートアプリケーションを同期させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you do not want to use the HTTP feature then you can simply run the `remote-dev` command without specifying the URL.  In this mode the command will continuously rebuild the local application, so you can use an external tool such as odo or rsync to sync to the remote application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP 機能を使用したくない場合は、URL を指定せずに `remote-dev`  コマンドを実行するだけです。このモードでは、コマンドはローカルアプリケーションを継続的に再構築するので、 odo や rsync のような外部ツールを使ってリモートアプリケーションに同期することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended you use SSL when using remote dev mode, however even if you are using an unencrypted connection your password is never sent directly over the wire. For the initial connection request the password is hashed with the initial state data, and subsequent requests hash it with a random session id generated by the server and any body contents for POST requests, and the path for DELETE requests, as well as an incrementing counter to prevent replay attacks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リモート開発モードを使用する際には SSL を使用することを推奨しますが、たとえ暗号化されていない接続を使用していても、パスワードが直接有線で送信されることはありません。最初の接続リクエストでは、パスワードは初期状態のデータでハッシュ化され、それ以降のリクエストでは、サーバによって生成されたランダムなセッションIDと、POSTリクエストのためのボディコンテンツ、DELETEリクエストのためのパス、そしてリプレイ攻撃を防ぐためのインクリメントカウンタでハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Development Mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Maven plugin picks up compiler flags to pass to `javac` from `maven-compiler-plugin`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Maven プラグインは `maven-compiler-plugin`  から `javac`  に渡すコンパイラフラグをピックアップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to customize the compiler flags used in development mode, add a `configuration` section to the `plugin` block and set the `compilerArgs` property just as you would when configuring `maven-compiler-plugin`.  You can also set `source`, `target`, and `jvmArgs`.  For example, to pass `--enable-preview` to both the JVM and `javac`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モードで使用するコンパイラ・フラグをカスタマイズする必要がある場合は、 `plugin`  ブロックに `configuration`  セクションを追加し、 `maven-compiler-plugin`  を設定するときと同じように `compilerArgs`  プロパティを設定します。また、 `source`  、 `target`  、および `jvmArgs`  を設定することもできます。例えば、 `--enable-preview`  を JVM と `javac`  の両方に渡すには、 を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal, run `./mvnw compile quarkus:dev`, and enjoy a highly productive environment.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末で `./mvnw compile quarkus:dev`  を実行し、生産性の高い環境を楽しむことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or in the embedded terminal, run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離された端末または埋め込み端末で、 `./mvnw compile quarkus:dev`  を実行してください。お楽しみください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In a separated terminal or the embedded terminal, go to the project root and run `./mvnw compile quarkus:dev`. Enjoy!</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>分離されたターミナルまたは埋め込みターミナルで、プロジェクトのルートに移動し、 `./mvnw compile quarkus:dev`  を実行します。お楽しみください！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Usually, dependencies of an application (which is a Maven project) could be displayed using `mvn dependency:tree` command. In case of a Quarkus application, however, this command will list only the runtime dependencies of the application.  Given that the Quarkus build process adds deployment dependencies of the extensions used in the application to the original application classpath, it could be useful to know which dependencies and which versions end up on the build classpath.  Luckily, the `quarkus-bootstrap` Maven plugin includes the `build-tree` goal which displays the build dependency tree for the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>通常、アプリケーション（Mavenプロジェクト）の依存関係は、 `mvn dependency:tree`  コマンドを使用して表示することができます。しかし、Quarkusアプリケーションの場合、このコマンドはアプリケーションの実行時の依存関係のみを表示します。Quarkusのビルドプロセスは、アプリケーションで使用されているエクステンションのデプロイメント依存関係を元のアプリケーションのクラスパスに追加するので、どの依存関係とどのバージョンがビルドクラスパスで終わるかを知ることは便利です。幸いにも、 `quarkus-bootstrap`  Mavenプラグインには、アプリケーションのビルド依存関係ツリーを表示する `build-tree`  ゴールが含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To be able to use it, the following plugin configuration has to be added to the `pom.xml`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これを使えるようにするためには、以下のプラグイン設定を `pom.xml` に追加する必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now you should be able to execute `./mvnw quarkus-bootstrap:build-tree` on your project and see something like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、プロジェクト上で `./mvnw quarkus-bootstrap:build-tree`  を実行して、以下のようなものが表示されるようになるはずです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Make sure to have `GRAALVM_HOME` configured and pointing to GraalVM version {graalvm-version} (Make sure to use a Java 11 version of GraalVM).  Verify that your `pom.xml` has the proper `native` profile (see &lt;&lt;build-tool-maven&gt;&gt;).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GRAALVM_HOME`  を設定し、GraalVM バージョン {graalvm-version} を指していることを確認してください。(GraalVMのJava 11バージョンを使用していることを確認してください)。あなたの `pom.xml`  が適切な `native`  プロファイルを持っていることを確認してください（ link:#build-tool-maven[[build-tool-maven]を]参照してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create a native executable using: `./mvnw package -Pnative`.  A native executable will be present in `target/`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw package -Pnative` を使用してネイティブ実行可能ファイルを作成します。ネイティブ実行ファイルは `target/` に出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To run Integration Tests on the native executable, make sure to have the proper Maven plugin configured (see &lt;&lt;build-tool-maven&gt;&gt;) and launch the `verify` goal.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルで統合テストを実行するには、適切なMavenプラグインが設定されていることを確認し（ link:#build-tool-maven[[build-tools-maven]を]参照）、 `verify`  ゴールを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build a container friendly executable</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナフレンドリーな実行可能ファイルのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can follow the link:building-native-image[Build a native executable guide] as well as link:deploying-to-kubernetes[Deploying Application to Kubernetes and OpenShift] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細については、 link:building-native-image[ネイティブ実行ファイルのビルドガイド]と同様に、 link:deploying-to-kubernetes[アプリケーションをKubernetesとOpenShiftにデプロイ]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have not used &lt;&lt;project-creation,project scaffolding&gt;&gt;, add the following elements in your `pom.xml`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;project-creation,プロジェクトの足場&gt;&gt;を使用していない場合は、以下の要素を `pom.xml` に追加してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optionally use a BOM file to omit the version of the different Quarkus dependencies.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>オプションで、BOMファイルを使用して、異なるQuarkus依存関係のバージョンを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the Quarkus Maven plugin that will hook into the build process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドプロセスにフックするQuarkus Mavenプラグインを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Add system properties to `maven-surefire-plugin`. + `maven.home` is only required if you have custom configuration in `${maven.home}/conf/settings.xml`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>システムのプロパティを `maven-surefire-plugin`  に追加します。+ `maven.home`  は、 `${maven.home}/conf/settings.xml`  にカスタム設定がある場合にのみ必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use a specific `native` profile for native executable building.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルのビルドには、特定の `native`  プロファイルを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable the `native` package type. The build will therefore produce a native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`native`  パッケージタイプを有効にします。そのため、ビルドはネイティブ実行可能ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to test your native executable with Integration Tests, add the following plugin configuration. Test names `*IT` and annotated `@NativeImageTest` will be run against the native executable. See the link:building-native-image[Native executable guide] for more info.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Integration Testsでネイティブ実行可能ファイルをテストしたい場合は、以下のプラグイン設定を追加してください。テスト名 `*IT`  と注釈付き `@NativeImageTest`  は、ネイティブ実行ファイルに対して実行されます。詳細は link:building-native-image[ネイティブ実行ファイルガイド]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The original jar will still be present in the `target` directory but it will be renamed to contain the `.original` suffix.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>元の jar は `target`  ディレクトリに残っていますが、 `.original`  の接尾辞を含むように名前が変更されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When building an Uber-Jar you can specify entries that you want to exclude from the generated jar by using the `quarkus.package.ignored-entries` configuration option, this takes a comma separated list of entries to ignore.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Uber-jar をビルドする際に、 `quarkus.package.ignored-entries`  設定オプションを使用して生成された jar から除外したいエントリを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar creation by default excludes link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[signature files] that might be present in the dependencies of the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Uber-Jar の作成は、アプリケーションの依存関係に存在する可能性のある link:https://docs.oracle.com/javase/tutorial/deployment/jar/intro.html[署名ファイル]を除外します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Uber-Jar's final name is configurable via a Maven's build settings `finalName` option.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Uber-Jarの最終的な名前は、Mavenのビルド設定 `finalName`  オプションで設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The best way to enable CDI bean discovery for a module in a multi-module project would be to include the `jandex-maven-plugin`, unless it is the main application module already configured with the quarkus-maven-plugin, in which case it will indexed automatically.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクト内のモジュールでCDI Bean検出を有効にするベストの方法は、 モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されていない限り、`jandex-maven-plugin`  をインクルードすることです。モジュールがメインアプリケーションモジュールでquarkus-maven-pluginが既に構成されている場合は自動的にインデックスが作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Project Output</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト出力の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a several configuration options that will define what the output of your project build will be.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのビルドの出力を定義するための設定オプションがいくつかあります。これらは他の設定プロパティと同じように `application.properties`  で提供されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is however possible to use a custom configuration profile for your tests with the Maven Surefire and Maven Failsafe configurations shown below. This can be useful if you need for example to run some tests using a specific database which is not your default testing database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ただし、以下に示すMaven SurefireおよびMaven Failsafe構成で、テストにカスタム構成プロファイルを使用することは可能です。これは、例えば、デフォルトのテストデータベースではない特定のデータベースを使用してテストを実行する必要がある場合に便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Camel on Quarkus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://camel.apache.org/[Apache Camel] is the Swiss knife of integrating heterogeneous systems with more than a decade of history and a lively community of users and developers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:http://camel.apache.org/[Apache Camel]は、10年以上の歴史とユーザーや開発者の活発なコミュニティを持つ、異種システムを統合するためのスイスアーミーナイフです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/latest/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus上のApache Camelのサポートは、 link:https://github.com/apache/camel-quarkus[Apache Camel Quarkusプロジェクト]によって提供されています。詳細は link:https://camel.apache.org/camel-quarkus/latest/[彼らのドキュメント]を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you look at either file you will see that it contains both a Kubernetes `Deployment` and a `Service`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どちらのファイルを見ても、Kubernetes `Deployment` と `Service` 両方が含まれていることに気づくでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The full source of the `kubernetes.json` file looks something like this:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`kubernetes.json` ファイルの完全なソースはこんな感じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example with a configuration like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>例えば、次のような設定の場合：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The image that will be used in the generated manifests will be `quarkus/demo-app:1.0`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストで使用されるイメージは `quarkus/demo-app:1.0` となります</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Docker registry can be specified with the following property:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Docker レジストリは以下のプロパティで指定できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Labels and Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ラベルとアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated manifests use the Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[recommended labels].  These labels can be customized using `quarkus.kubernetes.name`, `quarkus.kubernetes.version` and `quarkus.kubernetes.part-of`.  For example by adding the following configuration to your `application.properties`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたマニフェストには、Kubernetes link:https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels[推奨のラベル]が使用されます。これらのラベルは、 `quarkus.kubernetes.name`, `quarkus.kubernetes.version` および `quarkus.kubernetes.part-of` を使用してカスタマイズすることができます。例えば、 `application.properties` に以下の設定を追加してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The labels in generated resources will look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースのラベルは次のようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Labels</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Custom Labels</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To add additional custom labels, for example `foo=bar` just apply the following configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>追加のカスタムラベルを追加するには、例えば `foo=bar` を設定する場合、以下の設定を適用するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Out of the box, the generated resources will be annotated with version control related information that can be used either by tooling, or by the user for troubleshooting purposes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたリソースにはバージョン管理に関連する情報がアノテーションされ、ツールによって、またはユーザーがトラブルシューティングの目的で使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Custom Annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>カスタムアノテーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes provides multiple ways of defining environment variables:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesでは、環境変数を定義する方法が複数用意されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this example `initial-delay` and `period` are fields of the type `Probe`.  Below you will find tables describing all available types.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この例では、 `initial-delay` と `period` は `Probe` タイプのフィールドです。以下に、利用可能なすべてのタイプを説明した表を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Basic Types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>基本的な種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Env</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Env</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Port</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Port</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Container</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Container</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Probe</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Probe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mounts and Volumes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マウントとボリューム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mount</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ConfigMapVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SecretVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SecretVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AzureDiskVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AzureDiskVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AwsElasticBlockStoreVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AwsElasticBlockStoreVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GitRepoVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GitRepoVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>AzureFileVolume</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>AzureFileVolume</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable the generation of OpenShift resources, you need to include OpenShift in the target platforms:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>OpenShiftリソースの生成を可能にするには、OpenShiftをターゲットプラットフォームに含める必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>quarkus.kubernetes.deployment-target=openshift
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus.kubernetes.deployment-target=openshift
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need to generate resources for both platforms (vanilla Kubernetes and OpenShift), then you need to include both (comma separated).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>両方のプラットフォーム（バニラKubernetesとOpenShift）のリソースを生成する必要がある場合は、両方を含める必要があります（カンマ区切り）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The OpenShift resources can be customized in a similar approach with Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Kubernetesと同様のアプローチでOpenShiftのリソースをカスタマイズすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Knative</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Knative</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated service can be customized using the following properties:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたサービスは、以下のプロパティを使用してカスタマイズすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deprecated configuration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>非推奨の設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following categories of configuration properties have been deprecated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のカテゴリの構成プロパティは非推奨となりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties without the quarkus prefix</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>quarkus接頭辞のないプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In earlier versions of the extension, the `quarkus.` was missing from those properties. These properties are now deprecated.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以前のバージョンのエクステンションでは、これらのプロパティに `quarkus.` がありませんでした。これらのプロパティは現在非推奨となっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The properties for configuring `docker` and `s2i` are also deprecated in favor of the new container-image extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`docker` と `s2i` を設定するためのプロパティも非推奨となり、新しいコンテナイメージエクステンションが採用されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Config group arrays</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>設定グループ配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Properties referring to config group arrays (e.g. `kubernetes.labels[0]`, `kubernetes.env-vars[0]` etc) have been converted to maps, to align with the rest of the Quarkus ecosystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンフィググループ配列を参照するプロパティ（例： `kubernetes.labels[0]` 、 `kubernetes.env-vars[0]` など）は、Quarkusのエコシステムの他の部分と一致するようにマップに変換されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `labels` config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードは `labels` の設定を変更した様子を示しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code below demonstrates the change in `env-vars` config:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のコードは `env-vars` の設定を変更した様子を示しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deployment</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To trigger building and deploying a container image you need to enable the `quarkus.kubernetes.deploy` flag (the flag is disabled by default - furthermore it has no effect during test runs or dev mode).  This can be easily done with the command line:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテナイメージをビルドしてデプロイするには、 `quarkus.kubernetes.deploy` フラグを有効にする必要があります (このフラグはデフォルトでは無効になっています - さらに、テスト実行中や開発モードでは何の効果もありません)。これはコマンドラインで簡単に行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#docker[Docker]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#jib[Jib]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:container-image#s2i[s2i]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each time deployment is requested, a container image build will be implicitly triggered (no additional properties are required when the Kubernetes deployment has been enabled).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイが要求されるたびに、暗黙のうちにコンテナイメージのビルドがトリガーされます（Kubernetes のデプロイが有効になっている場合は、追加のプロパティは必要ありません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Deploying</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デプロイ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At the moment no additional options are provided for further customization.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のところ、さらなるカスタマイズのための追加オプションは提供されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference covers how to write applications that run and then exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファレンスでは、実行して終了するアプリケーションの書き方について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Command Mode Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are two different approaches that can be used to implement applications that exit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>終了するアプリケーションを実装するためには、2つの異なるアプローチがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and have Quarkus run this method automatically</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` を実装し、Quarkusがこのメソッドを自動的に実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implement `QuarkusApplication` and a Java main method, and use the Java main method to launch Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` とJava mainメソッドを実装し、Java mainメソッドを使用してQuarkusを起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this document the `QuarkusApplication` instance is referred to as the application main, and a class with a Java main method is the Java main.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このドキュメントでは、 `QuarkusApplication` インスタンスをアプリケーション mainと呼び、Java mainメソッドを持つクラスを Java mainと呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The simplest possible command mode application with access to Quarkus API's might appear as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのAPIにアクセスできる最もシンプルなコマンドモードのアプリケーションは、以下のようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;.&gt; The `@QuarkusMain` annotation tells Quarkus that this is the main entry point.  &lt;.&gt; The `run` method is invoked once Quarkus starts, and the application stops when it finishes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;.&gt; `@QuarkusMain` アノテーションは、これがメインのエントリーポイントであることをQuarkusに伝えます。  &lt;.&gt; `run` メソッドは、Quarkusが起動すると呼び出され、終了するとアプリケーションが停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contexts</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To get access to your application beans and services, be aware that a `@QuarkusMain` instance is an application scoped bean by default. It has access to singletons, application and dependent scoped beans. If you want to interact with beans that requires a request scope put a `@ActivateRequestContext` on your `run()` method.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションBeanやサービスにアクセスするために、 `@QuarkusMain` インスタンスはデフォルトでapplicationスコープのBeanであることに注意してください。singleton、application、dependentスコープのBeanへのアクセスを持っています。requestスコープを必要とするBeanと対話したい場合は、 `run()` メソッドに `@ActivateRequestContext` を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This let `run()` have access to methods like `listAll()` and `query*` methods on a Panache Entity. Without it you will eventually get a `ContextNotActiveException` when accessing such classes/beans.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これにより、 `run()` は Panache Entity 上の `listAll()` や `query*` のようなメソッドにアクセスできるようになります。これがないと、そのようなクラスやビーンにアクセスするときに、最終的には `ContextNotActiveException` に直面することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we want to use a Java main to run the application main it would look like:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java mainでアプリケーション mainを実行したい場合は以下のようになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is effectively the same as running the `HelloWorldMain` application main directly, but has the advantage it can be run from the IDE.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは `HelloWorldMain` アプリケーション mainを直接実行するのと実質的には同じですが、IDE から実行できるという利点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a class that implements `QuarkusApplication` and has a Java main then the Java main will be run.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` を実装したクラスで Java main がある場合は Java main が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is recommended that a Java main perform very little logic, and just launch the application main. In development mode the Java main will run in a different ClassLoader to the main application, so may not behave as you would expect.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Java mainはほとんどロジックを実行せず、アプリケーション mainを起動するだけにすることをお勧めします。開発モードでは、Java mainはアプリケーション mainとは異なるClassLoaderで実行されるので、期待通りの動作をしないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple Main Methods</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数のmainメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is possible to have multiple main methods in an application, and select between them at build time.  The `@QuarkusMain` annotation takes an optional 'name' parameter, and this can be used to select the main to run using the `quarkus.package.main-class` build time configuration option. If you don't want to use annotations this can also be used to specify the fully qualified name of a main class.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション内に複数のmainメソッドを持ち、ビルド時にそれらの間で選択することが可能です。 `@QuarkusMain` アノテーションはオプションの 'name' パラメータを取り、 `quarkus.package.main-class` ビルド時設定オプションを使用して実行するmainを選択するために使用できます。アノテーションを使用したくない場合は、メインクラスの完全修飾名を指定するために使用することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default the `@QuarkusMain` with no name (i.e. the empty string) will be used, and if it is not present and `quarkus.package.main-class` is not specified then Quarkus will automatically generate a main class that just runs the application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、名前のない `@QuarkusMain` （つまり空文字列）が使用され、それが存在せず `quarkus.package.main-class` が指定されていない場合は、Quarkus はアプリケーションを実行するだけのメインクラスを自動的に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `name` of `@QuarkusMain` must be unique (including the default of the empty string). If you have multiple `@QuarkusMain` annotations in your application the build will fail if the names are not unique.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@QuarkusMain` の `name` は一意である必要があります（デフォルトの空文字列を含む）。アプリケーション内に複数の `@QuarkusMain` アノテーションがある場合、名前が一意でないとビルドに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The command mode lifecycle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのライフサイクル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When running a command mode application the basic lifecycle is as follows:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのアプリケーションを実行する場合、基本的なライフサイクルは以下の通りです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the `QuarkusApplication` main method</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusApplication` mainメソッドの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shut down Quarkus and exit the JVM after the main method returns</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mainメソッドがreturnされた後にQuarkusをシャットダウンし、JVMを終了する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shutdown is always initiated by the application main thread returning. If you want to run some logic on startup, and then run like a normal application (i.e. not exit) then you should call `Quarkus.waitForExit` from the main thread (A non-command mode application is essentially just running an application that just calls `waitForExit`).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シャットダウンは常にアプリケーションのメインスレッドがreturnされることで開始されます。起動時に何らかのロジックを実行して、通常のアプリケーションのように実行したい場合 (つまり終了しない) は、メインスレッドから `Quarkus.waitForExit` を呼び出す必要があります (非コマンドモードのアプリケーションは、基本的に `waitForExit` を呼び出すだけのアプリケーションを実行しているだけです)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to shut down a running application and you are not in the main thread then you should call `Quarkus.asyncExit` in order to unblock the main thread and initiate the shutdown process.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>実行中のアプリケーションをシャットダウンしたい場合、メインスレッドにいない場合は、 `Quarkus.asyncExit` を呼び出してメインスレッドのブロックを解除し、シャットダウン処理を開始する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev mode</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>開発モード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also for command mode applications the dev mode is supported. When running `mvn compile quarkus:dev`, the command mode application is executed and on press of the Enter key, is restarted.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、コマンドモードアプリケーションでは、開発モードにも対応しています。 `mvn compile quarkus:dev` を実行しているときは、コマンドモードアプリケーションを実行し、Enter キーを押すと再起動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As command mode applications will often require arguments to be passed on the commandline, this is also possible in dev mode via:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードのアプリケーションでは、コマンドラインで引数を渡す必要があることが多く、これは開発モードでも可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The same can be achieved with Gradle:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Gradleでも同じことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Credentials Provider</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>資格情報プロバイダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically.  In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクのスケジュール方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need a clustered scheduler use the link:quartz[Quartz extension].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスタ化されたスケジューラが必要な場合は、 link:quartz[Quartz拡張機能] を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application accessible using HTTP to get the current value of a counter.  This counter is periodically (every 10 seconds) incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、カウンタの現在値を取得するために HTTP を使用してアクセスできる簡単なアプリケーションを作成します。このカウンタは定期的に (10 秒ごとに) インクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `scheduler-quickstart` {quickstarts-tree-url}/scheduler-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.scheduler.CountResource` resource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.scheduler.CountResource` リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Maven project also imports the Quarkus scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Maven プロジェクトは、Quarkus scheduler エクステンションもインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `scheduler` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでに Quarkus プロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `scheduler` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a scheduled job</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたジョブの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the `org.acme.scheduler` package, create the `CounterBean` class, with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.scheduler` パッケージで、以下の内容の `CounterBean` クラスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Declare the bean in the _application_ scope</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_application_ スコープでの Bean の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `get()` method allows retrieving the current value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`get()` メソッドでは、現在の値を取得することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use the `@Scheduled` annotation to instruct Quarkus to run this method every 10 seconds provided a worker thread is available (Quarkus is using 10 worker threads for the scheduler). If it is not available the method invocation should be re-scheduled by default i.e it should be invoked as soon as possible. The invocation of the scheduled method does not depend on the status or result of the previous invocation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Scheduled` アノテーションを使用して、ワーカースレッドが利用可能であれば 10 秒ごとにこのメソッドを実行するように Quarkus に指示します (Quarkus はスケジューラに10個のワーカースレッドを使用しています)。ワーカースレッドが利用できない場合は、メソッドの呼び出しをデフォルトで再スケジューリングする必要があります。スケジュールされたメソッドの呼び出しは、前回の呼び出しのステータスや結果には依存しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code is pretty straightforward. Every 10 seconds, the counter is incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードはとても簡単です。10 秒ごとにカウンターがインクリメントされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression. The annotated method is executed at 10:15am every day.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cron のような式でジョブを定義します。アノテーションされたメソッドは毎日午前 10 時 15 分に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Define a job with a cron-like expression `cron.expr` which is configurable in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` で設定可能な`cron.expr` で cron のような式でジョブを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the application configuration file</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーション設定ファイルの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `application.properties` file and add the `cron.expr` configuration:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`application.properties` ファイルを編集し、 `cron.expr` の設定を追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Updating the resource and the test</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リソースとテストの更新</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `CountResource` class, and update the content to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CountResource` クラスを編集して、内容を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CounterBean`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CounterBean` の注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Send back the current counter value</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在のカウンターの値の返却</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need to update the tests. Edit the `CountResourceTest` class to match:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストも更新する必要があります。`CountResourceTest` クラスを一致するように編集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ensure that the response contains `count`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>レスポンスに `count` が含まれていることを確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Run the application with: `./mvnw compile quarkus:dev`.  In another terminal, run `curl localhost:8080/count` to check the counter value.  After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`./mvnw compile quarkus:dev` でアプリケーションを実行してください。別のターミナルで `curl localhost:8080/count` を実行して、カウンターの値を確認します。数秒後に `curl localhost:8080/count` を再実行して、カウンターがインクリメントされていることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observe the console to verify that the message `Cron expression configured in application.properties` has been displayed indicating that the cron job using an expression configured in `application.properties` has been triggered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンソールを見て、 `application.properties` で構成された式を使用する cron ジョブがトリガーされたことを示すメッセージ `Cron expression configured in application.properties` が表示されたことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Configuration Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラー設定リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`/api/public`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `/api/public` endpoint can be accessed anonymously.  The `/api/admin` endpoint is protected with RBAC (Role-Based Access Control) where only users granted with the `admin` role can access. At this endpoint, we use the `@RolesAllowed` annotation to declaratively enforce the access constraint.  The `/api/users/me` endpoint is also protected with RBAC (Role-Based Access Control) where only users granted with the `user` role can access. As a response, it returns a JSON document with details about the user.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public` エンドポイントは匿名でアクセスできます。 `/api/admin` エンドポイントは RBAC (Role-Based Access Control) で保護されており、 `admin` の役割を与えられたユーザーのみがアクセスできます。このエンドポイントでは、 `@RolesAllowed` アノテーションを使用して、アクセス制約を宣言的に強制します。 `/api/users/me` エンドポイントも RBAC (Role-Based Access Control) で保護されており、 `user` ロールで付与されたユーザーのみがアクセスできます。レスポンスとして、ユーザーに関する詳細を含むJSONドキュメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Don't forget to add the database connector library of choice. Here we are using PostgreSQL as identity store.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>選択したデータベースコネクタライブラリを追加することを忘れないでください。ここでは、PostgreSQLをIDストアとして使用しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by implementing the `/api/public` endpoint. As you can see from the source code below, it is just a regular JAX-RS resource:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`/api/public` エンドポイントの実装から始めましょう。以下のソースコードから分かるように、通常のJAX-RSリソースです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, let's consider the `/api/users/me` endpoint. As you can see from the source code below, we are trusting only users with the `user` role.  We are using `SecurityContext` to get access to the current authenticated Principal and we return the user's name. This information is loaded from the database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、 `/api/users/me` エンドポイントを考えてみましょう。下のソースコードを見ればわかるように、 `user` の役割を持つユーザのみを信頼しています。現在認証されているプリンシパルへのアクセスを得るために `SecurityContext` を使用しており、ユーザーの名前を返します。この情報はデータベースから読み込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is now protected and the identities are provided by our database.  The very first thing to check is to ensure the anonymous access works.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションが保護され、アイデンティティがデータベースから提供されるようになりました。非常に最初に確認しなければならないことは、匿名アクセスが機能することを確認することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, let's try a to hit a protected resource anonymously.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>では、匿名で保護されたリソースを攻撃してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So far so good, now let's try with an allowed user.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ここまでは順調ですが、今度は許可されたユーザーで試してみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By providing the `admin:admin` credentials, the extension authenticated the user and loaded their roles.  The `admin` user is authorized to access to the protected resources.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`admin:admin` 資格情報を提供することで、エクステンションはユーザーを認証し、そのロールをロードしました。 `admin` ユーザーは、保護されたリソースへのアクセスを許可されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The user `admin` should be forbidden to access a resource protected with `@RolesAllowed("user")` because it doesn't have this role.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザー `admin` は、この役割を持っていないので、 `@RolesAllowed("user")` で保護されたリソースへのアクセスを禁止する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, using the user `user` works and the security context contains the principal details (username for instance).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最後に、ユーザ `user` を使用すると動作し、セキュリティコンテキストには主要な詳細（例えばユーザ名）が含まれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence offers a fluent query builder API on top of JPA with a deep Hibernate ORM integration that enables the use of advanced SQL features like Common Table Expressions while staying in the realm of the JPA model.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistenceは、Hibernate ORMとの深い統合により、JPAの上に流れるようなクエリビルダAPIを提供し、JPAモデルの範囲内でありながら、共通テーブル式のような高度なSQL機能の使用を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On top of that, the Blaze-Persistence Entity-View module allows for DTO definitions that can be applied to business logic queries which are then transformed to optimized queries that only fetch the data that is needed to construct the DTO instances.  The same DTO definitions can further be used for applying database updates, leading to a great reduction in boilerplate code and removing the need for object mapping tools.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さらに、Blaze-Persistence Entity-Viewモジュールは、ビジネスロジッククエリに適用出来るDTO定義を可能にし、そのクエリはDTOインスタンスを構築するために必要なデータのみを取得する最適化されたクエリに変換されます。同じDTO定義をデータベースの更新にも使用することができます。これにより、ボイラプレートコードが大幅に削減され、オブジェクトマッピングツールの必要性がなくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The extension comes with default producers for `CriteriaBuilderFactory` and `EntityViewManager` that work out of the box given a working Hibernate ORM configuration. For customization, overriding of the default producers is possible via the standard mechanism as documented in the link:{quarkus-home-url}/guides/cdi-reference#default_beans[Quarkus CDI reference].  This is needed if you need to set custom link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#anchor-configuration-properties[Blaze-Persistence properties].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このエクステンションには、 `CriteriaBuilderFactory` と `EntityViewManager` のデフォルトのプロデューサーが付属しており、動作する Hibernate ORM 設定があればすぐに動作します。カスタマイズのために、 link:{quarkus-home-url}/guides/cdi-reference#default_beans[Quarkus CDIリファレンス]に記載されている標準的なメカニズムを使用して、デフォルトのプロデューサーをオーバーライドすることができます。これは、カスタムの link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#anchor-configuration-properties[Blaze-Persistenceプロパティ]を設定する場合に必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Inject` `CriteriaBuilderFactory` or `EntityViewManager` and use it</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` または `EntityViewManager` を `@Inject` し、使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the Blaze-Persistence extension: `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistence エクステンション： `com.blazebit:blaze-persistence-integration-quarkus`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>further Blaze-Persistence integrations as needed:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>必要に応じて、さらにBlaze-Persistenceの統合を行います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jackson` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#Jackson%20integration[Jackson] の為に `blaze-persistence-integration-jackson`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`blaze-persistence-integration-jaxrs` for link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:https://persistence.blazebit.com/documentation/entity-view/manual/en_US/index.html#jaxrs-integration[JAX-RS]の為に `blaze-persistence-integration-jaxrs`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The use in native images requires a dependency on the entity view annotation processor that may be extracted into a separate `native` profile:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージでの使用には、別の `native` プロファイルに抽出される可能性のあるエンティティビューアノテーションプロセッサへの依存関係が必要です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `CriteriaBuilderFactory` and an `EntityViewManager` will be created based on the configured `EntityManagerFactory` as provided by the link:{quarkus-home-url}/guides/hibernate-orm[Hibernate-ORM extension].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` と `EntityViewManager` は、 link:{quarkus-home-url}/guides/hibernate-orm[Hibernate-ORM エクステンション]で提供される設定された `EntityManagerFactory` に基づいて作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can then access these beans via injection:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その後、注入によってこれらのBeanにアクセスすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `CriteriaBuilderFactory`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CriteriaBuilderFactory` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `EntityViewManager`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityViewManager` を注入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mark your CDI bean method as `@Transactional` so that a transaction is started or joined.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションが開始またはトランザクションに参加されるように、CDI Beanメソッドを `@Transactional` としてマークします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example Entity-View</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エンティティビューの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Example updatable Entity-View</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>更新可能なEntity-Viewの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are various optional properties useful to refine your `EntityViewManager` and `CriteriaBuilderFactory` or guide guesses of Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`EntityViewManager` と `CriteriaBuilderFactory` を洗練させたり、またはQuarkusの推測をガイドするのに便利な様々なオプションのプロパティがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are no required properties, as long as the Hibernate ORM extension is configured properly.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMエクステンションが適切に設定されている限り、必須のプロパティはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When no property is set, the Blaze-Persistence defaults apply.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロパティが設定されていない場合は、Blaze-Persistenceのデフォルトが適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Derby</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Derby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Blaze-Persistence currently does not come with support for Apache Derby.  This limitation could be lifted in the future, if there's a compelling need for it and if someone contributes it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Blaze-Persistenceは現在、Apache Derbyをサポートしていません。切実なニーズが存在し、誰かがコントリビュートしてくれれば、この制限は、将来的には解除されるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with link:hibernate-orm[Hibernate ORM] or link:hibernate-orm-panache[Hibernate ORM with Panache].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用し、 link:hibernate-orm[Hibernate ORM]または link:hibernate-orm-panache[Hibernate ORM with Panache]を使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `security-jpa-quickstart` {quickstarts-tree-url}/security-jpa-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates a Maven project, importing the `security-jpa` extension which allows you to map your security source to JPA entities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、セキュリティ ソースを JPA エンティティにマップできる `security-jpa` エクステンションをインポートして、Maven プロジェクトを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `security-jpa` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `security-jpa` エクステンションを追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Defining our user entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ユーザーエンティティの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We can now describe how our security information is stored in our model by adding a few annotations to our `User` entity:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これで、 `User` エンティティにいくつかのアノテーションを追加することで、セキュリティ情報がモデルにどのように保存されているかを説明することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension is only initialized if there is a single entity annotated with `@UserDefinition`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`security-jpa` 拡張子は、 `@UserDefinition` でアノテーションされた単一のエンティティがある場合にのみ初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This annotation must be present on a single entity. It can be a regular Hibernate ORM entity or a Hibernate ORM with Panache entity as in this example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このアノテーションは、単一のエンティティに存在しなければなりません。この例のように、通常のHibernate ORMエンティティまたはHibernate ORM with Panacheエンティティにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the user name.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、ユーザー名に使用されるフィールドを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the field used for the password. This defaults to using bcrypt hashed passwords, but you can also configure it for clear text passwords.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、パスワードに使用するフィールドを示します。これはデフォルトでは bcrypt ハッシュ化されたパスワードを使用するように設定されていますが、クリアテキストパスワード用に設定することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This indicates the comma-separated list of roles added to the target Principal representation attributes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは、対象のプリンシパル表現属性に追加されたロールのコンマ区切りリストを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This method allows us to add users while hashing the password with the proper bcrypt hash.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>この方法では、パスワードを適切なbcryptハッシュでハッシュしながらユーザーを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `security-jpa` extension requires at least one datasource to access to your database.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`security-jpa` 拡張モジュールは、データベースにアクセスするために少なくとも一つのデータソースが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In our context, we are using PostgreSQL as identity store. The database schema is created by Hibernate ORM automatically on startup (change this in production) and we initialize the database with users and roles in the `Startup` class:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>私たちのコンテキストでは、IDストアとしてPostgreSQLを使用しています。データベーススキーマはHibernate ORMによって起動時に自動的に作成され（本番ではこれを変更します）、 `Startup` クラスのユーザとロールでデータベースを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is probably useless but we kindly remind you that you must not store clear-text passwords in production environments ;-).  As a result, the `security-jpa` defaults to using bcrypt-hashed passwords.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>おそらく役に立たないと思いますが、本番環境ではクリアテキストのパスワードを保存してはいけないことをご注意ください。)その結果、 `security-jpa` はデフォルトで bcrypt でハッシュ化されたパスワードを使用するようになりました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the following tests we use the basic authentication mechanism, you can enable it by setting `quarkus.http.auth.basic=true` in the `application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のテストでは、基本的な認証メカニズムを使用していますが、 `application.properties` ファイルに `quarkus.http.auth.basic=true` を設定することで有効にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Supported model types</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>サポートされているモデルの種類</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@UserDefinition` class must be a JPA entity (with Panache or not).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@UserDefinition` クラスは JPA エンティティである必要があります（Panache を使用しているかどうかは問いません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Username` and `@Password` field types must be of type `String`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Username` と `@Password` フィールドの型は `String` でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@Roles` field must either be of type `String` or `Collection&lt;String&gt;` or alternately a `Collection&lt;X&gt;` where `X` is an entity class with one `String` field annotated with the `@RolesValue` annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`@Roles` フィールドは `String` か `Collection&amp;amp;lt;String&amp;amp;gt;` のいずれかのタイプであるか、または `Collection&amp;amp;lt;X&amp;amp;gt;` である必要があります。 `X` はエンティティクラスで、 `@RolesValue` アノテーションが付与された `String` フィールドが 1 つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Each `String` role element type will be parsed as a comma-separated list of roles.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>各 `String` role 要素の型は、カンマで区切られたロールのリストとして解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Storing roles in another entity</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>別のエンティティにロールを格納する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also store roles in another entity:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、別のエンティティにロールを格納することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Password storage and hashing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パスワードの保存とハッシュ化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, we consider passwords to be stored hashed with https://en.wikipedia.org/wiki/Bcrypt[bcrypt] under the https://en.wikipedia.org/wiki/Crypt_(C)[Modular Crypt Format] (MCF).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、パスワードは MCF ( link:https://en.wikipedia.org/wiki/Crypt_©[Modular Crypt Format]) の下で link:https://en.wikipedia.org/wiki/Bcrypt[bcrypt]でハッシュ化されて保存されると考えています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you need to create such a hashed password we provide the convenient `String BcryptUtil.bcryptHash(String password)` function, which defaults to creating a random salt and hashing in 10 iterations (though you can specify the iterations and salt too).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このようなハッシュ化されたパスワードを作成する必要がある場合は、便利な `String BcryptUtil.bcryptHash(String password)` 関数を用意しています。デフォルトでは、ランダムなソルトを作成して 10 回の繰り返しでハッシュ化します (繰り返しとソルトも指定できます)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>with MCF you don't need dedicated columns to store the hashing algorithm, the iterations count or the salt because they're all stored in the hashed value.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MCF を使うと、ハッシュアルゴリズムや反復回数、 ソルトを格納するための専用のカラムは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>WARN: you can also store passwords in clear text with `@Password(PasswordType.CLEAR)` but we strongly recommend against it in production.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>警告: `@Password(PasswordType.CLEAR)` を使ってパスワードをクリアテキストで保存することもできますが、本番では絶対にしないことを強くお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Glossary</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>用語集</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is a collection of preferred term in the documentation and website.  Please stay within these terms for consistency.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ドキュメントやウェブサイトで好まれる用語を集めたものです。一貫性を保つために、これらの用語の範囲内にとどめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>* Live coding</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>* ライブコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains logging and how to configure it.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ロギングとその設定方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Centralized Log Management</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>集中ログ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Kogito to add business automation to power it up with business processes and rules.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKogitoを使用してビジネスオートメーションを追加し、ビジネスプロセスとルールでパワーアップする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A brief introduction to Mutiny - the reactive programming library used by Quarkus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>概説Mutiny - Quarkusによって使用されているリアクティブプログラミングライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a reactive JAX-RS endpoint (asynchronous, streams...)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSエンドポイントの作成（非同期、ストリーム...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using reactive database access</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブデータベースアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interacting with other reactive APIs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他のリアクティブAPIの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions from &lt;&lt;bootstrapping-the-project,Bootstrapping project&gt;&gt; and onwards to create the application step by step.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;&lt;bootstrapping-the-project,プロジェクトのブートストラップ&gt;&gt;とそれ以降の解説に従って、ステップバイステップでアプリを作成していくことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、完成した例をすぐ確認することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download an {quickstarts-archive-url}[archive] or clone the git repository:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>{quickstarts-archive-url}[アーカイブ] をダウンロードするか、gitレポジトリをクローンします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>git clone {quickstarts-clone-url}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping the project</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクトのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to create a new Quarkus project is to open a terminal and run the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>新しいQuarkusプロジェクトを作成する最も簡単な方法は、ターミナルを開いて以下のコマンドを実行することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>example `Dockerfile` files for both `native` and `jvm` modes in `src/main/docker`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`src/main/docker` にある `native` と `jvm` の両方のモード用の `Dockerfile` ファイルの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Metrics specification through the SmallRye Metrics extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Metricsエクステンションを使用してMicroProfile Metrics仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, you will learn how to enable application data caching in any CDI managed bean of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションのCDI管理されたBeanでアプリケーションデータのキャッシングを有効にする方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scenario</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シナリオ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's imagine you want to expose in your Quarkus application a REST API that allows users to retrieve the weather forecast for the next three days.  The problem is that you have to rely on an external meteorological service which only accepts requests for one day at a time and takes forever to answer.  Since the weather forecast is updated once every twelve hours, caching the service responses would definitely improve your API performances.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションで、ユーザーが今後3日間の天気予報を取得できるREST APIを公開したいとします。問題は、一度に1日分のリクエストしか受け付けず、応答に時間がかかる外部の気象サービスに依存しなければならないことです。天気予報は12時間に一度更新されるので、サービスのレスポンスをキャッシュすればAPIのパフォーマンスは間違いなく向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We'll do that using a single Quarkus annotation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これをQuarkusの単一のアノテーションを使用して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `cache-quickstart` {quickstarts-tree-url}/cache-quickstart[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>First, we need to create a new Quarkus project using Maven with the following command:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まず、以下のコマンドでMavenを使って新しいQuarkusプロジェクトを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This command generates the Maven project with a REST endpoint and imports the `cache` and `resteasy-jackson` extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このコマンドは、REST エンドポイントを持つ Maven プロジェクトを生成し、 `cache` と `resteasy-jackson` のエクステンションをインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you already have your Quarkus project configured, you can add the `cache` extension to your project by running the following command in your project base directory:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すでにQuarkusプロジェクトが設定されている場合は、プロジェクトのベースディレクトリで以下のコマンドを実行することで、プロジェクトに `cache` エクステンションを追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's start by creating a service that will simulate an extremely slow call to the external meteorological service.  Create `src/main/java/org/acme/cache/WeatherForecastService.java` with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>まずは、外部気象サービスへの非常に遅い呼び出しをシミュレートするサービスを作成してみましょう。以下の内容で `src/main/java/org/acme/cache/WeatherForecastService.java` を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also need a class that will contain the response sent to the users when they ask for the next three days weather forecast.  Create `src/main/java/org/acme/cache/WeatherForecast.java` this way:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、ユーザーが次の3日間の天気予報を求めたときに送信されるレスポンスを含むクラスも必要です。 `src/main/java/org/acme/cache/WeatherForecast.java` をこのように作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a Hello World Quarkus app.  This guide covers:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hello World Quarkus アプリの作成方法を説明します。 このガイドでは、以下の内容を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Bootstrapping an application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのブートストラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Functional tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>機能テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging of the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのパッケージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you have multiple JDK's installed it is not certain Maven will pick up the expected java and you could end up with unexpected results.  You can verify which JDK Maven uses by running `mvn --version`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>複数の JDK をインストール済みで、Maven が意図した Java を使用するかわからない場合は、予期しない結果になることがあります。Maven が使用する JDK は、`mvn --version` コマンドで確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we create a straightforward application serving a `hello` endpoint. To demonstrate dependency injection, this endpoint uses a `greeting` bean.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、`hello` エンドポイントを提供する簡単なアプリケーションを作成します。依存性の注入を示すために、このエンドポイントでは `greeting` Bean を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide also covers the testing of the endpoint.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、エンドポイントのテストについても解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` {quickstarts-tree-url}/getting-started[directory].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソリューションは `getting-started` {quickstarts-tree-url}/getting-started[directory] にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName="org.acme.getting.started.GreetingResource" \
    -Dpath="/hello"
cd getting-started
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd , (don't use backward slash `\`)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cmd を使っている場合 (バックスラッシュは使わないでください)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create -DprojectGroupId=org.acme -DprojectArtifactId=getting-started -DclassName="org.acme.getting.started.GreetingResource" -Dpath="/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell , wrap `-D` parameters in double quotes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Powershell を使用する場合は、`-D` パラメータを二重引用符で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create "-DprojectGroupId=org.acme" "-DprojectArtifactId=getting-started" "-DclassName=org.acme.getting.started.GreetingResource" "-Dpath=/hello"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It generates the following in `./getting-started`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>以下のように `./getting-started` に生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>an `org.acme.getting.started.GreetingResource` resource exposed on `/hello`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`org.acme.getting.start.GreetingResource` リソースは、`/hello` で公開されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Once generated, look at the `pom.xml`.  You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies.  In addition, you can see the `quarkus-maven-plugin` responsible of the packaging of the application and also providing the development mode.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたら、`pom.xml` を確認してください。 Quarkus の BOM のインポートが存在することが分かります。これにより、異なる Quarkus の依存関係のバージョンを省略できます。さらに、アプリケーションのパッケージングと開発モードを処理する `quarkus-maven-plugin` が存在することが分かります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>依存関係の部分に注目すると、REST アプリケーションの開発を可能にするエクステンションを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>During the project creation, the `src/main/java/org/acme/getting/started/GreetingResource.java` file has been created with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プロジェクト作成時には、 `src/main/java/org/acme/getting/started/GreetingResource.java` ファイルが以下の内容で作成されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a very simple REST endpoint, returning "hello" to requests on "/hello".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これは非常にシンプルな REST エンドポイントで、"/hello" 上のリクエストに "hello" を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Differences with vanilla JAX-RS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バニラ JAX-RS との違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, there is no need to create an `Application` class. It's supported, but not required. In addition, only one instance of the resource is created and not one per request. You can configure this using the different `*Scoped` annotations (`ApplicationScoped`, `RequestScoped`, etc).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus では、`Application` クラスを作成する必要がありません。作成は可能ですが、必須ではありません。加えて、リソースは 1 つのみが作成され、リクエスト毎に 1 つではありません。これは、異なる `*Scoped` アノテーション (`ApplicationScoped`、`RequestScoped` など) を使用することで設定可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now we are ready to run our application.  Use: `./mvnw compile quarkus:dev`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これでアプリケーションを実行する準備が整いました。 `./mvnw compile quarkus:dev` を実行してみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hit `CTRL+C` to stop the application, or keep it running and enjoy the blazing fast hot-reload.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`CTRL+C` を押してアプリケーションを停止したり、アプリケーションを起動したままにでき、快適な操作を行うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus' architecture.  If you're new to CDI then we recommend you to read the link:cdi[Introduction to CDI] guide.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus の依存性注入は、Quarkus のアーキテクチャに合わせて調整された CDI ベースの依存性注入ソリューションである ArC をベースにしています。 CDI が初めての方は、 link:cdi[CDI入門] ガイドをお読みになることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus only implements a subset of the CDI features and comes with non-standard features and specific APIS, you can learn more about it in the link:cdi-reference[Contexts and Dependency Injection guide].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は CDI 機能のサブセットのみを実装しており、非標準の機能や特定の API が付属しています。詳細は、 link:cdi-reference[Contexts and Dependency Injection ガイド] を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Let's modify the application and add a companion bean.  Create the `src/main/java/org/acme/getting/started/GreetingService.java` file with the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを変更してコンパニオン Bean を追加してみましょう。 以下の内容で `src/main/java/org/acme/getting/started/GreetingService.java` ファイルを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Edit the `GreetingResource` class to inject the `GreetingService` and create a new endpoint using it:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`GreetingResource` クラスを編集して `GreetingService` を注入し、それを使って新しいエンドポイントを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you stopped the application, restart the application with `./mvnw compile quarkus:dev`.  Then check that the endpoint returns `hello quarkus` as expected:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを停止した場合は、`./mvnw compile quarkus:dev` でアプリケーションを再起動します。 そして、エンドポイントが `hello quarkus` を期待通りに返すことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`quarkus:dev` runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.  This works too for resource files like the configuration property file.  Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`quarkus:dev` は、開発モードで Quarkus を実行します。これにより、Java ファイルやリソースファイルを変更してブラウザを更新すると、これらの変更が自動的に反映されます。 これは、設定プロパティファイルなどのリソースファイルに対しても機能します。 ブラウザをリフレッシュすると、ワークスペースのスキャンがトリガーされ、変更が検出された場合、Java ファイルが再コンパイルされ、アプリケーションが再デプロイされます。リクエストは、再デプロイされたアプリケーションによって処理されます。コンパイルやデプロイに問題がある場合は、エラーページで通知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will also listen for a debugger on port `5005`. If you want to wait for the debugger to attach before running you can pass `-Dsuspend` on the command line. If you don't want the debugger at all you can use `-Ddebug=false`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これはポート `5005` のデバッガーもリッスンします。デバッガーがアタッチされるのを待ってから実行する場合は、コマンドラインで `-Dsuspend` を渡してください。デバッガーを全く必要としない場合は `-Ddebug=false` を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All right, so far so good, but wouldn't it be better with a few tests, just in case.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>さて、ここまでは問題ありませんが、念のためにテストをした方がいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the generated `pom.xml` file, you can see 2 test dependencies:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成された `pom.xml` ファイルでは、2 つのテスト依存関係を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus supports https://junit.org/junit5/[Junit 5] tests.  Because of this, the version of the https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] must be set, as the default version does not support Junit 5:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus は https://junit.org/junit5/[Junit 5] テストをサポートしています。 デフォルトのバージョンでは Junit 5 をサポートしていないため、 https://maven.apache.org/surefire/maven-surefire-plugin/[Surefire Maven Plugin] のバージョンを設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We also set the `java.util.logging` system property to make sure tests will use the correct logmanager and `maven.home` to ensure that custom configuration from `${maven.home}/conf/settings.xml` is applied (if any).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、 `java.util.logging` システムプロパティを設定して、テストが正しいログマネージャを使用することを確認し、 `maven.home` からカスタム設定が適用されることを確認します (該当する場合)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generated project contains a simple test.  Edit the `src/test/java/org/acme/getting/started/GreetingResourceTest.java` to match the following content:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>生成されたプロジェクトには簡単なテストが含まれています。 `src/test/java/org/acme/getting/started/GreetingResourceTest.java` を以下の内容に合わせて編集してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By using the `QuarkusTest` runner, you instruct JUnit to start the application before the tests.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`QuarkusTest` ランナーを使うことで、テストの前にアプリケーションを起動するように JUnit に指示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Check the HTTP response status code and content</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>HTTP レスポンスのステータスコードと内容を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>These tests use http://rest-assured.io/[RestAssured], but feel free to use your favorite library.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらのテストでは http://rest-assured.io/[RestAssured] を使用していますが、お好きなライブラリーをご自由にお使いください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run these using Maven:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>これらは Maven を使って実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also run the test from your IDE directly (be sure you stopped the application first).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、IDE から直接テストを実行することもできます (最初にアプリケーションを停止したことを確認してください)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, tests will run on port `8081` so as not to conflict with the running application. We automatically configure RestAssured to use this port. If you want to use a different client you should use the `@TestHTTPResource` annotation to directly inject the URL of the tested application into a field on the test class. This field can be of the type `String`, `URL` or `URI`. This annotation can also be given a value for the test path. For example, if I want to test a Servlet mapped to `/myservlet` I would just add the following to my test:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、実行中のアプリケーションと競合しないように、テストはポート `8081` で実行されます。 RestAssured は、この 8081 ポートを使用するように自動的にを設定されます。別のクライアントを使用したい場合は、`@TestHTTPResource` アノテーションを使用して、テストされたアプリケーションの URL をテストクラスのフィールドに直接注入する必要があります。このフィールドは `String`、 `URL`、`URI` のいずれかの型になります。このアノテーションにはテストパスの値を指定することもできます。例えば、`/myservlet` にマップされたサーブレットをテストしたい場合、次のようにテストに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The test port can be controlled via the `quarkus.http.test-port` config property. Quarkus also creates a system property called `test.url` that is set to the base test URL for situations where you cannot use injection.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストポートは、`quarkus.http.test-port` 設定プロパティで制御できます。Quarkus はまた、インジェクションを使用できない場合のためにベースとなるテストURLに設定される `test.url` というシステムプロパティを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Working with multi-module project or external modules</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチモジュールプロジェクトや外部モジュールとの連携</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus heavily utilizes https://github.com/wildfly/jandex[Jandex] at build time, to discover various classes or annotations. One immediately recognizable application of this, is CDI bean discovery.  As a result, most of the Quarkus extensions will not work properly if this build time discovery isn't properly setup.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus はビルド時に https://github.com/wildfly/jandex[Jandex] を多用して、さまざまなクラスやアノテーションを発見しています。これをすぐに認識できるアプリケーションの1つは、CDI Beanのディスカバリーです。 その結果、このビルド時のディスカバリーが適切に設定されていないと、Quarkusのエクステンションのほとんどが正しく動作しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This index is created by default on the project on which Quarkus is configured for, thanks to our Maven and Gradle plugins.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このインデックスは、Maven と Gradle プラグインのおかげで、Quarkus が設定されているプロジェクト上にデフォルトで作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, when working with a multi-module project, be sure to read the `Working with multi-module projects` section of the link:maven-tooling#multi-module-maven[Maven] or link:gradle-tooling#multi-module-maven[Gradle] guides.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>しかし、マルチモジュールプロジェクトで作業する場合は、 link:maven-toolsing#multi-module-maven[Maven] または link:gradle-toolsing#multi-module-maven[Gradle] ガイドの 「マルチモジュールプロジェクトでの作業」のセクションを必ず読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you plan to use external modules (for example, an external library for all your domain objects), you will need to make these modules known to the indexing process either by adding the Jandex plugin (if you can modify them)  or via the `quarkus.index-dependency` property inside your `application.properties` (useful in cases where you can't modify the module).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>外部モジュール (例えば、すべてのドメインオブジェクトのための外部ライブラリ) を使用する予定がある場合は、Jandex プラグインを追加するか (変更できる場合)、 `application.properties` 内の `quarkus.index-dependency` プロパティを使って (モジュールを変更できない場合に便利です)、これらのモジュールをインデックス作成プロセスに知らせておく必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be sure to read the link:cdi-reference#bean_discovery[Bean Discovery] section of the CDI guide for more information.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>詳細は、CDI ガイドの link:cdi-reference#bean_discovery[Bean Discovery] セクションを必ずお読みください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Packaging and run the application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パッケージングとアプリケーションの実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The application is packaged using `./mvnw package`.  It produces 2 jar files in `/target`:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションは `./mvnw package` を使ってパッケージ化されています。 これは `/target` に 2 つの jar ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it's the regular artifact produced by the Maven build;</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getting-started-1.0.0-SNAPSHOT.jar`: プロジェクトのクラスとリソースだけを含み、Maven ビルドによって生成される通常のアーティファクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`getting-started-1.0.0-SNAPSHOT-runner.jar` - being an executable _jar_. Be aware that it's not an _über-jar_ as the dependencies are copied into the `target/lib` directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`getting-started-1.0.0-SNAPSHOT-runner.jar`: 実行可能な _jar_ です。依存関係が `target/lib` ディレクトリにコピーされているので、これは _über-jar_ ではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application using: `java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar`</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>`java -jar target/getting-started-1.0.0-SNAPSHOT-runner.jar` を使ってアプリケーションを実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `Class-Path` entry of the `MANIFEST.MF` from the _runner jar_ explicitly lists the jars from the `lib` directory.  So if you want to deploy your application somewhere, you need to copy the _runner_ jar as well as the _lib_ directory.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MANIFEST.MF の `Class-Path` エントリーには、 _runner jar_ の `lib` ディレクトリーの jar が明示的にリストアップされています。 そのため、アプリケーションをどこかにデプロイしたい場合は、 _runner_ jar も _lib_ ディレクトリと同様にコピーする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before running the application, don't forget to stop the hot reload mode (hit `CTRL+C`), or you will have a port conflict.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションを実行する前に、ホットリロードモードを停止する (CTRL+C) ことを忘れないでください 。停止しないと、ポートが衝突します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring the banner</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>バナーの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default when a Quarkus application starts (in regular or dev mode), it will display an ASCII art banner. The banner can be disabled by setting `quarkus.banner.enabled=false` in `application.properties`, by setting the `-Dquarkus.banner.enabled=false` Java System Property, or by setting the `QUARKUS_BANNER_ENABLED` environment variable to `false`.  Furthermore, users can supply a custom banner by placing the banner file in `src/main/resources` and configuring `quarkus.banner.path=name-of-file` in `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>デフォルトでは、Quarkus アプリケーションが起動すると (通常モードまたは開発モードで) 、ASCII アートバナーが表示されます。バナーを無効にするには、 `application.properties` で `quarkus.banner.enabled=false` を設定するか、 `Dquarkus.banner.enabled=false` の Java システムプロパティを設定するか、 `QUARKUS_BANNER_ENABLED` 環境変数を `false` に設定します。 さらに、 `src/main/resources` にバナーファイルを配置し、 `application.properties` に `quarkus.banner.path=nam-of-file` を設定することで、ユーザーはカスタムのバナーを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of an application using Quarkus.  However, there is much more.  We recommend continuing the journey with the link:building-native-image[building a native executable guide], where you learn about creating a native executable and packaging it in a container.  If you are interested in reactive, we recommend the link:getting-started-reactive[Getting started with reactive guide], where you can see how to implement reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkus を使用したアプリケーションの作成について説明しました。 しかし、まだまだ多くのことがあります。 link:built-native-image[ネイティブ実行可能ファイルのビルド] では、ネイティブ実行ファイルの作成とコンテナへのパッケージングを説明します。 リアクティブに興味がある場合は、link:get-started-reactive[リアクティブ入門ガイド] をお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition, the link:tooling[tooling guide] document explains how to:</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>また、link:tooling[ツールガイド] のドキュメントでは、以下の方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>enable the _development mode_ (hot reload)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>_development mode_ (ホットリロード) を有効にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus - Kubernetes Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>You can find the source code for Minima at GitHub:
[jekyll][jekyll-organization] /
[minima](https://github.com/jekyll/minima)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>You can find the source code for Jekyll at GitHub:
[jekyll][jekyll-organization] /
[jekyll](https://github.com/jekyll/jekyll)
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>[jekyll-organization]: https://github.com/jekyll
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to create your first Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのQuarkusアプリケーションを作成する方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through First Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのアプリケーションを作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about developing reactive applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用したリアクティブアプリケーションの開発については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Getting Started with Reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ入門</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build native executables with GraalVM or Mandrel.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>GraalVMやMandrelを使ってネイティブの実行可能ファイルをビルドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building Native Executables</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブ実行可能ファイルのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/building-native-image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/building-native-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the Quarkus developer toolchain which makes Quarkus development so fast and enjoyable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの開発を非常に高速で楽しいものにするQuarkus開発者ツールチェーンをご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using our Tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツールの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>core</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>core</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hardcoded values in your code is a no go (even if we all did it at some point ;-)). In this guide, we learn how to configure your application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コードの中でハードコードされた値を使用することはできません (たとえ誰もがどこかの時点でそうしていたとしても ;-)。このガイドでは、アプリケーションを設定する方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how to configure your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを設定する為の詳細について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/config-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/config-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>List all the configuration properties per extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションごとのすべての設定プロパティのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All Configuration Properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべての設定プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/all-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/all-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You often need to execute custom actions when the application starts and clean up everything when the application stops. This guide explains how to be notified when an application stops or starts.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの起動時にカスタムアクションを実行し、アプリケーションの停止時にすべてをクリーンアップする必要があることがよくあります。このガイドでは、アプリケーションの停止時や起動時に通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application Initialization and Termination</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションの初期化と終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/lifecycle</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/lifecycle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのDIソリューションは、 [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec )仕様に基づいています。このガイドでは、CDIの基本を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>qualifier event interceptor observer arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cdi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Go more in depth into the Quarkus implementation of CDI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>CDIのQuarkus実装についてさらに詳しく説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>arc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>arc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cdi-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cdi-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の内容をカバーしています：
* JVM モードでのテスト 
* ネイティブモードでのテスト 
* テストへのリソースの注入
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Testing Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのテスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/getting-started-testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring Logging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ロギングの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/logging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This reference guide explains how to develop command line applications with Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このリファレンスガイドでは、Quarkusを使用してコマンドラインアプリケーションを開発する方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Mode Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドモードリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/command-mode-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this guide, we will discuss how you can get your native images to support SSL, as native images don't support it out of the box.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ネイティブイメージがそのままではSSLをサポートしていないため、ネイティブイメージをSSLに対応させる方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using SSL With Native Images</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブイメージでのSSLの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/native-and-ssl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can pass contextual information with our implementation of MicroProfile Context Propagation.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile Context Propagation の実装を使ってコンテキスト情報を渡す方法の詳細については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Context Propagation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コンテキストの伝搬</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/context-propagation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/context-propagation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is a collection of tips to help you solve the problems you encounter when compiling applications to native executable.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、アプリケーションをネイティブ実行可能ファイルにコンパイルする際に遭遇する問題を解決するためのヒントをまとめたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Native Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ネイティブアプリケーションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/writing-native-applications-tips</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ウェブ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JSON is now the lingua franca between microservices. In this guide, we see how you can get your REST services to consume and produce JSON payloads.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JSON は現在、マイクロサービス間の共通言語となっています。このガイドでは、REST サービスが JSON ペイロードを消費して生成する方法を見ていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-json</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-json</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Discover how to develop highly scalable reactive REST services with JAX-RS and RESTEasy Reactive.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>JAX-RSとRESTEasyReactiveを使用して拡張性の高いリアクティブRESTサービスを開発する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Highly Scalable Reactive REST Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>高度にスケーラブルなリアクティブRESTサービスの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/resteasy-reactive</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM REST Data with Panache simplifies the creation of CRUD applications based on JAX-RS and Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORM REST Data with Panacheは、JAX-RSとHibernate ORMをベースにしたCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Simple REST CRUD Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シンプルなREST CRUDサービスの書き方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-data-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use Hibernate Validator/Bean Validation in your REST services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、RESTサービスでHibernate Validator/Bean Validationを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/validation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/validation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client in order to interact with REST APIs (JSON and other) with very little effort.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST Clientを使ってREST API(JSONなど)とほとんど手間をかけずにやりとりする方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client (including JSON)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTクライアントを使う（JSONを含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the MicroProfile REST Client to send multipart REST requests, typically to upload documents.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、MicroProfile REST クライアントを使用してマルチパート REST リクエストを送信する方法、典型的にはドキュメントをアップロードする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the REST Client with Multipart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>マルチパートでのRESTクライアントの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/rest-client-multipart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your application can utilize MicroProfile JWT RBAC to provide secured access to the JAX-RS endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アプリケーションがMicroProfile JWT RBACを利用してJAX-RSエンドポイントへのセキュアなアクセスを提供する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jwt</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jwt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can utilize web sockets to create interactive web applications. Because it’s the canonical web socket application, we are going to create a simple chat application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがWeb Socketを利用してインタラクティブなウェブアプリケーションを作成する方法を説明します。定型的なWeb Socketアプリケーションなので、簡単なチャットアプリケーションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/websockets</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/websockets</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenAPI エクステンションを使用して OpenAPI ディスクリプタを生成し、Swagger UI フロントエンドを取得して REST エンドポイントをテストする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/openapi-swaggerui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusのVert.xベースのHTTPレイヤーの設定についての詳細と、サーブレットを使用している場合のUndertowについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/http-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/http-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize the MicroProfile Fault Tolerance specification through the SmallRye Fault Tolerance extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがSmallRye Fault Toleranceエクステンションを使用してMicroProfile Fault Tolerance仕様を利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Fault Tolerance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>フォールトトレランスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-fault-tolerance</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use reactive routes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、リアクティブルートの使用方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-routes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-routes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to leverage Eclipse MicroProfile GraphQL to consume and implement GraphQL services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Eclipse MicroProfile GraphQL を活用して GraphQL サービスを利用したり、実装する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-graphql</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus, you can easily configure a datasource, or several if need be.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusを使用すると、データソースを簡単に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring your datasources</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データソースの設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breath of an Object Relational Mapper. It works beautifully in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの完全な息吹を提供します。Quarkusでは見事に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate ORM is the de facto JPA implementation and offers you the full breadth of an Object Relational Mapper.
It makes complex mappings possible, but it does not make simple and common mappings trivial.
Panache focuses on making your entities trivial and fun to write.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate ORMは事実上のJPA実装であり、オブジェクトリレーショナルマッパーの全幅を提供します。
複雑なマッピングを可能にしますが、単純で一般的なマッピングをつまらなくするものではありません。
Panacheは、エンティティを些細なことではなく、書いていて楽しいものにすることに焦点を当てています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This explain the specifics of using Hibernate ORM with Panache in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>KotlinプロジェクトでHibernate ORMをPanacheで使う場合に固有の事情について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-orm-panache-kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search allows you to index your entities in an Elasticsearch cluster and easily offer full text search in all your Hibernate ORM-based applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate Searchは、Elasticsearchクラスタ内のエンティティをインデックス化し、Hibernate ORMベースのすべてのアプリケーションで簡単に全文検索を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Hibernate Search + Elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/hibernate-search-orm-elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusにはTransaction Managerが付属しており、これを使用してアプリケーションにトランザクションを調整して公開します。
永続性を扱う各エクステンションは、これと統合されます。
そして、CDIを介して明示的にトランザクションと対話することになります。
このガイドでは、これらすべてについて説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Transactions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>トランザクションの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/transaction</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/transaction</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Blaze-Persistence to simplify your data and DTO layers.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Blaze-Persistenceを使用してデータとDTOレイヤーを簡素化する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/blaze-persistence</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to cache expensive method calls of your CDI beans using simple annotations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、シンプルなアノテーションを使用してCDI Beanの高価なメソッド呼び出しをキャッシュする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cache your application data</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションデータのキャッシュ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Flyway extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Flyway エクステンションを使用してスキーマのマイグレーションを管理する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/flyway</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/flyway</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Liquibase extension to manage your schema migrations.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、スキーマのマイグレーションを管理するための Liquibase エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/liquibase</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/liquibase</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/infinispan-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/infinispan-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Reactive SQL Clients for MySQL and PostgreSQL in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusのMySQLおよびPostgreSQL用のReactive SQLクライアントの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Reactive SQL Clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブ SQL クライアント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-sql-clients</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use an Elasticsearch cluster using the low level or high level REST clients.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、低レベルまたは高レベルのRESTクライアントを使用してElasticsearchクラスタを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/elasticsearch</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/elasticsearch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use MongoDB in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでMongoDBを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mongodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、アクティブなレコードやリポジトリを使ったMongoDBの使い方について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mongodb-panache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use a Redis datastore in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでRedisデータストアを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/redis</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/redis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Neo4j graph database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでNeo4jグラフデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/neo4j</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/neo4j</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Apache Cassandra NoSQL database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでApache Cassandra NoSQLデータベースを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/cassandra</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/cassandra</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon DynamoDB database in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon DynamoDBデータベースを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-dynamodb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon S3 cloud storage in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon S3クラウドストレージの使い方を紹介しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon S3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon S3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-s3</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-s3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides covers the usage of Software Transactional Memory (STM)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、ソフトウェア・トランザクション・メモリ(STM)の使用法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Software Transactional Memory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ソフトウェア・トランザクション・メモリの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/software-transactional-memory</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>messaging</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メッセージング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AMQP with Reactive Messaging</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメッセージングでのAMQPの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amqp</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amqp</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can utilize MicroProfile Reactive Messaging to consume and produce HTTP messages.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicroProfile Reactive Messagingを使用してHTTPメッセージを消費および生成する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-messaging-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kafka-streams</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kafka-streams</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how different beans can interact using the event bus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、イベントバスを使用して異なるBeanがどのように相互作用するかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the event bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>イベントバスの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/reactive-event-bus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use JMS messaging with AMQP 1.0 using Apache Qpid JMS, or using Apache ActiveMQ Artemis JMS.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが、Apache Qpid JMSを使用してAMQP 1.0でJMSメッセージングを使用する方法、またはApache ActiveMQ Artemis JMSを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/jms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide is the entry point for everything security in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは、Quarkusのすべてのセキュリティに関するエントリーポイントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Security Overview</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>セキュリティの概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a .properties file to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが.propertiesファイルを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Security with .properties File</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>.propertiesファイルでセキュリティを使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a database to store your user identities with Hibernate ORM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションがデータベースを使用してHibernate ORMを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jpa</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-jdbc</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-jdbc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use a LDAP directory to store your user identities.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがLDAPディレクトリを使用してユーザーIDを保存する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-ldap</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-ldap</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can use Keycloak to protect your JAX-RS applications using bearer token authorization, where these tokens are issued by a Keycloak server.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloakを使用して、ベアラートークン認証を使用してJAX-RSアプリケーションを保護する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>sso</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>sso</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the OpenID Connect Extension to protect your web application based on the Authorization Code Flow using Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusを使用してAuthorization Code Flowに基づいてWebアプリケーションを保護するためにOpenID Connect Extensionを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-web-authentication</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your OpenID Connect application can support multi-tenancy so that you can serve multiple tenants from a single application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、単一のアプリケーションから複数のテナントにサービスを提供できるように、OpenID Connectアプリケーションがマルチテナントをサポートする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-multitenancy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can authorize access to protected resources using Keycloak Authorization Services.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがKeycloak認可サービスを使用して保護されたリソースへのアクセスを認可する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-keycloak-authorization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use OpenID Connect and OAuth2 Client and Filters to acquire, refresh and propagate access tokens.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenID ConnectとOAuth2クライアント、フィルタを使用してアクセストークンを取得、更新、伝播する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-openid-connect-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/security-oauth2</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/security-oauth2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault to securely store your credentials in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、HashiCorp Vaultを使用してQuarkusにクレデンシャルを安全に保存する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can use HashiCorp Vault for "encryption as a service".</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、HashiCorp Vaultを「サービスとしての暗号化」に利用する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Vault Transit Secret Engine</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヴォールトトランジットシークレットエンジンの使用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-transit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-transit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Keep confidential your database credentials by storing them in Vault.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データベースの資格情報をVaultに保存して、機密を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-datasource</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-datasource</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains the various methods supported by Quarkus to authenticate to your Vault.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusがサポートする、Vaultへの認証を行うためのさまざまな方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vault-auth</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vault-auth</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guides explains how to use the Vault credentials provider or implement your own custom one.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vault の資格情報プロバイダを使用する方法、または独自のカスタムのものを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/credentials-provider</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/credentials-provider</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>business-automation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>business-automation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Business Automation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビジネスオートメーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kogito</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kogito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OptaPlannerの制約解決人工知能（AI）を使用してQuarkusアプリケーションを作成するプロセスを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/optaplanner</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/optaplanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the systems integration with Apache Camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Apache Camel でのシステム統合について説明します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Apache Camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/camel</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/camel</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command-line</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>command-line</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Command Line Applications</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>コマンドラインアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Simplify command line applications creation with the Picocli extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Picocli エクステンションでコマンドラインアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/picocli</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/picocli</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Easy Quarkus-based scripting with jbang.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangを使った簡単なQuarkusベースのスクリプティング方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>jbangの統合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scripting</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scripting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラウド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to build and push container images with Jib, S2I or Docker as part of the Quarkus build.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのビルドの一部として、Jib、S2I、またはDockerを使用してコンテナイメージをビルドしてプッシュする方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build Container Images</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ビルドコンテナイメージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/container-image</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/container-image</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on Kubernetes.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Kubernetes上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to deploy a native application on OpenShift.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、OpenShift上にネイティブアプリケーションをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-openshift</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use ConfigMaps as a configuration source for your Quarkus applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ConfigMapsをQuarkusアプリケーションの設定ソースとして使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kubernetes-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how to use the Fabric8 Kubernetes client to interact with your Kubernetes cluster.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Fabric8 Kubernetes クライアントを使用して Kubernetes クラスタと対話する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kubernetes-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Microsoft Azure Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションをMicrosoft Azure Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-azure-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Azure Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAzure Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Amazon Lambdas.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusベースのAmazon Lambdasをデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as an Amazon Lambda.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをAmazon Lambdaとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to deploy a Quarkus application to Google Cloud.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションをGoogle Cloudにデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/deploying-to-google-cloud</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Quarkus-based Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusベースのGoogle Cloud Functionsを導入する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can deploy Vert.x Web, Servlet, or RESTEasy microservices as a Google Cloud Function.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Vert.x Web、Servlet、またはRESTEasyマイクロサービスをGoogle Cloud Functionとしてデプロイする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains basics of the Funqy framework, a simple portable cross-provider cloud function API.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Funqyフレームワークの基本、シンプルなポータブルクロスプロバイダーCloud Function APIについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのHTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのAmazon Lambdaバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Amazon Lambdas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-amazon-lambda</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Amazon Lambda HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのAmazon Lambda HTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Amazon Lambdas HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-amazon-lambda-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Knative Events binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのKnative Eventsバインディングについて説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Knative Events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-knative-events</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Azure Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、FunqyのAzure Functions HTTPバインディングについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Azure Functions HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-azure-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのGoogle Cloud Platform Functionsバインディングについて解説しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Google Cloud Platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-gcp-functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains Funqy's Google Cloud Platform Functions HTTP binding.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>FunqyのGoogle Cloud Platform FunctionsのHTTPバインディングについて解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus Funqy Google Cloud Platform HTTP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/funqy-gcp-functions-http</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Key Management Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon Key Management Serviceの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon KMS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon KMS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-kms</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-kms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Identity and Access Management in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでのAmazon Identity and Access Managementの使用方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon IAM</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon IAM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-iam</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-iam</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Email Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Mail Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SES</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SES</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-ses</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-ses</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Notification Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Notification Serviceを利用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SNS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SNS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sns</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-sns</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use the Amazon Simple Queue Service in Quarkus.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでAmazon Simple Queue Serviceを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Amazon SQS</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Amazon SQS</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/amazon-sqs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>observability</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Observability</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Observability</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using Health Check</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ヘルスチェックの利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-health</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-health</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/opentracing</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/opentracing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide demonstrates how your Quarkus application can collect metrics using the Micrometer extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションがMicrometerエクステンションを使用してメトリクスを収集する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/micrometer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/micrometer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/microprofile-metrics</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Sentry to monitor your application and be notified when exceptions occur.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Sentry を使ってアプリケーションを監視し、例外が発生したときに通知を受ける方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/logging-sentry</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/logging-sentry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to centralize your logs with Logstash or Fluentd using the Graylog Extended Log Format (GELF).</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Graylog Extended Log Format (GELF) を使用して Logstash または Fluentd でログを集中管理する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/centralized-log-management</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>serialization</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Serialization</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>シリアル化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to start using gRPC in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCを使用する方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-getting-started</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to implement gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションにgRPCサービスを実装する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing gRPC Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-service-implementation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to consume gRPC services in your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusアプリケーションでgRPCサービスを使用する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consuming gRPC Services</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>gRPCサービスを消費する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/grpc-service-consumption</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、以下の内容について説明します。
* Maven の設定 
* 新しいプロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/maven-tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/maven-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native image
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下の内容をカバーしています。
* Gradle の設定 
* 新規プロジェクトの作成 
* エクステンションの扱い 
* 開発モード 
* デバッグ 
* IDE でのインポート 
* ネイティブイメージの構築 
* コンテナフレンドリーな実行ファイルの構築
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/gradle-tooling</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to measure the test coverage of your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションのテストカバレッジを測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring the coverage of your tests</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>テストの適用範囲の測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tests-with-coverage</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>compatibility</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>compatibility</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the spring-di extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>インジェクションにはCDIアノテーションを使用することが推奨されていますが、Quarkusはspring-diエクステンションの形でSpring依存性インジェクション用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-di</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-di</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use JAX-RS annotations for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the spring-web extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>RESTエンドポイントの定義にはJAX-RSアノテーションを使用することが推奨されていますが、QuarkusはSpring-webエクステンションという形でSpring Webとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-web</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-web</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use Hibernate ORM with Panache for your data layer, Quarkus provides a compatibility layer for Spring Data JPA in the form of the spring-data-jpa extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>データレイヤーにはHibernate ORM with Panacheを使用することが推奨されていますが、Quarkusはspring-data-jpaエクステンションの形でSpring Data JPAの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-data-jpa</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Spring Data REST simplifies the creation of CRUD applications based on our Spring Data compatibility layer.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Spring Data RESTは、当社のSpring Data互換性レイヤをベースにCRUDアプリケーションの作成を簡素化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-data-rest</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Quarkus security layer to secure your applications, Quarkus provides a compatibility layer for Spring Security in the form of the spring-security extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのセキュリティレイヤーを使用してアプリケーションを保護することが推奨されていますが、Quarkusはspring-securityのエクステンションの形でSpring Securityとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-security</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-security</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Cache extension for your application-level caching, Quarkus provides a compatibility layer for Spring Cache in the form of the spring-cache extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションレベルのキャッシングにはCacheエクステンションを使用することが推奨されていますが、QuarkusはSpring Cacheエクステンションの形でSpring Cacheの互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cache</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-cache</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>While you are encouraged to use the Scheduler or Quartz extensions to schedule tasks, Quarkus provides a compatibility layer for Spring Scheduled in the form of the spring-scheduled extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>SchedulerやQuartzのエクステンションを使ってタスクをスケジュールすることが推奨されていますが、QuarkusはSpring-scheduledエクステンションの形でSpring Scheduledとの互換性のあるレイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-scheduled</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>MicroProfile Config アノテーションの代わりに Spring Boot の `@ConfigurationProperties`  を使用します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-boot-properties</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a compatibility layer for Spring Cloud Config in the form of the spring-cloud-config-client extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは、Spring-cloud-config-clientエクステンションの形でSpring Cloud Config用の互換性レイヤーを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/spring-cloud-config-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>miscellaneous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>miscellaneous</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Miscellaneous</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>その他</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Modern applications often need to run specific tasks periodically. In this guide, you learn how to schedule periodic tasks.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最近のアプリケーションでは、定期的に特定のタスクを実行する必要があります。このガイドでは、定期的なタスクをスケジュールする方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduling Periodic Tasks</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>定期的なタスクのスケジューリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scheduler</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about the Scheduler extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラーエクステンションの詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scheduler Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジューラリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/scheduler-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You need clustering support for your scheduled tasks? This guide explains how to use the Quartz extension for that.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>スケジュールされたタスクにクラスタリングのサポートが必要ですか？このガイドでは、そのための Quartz エクステンションの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/quartz</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/quartz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can send email from a Quarkus application with our reactive email client.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>リアクティブメールクライアントを使用してQuarkusアプリケーションからメールを送信する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sending Emails</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>メールの送信</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/mailer</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/mailer</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you can use templating in your applications with the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteのテンプレートエンジンを使ったアプリケーションでのテンプレートの使用方法については、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/qute</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn everything you need to know about the Qute template engine.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quteのテンプレートエンジンについて知りたい方は、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/qute-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/qute-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about how you extract content from documents using the Apache Tika toolkit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Apache Tika ツールキットを使ってドキュメントからコンテンツを抽出する方法についての詳細はこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/tika</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/tika</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Vert.x in Quarkus to build reactive applications.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、QuarkusでVert.xを使用してリアクティブアプリケーションを構築する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/vertx</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/vertx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how you can access Git repositories with JGit.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、JGitを使ってGitリポジトリにアクセスする方法を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/jgit</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/jgit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how your Quarkus application can read configuration properties at runtime from Consul.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションが実行時にConsulから設定プロパティを読み取る方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/consul-config</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/consul-config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to best measure the footprint of a Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Quarkusアプリケーションのフットプリントを最適に測定する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Measuring Performance</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>パフォーマンスの測定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/performance-measure</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/performance-measure</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>alternative-languages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>alternative-languages</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternative Languages</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>代替言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use Kotlin.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドでは、Kotlinの使い方を説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/kotlin</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/kotlin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>writing-extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn step by step how to build a simple extension.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>簡単なエクステンションを構築する方法をステップバイステップで学ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building My First Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>初めてのエクステンションのビルド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>building-my-first-extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>building-my-first-extension</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションをQuarkusのCDIコンテナに統合する方法について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>cdi-integration</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>cdi-integration</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを Dev UI に機能貢献させる方法をご紹介します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>dev-ui</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>dev-ui</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore all the BuildItems you can consume/produce in your extensions.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションで消費/生産できるすべての BuildItems を調べてみましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>All BuildItems</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>すべてのビルドアイテム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>all-builditems</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>all-builditems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions optimize your applications by pushing as much work as possible to the build operation. This guide explains the rationale of Quarkus extensions and guides you through authoring your own extensions.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusのエクステンションは、可能な限り多くの作業をビルド処理にプッシュすることで、アプリケーションを最適化します。このガイドでは、Quarkusエクステンションの根拠を説明し、独自のエクステンションを作成する方法を説明します。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Writing Your Own Extension</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>独自のエクステンションを書く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/writing-extensions</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/writing-extensions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about Quarkus class loading infrastructure.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusクラスのローディングインフラストラクチャについてはこちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Class Loading Reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>クラスローディングリファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/class-loading-reference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about what we call a Platform in the Quarkus world.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの世界でプラットフォームと呼ばれているものについては、こちらをご覧ください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Understanding the Platform concept</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>プラットフォームのコンセプトを理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/platform</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>/guides/platform</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>layout: faq
title: FAQ
permalink: /faq/
---
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is your license?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ライセンスは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは https://www.apache.org/licenses/LICENSE-2.0[Apache License version 2.0] でライセンスされているオープンソースプロジェクトです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Where can I get it?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>どこから入手できますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>QuarkusはMaven Centralで公開されています。必要な link:/extensions[which extensions] を確認し、`pom.xml` にインポートするだけでQuarkusを入手できます。link:/get-started[Getting Started guides] からQuarkusの体験を始めることをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is stable?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusは安定していますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yes, we consider Quarkus stable. Remember 95% of the features Quarkus apps use are provided by the ecosystem like Hibernate ORM, Eclipse Vert.x, Netty, RESTEasy, etc. These libraries are rock solid :)</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>はい、Quarkusは安定していると考えています。Quarkusのアプリが使用する機能の95%は、Hibernate ORM、Eclipse Vert.x、Netty、RESTEasyなどのエコシステムによって提供されていることを忘れないでください。これらのライブラリは極めて盤石です:)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can go to https://code.quarkus.io/[code.quarkus.io] to see if a particular extension is _stable_ (default) or _preview_.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://code.quarkus.io/[code.quarkus.io]にアクセスして、特定の拡張子が_安定_（デフォルト）か_プレビュー_かを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What is a Quarkus extension?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションとは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>One of the main goals of Quarkus is ease of extensibility and to build a vibrant ecosystem.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusの主な目標の1つは、拡張性の容易さと活気のあるエコシステムの構築です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusエクステンションはプロジェクトの依存関係だと考えてください。エクステンションは、フレームワークまたはテクノロジーをQuarkusアプリケーションに構成、起動、および統合します。また、アプリケーションをネイティブにコンパイルするために、GraalVMに適切な情報を提供するという面倒な作業もすべて行います。これにより、サードパーティのプロジェクトは、GraalVMをターゲットにしやすくするために我々が行った作業を簡単に利用できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>What are the extension statuses?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションステータスとは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Extensions have a various degree of maturity when they enter the Quarkus ecosystem. A status offers the expectations you can rely on.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションは、Quarkusエコシステムに入る際に、さまざまな成熟度を持ちます。ステータスは、信頼度の期待値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Stable*: backward compatibility and presence in the ecosystem are taken very seriously. An application can safely rely on these extensions. Extensions not marked as preview or experimental (the majority) are stable.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*安定*：下位互換性とエコシステムでの存在感が非常に重要視されています。アプリケーションはこれらのエクステンションに安全に依存できます。プレビューまたは実験的（大部分）としてマークされていないエクステンションは安定しています。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Preview*: backward compatibility and presence in the ecosystem is not guaranteed. Specific improvements might require to change configuration or APIs and plans to become _stable_ are under way. Such extensions are in the middle of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*プレビュー*：下位互換性とエコシステム内での存在感は保証されません。特定の改善には、構成またはAPIの変更が必要になる場合があり、_安定_になる計画が進行中です。このようなエクステンションは、成熟プロセスの途中です。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>*Experimental*: early feedback is requested to mature the idea. There is no guarantee of stability nor long term presence in the platform until the solution matures. Such extensions are at the beginning of their maturation process.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>*実験的*：アイデアを成熟させるために、早期のフィードバックが必要です。ソリューションが成熟するまで、プラットフォーム内での安定性や長期的な存在は保証されません。このようなエクステンションは、成熟プロセスの初期段階にあります。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find the extension status on https://code.quarkus.io[code.quarkus.io] or in the extension link:/guides/[guides].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションステータスは、https：//code.quarkus.io[code.quarkus.io] またはエクステンション link:/guides/[guides] で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Can I write an extension?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>エクステンションを作成できますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Will the Quarkus team accept my extension?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusチームは私のエクステンションを受け入れますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Oh yeah! We had quite a few extensions written outside the Quarkus "initial" team.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>勿論です！ Quarkusの「初期」チームの外部でかなりの数のエクステンションが作成されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an open ecosystem and we hope to see all the extensions people need to write their apps. We are working as we speak to allow an extension to be published in separate repos and separate GAVs and thus published in Maven repos independently of Quarkus core. This will greatly simplify the publication process. Expect news soon.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusはオープンエコシステムであり、人々がアプリを作成するために必要なすべてのエクステンションが存在することを期待しています。エクステンションを個別のリポジトリと個別のGAVで公開し、Quarkusコアとは独立してMavenリポジトリで公開できるようにするために取り組んでいます。これにより、公開プロセスが大幅に簡素化されます。近いうちのニュースを期待してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The one current restriction is that extensions should work in both OpenJDK and GraalVM native executables. That is the guarantee we give Quarkus users (a cross compilation for their app). We have a maturity model to improve an extension to be fully "Quarked" and benefit from Quarkus, all done in incremental steps. Just hop on our https://quarkus.io/community/#discussions[mailing list] to discuss your ideas and get help. And you can start reading our https://quarkus.io/guides/writing-extensions[Writing extensions guide] as well or more simply get inspiration from the https://github.com/quarkusio/quarkus/tree/master/extensions[existing ones].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>現在の制限の1つは、エクステンションはOpenJDKとGraalVMの両方のネイティブ実行可能ファイルで機能する必要があるということです。これは、Quarkusユーザーに提供する保証です（アプリのクロスコンパイル）。エクステンションを改善して完全に「Quarked」し、Quarkusの恩恵を受けるための成熟度モデルがあり、すべて段階的に実行されます。 https://quarkus.io/community/#discussions[メーリングリスト] にアクセスして、アイデアについて話し合い、サポートを受けてください。また、https://quarkus.io/guides/writing-extensions[エクステンションガイドの作成] を読み始めることも、 https://github.com/quarkusio/quarkus/tree/master/extensions[既存のエクステンション] からインスピレーションを得ることもできます。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is GraalVM?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## GraalVMとは何ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://www.graalvm.org[GraalVM] is a universal virtual machine for running applications written in various different languages, as well as providing the ability to compile JVM bytecode to a native executable (this native executable runs a special virtual machine called SubstrateVM). These native executables start much faster and can use a lot less memory than a traditional JVM, however not every JVM feature is supported, and some are more limited than normal.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>https://www.graalvm.org[GraalVM] は、さまざまな異なる言語で記述されたアプリケーションを実行するためのユニバーサル仮想マシンであり、JVMバイトコードをネイティブ実行可能ファイルにコンパイルする機能を提供します（このネイティブ実行可能ファイルは、SubstrateVMと呼ばれる特別な仮想マシンを実行します）。これらのネイティブ実行可能ファイルは、従来のJVMよりもはるかに高速に起動し、使用するメモリを大幅に削減できますが、すべてのJVM機能がサポートされているわけではなく、一部は通常よりも制限されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For example by default reflection in GraalVM will not work, unless a class/member has been explicitly registered for reflection. This is normally achieved by listing every class, method, field and constructor in a JSON file, and passing this as a parameter into the native image build. This obviously gets quite cumbersome for all but the most trivial projects. Quarkus provides a framework that makes it easy to work around these annotations, and programmatically determine what should be registered.</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>たとえば、デフォルトでは、クラス/メンバーがリフレクション用に明示的に登録されていない限り、GraalVMでのリフレクションは機能しません。これは通常、すべてのクラス、メソッド、フィールド、コンストラクターをJSONファイルにリストし、これをパラメーターとしてネイティブイメージビルドに渡すことで実現されます。これは、最も些細なプロジェクトを除いて、明らかに非常に面倒になります。 Quarkusは、これらの注釈を簡単に回避し、何を登録するかをプログラムで決定できるフレームワークを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## How do you unify imperative and reactive programming?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 命令型プログラミングとリアクティブプログラミングをどのように統合しますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/continuum[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/continuum[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What does Container First mean?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## コンテナ・ファーストはどういう意味ですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/container-first[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/container-first[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What is your view on standards?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 標準についてどう考えていますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/standards[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/standards[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## What are you doing to improve developer joy?</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>## 開発者の満足度を向上させるために何に取り組んでいますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>link:/vision/developer-joy[Learn more].</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>link:/vision/developer-joy[詳細をご覧ください].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;div class="grid__item width-4-12 hide-mobile toc" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Guides</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;/div&gt;
&lt;div class="grid__item width-8-12 width-12-12-m gs-content"&gt;
&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Be Guided Through Your First Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>最初のアプリケーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Bootstrapping an application
- Creating a JAX-RS endpoint
- Injecting beans
- Functional tests
- Packaging of the application
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下をカバーします:
- アプリケーションの起動
- JAX-RSエンドポイントの作成
- Beanの挿入
- ファンクションテスト
- アプリケーションのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;div class="guide-item" markdown="1"&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to create a reactive application with Quarkus and explore the different reactive features offered by Quarkus.
This guide covers:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusでリアクティブアプリケーションを作成する方法を学習し、Quarkusによって提供される様々なリアクティブ機能を学びます。
このガイドは以下をカバーします：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/getting-started-reactive" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quickly Bootstrap Your Application</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>アプリケーションのクイック起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With &lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt;, in a few clicks, you can bootstrap your Quarkus application and discover its extension ecosystem.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="https://code.quarkus.io"&gt;code.quarkus.io&lt;/a&gt; では、数クリックでQuarkusアプリケーションを起動し、エクステンションエコシステムを発見出来ます。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Explore the wide breadth of technologies Quarkus applications can be made with.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkusアプリケーションを作成する際に利用できる幅広いテクノロジーをご覧ください。
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
- Compiling the application to a native executable
- The packaging of an application in a Docker container
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下をカバーします：
- アプリケーションのネイティブ実行可能ファイルへのコンパイル
- アプリケーションのDockerコンテナへのパッケージング
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide requires:
- Completion of the [Creating Your First Application]({{site.baseurl}}/guides/getting-started) guide
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>このガイドは以下を必要とします:
- [最初のアプリケーションの作成]({{site.baseurl}}/guides/getting-started) ガイドの完了
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/building-native-image" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain enabling developers from live reload all the way down to deploying a Kubernetes application.
In this guide, we will explore:
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Quarkus には開発者がライブリロードからKubernetesへのアプリケーションのデプロイまで、ツールチェインが付属しています。
このガイドでは、以下について説明します：
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;READ THE GUIDE&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;a href="{{site.baseurl}}/guides/tooling" class="button-cta secondary"&gt;ガイドを読む&lt;/a&gt;
&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>&lt;/div&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Contributing to the Quarkus.io website</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
      <tuv xml:lang="ja_JP">
        <seg>**Important:** the guides are maintained in the main Quarkus repository and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc.
</seg>
      </tuv>
    </tu>
  </body>
</tmx>
